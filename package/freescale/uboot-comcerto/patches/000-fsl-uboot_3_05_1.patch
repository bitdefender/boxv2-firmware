diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/arch/arm/cpu/armv7/comcerto/clkcore.c u-boot-2013.01.new/arch/arm/cpu/armv7/comcerto/clkcore.c
--- u-boot-2013.01/arch/arm/cpu/armv7/comcerto/clkcore.c	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/arch/arm/cpu/armv7/comcerto/clkcore.c	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,696 @@
+#include <common.h>
+#include <asm/types.h>
+#include <asm/io.h>
+#include <asm/arch/clkcore.h>
+
+
+#if defined(CONFIG_COMCERTO_PLL)
+
+static inline void HAL_set_clock_divider(int clk_freq, int pll_src, u32 reg);
+
+struct clock_cfg_settings *cfg_clk;
+
+static u32 pll_cfg_freq_table[] = {
+	[PLL_CFG_1800] = PLL_FREQ_1800,
+	[PLL_CFG_1600] = PLL_FREQ_1600,
+	[PLL_CFG_1500] = PLL_FREQ_1500,
+	[PLL_CFG_1400] = PLL_FREQ_1400,
+	[PLL_CFG_1300] = PLL_FREQ_1300,
+	[PLL_CFG_1000] = PLL_FREQ_1000,
+	[PLL_CFG_800] = PLL_FREQ_800,
+	[PLL_CFG_750] = PLL_FREQ_750,
+	[PLL_CFG_500] = PLL_FREQ_500,
+	[PLL_CFG_2400] = PLL_FREQ_2400
+};
+
+static u32 pll3_cfg_freq_table[] = {
+	[PLL3_CFG_1066] = PLL_FREQ_1066,
+	[PLL3_CFG_800] = PLL_FREQ_800
+};
+
+static struct pll_info pll_table[] = {
+#if (CFG_REFCLKFREQ == CFG_REFCLKFREQ_24)
+        [PLL_CFG_1800] = {450,  6,  0,	1},
+        [PLL_CFG_1600] = {400,  6,  0,	1},
+        [PLL_CFG_1500] = {375,  6,  0,	1},
+        [PLL_CFG_1400] = {350,  6,  0,	0},
+        [PLL_CFG_1300] = {325,  6,  0,	0},
+        [PLL_CFG_1000] = {500,  6,  1,	1},
+        [PLL_CFG_800] =  {400,  6,  1,	1},
+        [PLL_CFG_750] =  {375,  6,  1,	1},
+        [PLL_CFG_500] =  {500,  6,  2,	1},
+		[PLL_CFG_2400] =  {600,	6,	0,	1}
+#else
+        [PLL_CFG_1800] = {450,  12,  0,  1},
+        [PLL_CFG_1600] = {400,  12,  0,  1},
+        [PLL_CFG_1500] = {375,  12,  0,  1},
+        [PLL_CFG_1400] = {350,  12,  0,  0},
+        [PLL_CFG_1300] = {325,  12,  0,  0},
+        [PLL_CFG_1000] = {500,  12,  1,  1},
+        [PLL_CFG_800] =  {400,  12,  1,  1},
+        [PLL_CFG_750] =  {375,  12,  1,  1},
+        [PLL_CFG_500] =  {500,  12,  2,  1},
+		[PLL_CFG_2400] =  {600,	12,  0,  1}
+#endif
+};
+
+static struct pll3_info pll3_table[] = {
+#if (CFG_REFCLKFREQ == CFG_REFCLKFREQ_24)
+	[PLL3_CFG_1066]	= {0x57, 2, 0, 0x755, 1},
+#else
+        [PLL3_CFG_1066]	= {0x57, 4, 0, 0x755, 1},
+	[PLL3_CFG_800]	= {0x41, 4, 0, 0x6ab, 0}
+#endif
+};
+
+struct pll_setting pll_freq_table[] = {
+        {PLL0_CFG_1800, PLL1_CFG_1000, PLL2_CFG_1500, PLL3_CFG_1066},
+	{PLL0_CFG_750, PLL1_CFG_1000, PLL2_CFG_1500, PLL3_CFG_800},
+        {PLL0_CFG_1300, PLL1_CFG_800, PLL2_CFG_500, PLL3_CFG_800},
+        {PLL0_CFG_1300, PLL1_CFG_800, PLL2_CFG_500, PLL3_CFG_1066},
+        {PLL0_CFG_1800, PLL1_CFG_800, PLL2_CFG_500, PLL3_CFG_1066},
+        {PLL0_CFG_2400, PLL1_CFG_1000, PLL2_CFG_1500, PLL3_CFG_1066},
+};
+
+struct clock_cfg_settings clk_cfg_table[] =
+{
+        [CLK_CFG1] = { PLL_CFG_1800_1000_1500_1066,
+                        ARM_CLK_900, PLL0,
+                        AXI_CLK_250, PLL1,
+                        DDR_CLK_533, PLL3,
+                        IPSEC_CLK_300, PLL2,
+                        SATA_OOB_CLK_125, PLL1,
+                        SATA_PMU_CLK_30, PLL0,
+                        DECT_CLK_250, PLL2,
+                        L2CC_CLK_450, PLL0,
+                        HFE_CLK_500, PLL1,
+                        GEMTX_CLK_125, PLL2,
+                        EXTPHY0_CLK_125, PLL2,
+                        EXTPHY1_CLK_125, PLL2,
+                        EXTPHY2_CLK_125, PLL2,
+			TPI_CLK_250, PLL0,
+			CSYS_CLK_166, PLL0},
+
+
+	[CLK_CFG2] = { PLL_CFG_750_1000_1500_800,
+			ARM_CLK_750, PLL2,
+			AXI_CLK_250, PLL2,
+			DDR_CLK_400, PLL3,
+			IPSEC_CLK_300 , PLL0,
+			SATA_OOB_CLK_125, PLL0,
+			SATA_PMU_CLK_30, PLL0,
+			DECT_CLK_250, PLL0,
+			L2CC_CLK_375, PLL0,
+			HFE_CLK_500, PLL2,
+			GEMTX_CLK_125, PLL0,
+			EXTPHY0_CLK_125, PLL0,
+			EXTPHY1_CLK_125, PLL0,
+			EXTPHY2_CLK_125, PLL0,
+			TPI_CLK_250, PLL0,
+			CSYS_CLK_166, PLL0},
+
+        [CLK_CFG3] = {  PLL_CFG_1300_800_500_800,
+                        ARM_CLK_650, PLL0,
+                        AXI_CLK_200, PLL1,
+                        DDR_CLK_400, PLL3,
+                        IPSEC_CLK_250, PLL2,
+                        SATA_OOB_CLK_125, PLL2,
+                        SATA_PMU_CLK_25, PLL2,
+                        DECT_CLK_250, PLL2,
+                        L2CC_CLK_325, PLL0,
+                        HFE_CLK_400, PLL1,
+                        GEMTX_CLK_125, PLL2,
+                        EXTPHY0_CLK_125, PLL2,
+                        EXTPHY1_CLK_125, PLL2,
+                        EXTPHY2_CLK_125, PLL2,
+			TPI_CLK_250, PLL0,
+			CSYS_CLK_166, PLL0},
+
+        [CLK_CFG4] = {  PLL_CFG_1300_800_500_1066,
+                        ARM_CLK_650, PLL0,
+                        AXI_CLK_200, PLL1,
+                        DDR_CLK_533, PLL3,
+                        IPSEC_CLK_250, PLL2,
+                        SATA_OOB_CLK_125, PLL2,
+                        SATA_PMU_CLK_25, PLL2,
+                        DECT_CLK_250, PLL2,
+                        L2CC_CLK_325, PLL0,
+                        HFE_CLK_400, PLL1,
+                        GEMTX_CLK_125, PLL2,
+                        EXTPHY0_CLK_125, PLL2,
+                        EXTPHY1_CLK_125, PLL2,
+                        EXTPHY2_CLK_125, PLL2,
+			TPI_CLK_250, PLL0,
+			CSYS_CLK_166, PLL0},
+
+        [CLK_CFG5] = {  PLL_CFG_1800_800_500_1066,
+                        ARM_CLK_900, PLL0,
+                        AXI_CLK_200, PLL1,
+                        DDR_CLK_533, PLL3,
+                        IPSEC_CLK_250, PLL2,
+                        SATA_OOB_CLK_125, PLL2,
+                        SATA_PMU_CLK_25, PLL2,
+                        DECT_CLK_250, PLL2,
+                        L2CC_CLK_450, PLL0,
+                        HFE_CLK_400, PLL1,
+                        GEMTX_CLK_125, PLL2,
+                        EXTPHY0_CLK_125, PLL2,
+                        EXTPHY1_CLK_125, PLL2,
+                        EXTPHY2_CLK_125, PLL2,
+			TPI_CLK_250, PLL0,
+			CSYS_CLK_166, PLL0},
+
+        [CLK_CFG6] = { PLL_CFG_2400_1000_1500_1066,
+                        ARM_CLK_1200, PLL0,
+                        AXI_CLK_250, PLL1,
+                        DDR_CLK_533, PLL3,
+                        IPSEC_CLK_300, PLL2,
+                        SATA_OOB_CLK_125, PLL1,
+                        SATA_PMU_CLK_30, PLL0,
+                        DECT_CLK_250, PLL2,
+                        L2CC_CLK_600, PLL0,
+                        HFE_CLK_500, PLL1,
+                        GEMTX_CLK_125, PLL2,
+                        EXTPHY0_CLK_125, PLL2,
+                        EXTPHY1_CLK_125, PLL2,
+                        EXTPHY2_CLK_125, PLL2,
+						TPI_CLK_250, PLL0,
+						CSYS_CLK_166, PLL0},
+};
+
+static inline void HAL_set_pll(u32 pll_no, u32 pll_freq_idx)
+{
+	u32 m = 0;
+	u32 p = 0;
+	u32 s = 0;
+	u32 k;
+	u32 vsel = 0;
+	u32 val;
+
+	if (pll_no < PLL3)
+	{
+		m = pll_table[pll_freq_idx].m;
+		p = pll_table[pll_freq_idx].p;
+		s = pll_table[pll_freq_idx].s;
+		vsel = pll_table[pll_freq_idx].vsel;
+
+		switch (pll_no)
+		{
+		case PLL0:
+			writel((m & 0xFF),   PLL0_M_LSB);
+			writel((m >> 8) & 0x3,   PLL0_M_MSB);
+			writel(p,  PLL0_P);
+			writel(s,  PLL0_S);
+			val = readl(PLL0_CNTRL);
+			val &= ~(1 << 6); //clear the vsel bit
+			val |= PLL_LOCK_EN | PLL_RESET | (vsel << 6); //configure for vsel bit
+			writel(val, PLL0_CNTRL);
+			break;
+
+		case PLL1:
+			writel(m & 0xFF,   PLL1_M_LSB);
+			writel((m >> 8) & 0x3,   PLL1_M_MSB);
+			writel(p,  PLL1_P);
+			writel(s,  PLL1_S);
+			val = readl(PLL1_CNTRL);
+			val &= ~(1 << 6);
+			val |= PLL_LOCK_EN | PLL_RESET | (vsel << 6);
+			writel(val, PLL1_CNTRL);
+			break;
+
+		case PLL2:
+			writel(m & 0xFF,   PLL2_M_LSB);
+			writel((m >> 8) & 0x3,   PLL2_M_MSB);
+			writel(p,  PLL2_P);
+			writel(s,  PLL2_S);
+			val = readl(PLL2_CNTRL);
+			val &= ~(1 << 6);
+			val |= PLL_LOCK_EN | PLL_RESET | (vsel << 6);
+			writel(val, PLL2_CNTRL);
+			break;
+
+		default:
+			break;
+		}
+	}
+	else if (pll_no == PLL3)
+	{
+		m = pll3_table[pll_freq_idx].m;
+		p = pll3_table[pll_freq_idx].p;
+		s = pll3_table[pll_freq_idx].s;
+		k = pll3_table[pll_freq_idx].k;
+		vsel = pll3_table[pll_freq_idx].vsel;
+
+		writel(m & 0xFF,   PLL3_M_LSB);
+		writel((m >> 0x8) & 0x1,   PLL3_M_MSB);
+		writel(p,  PLL3_P);
+		writel(s,  PLL3_S);
+		writel(0x0, PLL3_DITHER_CNTRL);
+		writel(k & 0xff, PLL3_K_LSB);
+		writel((k >> 8) & 0xf, PLL3_K_MSB);
+		writel(0x1, PLL3_MFR);
+		writel(0x7, PLL3_MRR);
+		val = readl(PLL3_CNTRL);
+		val &= ~(1 << 6);
+		val |= PLL_LOCK_EN | PLL_RESET | (vsel << 6);
+		writel(val, PLL3_CNTRL);
+	}
+}
+
+static inline void HAL_set_clock_pll_source(void)
+{
+	u32 val;
+
+	val = readl(A9DP_CLK_CNTRL);
+	val &=~(CLK_PLL_SRC_MASK << CLK_PLL_SRC_SHIFT);
+	val |= (cfg_clk->arm_clk_src << 1);
+	writel(val , A9DP_CLK_CNTRL);
+
+	val = readl(AXI_CLK_CNTRL_0);
+	val &=~(CLK_PLL_SRC_MASK << CLK_PLL_SRC_SHIFT);
+	val |= (cfg_clk->axi_clk_src << 1);
+	writel(val, AXI_CLK_CNTRL_0);
+
+	val = readl(DDR_CLK_CNTRL);
+	val &=~(CLK_PLL_SRC_MASK << CLK_PLL_SRC_SHIFT);
+	val |= (cfg_clk->ddr_clk_src << 1);
+	writel(val, DDR_CLK_CNTRL);
+
+	val = readl(IPSEC_CLK_CNTRL);
+	val &=~(CLK_PLL_SRC_MASK << CLK_PLL_SRC_SHIFT);
+	val |= (cfg_clk->ipsec_clk_src << 1);
+	writel(val, IPSEC_CLK_CNTRL);
+
+	val = readl(SATA_OOB_CLK_CNTRL);
+	val &=~(CLK_PLL_SRC_MASK << CLK_PLL_SRC_SHIFT);
+	val |= (cfg_clk->sata_oob_clk_src << 1);
+	writel(val, SATA_OOB_CLK_CNTRL);
+
+	val = readl(SATA_PMU_CLK_CNTRL);
+	val &=~(CLK_PLL_SRC_MASK << CLK_PLL_SRC_SHIFT);
+	val |=  (cfg_clk->sata_pmu_clk_src << 1);
+	writel(val, SATA_PMU_CLK_CNTRL);
+
+	val = readl(DECT_CLK_CNTRL);
+	val &=~(CLK_PLL_SRC_MASK << CLK_PLL_SRC_SHIFT);
+	val |= (cfg_clk->dect_clk_src << 1);
+	writel(val, DECT_CLK_CNTRL);
+
+	val = readl(L2CC_CLK_CNTRL);
+	val &=~(CLK_PLL_SRC_MASK << CLK_PLL_SRC_SHIFT);
+	val |= (cfg_clk->l2cc_clk_src << 1);
+	writel(val, L2CC_CLK_CNTRL);
+
+	val = readl(HFE_CLK_CNTRL);
+	val &=~(CLK_PLL_SRC_MASK << CLK_PLL_SRC_SHIFT);
+	val |= (cfg_clk->hfe_clk_src << 1);
+	writel(val, HFE_CLK_CNTRL);
+
+	val = readl(GEMTX_CLK_CNTRL);
+	val &=~(CLK_PLL_SRC_MASK << CLK_PLL_SRC_SHIFT);
+	val |= (cfg_clk->gemtx_clk_src << 1);
+	writel(val, GEMTX_CLK_CNTRL);
+
+	val = readl(EXTPHY0_CLK_CNTRL);
+	val &=~(CLK_PLL_SRC_MASK << CLK_PLL_SRC_SHIFT);
+	val |= (cfg_clk->extphy0_clk_src << 1);
+	writel(val, EXTPHY0_CLK_CNTRL);
+
+	val = readl(EXTPHY1_CLK_CNTRL);
+	val &=~(CLK_PLL_SRC_MASK << CLK_PLL_SRC_SHIFT);
+	val |= (cfg_clk->extphy1_clk_src << 1);
+	writel(val, EXTPHY1_CLK_CNTRL);
+
+	val = readl(EXTPHY2_CLK_CNTRL);
+	val &=~(CLK_PLL_SRC_MASK << CLK_PLL_SRC_SHIFT);
+	val |= (cfg_clk->extphy2_clk_src << 1);
+	writel(val, EXTPHY2_CLK_CNTRL);
+
+	val = readl(TPI_CLK_CNTRL);
+	val &=~(CLK_PLL_SRC_MASK << CLK_PLL_SRC_SHIFT);
+	val |= (cfg_clk->tpi_clk_src << 1);
+	writel(val, TPI_CLK_CNTRL);
+
+	val = readl(CSYS_CLK_CNTRL);
+	val &=~(CLK_PLL_SRC_MASK << CLK_PLL_SRC_SHIFT);
+	val |= (cfg_clk->csys_clk_src << 1);
+	writel(val, CSYS_CLK_CNTRL);
+}
+
+static inline void HAL_set_clock(void)
+{
+	HAL_set_clock_divider(cfg_clk->axi_clk, cfg_clk->axi_clk_src, AXI_CLK_DIV_CNTRL);
+	HAL_set_clock_divider(cfg_clk->ddr_clk, cfg_clk->ddr_clk_src, DDR_CLK_DIV_CNTRL);
+	HAL_set_clock_divider(cfg_clk->hfe_clk, cfg_clk->hfe_clk_src, HFE_CLK_DIV_CNTRL);
+	HAL_set_clock_divider(cfg_clk->gemtx_clk, cfg_clk->gemtx_clk_src, GEMTX_CLK_DIV_CNTRL);
+	HAL_set_clock_divider(cfg_clk->ipsec_clk, cfg_clk->ipsec_clk_src, IPSEC_CLK_DIV_CNTRL);
+	HAL_set_clock_divider(cfg_clk->extphy0_clk, cfg_clk->extphy0_clk_src, EXTPHY0_CLK_DIV_CNTRL);
+	HAL_set_clock_divider(cfg_clk->extphy1_clk, cfg_clk->extphy1_clk_src, EXTPHY1_CLK_DIV_CNTRL);
+	HAL_set_clock_divider(cfg_clk->extphy2_clk, cfg_clk->extphy2_clk_src, EXTPHY2_CLK_DIV_CNTRL);
+	HAL_set_clock_divider(cfg_clk->sata_oob_clk, cfg_clk->sata_oob_clk_src, SATA_OOB_CLK_DIV_CNTRL);
+	HAL_set_clock_divider(cfg_clk->sata_pmu_clk, cfg_clk->sata_pmu_clk_src, SATA_PMU_CLK_DIV_CNTRL);
+	HAL_set_clock_divider(cfg_clk->dect_clk, cfg_clk->dect_clk_src, DECT_CLK_DIV_CNTRL);
+	HAL_set_clock_divider(cfg_clk->l2cc_clk, cfg_clk->l2cc_clk_src, L2CC_CLK_DIV_CNTRL);
+	HAL_set_clock_divider(cfg_clk->arm_clk, cfg_clk->arm_clk_src, A9DP_CLK_DIV_CNTRL);
+	HAL_set_clock_divider(cfg_clk->tpi_clk, cfg_clk->tpi_clk_src, TPI_CLK_DIV_CNTRL);
+	HAL_set_clock_divider(cfg_clk->csys_clk, cfg_clk->csys_clk_src, CSYS_CLK_DIV_CNTRL);
+}
+
+
+
+static inline void HAL_set_clock_divider(int clk_freq, int pll_src, u32 reg)
+{
+	u32 pll_freq;
+	int pll_freq_idx;
+	int divider;
+	u32 val;
+
+	if (pll_src < PLL3)
+	{
+		switch(pll_src)
+		{
+		case PLL0:
+			pll_freq_idx = pll_freq_table[cfg_clk->pll_cfg_idx].pll0_freq_idx;
+			break;
+
+		case PLL1:
+			pll_freq_idx = pll_freq_table[cfg_clk->pll_cfg_idx].pll1_freq_idx;
+			break;
+
+		case PLL2:
+			pll_freq_idx = pll_freq_table[cfg_clk->pll_cfg_idx].pll2_freq_idx;
+			break;
+
+		default:
+			pll_freq_idx = pll_freq_table[cfg_clk->pll_cfg_idx].pll0_freq_idx;
+			break;
+		}
+
+		pll_freq = pll_cfg_freq_table[pll_freq_idx];
+	}
+	else
+	{
+		pll_freq_idx = pll_freq_table[cfg_clk->pll_cfg_idx].pll3_freq_idx;
+		pll_freq = pll3_cfg_freq_table[pll_freq_idx];
+	}
+
+	divider = pll_freq / clk_freq;
+
+	/* Write the clock divider value and backup the divider bypass value in IRAM */
+	/* This is to workaround an hardware bug where the divider bypass value read is not working */
+	/* The global bypass is still overriding the individual clock bypasses */
+	if (divider == 1)
+	{
+		write_clk_div_bypass_backup(CLK_DIV_BYPASS, reg);
+	}
+	else
+	{
+		write_clk_div_bypass_backup(0, reg);
+
+		val = readl(reg);
+		val &= ~0x1f;
+		val |= divider;
+		writel(val, reg);
+	}
+}
+
+static inline void HAL_clock_remove_reg_bypass(u32 reg)
+{
+	u32 val;
+
+	/* Remove individual clock bypass, based on bypass value backed up in IRAM */
+	/* The global bypass is still overriding the individual clock bypasses */
+	if (!(read_clk_div_bypass_backup(reg) & CLK_DIV_BYPASS))
+	{
+		val = readl(reg);
+		val &= ~(1 << 7);
+		writel(val, reg);
+	}
+}
+
+static inline void HAL_clock_remove_bypass(void)
+{
+	HAL_clock_remove_reg_bypass(AXI_CLK_DIV_CNTRL);
+	HAL_clock_remove_reg_bypass(HFE_CLK_DIV_CNTRL);
+	HAL_clock_remove_reg_bypass(DDR_CLK_DIV_CNTRL);
+	HAL_clock_remove_reg_bypass(GEMTX_CLK_DIV_CNTRL);
+	HAL_clock_remove_reg_bypass(EXTPHY0_CLK_DIV_CNTRL);
+	HAL_clock_remove_reg_bypass(EXTPHY1_CLK_DIV_CNTRL);
+	HAL_clock_remove_reg_bypass(EXTPHY2_CLK_DIV_CNTRL);
+	HAL_clock_remove_reg_bypass(DECT_CLK_DIV_CNTRL);
+	HAL_clock_remove_reg_bypass(IPSEC_CLK_DIV_CNTRL);
+	HAL_clock_remove_reg_bypass(SATA_OOB_CLK_DIV_CNTRL);
+	HAL_clock_remove_reg_bypass(SATA_PMU_CLK_DIV_CNTRL);
+	HAL_clock_remove_reg_bypass(L2CC_CLK_DIV_CNTRL);
+	HAL_clock_remove_reg_bypass(A9DP_CLK_DIV_CNTRL);
+
+	//TBD for TPI, NTG
+}
+
+static inline void HAL_bypass_all(void)
+{
+	//PLL Output Clock is bypassed using Reference Clock
+	writel(0xf, PLLS_GLOBAL_CNTRL);
+
+	writel(CLK_DIV_BYPASS|CLK_DIV_VAL_DEFAULT, A9DP_CLK_DIV_CNTRL);
+	writel(CLK_DIV_BYPASS|CLK_DIV_VAL_DEFAULT, L2CC_CLK_DIV_CNTRL);
+	writel(CLK_DIV_BYPASS|CLK_DIV_VAL_DEFAULT, AXI_CLK_DIV_CNTRL);
+	writel(CLK_DIV_BYPASS|CLK_DIV_VAL_DEFAULT, DDR_CLK_DIV_CNTRL);
+	writel(CLK_DIV_BYPASS|CLK_DIV_VAL_DEFAULT, HFE_CLK_DIV_CNTRL);
+	writel(CLK_DIV_BYPASS|CLK_DIV_VAL_DEFAULT, GEMTX_CLK_DIV_CNTRL);
+	writel(CLK_DIV_BYPASS|CLK_DIV_VAL_DEFAULT, SATA_PMU_CLK_DIV_CNTRL);
+	writel(CLK_DIV_BYPASS|CLK_DIV_VAL_DEFAULT, SATA_OOB_CLK_DIV_CNTRL);
+
+	writel(0x210000, USB0_PHY_CTRL_REG0);
+	writel(0x210000, USB1_PHY_CTRL_REG0);
+	writel(0x22, USB_RST_CNTRL);
+
+	//PLL is put in Reset
+	writel(PLL_RESET|PLL_LOCK_EN, PLL0_CNTRL);
+	writel(PLL_RESET|PLL_LOCK_EN, PLL1_CNTRL);
+	writel(PLL_RESET|PLL_LOCK_EN, PLL2_CNTRL);
+	writel(PLL_RESET|PLL_LOCK_EN, PLL3_CNTRL);
+}
+
+static inline void HAL_unreset_pll(void)
+{
+	int val;
+
+        //PLL taken out of Reset
+	val = readl(PLL0_CNTRL);
+	val &= ~PLL_RESET;
+        writel(val, PLL0_CNTRL);
+
+	val = readl(PLL1_CNTRL);
+	val &= ~PLL_RESET;
+        writel(val, PLL1_CNTRL);
+
+	val = readl(PLL2_CNTRL);
+	val &= ~PLL_RESET;
+        writel(val, PLL2_CNTRL);
+
+	val = readl(PLL3_CNTRL);
+	val &= ~PLL_RESET;
+        writel(val, PLL3_CNTRL);
+}
+
+static inline void HAL_wait_pll_lock(void)
+{
+	int p0, p1, p2;
+        volatile u32 delay_count;
+
+        //wait more than 750 uS for PLL3 to get locked
+        delay_count = 0x9000;
+        while (delay_count--);
+
+         //clear status bit
+        do {
+                p0 = readl(PLL0_STATUS);
+
+                p1 = readl(PLL1_STATUS);
+
+                p2 = readl(PLL2_STATUS);
+
+        }
+        while(!p0 || !p1 || !p2);
+}
+
+static inline void HAL_unreset_blocks(void)
+{
+	writel(0, AXI_RESET_0);
+	writel(0, AXI_RESET_1);
+	writel(0, AXI_RESET_2);
+}
+
+void SoC_PLL_init(void)
+{
+        volatile u32 delay_count;
+
+	cfg_clk = &clk_cfg_table[CLK_CFG];
+
+	HAL_bypass_all();
+
+	//configure PLL0, PLL1, PLL2 and PLL3
+	HAL_set_pll(PLL0, pll_freq_table[cfg_clk->pll_cfg_idx].pll0_freq_idx);
+	HAL_set_pll(PLL1, pll_freq_table[cfg_clk->pll_cfg_idx].pll1_freq_idx);
+	HAL_set_pll(PLL2, pll_freq_table[cfg_clk->pll_cfg_idx].pll2_freq_idx);
+	HAL_set_pll(PLL3, pll_freq_table[cfg_clk->pll_cfg_idx].pll3_freq_idx);
+
+	//count 1 uS
+        delay_count = 0x40;
+        while (delay_count--);
+
+	//bring PLL out of reset
+	HAL_unreset_pll();
+
+	//set the Global Bypass bit 
+	writel(0xd1, GNRL_CLK_CNTRL_1);
+
+	//configure the PLL source for all the clocks
+	HAL_set_clock_pll_source();
+
+	//configure all the clocks
+	HAL_set_clock();
+
+	//clock divider resync
+	writel(0x80, DEVICE_RST_CNTRL);
+
+	HAL_wait_pll_lock();
+
+	HAL_clock_remove_bypass();
+
+	//Global Bypass is off
+	writel(0xd0, GNRL_CLK_CNTRL_1);
+
+	//switch to PLL Clock
+	writel(0, PLLS_GLOBAL_CNTRL);
+
+	//bring all the block out of reset
+	HAL_unreset_blocks();
+}
+
+#endif
+
+u32 HAL_get_pll_freq(int pll_no)
+{
+	u32 p;
+	u32 od;
+	u32 m;
+	u32 k;
+	u32 s;
+	u32 pll_clk = 0;
+
+	if (pll_no < PLL3)
+	{
+		//get NF, NR and OD values
+		switch (pll_no)
+		{
+		case PLL0:
+			m = readl(PLL0_M_LSB) & 0xff;
+			m |= (readl(PLL0_M_MSB) & 0x3) << 8;
+			p = readl(PLL0_P) & 0x3f;
+			s = readl(PLL0_S) & 0x7;
+			od = (1 << s); // 2^s;
+			break;
+
+		case PLL1:
+			m = readl(PLL1_M_LSB) & 0xff;
+			m |= (readl(PLL1_M_MSB) & 0x3) << 8;
+			p = readl(PLL1_P) & 0x3f;
+			s = readl(PLL1_S) & 0x7;
+			od = (1 << s);
+			break;
+
+		case PLL2:
+			m = readl(PLL2_M_LSB) & 0xff;
+			m |= (readl(PLL2_M_MSB) & 0x3) << 8;
+			p = readl(PLL2_P) & 0x3f;
+			s = readl(PLL2_S) & 0x7;
+			od = (1 << s);
+			break;
+
+		default:
+			return 0;
+			break;
+		}
+
+		/* Ref Clock divided by 1000000. It should be displayed in MHz. */
+		pll_clk = ((CFG_REFCLKFREQ / 1000000) * m) / p / od ;
+	}
+	else if (pll_no == PLL3)
+	{
+		m = readl(PLL3_M_LSB) & 0xff;
+		m |= (readl(PLL3_M_MSB) & 0x3) << 8;
+		p = readl(PLL3_P) & 0x3f;
+		s = readl(PLL3_S) & 0x7;
+		k = readl(PLL3_K_LSB) & 0xff;
+		k |= (readl(PLL3_K_MSB) & 0xf) << 8;
+		od = (1 << s);
+
+		pll_clk = (((CFG_REFCLKFREQ / 1000000) * (m * 1024 + k)) / p / od + 1023) / 1024;
+	}
+
+	return pll_clk;
+}
+
+static inline u32 HAL_get_clk_freq(u32 ctrl_reg, u32 div_reg)
+{
+	u32 pll_src;
+	u32 pll_clk;
+	u32 clk_div;
+	u32 clk_out;
+	int bypass = 0;
+
+	//get PLL source
+	pll_src = readl(ctrl_reg);
+	pll_src = (pll_src >> CLK_PLL_SRC_SHIFT) & CLK_PLL_SRC_MASK;
+
+	//get clock divider bypass value from IRAM Clock Divider registers mirror location
+	clk_div = read_clk_div_bypass_backup(div_reg);
+
+	if (clk_div & CLK_DIV_BYPASS)
+		bypass = 1;
+	else
+	{
+		clk_div = readl(div_reg);
+		clk_div &= 0x1f;
+	}
+
+	pll_clk = HAL_get_pll_freq(pll_src);
+
+	if (bypass)
+		clk_out = pll_clk;
+	else
+		clk_out = pll_clk / clk_div;
+
+	return clk_out;
+}
+
+u32 HAL_get_arm_clk(void)
+{
+	return HAL_get_clk_freq(A9DP_CLK_CNTRL, A9DP_CLK_DIV_CNTRL);
+}
+
+u32 HAL_get_axi_clk(void)
+{
+	return HAL_get_clk_freq(AXI_CLK_CNTRL_0, AXI_CLK_DIV_CNTRL);
+}
+
+u32 HAL_get_ddr_clk(void)
+{
+	return HAL_get_clk_freq(DDR_CLK_CNTRL, DDR_CLK_DIV_CNTRL);
+}
+
+u32 HAL_get_ipsec_clk(void)
+{
+	return HAL_get_clk_freq(IPSEC_CLK_CNTRL, IPSEC_CLK_DIV_CNTRL);
+}
+
+
+u32 HAL_get_arm_peri_clk(void)
+{
+        u32 clk = HAL_get_arm_clk() / 4 ;
+
+        return clk;
+}
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/arch/arm/cpu/armv7/comcerto/emac.c u-boot-2013.01.new/arch/arm/cpu/armv7/comcerto/emac.c
--- u-boot-2013.01/arch/arm/cpu/armv7/comcerto/emac.c	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/arch/arm/cpu/armv7/comcerto/emac.c	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,15 @@
+#include <config.h>
+#include <linux/types.h>
+#include <asm/u-boot.h>
+
+
+/*
+ * Initializes on-chip ethernet controllers.
+ * to override, implement board_eth_init()
+ */
+int cpu_eth_init(bd_t *bis)
+{
+	/* ensure that the module is out of reset */
+	c2000_gemac_initialize(bis, 0, "c2000_gemac0");
+	/* TODO Add support to gemac ports 1 & 2 */
+}
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/arch/arm/cpu/armv7/comcerto/ibr_wrapper.c u-boot-2013.01.new/arch/arm/cpu/armv7/comcerto/ibr_wrapper.c
--- u-boot-2013.01/arch/arm/cpu/armv7/comcerto/ibr_wrapper.c	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/arch/arm/cpu/armv7/comcerto/ibr_wrapper.c	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,128 @@
+#include <common.h>
+#include <config.h>
+#include <asm/arch/clkcore.h>
+#include <asm/io.h>
+#include <asm/arch/ibr_wrapper.h>
+
+static void (*spacc_init)(void);
+static int (*calculate_hash)(u8 *buffer, u32 buffer_len, u32 hash_type, u8 *hash, u32 hash_len);
+static u32 (*otp_read)(u32 s_addr, u8 *read_data, u32 size);
+static void (*pka_init)(void);
+static u32 (*rsa_sig_decrypt)(u8 *pub_N, u32 pub_N_len, u8 *sig, u32 siglen, u8 *hash, u32 hash_len, u32 pad_type);
+static u32 (*secureboot_get_key_length)(void);
+static unsigned int (*secureboot_get_auth_mode)(void);
+static unsigned int (*secureboot_is_key_in_header)(void);
+static retcode (*secureboot_get_hash_key)(u8* hash);
+static retcode (*secureboot_get_key)(u8* key);
+static retcode (*secureboot_init)(void);
+
+/* BIG FAT WARNING: currently only works with MMU disable and uloader code compiled in ARM mode*/
+
+void ibr_wrapper_init(void)
+{
+	spacc_init = (void (*)(void)) 0x90001CA8;
+	calculate_hash = (int (*)(u8*, u32, u32, u8*, u32))0x90001CD4;
+	otp_read = (u32 (*)(u32, u8*, u32))0x90001978;
+	pka_init = (void (*)(void))0x90002258;
+	rsa_sig_decrypt = (u32 (*)(u8*, u32, u8*, u32, u8*, u32, u32))0x90002334;
+
+	secureboot_get_key_length = (u32 (*)(void))0x9000054c;
+	secureboot_get_auth_mode = (unsigned int (*)(void))0x90000574;
+	secureboot_is_key_in_header = (unsigned int (*)(void))0x900005a4;
+	secureboot_get_hash_key = (retcode (*)(u8*))0x900005bc;
+	secureboot_get_key = (retcode (*)(u8*))0x900005f8;
+	secureboot_init = (retcode (*)(void))0x90000640;
+}
+
+retcode ibr_wrapper_secureboot_init(void)
+{
+	return (*secureboot_init)();
+}
+
+u32 ibr_wrapper_secureboot_get_key_length(void)
+{
+	return (*secureboot_get_key_length)();
+}
+
+unsigned int ibr_wrapper_secureboot_is_key_in_header(void)
+{
+	return (*secureboot_is_key_in_header)();
+}
+
+unsigned int ibr_wrapper_secureboot_get_auth_mode(void)
+{
+	return (*secureboot_get_auth_mode)();
+}
+
+retcode ibr_wrapper_secureboot_get_hash_key(u8 *hash)
+{
+	return (*secureboot_get_hash_key)(hash);
+}
+
+retcode ibr_wrapper_secureboot_get_key(u8 *key)
+{
+	return (*secureboot_get_key)(key);
+}
+
+void ibr_wrapper_spacc_init(void)
+{
+	(*spacc_init)();
+}
+
+/*
+ * This function computes hash value of a given buffer
+ * Currently it supports SHA-256
+ *
+ * inputs
+ *	buffer	  	pointer to the input buffer to perform hash on
+ *	buffer_len     	input buffer length
+ *	hash_type	must be H_SHA256
+ *	hash    	pointer to the output buffer where the hash value will be stored
+ *	hash_len  	len of the output buffer. must be SHA_256_LENGTH
+ *
+ * Return value
+ *	0	  Successfully verified given signature and hash
+ *	>0	  Failed
+ *
+ * Note: there is an hardware limitation: input buffer must be < 64K Bytes
+ */
+
+int ibr_wrapper_calculate_hash(u8 *buffer, u32 buffer_len, u32 hash_type, u8 *hash, u32 hash_len)
+{
+	return (*calculate_hash)(buffer, buffer_len, hash_type, hash, hash_len);
+}
+
+u32 ibr_wrapper_otp_read(u32 s_addr, u8 *read_data, u32 size)
+{
+	return (*otp_read)(s_addr, read_data, size);
+}
+
+void ibr_wrapper_pka_init(void)
+{
+	(*pka_init)();
+}
+
+/*
+ * This function verifies the given RSA signature with PKA hardware
+ * Currently it supports hardware supported RSA key size only 512,1024,2048
+ *
+ * inputs
+ *	pub_N	  N value from public key
+ *	pub_N_len     Length of N
+ *	sig	  RSA signature
+ *	siglen    Lenght of the signature
+ *	hash      hash value after RSA decrypt
+ *	hash_len  maximum hash buffer size
+ *	pad_type  Padding type used (only PKCS1 padding is suppoted)
+ *
+ * Return value
+ *	0	  Successfully verified given signature and hash
+ *	>0	  Failed
+ *
+ * Note: e value is always fixed to 0x10001.
+ */
+
+u32 ibr_wrapper_rsa_sig_decrypt(u8 *pub_N, u32 pub_N_len, u8 *sig, u32 siglen, u8 *hash, u32 hash_len, u32 pad_type)
+{
+	return (*rsa_sig_decrypt)(pub_N, pub_N_len, sig, siglen, hash, hash_len, pad_type);
+}
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/arch/arm/cpu/armv7/comcerto/image.c u-boot-2013.01.new/arch/arm/cpu/armv7/comcerto/image.c
--- u-boot-2013.01/arch/arm/cpu/armv7/comcerto/image.c	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/arch/arm/cpu/armv7/comcerto/image.c	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,321 @@
+/*
+;=======================================================================
+;   Copyright (C) 2007 Mindspeed Technologies, Inc.
+;
+;        Author   : Ananda Rao gurram
+;        Filename : image.c
+;        Purpose  : Image Header Handling Functions.
+;======================================================================
+*/
+
+#include <common.h>
+#include <config.h>
+#include <asm/arch/clkcore.h>
+#include <asm/io.h>
+#include <command.h>
+#include <asm/arch/ibr_wrapper.h>
+#include <asm/arch/image.h>
+#include <asm/arch/secureboot.h>
+#include <asm/arch/spacc.h>
+#include <fs.h>
+
+
+#ifdef CONFIG_SECUREBOOT_TEST
+static const u16 __aligned(8) pub_key_storage[RSA_KEY_LENGTH_2K]={
+0x14bd, 0xfba1, 0x800f, 0x4127, 0xfa1c, 0xccf6, 0x8545, 0xcbd2,
+0x76a5, 0x4a20, 0xff03, 0x4b9f, 0x4c4d, 0x4b56, 0xf8ee, 0xe7c6,
+0xd8a6, 0x890d, 0x9912, 0x63fa, 0x41c4, 0x9335, 0xe9c8, 0x30f1,
+0xfebe, 0x50fe, 0x1a9b, 0x5534, 0xdbe8, 0xb0b1, 0x6e3f, 0x9f82,
+0x14d8, 0xee5a, 0x62c8, 0xadcd, 0xa051, 0x1d12, 0xbec6, 0xa833,
+0xf2ba, 0xf165, 0x5053, 0xe580, 0xadaf, 0x2037, 0xf9b0, 0xeb61,
+0x69bc, 0xcd4f, 0xced8, 0xf10f, 0x47b2, 0xeabc, 0xdf08, 0x5ded,
+0xfe2a, 0x7dc0, 0xe154, 0x0b18, 0x74da, 0x1e3a, 0x0d7b, 0x5e5d,
+0x5761, 0x78a6, 0xc17c, 0x4c9d, 0x75ac, 0x2073, 0xe373, 0x910b,
+0x9fce, 0xf5b9, 0xee54, 0x6d36, 0x0939, 0x52fd, 0x70a3, 0xa352,
+0xe45d, 0xdb8e, 0x641d, 0xda9f, 0xa980, 0x1dfc, 0x4018, 0xa384,
+0xddb4, 0x5821, 0x6110, 0x3734, 0x6806, 0xd661, 0x5375, 0x3b23,
+0xdeb6, 0xaa23, 0x6b55, 0xa924, 0xe990, 0xb54e, 0xb80b, 0x8109,
+0xea13, 0x1538, 0x308b, 0x1d0f, 0x1e70, 0x7205, 0x3ece, 0xba7f,
+0xf4be, 0xc2d7, 0xf7f7, 0x6876, 0xdfef, 0x93cc, 0x2ec2, 0x7da6,
+0x861f, 0x5e79, 0x78a2, 0x5e4c, 0x0efa, 0x5299, 0xf401, 0x41c2
+};
+static const u16 __aligned(8) aes_key_buffer[AES_128_KEY_LENGTH]={0xebf7, 0x75a2, 0x3a6e, 0x0cd1, 0x2dde, 0x357b, 0x3c98, 0x077e};
+#endif
+
+void * verify_and_authenticate_boot_image(u8 *image_buf)
+{
+	img_hdr *boot_hdr;
+	retcode ret;
+	u32 hdr_len = IMAGE_HEADER_SIZE;
+	u32 hash_length = SHA_256_LENGTH;
+	u32 pub_key_length = 0;
+	u32 aes_key_length = 0;
+	u32 crc = CRC_INIT ;
+	u32 crc_read = 0;
+#ifndef CONFIG_SECUREBOOT_TEST
+	u8 key_in_header;
+#endif
+	u8 compute_hash[SHA_256_LENGTH];
+	u8 decrypted_hash[SHA_256_LENGTH];
+	u8 *hash_val, *stored_hash;
+	u8 *pub_key= (u8 *) SECBOOT_IRAM_PUBLIC_KEY_OFFSET;
+	u8 *aes_key= (u8 *) SECBOOT_IRAM_AES_KEY_OFFSET;
+	u8 auth;
+	void * payload;
+	u32 buffer_len;
+	u8 *enc_buffer;
+	hash_algo hash_type;
+	u8 is_first_pkt=0;
+
+	/* Initialize ibr wrapper*/
+	ibr_wrapper_init();
+
+#ifndef CONFIG_SECUREBOOT_TEST
+        if (ibr_wrapper_secureboot_init() != RETCODE_OK) {
+                printf ("secureboot init failed\n");
+                return NULL;
+        }
+
+	printf("Is secure boot on?\r\n");
+	/* Find out if secure boot is on */
+	if (ibr_wrapper_secureboot_get_auth_mode()) {
+		pub_key_length = ibr_wrapper_secureboot_get_key_length();
+
+		if ( RSA_KEY_LENGTH_INVALID == pub_key_length ) {
+			printf ("Invalid public key length\n");
+			return NULL;
+		}
+
+		hash_length = pub_key_length;
+	}
+
+	/* Find out the Key length and source */
+	key_in_header = ibr_wrapper_secureboot_is_key_in_header();
+	if ( key_in_header == TRUE )
+		hdr_len += pub_key_length;
+#else
+	hash_length = pub_key_length = RSA_KEY_LENGTH_2K;
+#endif
+
+	hdr_len += hash_length;
+
+	boot_hdr = (img_hdr *)image_buf;
+
+	/* calculate hash and public key position */
+	hash_val = (u8*) ((u32) boot_hdr + IMAGE_HEADER_SIZE);
+#ifndef CONFIG_SECUREBOOT_TEST
+	if ( key_in_header == TRUE )
+		pub_key = (u8*) ((u32)boot_hdr + IMAGE_HEADER_SIZE + hash_length);
+#else
+	pub_key = (u8 *)&pub_key_storage[0];
+#endif
+
+	hash_type = (hash_algo)boot_hdr->hash_type;
+
+	/* Initialize SPAcc */
+	ibr_wrapper_spacc_init();
+
+	//printf("Verify Image Header Entry\r\n");
+	/* Check Magic number */
+	if (boot_hdr->magic != IMAGE_MAGIC_IDENTIFIER) {
+		printf (" Invalid Magic Header\n");
+		return NULL;
+	}
+	printf("Magic number is valid\r\n");
+
+	/* Check key length */
+#ifndef CONFIG_SECUREBOOT_TEST
+	if ( key_in_header == FALSE ) {
+		if (boot_hdr->key_length != 0 ) {
+			printf ("Invalid Image header key length\n");
+			return NULL;
+		}
+	} else {
+		if (boot_hdr->key_length != pub_key_length) {
+			printf ("Invalid Image header key length\n");
+			return NULL;
+		}
+	}
+	printf("Image Header key length is valid\r\n");
+
+	/* Check hash type */
+
+	auth = ibr_wrapper_secureboot_get_auth_mode();
+#else
+	auth = TRUE;
+#endif
+
+	if (hash_type > aes_rsa_sha256) {
+		printf ("Invalid Image header\n");
+		return NULL;
+	}
+
+	if (auth == TRUE) {
+		if ( (hash_type != rsa_sha256) && (hash_type != aes_rsa_sha256)) {
+			printf ("Invalid Image header\n");
+			return NULL;
+		}
+	} else {
+		if ( (hash_type == rsa_sha256) || (hash_type == aes_rsa_sha256)) {
+			printf ("Invalid Image header\n");
+			return NULL;
+		}
+	}
+	printf("Hash Type is valid\r\n");
+
+	if (hash_type == aes_rsa_sha256) {
+#ifndef CONFIG_SECUREBOOT_TEST
+		aes_key_length = secureboot_get_aes_key_length();
+#else
+		aes_key_length = AES_128_KEY_LENGTH;
+#endif
+		hdr_len += AES_IV_LENGTH;
+	}
+
+	/* Check crc */
+	crc_read = boot_hdr->header_crc;
+	boot_hdr->header_crc = 0;
+	crc = crc32(crc, (unsigned char *)boot_hdr, hdr_len);
+
+	if ( crc_read != crc) {
+		printf ("Image header CRC check failed\n");
+		return NULL;
+	}
+	printf("CRC is valid\r\n");
+
+#ifndef CONFIG_SECUREBOOT_TEST
+	if (key_in_header == TRUE) {
+		/*
+		 * Here we are assuming that the hash algorithm is always SHA256
+		 */
+		u8 compute_hash[SHA_256_LENGTH];
+		u8 stored_hash[SHA_256_LENGTH];
+
+		/* Calculate Hash on the public key, always use SHA-256 */
+		if (ibr_wrapper_calculate_hash(pub_key, pub_key_length, H_SHA256 ,&compute_hash[0], SHA_256_LENGTH))
+			return NULL;
+
+		/* fetch public hash stored in OTP */
+		ret = ibr_wrapper_secureboot_get_hash_key(&stored_hash[0]);
+		if (!ret) {
+			printf("Fetching hash failed \n");
+			return NULL;
+		}
+
+		if ( memcmp(&compute_hash[0], &stored_hash[0], SHA_256_LENGTH) ) {
+			printf ("Invalid Image header hash\n");
+			return NULL;
+		}
+	}
+	else {
+		/* If authentication is enabled read the key from OTP area */
+		if (ibr_wrapper_secureboot_get_auth_mode()) {
+			ret = ibr_wrapper_secureboot_get_key(pub_key);
+			if (!ret) {
+				printf("Fetching hash failed \n");
+				return NULL;
+			}
+		}
+	}
+#endif
+
+	payload = (void*)(image_buf + hdr_len);
+
+	/* check if we need to do anything */
+
+	if (hash_type == null_hash) {
+		memcpy(image_buf,payload,boot_hdr->image_len);
+		return image_buf;
+	}
+
+	/* Calculate Hash on the image, always use SHA-256 */
+	if (calculate_hash_bigsize((u8*)payload, boot_hdr->image_len, H_SHA256, &compute_hash[0], SHA_256_LENGTH)) {
+		printf ("Image Hash calculation failed\n");
+		return NULL;
+	}
+
+	if ( (hash_type == rsa_sha256) || (hash_type == aes_rsa_sha256)) {
+		/* Initialize PKA */
+		ibr_wrapper_pka_init();
+
+		/*
+		 * Decrypt the signature, always use RSA
+		 * Here we are assuming that the hash algorithm is always SHA256
+		 * So the result of the rsa_dsa_decrypt (ie stored_hash) will alwaus be 256 bits
+		 */
+		ret = ibr_wrapper_rsa_sig_decrypt((u8*)&pub_key[0],
+				pub_key_length,
+				(u8*)&hash_val[0],
+				hash_length,
+				&decrypted_hash[0], SHA_256_LENGTH, RSA_PKCS1_PADDING);
+		if (ret != 0)
+		{
+			printf ("Image RSA Hash decryption failed ret = %d\n",ret);
+			return NULL;
+		}
+
+		stored_hash = decrypted_hash;
+	}
+	else
+	{
+		stored_hash = hash_val;
+	}
+
+	if (memcmp(&stored_hash[0], &compute_hash[0], SHA_256_LENGTH)) {
+		printf ("Image Hash authentication failed\n");
+		return NULL;
+	}
+
+	if (hash_type == aes_rsa_sha256) {
+#ifndef CONFIG_SECUREBOOT_TEST
+		ret = secureboot_get_aes_key(aes_key,aes_key_length);
+		if (!ret) {
+			printf("Fetching hash failed \n");
+			return NULL;
+		}
+#else
+		memcpy(aes_key, aes_key_buffer, aes_key_length);
+#endif
+		/* Decrypt the Image */
+		/* Divide total buffer several SPACC_MAX_PROC_SIZE chunks, and perform decryption*/
+		buffer_len = boot_hdr->image_len;
+		enc_buffer = (u8 *) payload;
+		is_first_pkt=1;
+		while(buffer_len > SPACC_MAX_PROC_SIZE)
+		{
+			ret = spacc_decrypt(enc_buffer, SPACC_MAX_PROC_SIZE, C_AES, CM_CBC, aes_key, aes_key_length << 3,
+							&boot_hdr->optional_field[pub_key_length],enc_buffer, is_first_pkt);
+			if (ret != 0){
+				printf ("Image decryption failed\n");
+				return NULL;
+			}
+
+			buffer_len -= SPACC_MAX_PROC_SIZE;
+			enc_buffer += SPACC_MAX_PROC_SIZE;
+			is_first_pkt=0;
+		}
+
+		/* Perform decryption on remaining data */
+		if(buffer_len > 0)
+		{
+			ret = spacc_decrypt(enc_buffer, buffer_len, C_AES, CM_CBC, aes_key, aes_key_length << 3,
+							&boot_hdr->optional_field[pub_key_length],enc_buffer, is_first_pkt);
+			if (ret != 0){
+				printf ("Image decryption failed\n");
+				return NULL;
+			}
+		}
+	}
+
+	if (hash_type == aes_rsa_sha256)
+		printf("Image authenticated and decrypted\n");
+	else
+		printf("Image verified and authenticated\n");
+	memset(aes_key,0,aes_key_length);
+	memset(pub_key,0,pub_key_length);
+
+	memcpy(image_buf,payload,boot_hdr->image_len);
+
+	return  image_buf;
+}
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/arch/arm/cpu/armv7/comcerto/image_parser.c u-boot-2013.01.new/arch/arm/cpu/armv7/comcerto/image_parser.c
--- u-boot-2013.01/arch/arm/cpu/armv7/comcerto/image_parser.c	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/arch/arm/cpu/armv7/comcerto/image_parser.c	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,282 @@
+#include <common.h>
+#include <config.h>
+#include <asm/arch/clkcore.h>
+#include <asm/io.h>
+#include <command.h>
+#include <asm/arch/ibr_wrapper.h>
+#include <asm/arch/image.h>
+#include <asm/arch/spacc.h>
+#include <fs.h>
+
+static u8 public_key_storage[RSA_KEY_LENGTH_2K];
+static u8 compute_hash[SHA_256_LENGTH];
+static u8 extract_hash[SHA_256_LENGTH];
+static u8 aes_key_storage[AES_256_KEY_LENGTH];
+//u8 __aligned(8) dec_buffer[SPACC_MAX_PROC_SIZE+1];
+
+static void print_c2k_image(img_hdr *image)
+{
+	printf("magic:		0x%x\n", image->magic);
+	printf("timestamp:	0x%x\n", image->timestamp);
+	printf("header_crc:	0x%x\n", image->header_crc);
+	printf("key_length:	0x%x\n", image->key_length);
+	printf("hash_type:	0x%x\n", image->hash_type);
+	printf("image_len:	0x%x\n", image->image_len);
+}
+
+static void print_c2k_key(u8 *buf, u32 length)
+{
+	int ii;
+	for(ii=0; ii < length; ii++) {
+		if (!(ii % 16))
+			printf("\n");
+		printf(" 0x%02x", buf[ii]);
+	}
+}
+static void do_c2k_image_check(char *image_s, char *key_location_s, char *key_offset_s, char *key_length_s, char *aes_key_location_s, char *aes_key_offset_s, char *aes_key_length_s)
+{
+	int ret;
+	void *buf;
+	int len;
+	img_hdr *c2k_image;
+	u32 hdr_len = 0, buffer_len = 0;
+	u32 crc_read, crc;
+	u32 key_offset;
+	u32 key_size;
+	u32 aes_key_offset=0;
+	u32 aes_key_size = 0;
+	void *payload;
+	u8 *enc_buffer;
+	u8 is_first_pkt=0;
+
+
+	buf = (void*) simple_strtoul(image_s, NULL, 16);
+
+	key_offset = (u32) simple_strtoul(key_offset_s, NULL, 16);
+	if ((int) simple_strtoul(key_length_s, NULL, 10) == 1)
+		key_size = RSA_KEY_LENGTH_1K;
+	else
+		key_size = RSA_KEY_LENGTH_2K;
+
+	if (aes_key_offset_s != NULL)
+		aes_key_offset = (u32) simple_strtoul(aes_key_offset_s, NULL, 16);
+	if (aes_key_length_s != NULL) {
+		if ((int) simple_strtoul(aes_key_length_s, NULL, 10) == 128)
+			aes_key_size = AES_128_KEY_LENGTH;
+		if ((int) simple_strtoul(aes_key_length_s, NULL, 10) == 256)
+			aes_key_size = AES_256_KEY_LENGTH;
+	}
+
+	// check header
+	c2k_image = (img_hdr *)buf;
+	print_c2k_image(c2k_image);
+
+	/* Check Magic number */
+	if (c2k_image->magic != IMAGE_MAGIC_IDENTIFIER) {
+		printf("c2k_image_check: wrong magic number\n");
+		return;
+	}
+
+	hdr_len = IMAGE_HEADER_SIZE + key_size + aes_key_size; //don't take into account key in header for now
+
+	printf("\nhdr_len %d IMAGE_HEADER_SIZE %d keysize %d aes_key_size %d\n",hdr_len,IMAGE_HEADER_SIZE,key_size,aes_key_size);
+	printf(" c2k_image->image_len %d \n", c2k_image->image_len);
+
+	len = hdr_len + c2k_image->image_len;
+
+	printf ("image header dump\n");
+	print_c2k_key((u8 *)c2k_image, hdr_len);
+	printf ("\n");
+
+	/* Check image length */
+	if (len > MAX_SEC_BOOT_IMG_LEN) {
+		printf("c2k_image_check: image too big (%x > %x)\n", len, MAX_SEC_BOOT_IMG_LEN);
+		return;
+	}
+
+	/* Check crc */
+	crc_read = c2k_image->header_crc;
+
+	c2k_image->header_crc = 0;
+	crc = crc32(0, (unsigned char *)c2k_image, hdr_len);
+
+	if ( crc_read != crc) {
+		printf("c2k_image_check: error CRC (%x != %x)\n", crc_read, crc);
+		return;
+	}
+
+	/* Initialize ibr wrapper*/
+	ibr_wrapper_init();
+
+
+	/* Get the Public key */
+	/* Currently only supporting key in full key storage, i.e no key in header */
+
+	if (strcmp(key_location_s, "ddr") == 0) {
+		printf("c2k_image_check: Using Public key (size = %d) stored in DDR at addr=%x\n", key_size, key_offset);
+		memcpy(public_key_storage, (void*)key_offset, key_size);
+	} else if (strcmp(key_location_s, "otp") == 0) {
+		printf("c2k_image_check: Using Public key  (size = %d) stored in OTP at offset=%x\n", key_size, key_offset);
+		if (ibr_wrapper_otp_read(key_offset *8 , (u8 *)public_key_storage, key_size) != RETCODE_OK) {
+			printf ("c2k_image_check: error reading OTP\n");
+			return;
+		}
+	} else {
+		printf ("c2k_image_check: error please select correct public key location (ddr - otp\n");
+			return;
+	}
+
+	/* print Public key */
+	printf ("c2k_image_check: public key\n");
+	print_c2k_key(public_key_storage, key_size);
+	printf ("\n");
+
+	/* Compute sha-256 on the image payload */
+	/* hardware init */
+	ibr_wrapper_spacc_init();
+	payload = (void*)(buf + hdr_len);
+
+	printf ("c2k_image_check: image payload\n");
+	print_c2k_key(payload, 256);
+	printf ("\n...\n");
+
+	ret = calculate_hash_bigsize((u8 *)payload, c2k_image->image_len, H_SHA256, &compute_hash[0], SHA_256_LENGTH);
+	if (ret){
+		printf("c2k_image_check: sha-256 error (%x)\n",ret);
+		return;
+	}
+
+	printf ("c2k_image_check: sha-256 payload\n");
+	print_c2k_key(compute_hash, SHA_256_LENGTH);
+	printf ("\n");
+
+	/* Compute rsa decrypt on the image signature */
+
+	/* hardware init */
+	ibr_wrapper_pka_init();
+
+	/* decrypt signature */
+	ret = ibr_wrapper_rsa_sig_decrypt(public_key_storage, key_size,
+				&c2k_image->optional_field[0], key_size,
+				&extract_hash[0], SHA_256_LENGTH, RSA_PKCS1_PADDING);
+
+	if (ret){
+		printf("c2k_image_check: rsa decrypt error (%x)\n",ret);
+		return;
+	}
+
+	printf ("c2k_image_check: extract_hash payload\n");
+	print_c2k_key(extract_hash, SHA_256_LENGTH);
+	printf ("\n");
+
+	/* Compare hash values */
+	ret = memcmp(&extract_hash[0], &compute_hash[0], SHA_256_LENGTH);
+	if (ret != 0) {
+		printf ("c2k_image_check: hashes do not match\n");
+		return;
+	}
+
+	if (aes_key_location_s != NULL)	{
+		/* Get the AES key */
+
+		if (strcmp(aes_key_location_s, "ddr") == 0) {
+			printf("c2k_image_check: Using AES key (size = %d) stored in DDR at addr=%x\n", aes_key_size, aes_key_offset);
+			memcpy(aes_key_storage, (void*)aes_key_offset, aes_key_size);
+		} else if (strcmp(aes_key_location_s, "otp") == 0) {
+			printf("c2k_image_check: Using AES key  (size = %d) stored in OTP at offset=%x\n", aes_key_size, aes_key_offset);
+			if (ibr_wrapper_otp_read(aes_key_offset *8 , (u8 *)aes_key_storage, aes_key_size) != RETCODE_OK) {
+				printf ("c2k_image_check: error reading OTP\n");
+				return;
+			}
+		} else {
+			printf ("c2k_image_check: error please select correct aes key location (ddr - otp\n");
+				return;
+		}
+
+		printf ("\nc2k_image_check: aes_key\n");
+		print_c2k_key(aes_key_storage, aes_key_size);
+		printf ("\n");
+		printf ("\nc2k_image_check: aes_iv\n");
+		print_c2k_key(&c2k_image->optional_field[key_size], aes_key_size);
+		printf ("\n");
+
+
+		/* Divide total buffer several SPACC_MAX_PROC_SIZE chunks, and perform decryption*/
+		buffer_len = c2k_image->image_len;
+		enc_buffer = (u8 *) payload;
+		is_first_pkt=1;
+
+		while(buffer_len > SPACC_MAX_PROC_SIZE)
+		{
+			ret = spacc_decrypt(enc_buffer, SPACC_MAX_PROC_SIZE, C_AES, CM_CBC, aes_key_storage, aes_key_size << 3,
+								&c2k_image->optional_field[key_size], enc_buffer,is_first_pkt);
+			if (ret != 0){
+				printf("c2k_image_check: AES error (%x)\n",ret);
+				return;
+			}
+			
+			//memcpy(enc_buffer, dec_buffer,SPACC_MAX_PROC_SIZE);
+			//memset(dec_buffer,0,SPACC_MAX_PROC_SIZE);
+
+			buffer_len -= SPACC_MAX_PROC_SIZE;
+			enc_buffer += SPACC_MAX_PROC_SIZE;
+			is_first_pkt=0;
+		}
+
+		//memset(dec_buffer,0,SPACC_MAX_PROC_SIZE);
+		/* Perform decryption on remaining data */
+		if(buffer_len > 0)
+		{
+			ret = spacc_decrypt(enc_buffer, buffer_len, C_AES, CM_CBC, aes_key_storage, aes_key_size << 3,
+								&c2k_image->optional_field[key_size], enc_buffer, is_first_pkt);
+			if (ret != 0){
+				printf("c2k_image_check: AES error (%x)\n",ret);
+				return;
+			}
+			//memcpy(enc_buffer, dec_buffer, buffer_len);
+		}
+	}
+
+	printf ("\n\nc2k_image_check: C2k image is valid !!!\n");
+}
+
+static int do_image_parser(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	if ((argc != 9) && (argc !=6))
+		return CMD_RET_USAGE;
+
+	if (argc == 9 && strcmp(argv[1], "check") == 0)
+		do_c2k_image_check(argv[2], argv[3], argv[4], argv[5], argv[6], argv[7], argv[8]);
+	else if (argc == 6 && strcmp(argv[1], "check") == 0)
+		do_c2k_image_check(argv[2], argv[3], argv[4], argv[5], 0, 0, 0);
+	else
+		return CMD_RET_USAGE;
+
+	return 0;
+}
+
+static const __maybe_unused char cmd_c2k_image_help[] =
+"Usage:\n \
+c2k_image check <image address in ddr> <public key location> <public key offset> <key length> { <aes key location> <aes key offset> <aes key length> }\n \
+image: image address in ddr\n \
+public key location: otp or ddr\n \
+public key offset: in bytes from top of otp or ddr \n\
+key length: 1 or 2\n\
+aes key offset: in bytes from top of otp or ddr \n\
+aes key length: 128 or 256";
+
+
+U_BOOT_CMD(
+	c2k_image,   10,      1,      do_image_parser,
+	"Parse image header",
+	"Usage:\n"
+	"c2k_image check <image address in ddr> <public key location> <public key offset> <key length> {<aes key location> <aes key offset> <aes key len>} "
+	"image: image address in ddr\n"
+	"public key location: otp or ddr\n"
+	"public key offset: in bytes from top of otp or ddr \n"
+	"key length: 1 or 2\n"
+	"aes key location: otp or ddr\n"
+	"aes key offset: in bytes from top of otp or ddr \n"
+	"aes key length: 128 or 256\n"
+);
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/arch/arm/cpu/armv7/comcerto/Makefile u-boot-2013.01.new/arch/arm/cpu/armv7/comcerto/Makefile
--- u-boot-2013.01/arch/arm/cpu/armv7/comcerto/Makefile	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/arch/arm/cpu/armv7/comcerto/Makefile	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,54 @@
+#
+# (C) Copyright 2000-2005
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(SOC).o
+
+COBJS	+= timer.o
+COBJS	+= pad_config.o
+COBJS	+= clkcore.o
+COBJS	+= emac.o
+COBJS	+= ibr_wrapper.o
+COBJS	+= image_parser.o
+COBJS	+= secureboot_config.o
+COBJS	+= image.o
+COBJS	+= secureboot.o
+
+SRCS    := $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS    := $(addprefix $(obj),$(COBJS) $(SOBJS))
+
+all:	$(obj).depend $(LIB)
+
+$(LIB): $(OBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/arch/arm/cpu/armv7/comcerto/pad_config.c u-boot-2013.01.new/arch/arm/cpu/armv7/comcerto/pad_config.c
--- u-boot-2013.01/arch/arm/cpu/armv7/comcerto/pad_config.c	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/arch/arm/cpu/armv7/comcerto/pad_config.c	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,82 @@
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/clkcore.h>
+#include <asm/arch/ddr.h>
+#include <asm/arch/gpio.h>
+
+#define CONFIG_GEM_RGMII_2_5V
+//#define CONFIG_GEM_RGMII_3_3V
+#define CONFIG_HFE_OVERDRIVE
+
+/* Initialize pad config according to C2K_ChipDef_spec_010.doc */
+void comcerto_pad_config()
+{
+	u32 val;
+
+	/* HFE configurations */
+
+	/* Memories EMA Config 1 */
+	val = readl(COMCERTO_GPIO_MEM_EMA_CONFIG1);
+	val &= ~((0x3 << 6)|(0x3 << 17));
+	writel(val, COMCERTO_GPIO_MEM_EMA_CONFIG1);
+
+#if defined(CONFIG_GEM_RGMII_3_3V)
+	/*  Driving Strength of IO Pads */
+	/*In case GEMX operates in RMII or RGMII @3.3V mode then need to adjust
+	 *the driving strength of its IO pad (default value is for 2.5V) */
+	val = readl(COMCERTO_GPIO_PAD_CONFIG3);
+	val &= ~((0x3 << 6) | (0x3 << 12));
+	val |= ((0x2 << 6) | (0x2 << 12));
+	writel(val, COMCERTO_GPIO_PAD_CONFIG3);
+
+	val = readl(COMCERTO_GPIO_PAD_CONFIG4);
+	val &= ~((0x3 << 6)| (0x3 << 12));
+	val |= ((0x2 << 6) | (0x2 << 12));
+	writel(val, COMCERTO_GPIO_PAD_CONFIG4);
+
+	val = readl(COMCERTO_GPIO_PAD_CONFIG5);
+	val &= ~((0x3 << 6) | (0x3 << 12));
+	val |= ((0x2 << 6) | (0x2 << 12));
+	writel(val, COMCERTO_GPIO_PAD_CONFIG5);
+
+#elif defined(CONFIG_GEM_RGMII_2_5V)
+	/* RGMII Pad Compensation Logic (Tx side only)*/
+	val = readl(COMCERTO_GPIO_PAD_CTRL);
+	val &= ~((0x3 << 22) | (0x3 << 26) | (0x3 << 30));
+	writel(val, COMCERTO_GPIO_PAD_CTRL);
+#else
+#error "Either CONFIG_GEM_RGMII_3_3V or CONFIG_GEM_RGMII_2_5V should be selected"
+#endif
+	/* Slew Rate Control of IO Pads */
+	val = readl(COMCERTO_GPIO_PAD_CONFIG3);
+	val |= ((0x1 << 11) | (0x1 << 17));
+	writel(val, COMCERTO_GPIO_PAD_CONFIG3);
+
+	val = readl(COMCERTO_GPIO_PAD_CONFIG4);
+	val |= ((0x1 << 11) | (0x1 << 17));
+	writel(val, COMCERTO_GPIO_PAD_CONFIG4);
+
+	val = readl(COMCERTO_GPIO_PAD_CONFIG5);
+	val |= ((0x1 << 11) | (0x1 << 17));
+	writel(val, COMCERTO_GPIO_PAD_CONFIG5);
+
+#if defined (CONFIG_HFE_OVERDRIVE)
+	/* Memory Margin Bit setting */
+	/* In case HFE block operates in overdrive (1.2V) mode then need to
+	* modify few EMA fields related to HFE memories. The configuration
+	* registers are in GPIO block */
+	val = readl(COMCERTO_GPIO_MEM_EMA_CONFIG0);
+	val &= ~(0xFFF << 18);
+	val |= (0x38E << 18);
+	writel(val, COMCERTO_GPIO_MEM_EMA_CONFIG0);
+
+	val = readl(COMCERTO_GPIO_MEM_EMA_CONFIG1);
+	val &= ~(0x3F << 19);
+	val |= (0x8 << 18);
+	writel(val, COMCERTO_GPIO_MEM_EMA_CONFIG1);
+#endif
+
+	/*TODO Add rest of the configurations here*/
+
+}
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/arch/arm/cpu/armv7/comcerto/secureboot.c u-boot-2013.01.new/arch/arm/cpu/armv7/comcerto/secureboot.c
--- u-boot-2013.01/arch/arm/cpu/armv7/comcerto/secureboot.c	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/arch/arm/cpu/armv7/comcerto/secureboot.c	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,78 @@
+/*
+;=======================================================================
+;   Copyright (C) 2007 Mindspeed Technologies, Inc.
+;
+;        Author   : Makarand Pawagi
+;        Filename : secureboot.c
+;        Purpose  : secureboot wrapper Routines.
+;======================================================================
+*/
+
+/* Includes */
+#include <common.h>
+#include <config.h>
+#include <asm/arch/clkcore.h>
+#include <asm/io.h>
+#include <command.h>
+#include <asm/arch/ibr_wrapper.h>
+#include <asm/arch/otp.h>
+#include <asm/arch/secureboot.h>
+#include <asm/arch/spacc.h>
+#include <asm/arch/image.h>
+#include <fs.h>
+
+u32 secureboot_get_aes_key_length()
+{
+	u32 ret, aes_key_len = 0;
+	u8 secureboot_config;
+
+	ret = ibr_wrapper_otp_read(SECURE_CONFIG_OFFSET_BYTE_1, (u8 *)&secureboot_config, SECURE_CONFIG_SIZE_IN_BYTES);
+
+	if ( ret != RETCODE_OK )
+		return RETCODE_ERROR;
+
+	switch (secureboot_config & SEC_CONFIG_AES_KEY_SIZE) {
+		case 0:
+			aes_key_len = AES_128_KEY_LENGTH;
+		case 1:
+			aes_key_len = AES_256_KEY_LENGTH;
+	}
+	return aes_key_len;
+}
+/*
+ ****************************************
+ *   secureboot_get_aes_key ()
+ *
+ * Read AES Key from OTP config memory
+ * cache (refer eFuse Layout)
+ ****************************************
+ */
+u8 secureboot_get_aes_key(u8* key, u32 key_length)
+{
+	u32 ret;
+	u32 aes_key_offset=0, public_key_length=0;
+	u8 key_in_header;
+
+	if (ibr_wrapper_secureboot_init() != RETCODE_OK) {
+		printf ("secureboot init failed\n");
+		return -1;
+	}
+
+	key_in_header = ibr_wrapper_secureboot_is_key_in_header();
+
+	if(key_in_header != TRUE)
+		public_key_length = ibr_wrapper_secureboot_get_key_length();
+	else
+		public_key_length = SHA_256_LENGTH;
+
+	/* aes key offset = 4 byte offset for config area + public key or public key hash size*/
+	aes_key_offset = 4 + public_key_length;
+
+	ret = ibr_wrapper_otp_read((aes_key_offset * 8), (u8 *)key, key_length);
+
+	if ( ret != RETCODE_OK )
+		return RETCODE_ERROR;
+
+	return RETCODE_OK;
+}
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/arch/arm/cpu/armv7/comcerto/secureboot_config.c u-boot-2013.01.new/arch/arm/cpu/armv7/comcerto/secureboot_config.c
--- u-boot-2013.01/arch/arm/cpu/armv7/comcerto/secureboot_config.c	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/arch/arm/cpu/armv7/comcerto/secureboot_config.c	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,613 @@
+#include <common.h>
+#include <config.h>
+#include <asm/arch/clkcore.h>
+#include <asm/io.h>
+#include <command.h>
+#include <fs.h>
+#include <asm/arch/ibr_wrapper.h>
+#include <asm/arch/image.h>
+
+
+extern void otp_write(u32 offset, u8 *prog_data, int size);
+
+static int check_otp_range(u32 offset, int size)
+{
+	/* OTP size is 1KB*/
+	if (size <= 0)
+		return -1;
+	if (offset > 1024)
+		return -1;
+	if ((offset + size) > 1024)
+		return -1;
+	return 0;
+}
+
+static int c2k_otp_write(u32 byte_offset, u8 *write_data, u32 no_bytes)
+{
+	int ii, jj;
+	unsigned char bit_val;
+
+	printf("OTP Write request at byte offset: %d no of bytes: %d :\n", byte_offset, no_bytes);
+
+	for(ii=0; ii < no_bytes; ii++) {
+		if (!(ii % 16))
+			printf("\n");
+		printf(" 0x%02x", write_data[ii]);
+	}
+
+	printf("\n");
+
+	for(ii=0; ii < no_bytes; ii++) {
+		for(jj=0; jj < 8; jj++) {
+			bit_val = (write_data[ii] & (1 << jj)) ? 1 : 0;
+			if (bit_val)
+				otp_write(((byte_offset * 8) + (ii * 8) + jj), &bit_val, 1);
+		}
+	}
+
+	printf("\nOTP Write request done\n");
+
+	return 0;
+}
+
+
+static int c2k_otp_read(u32 byte_offset, u8 *read_data, u32 no_bytes)
+{
+	int ii;
+
+	printf("OTP read request at byte offset: %d no of bytes: %d :\n", byte_offset, no_bytes);
+
+	/* Initialize ibr wrapper*/
+	ibr_wrapper_init();
+
+	if (ibr_wrapper_otp_read(byte_offset * 8 , (u8 *)read_data, no_bytes) != RETCODE_OK) {
+		printf ("c2k_image_check: error reading OTP\n");
+		return -1;
+	}
+
+	for(ii=0; ii < no_bytes; ii++) {
+		if (!(ii % 16))
+			printf("\n");
+		printf(" 0x%02x", read_data[ii]);
+	}
+
+	printf("\n");
+	printf("\nOTP Read request done\n");
+
+	return 0;
+}
+
+static u8 public_key_storage[RSA_KEY_LENGTH_2K];
+static void do_c2k_key_write(char *byte_offset_s, char *write_data_s, char *key_length_s)
+{
+	u32 byte_offset;
+	u8 *write_data;
+	u32 no_bytes;
+	int ret;
+	int key_size=0;
+
+	byte_offset = (u32) simple_strtoul(byte_offset_s, NULL, 16);
+	write_data = (u8*) simple_strtoul(write_data_s, NULL, 16);
+
+	key_size = (int) simple_strtoul(key_length_s, NULL, 10);
+	if (key_size == 1) {
+		no_bytes = RSA_KEY_LENGTH_1K;
+	} else if (key_size == 2) {
+		no_bytes = RSA_KEY_LENGTH_2K;
+	} else if (key_size == 128) {
+		no_bytes = AES_128_KEY_LENGTH;
+	} else if (key_size == 256) {
+		no_bytes = AES_256_KEY_LENGTH;
+	} else {
+		printf ("c2k_key_write: key size is incorrect\n");
+		return;
+	}
+
+	if (check_otp_range(byte_offset, no_bytes))
+	{
+		printf ("c2k_key_write: wrong otp range\n");
+		return;
+	}
+	c2k_otp_write(byte_offset, write_data, no_bytes);
+
+	/* verify write */
+	c2k_otp_read(byte_offset, public_key_storage, no_bytes);
+
+	/* Compare buffers */
+	ret = memcmp(&public_key_storage[0], write_data, no_bytes);
+	if (ret != 0) {
+		printf ("c2k_key_write: buffers do not match\n");
+		return;
+	}
+}
+
+static void do_c2k_key_read(char *byte_offset_s, char *read_data_s, char *key_length_s)
+{
+
+	u32 byte_offset;
+	u8 *read_data;
+	u32 no_bytes;
+	int key_size=0;
+
+	byte_offset = (u32) simple_strtoul(byte_offset_s, NULL, 16);
+	read_data = (u8*) simple_strtoul(read_data_s, NULL, 16);
+
+	key_size = (int) simple_strtoul(key_length_s, NULL, 10);
+	if (key_size == 1) {
+		no_bytes = RSA_KEY_LENGTH_1K;
+	} else if (key_size == 2) {
+		no_bytes = RSA_KEY_LENGTH_2K;
+	} else if (key_size == 128) {
+		no_bytes = AES_128_KEY_LENGTH;
+	} else if (key_size == 256) {
+		no_bytes = AES_256_KEY_LENGTH;
+	} else {
+		printf ("c2k_key_write: key size is incorrect\n");
+		return;
+	}
+
+	if (check_otp_range(byte_offset, no_bytes))
+	{
+		printf ("c2k_key_read: wrong otp range\n");
+		return;
+	}
+
+	c2k_otp_read(byte_offset, read_data, no_bytes);
+}
+
+static int do_c2k_key(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	if (argc != 5)
+		return CMD_RET_USAGE;
+
+	if (argc == 5 && strcmp(argv[1], "write") == 0)
+		do_c2k_key_write(argv[2], argv[3], argv[4]);
+	else if (argc == 5 && strcmp(argv[1], "read") == 0)
+		do_c2k_key_read(argv[2], argv[3], argv[4]);
+	else
+		return CMD_RET_USAGE;
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	c2k_key,   5,      1,      do_c2k_key,
+	"c2k_key read/write",
+	"Usage:\n"
+	"c2k_key read <OTP offset> <ddr offset> <key length>\n"
+	"c2k_key write <OTP offset> <ddr offset> <key length>\n"
+	"read: read from OTP and write to ddr\n"
+	"read: read from ddr and write to OTP\n"
+	"OTP offset: offset in bytes from otp base\n"
+	"ddr offset: offset in bytes from ddr base\n"
+	"key length: for RSA 1 or 2, for AES 128 or 256"
+);
+
+
+static u8 scratch_pad[RSA_KEY_LENGTH_2K+4]; // 4 bytes of secureboot config space + maximum key size
+static int is_empty(char * buf, int size)
+{
+    int i;
+    for(i = 0; i < size; i++) {
+        if(buf[i] != 0) return 0;
+    }
+    return 1;
+}
+
+static int do_c2k_publickey(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	char *buf;
+	int key_len;
+	char secureboot_config;
+	int ret;
+	int ch;
+	if (argc != 2)
+		return CMD_RET_USAGE;
+
+	/*printf("loading file %s\n",argv[1]);
+	buf = read_file(argv[1], &len);
+	printf("done with len=%d\n",len);*/
+
+	buf = (void*) simple_strtoul(argv[1], NULL, 16);
+
+	key_len = (int) simple_strtoul(argv[2], NULL, 10);
+
+	if ( (key_len != RSA_KEY_LENGTH_1K) && (key_len != RSA_KEY_LENGTH_2K)) {
+		printf("c2k_publickey: file length does not match expected value (i.e 1Kb/2Kb for full key  (len=%d)\n",key_len);
+		return -1;
+	}
+
+	/* check otp memory */
+	/* otp is not write protected*/
+
+	/* check that otp has only 0s */
+	ret = c2k_otp_read(0, scratch_pad, (u32)(key_len + 4));
+	if (ret) {
+		printf("c2k_publickey:unable to read OTP\n");
+		return -1;
+	}
+	/* */
+	if(!is_empty((char *)scratch_pad, key_len + 4)) {
+		printf("c2k_publickey:OTP memory is not empty\n");
+		return -1;
+	}
+
+/*
+ * -------------------------------------------------------------------------
+ * OTP Layout
+ * -------------------------------------------------------------------------
+ *
+ *  Byte 0:
+ * 		 not used
+ *
+ *  Byte 1:
+ * 		 Bit [0] = JTAG/Coresight -- 0: Not Blocked, 1: Blocked
+ *		 Bit [1] = Authenticate boot code 0: Disable, 1: Enable
+ *		 Bit [3:2] = key size :  00 N/A
+ *						          01 1K
+ *							      10 2K
+ *							      11 4K
+ *		 Bit [4] = Key Package 0: Full 1: SHA-256 hash
+ * --------------------------------------------------------------------------
+ */
+
+	if (key_len == RSA_KEY_LENGTH_1K) {
+		secureboot_config = (char) 0x7; /* 0111 */
+	} else if (key_len == RSA_KEY_LENGTH_2K) {
+		secureboot_config = (char) 0xB; /* 1011 */
+	} else {
+		return -1; /* should not happen, but to please the compiler */
+	}
+
+	printf ("About to write to the OTP.\nPlease review the settings\n");
+	printf ("public key offset %s\n",argv[1]);
+	printf ("key size= %dKb\n", (key_len == RSA_KEY_LENGTH_1K)?1:2 );
+	printf ("secure boot config (%x)\n", secureboot_config);
+	printf ("is config correct? (Y/N)");
+	ch = getc();
+
+	switch(ch) {
+		case 'Y':
+		case 'y':
+			break;
+		case 'N':
+		case 'n':
+		default:
+			printf("\nc2k_publickey: Aborting\n");
+			return -1;
+	}
+
+	/* We are now able to write key to OTP */
+	c2k_otp_write(0x1, (u8 *)&secureboot_config, 1);
+	c2k_otp_write(0x4, (u8 *) buf, key_len);
+
+	printf("\nc2k_publickey: Please make sure that a valid uloader is stored in flash before resetting the board\n");
+	return 0;
+}
+
+U_BOOT_CMD(
+	c2k_publickey,   2,      0,      do_c2k_publickey,
+	"c2k_publickey <public key offset in ddr> <public key length in bytes",
+	"Usage:	 c2k_publickey <public key offset in ddr> <public key length in bytes>"
+);
+
+static int do_c2k_aeskey(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	char *buf,key_in_header=0;
+	int key_len=0, public_key_length=0;
+	int ch;
+	int aes_key_offset=0;
+
+	if (argc != 2)
+		return CMD_RET_USAGE;
+
+	/*printf("loading file %s\n",argv[1]);
+	buf = read_file(argv[1], &len);
+	printf("done with len=%d\n",len);*/
+
+	buf = (void*) simple_strtoul(argv[1], NULL, 16);
+
+	key_len = (int) simple_strtoul(argv[2], NULL, 10);
+
+	if ((key_len != AES_128_KEY_LENGTH) && (key_len != AES_256_KEY_LENGTH) ) {
+		printf("c2k_aeskey: key length does not match expected value (i.e 16bytes/32bytes (len=%d)\n",key_len);
+		return -1;
+	}
+
+	printf ("Please ensure that OTP config is already programmed if not this command will not succeed\n");
+	printf ("\n");
+	printf ("About to write to the OTP.\nPlease review the settings\n");
+	printf ("aes key offset in DDR %s\n",argv[1]);
+	printf ("key size = %d bits\n", key_len * 8 );
+	printf ("is config correct? (Y/N)");
+	ch = getc();
+
+	switch(ch) {
+		case 'Y':
+		case 'y':
+			break;
+		case 'N':
+		case 'n':
+		default:
+			printf("\nc2k_aeskey: Aborting\n");
+			return -1;
+	}
+
+	if (ibr_wrapper_secureboot_init() != RETCODE_OK) {
+                printf ("secureboot init failed\n");
+                return -1;
+        }
+
+	if(ibr_wrapper_secureboot_get_auth_mode() == FALSE) {
+		printf("Authentication mode is not enabled in OTP\n");
+		return -1;
+	}
+
+	key_in_header = ibr_wrapper_secureboot_is_key_in_header();
+
+	if(key_in_header != TRUE)
+		public_key_length = ibr_wrapper_secureboot_get_key_length();
+	else
+		public_key_length = SHA_256_LENGTH;
+
+	/* We are now able to write key to OTP */
+	/* aes key offset = 4 byte offset for config area + public key or public key hash size*/
+	aes_key_offset = 4 + public_key_length;
+	c2k_otp_write( aes_key_offset, (u8 *)buf, key_len);
+
+	printf("\nc2k_aeskey: Please make sure that a valid uloader is stored in flash before resetting the board\n");
+	return 0;
+}
+
+U_BOOT_CMD(
+	c2k_aeskey,   3,      0,      do_c2k_aeskey,
+	"c2k_aeskey <AES key offset in ddr> <AES key length in bytes",
+	"Usage:	 c2k_aeskey <AES key offset in ddr> <AES key length in bytes>"
+);
+
+static u8 temp_storage[256];
+static int do_c2k_otp_write(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	u32 byte_offset;
+	u8 *write_data;
+	u32 no_bytes;
+	int ch;
+	int ret;
+
+	if (argc != 4)
+		return CMD_RET_USAGE;
+
+	byte_offset = (u32) simple_strtoul(argv[1], NULL, 16);
+	write_data = (u8*) simple_strtoul(argv[2], NULL, 16);
+	no_bytes = (u32) simple_strtoul(argv[3], NULL, 10);
+
+	if (check_otp_range(byte_offset, no_bytes))
+	{
+		printf ("do_c2k_otp_write: wrong otp range\n");
+		return CMD_RET_USAGE;
+	}
+
+	/* check otp memory */
+	/* otp is not write protected*/
+
+	/* check that otp offset has only 0s */
+
+	ret = c2k_otp_read(byte_offset, scratch_pad, no_bytes);
+	if (ret) {
+		printf("do_c2k_otp_write: unable to read OTP\n");
+		return -1;
+	}
+	if(!is_empty((char *)scratch_pad, (int)(no_bytes))) {
+		printf("do_c2k_otp_write: OTP memory is not empty\n");
+		return -1;
+	}
+
+	printf ("About to write to the OTP.\nPlease review the settings\n");
+	printf ("OTP offset %s\n",argv[1]);
+	printf ("DDR offset %s\n",argv[2]);
+	printf ("number of bytes = %s\n", argv[3]);
+	printf ("is config correct? (Y/N)");
+	ch = getc();
+
+	switch(ch) {
+		case 'Y':
+		case 'y':
+			break;
+		case 'N':
+		case 'n':
+		default:
+			printf("\ndo_c2k_otp_write: Aborting\n");
+			return -1;
+	}
+
+	c2k_otp_write(byte_offset, write_data, no_bytes);
+
+	/* verify write */
+	c2k_otp_read(byte_offset, temp_storage, no_bytes);
+
+	/* Compare buffers */
+	ret = memcmp(&temp_storage[0], write_data, no_bytes);
+	if (ret != 0) {
+		printf ("c2k_otp_write: buffers do not match\n");
+		return 0;
+	}
+	return 0;
+}
+
+U_BOOT_CMD(
+	c2k_otp_write,   4,      1,      do_c2k_otp_write,
+	"c2k_otp_write",
+	"Usage:\n"
+	"c2k_otp_write <OTP offset> <DDR offset> <length>\n"
+	"OTP offset: offset in bytes from otp base\n"
+	"ddr offset: offset in bytes from ddr base\n"
+	"length: Number of bytes"
+);
+
+static int do_c2k_otp_config(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	char secureboot_config, temp_config;
+	int ret;
+	int ch;
+	int rsa_key_size=0;
+	int key_package=0;
+	int aes_key_size=0;
+	int jtag_blocking=0;
+
+/*
+ * -------------------------------------------------------------------------
+ * OTP Layout
+ * -------------------------------------------------------------------------
+ *
+ *  Byte 0:
+ * 		 not used
+ *
+ *  Byte 1:
+ * 		 Bit [0] = JTAG/Coresight -- 0: Not Blocked, 1: Blocked
+ *		 Bit [1] = Authenticate boot code 0: Disable, 1: Enable
+ *		 Bit [3:2] = key size :  00 N/A
+ *						          01 1K
+ *							      10 2K
+ *							      11 4K
+ *		 Bit [4] = Key Package 0: Full 1: SHA-256 hash
+ *		 Bit [5] = AES Key Size 0: 128-bit 1: 256-bit
+ * --------------------------------------------------------------------------
+ */
+
+	if (argc < 4)
+		return CMD_RET_USAGE;
+
+	rsa_key_size = (int) simple_strtoul(argv[1], NULL, 10);
+	key_package = (u32) simple_strtoul(argv[2], NULL, 10);
+	jtag_blocking = (u32) simple_strtoul(argv[3], NULL, 10);
+
+	if( argc == 5) {
+		aes_key_size =  (int) simple_strtoul(argv[4], NULL, 10);
+		if ( (aes_key_size != 0) && (aes_key_size != 1)) {
+			printf("Invalid AES key size option %d\n",aes_key_size);
+			return CMD_RET_USAGE;
+		}
+	}
+
+	if((key_package != 0) && (key_package != 1)) {
+		printf("Invalid option for key package\n");
+		return CMD_RET_USAGE;
+	}
+
+	if (rsa_key_size == 1) {
+		if(key_package == 0) {
+			if(jtag_blocking == 0) {
+				if(aes_key_size == 0)
+					secureboot_config = (char) 0x6; /* 0110 */
+				else
+					secureboot_config = (char) 0x26; /* 00100110 */
+			}
+			else {
+				if(aes_key_size == 0)
+					secureboot_config = (char) 0x7; /* 0111 */
+				else
+					secureboot_config = (char) 0x27; /* 00100111 */
+			}
+		}
+		else {
+			if(jtag_blocking == 0) {
+				if(aes_key_size == 0)
+					secureboot_config = (char) 0x16; /* 00010110 */
+				else
+					secureboot_config = (char) 0x36; /* 00110110 */
+			}
+			else {
+				if(aes_key_size == 0)
+					secureboot_config = (char) 0x17; /* 00010111 */
+				else
+					secureboot_config = (char) 0x37; /* 00110111 */
+			}
+		}
+	} else if (rsa_key_size == 2) {
+		if(key_package == 0) {
+			if(jtag_blocking == 0) {
+				if(aes_key_size == 0)
+					secureboot_config = (char) 0xA; /* 1010 */
+				else
+					secureboot_config = (char) 0x2A; /* 00101010 */
+			}
+			else {
+				if(aes_key_size == 0)
+					secureboot_config = (char) 0xB; /* 1011 */
+				else
+					secureboot_config = (char) 0x2B; /* 00101011 */
+			}
+		}
+		else {
+			if(jtag_blocking == 0) {
+				if(aes_key_size == 0)
+					secureboot_config = (char) 0x1A; /* 00011010 */
+				else
+					secureboot_config = (char) 0x3A; /* 00111010 */
+			}
+			else {
+				if(aes_key_size == 0)
+					secureboot_config = (char) 0x1B; /* 00011011 */
+				else
+					secureboot_config = (char) 0x3B; /* 00111011 */
+			}
+		}
+	} else {
+		printf("Invalid key length\n");
+		return CMD_RET_USAGE;
+	}
+
+	/* check otp memory */
+	/* otp is not write protected*/
+
+	/* check that otp config area has only 0s */
+
+	ret = c2k_otp_read(0x1, (u8 *)&temp_config, 1);
+	if (ret) {
+		printf("do_c2k_otp_write: unable to read OTP\n");
+		return -1;
+	}
+	if(temp_config != 0) {
+		printf("do_c2k_otp_config: OTP config memory is not empty\n");
+		return -1;
+	}
+
+	printf ("About to write to the OTP config.\nPlease review the settings\n");
+	printf ("secure boot config (%x)\n", secureboot_config);
+	printf ("is config correct? (Y/N)");
+	ch = getc();
+
+	switch(ch) {
+		case 'Y':
+		case 'y':
+			break;
+		case 'N':
+		case 'n':
+		default:
+			printf("\ndo_c2k_otp_config: Aborting\n");
+			return -1;
+	}
+
+	c2k_otp_write(0x1, (u8 *)&secureboot_config, 1);
+
+	/* verify write */
+	c2k_otp_read(0x1, (u8 *)&temp_config, 1);
+
+	/* Compare*/
+	if (secureboot_config != temp_config) {
+		printf ("c2k_otp_config: read write buffers do not match\n");
+		return 0;
+	}
+	return 0;
+}
+U_BOOT_CMD(
+	c2k_otp_config,   4,      1,      do_c2k_otp_config,
+	"c2k_otp_config",
+	"Usage:\n"
+	"c2k_otp_config <RSA key size> <key package> <Jtag blocking> { <aes key size> }\n"
+	"key size: 1 or 2, 1 for RSA-1024 2 for RSA-2048 \n"
+	"key package: 0 or 1, 0 for key in OTP 1 for Hash of key in OTP \n"
+	"JTAG blocking: 0 or 1, 0 non blocking 1 for blocking "
+	"AES key size: 0 or 1, 0 for 128-bit 1 for 256-bit"
+);
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/arch/arm/cpu/armv7/comcerto/timer.c u-boot-2013.01.new/arch/arm/cpu/armv7/comcerto/timer.c
--- u-boot-2013.01/arch/arm/cpu/armv7/comcerto/timer.c	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/arch/arm/cpu/armv7/comcerto/timer.c	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,148 @@
+/*
+ * (C) Copyright 2006
+ * Mindspeed Technologies, Inc. <www.mindspeed.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/hardware.h>
+#include <asm/byteorder.h>
+#include <div64.h>
+#include <asm/arch/a9_mpu.h>
+#include <asm/arch/clkcore.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define TIMER_LOAD_VAL		0xFFFFFFFF
+
+int timer_init (void)
+{
+	int i;
+
+        writel(TIMER_LOAD_VAL, COMCERTO_A9_TIMER_BASE + A9_TIMER_LOAD);
+        writel(TIMER_LOAD_VAL, COMCERTO_A9_TIMER_BASE + A9_TIMER_COUNTER);
+        writel(A9_TIMER_ENABLE | A9_TIMER_RELOAD, COMCERTO_A9_TIMER_BASE + A9_TIMER_CNTRL);
+
+	reset_timer();
+	return 0;
+}
+
+static u32 read_timer(void)
+{
+	return readl(COMCERTO_A9_TIMER_BASE + A9_TIMER_COUNTER);
+}
+
+/*
+ * Delay x useconds
+ */
+void __udelay(unsigned long usec)
+{
+	unsigned long now, last;
+	/*
+	 * get the tmo value based on timer clock speed
+	 * tmo = delay required / period of timer clock
+	 */
+	long long tmo = usec * HAL_get_arm_peri_clk();
+
+	last = read_timer();
+	while (tmo > 0) {
+		now = read_timer();
+		if (last >= now)
+			/* normal mode (non roll) */
+			tmo -= last - now;
+		else
+			/* we have overflow of the count down timer */
+			tmo -= TIMER_LOAD_VAL - last + now;
+		last = now;
+	}
+}
+
+/*
+ * Get the timer value
+ */
+ulong get_timer(ulong base)
+{
+	return get_timer_masked() - base;
+}
+
+/*
+ * Timer : get the time difference
+ * Unit of tick is based on the CONFIG_SYS_HZ
+ */
+ulong get_timer_masked(void)
+{
+	/* current tick value */
+	ulong now = read_timer() / ((HAL_get_arm_peri_clk() * 1000 * 1000) / CONFIG_SYS_HZ);
+
+	if (gd->lastinc >= now) {
+
+		/* normal mode (non roll) */
+		/* move stamp forward with absolute diff ticks */
+		gd->tbl += gd->lastinc - now;
+
+	} else {
+
+		/* we have overflow of the count down timer */
+		gd->tbl += (TIMER_LOAD_VAL/((HAL_get_arm_peri_clk() * 1000 * 1000)/CONFIG_SYS_HZ)) - gd->lastinc - now;
+
+	}
+	gd->lastinc = now;
+
+	return gd->tbl;
+}
+
+/*
+ * Reset the timer
+ */
+void reset_timer(void)
+{
+	/* capture current decrementer value time */
+	gd->lastinc = read_timer() / ((HAL_get_arm_peri_clk() * 1000 * 1000) / CONFIG_SYS_HZ);
+	/* start "advancing" time stamp from 0 */
+	gd->tbl = 0;
+}
+
+unsigned long long get_ticks(void)
+{
+	return get_timer(0);
+}
+
+/*
+ * This function is derived from PowerPC code (timebase clock frequency).
+ * On ARM it returns the number of timer ticks per second.
+ */
+ulong get_tbclk (void)
+{
+	ulong tbclk;
+
+	tbclk = CONFIG_SYS_HZ;
+	return tbclk;
+}
+
+/*
+ *
+ */
+void reset_cpu (ulong ignored)
+{
+	/* Soft reset */
+	writel(0x1, DEVICE_RST_CNTRL);
+
+	while(1)
+		;
+}
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/arch/arm/cpu/armv7/Makefile u-boot-2013.01.new/arch/arm/cpu/armv7/Makefile
--- u-boot-2013.01/arch/arm/cpu/armv7/Makefile	2013-01-16 03:17:42.000000000 +0530
+++ u-boot-2013.01.new/arch/arm/cpu/armv7/Makefile	2016-03-23 16:10:34.000000000 +0530
@@ -32,7 +32,7 @@
 COBJS	+= cpu.o
 COBJS	+= syslib.o
 
-ifneq ($(CONFIG_AM33XX)$(CONFIG_OMAP44XX)$(CONFIG_OMAP54XX)$(CONFIG_TEGRA20),)
+ifneq ($(CONFIG_AM33XX)$(CONFIG_OMAP44XX)$(CONFIG_OMAP54XX)$(CONFIG_TEGRA20)$(CONFIG_COMCERTO_2000),)
 SOBJS	+= lowlevel_init.o
 endif
 
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/arch/arm/include/asm/arch-comcerto/a9_mpu.h u-boot-2013.01.new/arch/arm/include/asm/arch-comcerto/a9_mpu.h
--- u-boot-2013.01/arch/arm/include/asm/arch-comcerto/a9_mpu.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/arch/arm/include/asm/arch-comcerto/a9_mpu.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,20 @@
+#define A9_TIMER_LOAD		0x0
+#define A9_TIMER_COUNTER	0x4
+#define A9_TIMER_CNTRL		0x8
+#define A9_TIMER_INT_STAT	0xC
+
+#define	A9_WD_LOAD		0x20
+#define	A9_WD_COUNTER		0x24
+#define	A9_WD_CNTRL		0x28
+#define	A9_WD_INT_STAT		0x2C
+#define	A9_WD_RST_STAT		0x30
+#define	A9_WD_DISABLE		0x34
+
+#define A9_TIMER_ENABLE		(1<<0)
+#define A9_TIMER_RELOAD		(1<<1)
+#define A9_TIMER_IRQ_EN		(1<<2)
+
+#define A9_WD_ENABLE		(1<<0)
+#define A9_WD_RELOAD		(1<<1)
+#define A9_WD_MODE_WD		(1<<3)
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/arch/arm/include/asm/arch-comcerto/bits.h u-boot-2013.01.new/arch/arm/include/asm/arch-comcerto/bits.h
--- u-boot-2013.01/arch/arm/include/asm/arch-comcerto/bits.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/arch/arm/include/asm/arch-comcerto/bits.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,38 @@
+#ifndef __bits_h
+#define __bits_h 1
+
+#define BIT0  (1<<0)
+#define BIT1  (1<<1)
+#define BIT2  (1<<2)
+#define BIT3  (1<<3)
+#define BIT4  (1<<4)
+#define BIT5  (1<<5)
+#define BIT6  (1<<6)
+#define BIT7  (1<<7)
+#define BIT8  (1<<8)
+#define BIT9  (1<<9)
+#define BIT10 (1<<10)
+#define BIT11 (1<<11)
+#define BIT12 (1<<12)
+#define BIT13 (1<<13)
+#define BIT14 (1<<14)
+#define BIT15 (1<<15)
+#define BIT16 (1<<16)
+#define BIT17 (1<<17)
+#define BIT18 (1<<18)
+#define BIT19 (1<<19)
+#define BIT20 (1<<20)
+#define BIT21 (1<<21)
+#define BIT22 (1<<22)
+#define BIT23 (1<<23)
+#define BIT24 (1<<24)
+#define BIT25 (1<<25)
+#define BIT26 (1<<26)
+#define BIT27 (1<<27)
+#define BIT28 (1<<28)
+#define BIT29 (1<<29)
+#define BIT30 (1<<30)
+#define BIT31 (1<<31)
+
+#endif
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/arch/arm/include/asm/arch-comcerto/clkcore.h u-boot-2013.01.new/arch/arm/include/asm/arch-comcerto/clkcore.h
--- u-boot-2013.01/arch/arm/include/asm/arch-comcerto/clkcore.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/arch/arm/include/asm/arch-comcerto/clkcore.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,343 @@
+#ifndef __CLKCORE_H__
+#define __CLKCORE_H__
+
+#include "comcerto-2000.h"
+
+#define USB0_PHY_CTRL_REG0           0x90410000
+#define USB1_PHY_CTRL_REG0           0x90410010
+#define USB_PHY_SCALEDOWN_ADDR       0x9046003C
+
+#define DEVICE_RST_CNTRL	     (COMCERTO_APB_CLK_BASE + 0x00)
+#define SERDES_RST_CNTRL             (COMCERTO_APB_CLK_BASE + 0x04)
+#define PCIe_SATA_RST_CNTRL          (COMCERTO_APB_CLK_BASE + 0x08)
+#define USB_RST_CNTRL                (COMCERTO_APB_CLK_BASE + 0x0C)
+#define A9DP_PWR_STAT                (COMCERTO_APB_CLK_BASE + 0x28)
+#define A9DP_PWR_CNTRL               (COMCERTO_APB_CLK_BASE + 0x2C)
+#define GNRL_CLK_CNTRL_0	     (COMCERTO_APB_CLK_BASE + 0x30)
+#define GNRL_CLK_CNTRL_1	     (COMCERTO_APB_CLK_BASE + 0x34)
+#define PLLS_GLOBAL_CNTRL            (COMCERTO_APB_CLK_BASE + 0x38)
+#define AXI_CLK_CNTRL_0              (COMCERTO_APB_CLK_BASE + 0x40)
+#define AXI_CLK_CNTRL_1              (COMCERTO_APB_CLK_BASE + 0x44)
+#define AXI_CLK_CNTRL_2              (COMCERTO_APB_CLK_BASE + 0x48)
+#define AXI_CLK_DIV_CNTRL            (COMCERTO_APB_CLK_BASE + 0x4C)
+#define AXI_RESET_0                  (COMCERTO_APB_CLK_BASE + 0x50)
+#define AXI_RESET_1                  (COMCERTO_APB_CLK_BASE + 0x54)
+#define AXI_RESET_2                  (COMCERTO_APB_CLK_BASE + 0x58)
+#define A9DP_MPU_CLK_CNTRL           (COMCERTO_APB_CLK_BASE + 0x68)
+#define A9DP_MPU_CLK_DIV_CNTRL       (COMCERTO_APB_CLK_BASE + 0x6C)
+#define A9DP_MPU_RESET               (COMCERTO_APB_CLK_BASE + 0x70)
+#define A9DP_CPU_CLK_CNTRL           (COMCERTO_APB_CLK_BASE + 0x74)
+#define A9DP_CPU_RESET               (COMCERTO_APB_CLK_BASE + 0x78)
+#define A9DP_CLK_CNTRL               (COMCERTO_APB_CLK_BASE + 0x80)
+#define A9DP_CLK_DIV_CNTRL           (COMCERTO_APB_CLK_BASE + 0x84)
+#define A9DP_RESET                   (COMCERTO_APB_CLK_BASE + 0x88)
+#define L2CC_CLK_CNTRL               (COMCERTO_APB_CLK_BASE + 0x90)
+#define L2CC_CLK_DIV_CNTRL           (COMCERTO_APB_CLK_BASE + 0x94)
+#define L2CC_RESET                   (COMCERTO_APB_CLK_BASE + 0x98)
+#define TPI_CLK_CNTRL                (COMCERTO_APB_CLK_BASE + 0xA0)
+#define TPI_CLK_DIV_CNTRL            (COMCERTO_APB_CLK_BASE + 0xA4)
+#define TPI_RESET                    (COMCERTO_APB_CLK_BASE + 0xA8)
+#define CSYS_CLK_CNTRL               (COMCERTO_APB_CLK_BASE + 0xB0)
+#define CSYS_CLK_DIV_CNTRL           (COMCERTO_APB_CLK_BASE + 0xB4)
+#define CSYS_RESET                   (COMCERTO_APB_CLK_BASE + 0xB8)
+#define EXTPHY0_CLK_CNTRL            (COMCERTO_APB_CLK_BASE + 0xC0)
+#define EXTPHY0_CLK_DIV_CNTRL        (COMCERTO_APB_CLK_BASE + 0xC4)
+#define EXTPHY0_RESET                (COMCERTO_APB_CLK_BASE + 0xC8)
+#define EXTPHY1_CLK_CNTRL            (COMCERTO_APB_CLK_BASE + 0xD0)
+#define EXTPHY1_CLK_DIV_CNTRL        (COMCERTO_APB_CLK_BASE + 0xD4)
+#define EXTPHY1_RESET                (COMCERTO_APB_CLK_BASE + 0xD8)
+#define EXTPHY2_CLK_CNTRL            (COMCERTO_APB_CLK_BASE + 0xE0)
+#define EXTPHY2_CLK_DIV_CNTRL        (COMCERTO_APB_CLK_BASE + 0xE4)
+#define EXTPHY2_RESET                (COMCERTO_APB_CLK_BASE + 0xE8)
+#define DDR_CLK_CNTRL                (COMCERTO_APB_CLK_BASE + 0xF0)
+#define DDR_CLK_DIV_CNTRL            (COMCERTO_APB_CLK_BASE + 0xF4)
+#define DDR_RESET                    (COMCERTO_APB_CLK_BASE + 0xF8)
+#define HFE_CLK_CNTRL                (COMCERTO_APB_CLK_BASE + 0x100)
+#define HFE_CLK_DIV_CNTRL            (COMCERTO_APB_CLK_BASE + 0x104)
+#define HFE_RESET                    (COMCERTO_APB_CLK_BASE + 0x108)
+#define IPSEC_CLK_CNTRL              (COMCERTO_APB_CLK_BASE + 0x110)
+#define IPSEC_CLK_DIV_CNTRL          (COMCERTO_APB_CLK_BASE + 0x114)
+#define IPSEC_RESET                  (COMCERTO_APB_CLK_BASE + 0x118)
+#define DECT_CLK_CNTRL               (COMCERTO_APB_CLK_BASE + 0x120)
+#define DECT_CLK_DIV_CNTRL           (COMCERTO_APB_CLK_BASE + 0x124)
+#define DECT_RESET                   (COMCERTO_APB_CLK_BASE + 0x128)
+#define GEMTX_CLK_CNTRL              (COMCERTO_APB_CLK_BASE + 0x130)
+#define GEMTX_CLK_DIV_CNTRL          (COMCERTO_APB_CLK_BASE + 0x134)
+#define GEMTX_RESET                  (COMCERTO_APB_CLK_BASE + 0x138)
+#define TDMNTG_REF_CLK_CNTRL         (COMCERTO_APB_CLK_BASE + 0x140)
+#define TDMNTG_REF_CLK_DIV_CNTRL     (COMCERTO_APB_CLK_BASE + 0x144)
+#define TDMNTG_RESET                 (COMCERTO_APB_CLK_BASE + 0x148)
+#define TDM_CLK_CNTRL                (COMCERTO_APB_CLK_BASE + 0x14C)
+#define TSUNTG_REF_CLK_CNTRL         (COMCERTO_APB_CLK_BASE + 0x150)
+#define TSUNTG_REF_CLK_DIV_CNTRL     (COMCERTO_APB_CLK_BASE + 0x154)
+#define TSUNTG_RESET                 (COMCERTO_APB_CLK_BASE + 0x158)
+#define SATA_PMU_CLK_CNTRL           (COMCERTO_APB_CLK_BASE + 0x160)
+#define SATA_PMU_CLK_DIV_CNTRL       (COMCERTO_APB_CLK_BASE + 0x164)
+#define SATA_PMU_RESET               (COMCERTO_APB_CLK_BASE + 0x168)
+#define SATA_OOB_CLK_CNTRL           (COMCERTO_APB_CLK_BASE + 0x170)
+#define SATA_OOB_CLK_DIV_CNTRL       (COMCERTO_APB_CLK_BASE + 0x174)
+#define SATA_OOB_RESET               (COMCERTO_APB_CLK_BASE + 0x178)
+#define PLL0_M_LSB                   (COMCERTO_APB_CLK_BASE + 0x1C0)
+#define PLL0_M_MSB                   (COMCERTO_APB_CLK_BASE + 0x1C4)
+#define PLL0_P                       (COMCERTO_APB_CLK_BASE + 0x1C8)
+#define PLL0_S                       (COMCERTO_APB_CLK_BASE + 0x1CC)
+#define PLL0_CNTRL                   (COMCERTO_APB_CLK_BASE + 0x1D0)
+#define PLL0_TEST                    (COMCERTO_APB_CLK_BASE + 0x1D4)
+#define PLL0_STATUS                  (COMCERTO_APB_CLK_BASE + 0x1D8)
+#define PLL1_M_LSB                   (COMCERTO_APB_CLK_BASE + 0x1E0)
+#define PLL1_M_MSB                   (COMCERTO_APB_CLK_BASE + 0x1E4)
+#define PLL1_P                       (COMCERTO_APB_CLK_BASE + 0x1E8)
+#define PLL1_S                       (COMCERTO_APB_CLK_BASE + 0x1EC)
+#define PLL1_CNTRL                   (COMCERTO_APB_CLK_BASE + 0x1F0)
+#define PLL1_TEST                    (COMCERTO_APB_CLK_BASE + 0x1F4)
+#define PLL1_STATUS                  (COMCERTO_APB_CLK_BASE + 0x1F8)
+#define PLL2_M_LSB                   (COMCERTO_APB_CLK_BASE + 0x200)
+#define PLL2_M_MSB                   (COMCERTO_APB_CLK_BASE + 0x204)
+#define PLL2_P                       (COMCERTO_APB_CLK_BASE + 0x208)
+#define PLL2_S                       (COMCERTO_APB_CLK_BASE + 0x20C)
+#define PLL2_CNTRL                   (COMCERTO_APB_CLK_BASE + 0x210)
+#define PLL2_TEST                    (COMCERTO_APB_CLK_BASE + 0x214)
+#define PLL2_STATUS                  (COMCERTO_APB_CLK_BASE + 0x218)
+#define PLL3_M_LSB                   (COMCERTO_APB_CLK_BASE + 0x220)
+#define PLL3_M_MSB                   (COMCERTO_APB_CLK_BASE + 0x224)
+#define PLL3_P                       (COMCERTO_APB_CLK_BASE + 0x228)
+#define PLL3_S                       (COMCERTO_APB_CLK_BASE + 0x22C)
+#define PLL3_CNTRL                   (COMCERTO_APB_CLK_BASE + 0x230)
+#define PLL3_TEST                    (COMCERTO_APB_CLK_BASE + 0x234)
+#define PLL3_STATUS                  (COMCERTO_APB_CLK_BASE + 0x238)
+#define PLL3_DITHER_CNTRL 	     (COMCERTO_APB_CLK_BASE + 0x23C) 
+#define PLL3_K_LSB 		     (COMCERTO_APB_CLK_BASE + 0x240) 
+#define PLL3_K_MSB 		     (COMCERTO_APB_CLK_BASE + 0x244) 
+#define PLL3_MFR 		     (COMCERTO_APB_CLK_BASE + 0x248) 
+#define PLL3_MRR 		     (COMCERTO_APB_CLK_BASE + 0x24C)
+
+/* PCIe, SATA,  and SERDES Reset bits*/ 
+#define PCIE0_PWR_RST           (1 << 0)
+#define PCIE0_REG_RST  	        (1 << 1)
+#define PCIE1_PWR_RST           (1 << 2)
+#define PCIE1_REG_RST  	        (1 << 3)
+
+#define SATA0_RX_RST           	(1 << 4)
+#define SATA0_TX_RST 	       	(1 << 5)
+#define SATA1_RX_RST           	(1 << 6)
+#define SATA1_TX_RST  	        (1 << 7)
+
+#define PCIE0_AXI_RST  	        (1 << 0)
+#define PCIE1_AXI_RST  	        (1 << 1)
+#define SATA_AXI_RST	        (1 << 2)
+#define AXI_PCIE0_CLK_EN	(1 << 0)
+#define AXI_PCIE1_CLK_EN	(1 << 1)
+#define AXI_SATA_CLK_EN		(1 << 2)
+
+#define SERDES0_RST           	(1 << 0)
+#define SERDES1_RST           	(1 << 1)
+#define SERDES2_RST           	(1 << 2)
+
+/* AXI_RESET_1 bits */
+#define HFE_AXI_RESET		(1 << 3)
+
+//Clock Divider mirror mechanism in IRAM. It is going to take more than 256 bytes of IRAM
+#define IRAM_CLK_REG_MIRROR	0x8300FC00 //maybe to need to think of the another fixed location
+#define CLK_REG_DIV_BUG_BASE	AXI_CLK_DIV_CNTRL	
+
+#define PLL_RESET (1 << 0)
+#define PLL_BYPASS (1 << 4)
+#define PLL_LOCK_EN (1 << 5)
+#define PLL_VSEL (1 << 6)
+
+#define CLK_DIV_BYPASS	(1 << 7)
+#define CLK_A9DP_PERI_DIV_BYPASS	(1 << 3)
+#define CLK_A9DP_ACP_DIV_BYPASS	(1 << 7)
+
+#define CLK_PLL_SRC_MASK	0x7
+#define CLK_PLL_SRC_SHIFT	1
+
+#define CLK_DIV_VAL_DEFAULT		0x2
+#define A9DP_ACP_CLK_DIV_VAL_DEFAULT	0x2
+#define A9DP_PERI_CLK_DIV_VAL_DEFAULT	0x2
+
+struct pll_info {
+	u32 m;
+	u32 p;
+	u32 s;
+	u32 vsel;
+};
+
+struct pll3_info {
+	u32 m;
+	u32 p;
+	u32 s;
+	u32 k;
+	u32 vsel;
+};
+
+struct pll_setting {
+        u32 pll0_freq_idx;
+        u32 pll1_freq_idx;
+        u32 pll2_freq_idx;
+        u32 pll3_freq_idx;
+};
+
+struct clock_cfg_settings 
+{
+	u32 pll_cfg_idx;
+
+	u32 arm_clk;
+	u32 arm_clk_src;
+
+	u32 axi_clk;
+	u32 axi_clk_src;
+
+	u32 ddr_clk;
+	u32 ddr_clk_src;
+
+	u32 ipsec_clk;
+	u32 ipsec_clk_src;
+
+	u32 sata_oob_clk;
+	u32 sata_oob_clk_src;
+
+	u32 sata_pmu_clk;
+	u32 sata_pmu_clk_src;
+
+	u32 dect_clk;
+	u32 dect_clk_src;
+
+	u32 l2cc_clk;
+	u32 l2cc_clk_src;
+
+	u32 hfe_clk;
+	u32 hfe_clk_src;
+	
+	u32 gemtx_clk;
+	u32 gemtx_clk_src;
+
+	u32 extphy0_clk;
+	u32 extphy0_clk_src;
+
+	u32 extphy1_clk;
+	u32 extphy1_clk_src;
+
+	u32 extphy2_clk;
+	u32 extphy2_clk_src;
+
+	u32 tpi_clk;
+	u32 tpi_clk_src;
+
+	u32 csys_clk;
+	u32 csys_clk_src;
+};
+
+enum {
+	PLL0 = 0,
+	PLL1,
+	PLL2,
+	PLL3
+};
+
+#define CFG_REFCLKFREQ_24          24000000        /* 24 MHz */
+#define CFG_REFCLKFREQ_48          48000000        /* 48 MHz */
+#define CFG_REFCLKFREQ          CFG_REFCLKFREQ_48
+
+#define PLL_FREQ_2400	2400
+#define PLL_FREQ_1800	1800
+#define PLL_FREQ_1600	1600
+#define PLL_FREQ_1500	1500
+#define PLL_FREQ_1400	1400
+#define PLL_FREQ_1300	1300
+#define PLL_FREQ_1066	1066
+#define PLL_FREQ_1000	1000
+#define PLL_FREQ_800	800
+#define PLL_FREQ_750	750
+#define PLL_FREQ_500	500
+
+enum {
+	PLL_CFG_1800 = 0,
+	PLL_CFG_1600,
+	PLL_CFG_1500,
+	PLL_CFG_1400,
+	PLL_CFG_1300,
+	PLL_CFG_1000,
+	PLL_CFG_800,
+	PLL_CFG_750,
+	PLL_CFG_500,
+	PLL_CFG_2400	
+};
+
+enum {
+	PLL3_CFG_1066 = 0,
+	PLL3_CFG_800
+};
+
+#define PLL0_CFG_2400   PLL_CFG_2400
+#define PLL0_CFG_1300   PLL_CFG_1300
+#define PLL0_CFG_1800   PLL_CFG_1800
+#define PLL0_CFG_750    PLL_CFG_750
+
+#define PLL1_CFG_1000   PLL_CFG_1000
+#define PLL1_CFG_800    PLL_CFG_800
+
+#define PLL2_CFG_1500   PLL_CFG_1500
+#define PLL2_CFG_500    PLL_CFG_500
+
+
+enum {
+	CLK_CFG1 = 0,
+	CLK_CFG2,
+	CLK_CFG3,
+	CLK_CFG4,
+	CLK_CFG5,
+	CLK_CFG6	
+};
+
+enum {
+	PLL_CFG_1800_1000_1500_1066 = 0,
+	PLL_CFG_750_1000_1500_800,
+	PLL_CFG_1300_800_500_800,
+	PLL_CFG_1300_800_500_1066,
+	PLL_CFG_1800_800_500_1066,
+	PLL_CFG_2400_1000_1500_1066	
+};
+
+#if     defined(CONFIG_M86201) || defined(CONFIG_M86202) || defined(CONFIG_M86203) || defined(CONFIG_M86204) || defined(CONFIG_M86206) || defined(CONFIG_M86207) || defined(CONFIG_M86208)
+#define CLK_CFG		CLK_CFG6
+#elif 	defined(CONFIG_M86260) || defined(CONFIG_M86261) || defined(CONFIG_M86262)
+#define CLK_CFG		CLK_CFG3
+#elif 	defined(CONFIG_M86261_NAS) 
+#define CLK_CFG		CLK_CFG4
+#elif   defined (CONFIG_M86291) || defined (CONFIG_M86292) || defined (CONFIG_M86293) || defined (CONFIG_M86294) || defined (CONFIG_M86295) || defined (CONFIG_M86296) || defined (CONFIG_M86297) || defined (CONFIG_M86298)
+#define CLK_CFG		CLK_CFG1
+#endif
+
+#define ARM_CLK_1200	1200
+#define ARM_CLK_900	900
+#define ARM_CLK_750	750
+#define ARM_CLK_650	650
+#define AXI_CLK_250	250
+#define AXI_CLK_200	200
+#define DDR_CLK_533	533
+#define DDR_CLK_400	400
+#define SATA_OOB_CLK_125	125
+#define SATA_PMU_CLK_30		30
+#define SATA_PMU_CLK_25		25
+#define	IPSEC_CLK_300	300
+#define	IPSEC_CLK_250	250
+#define DECT_CLK_250	250
+#define L2CC_CLK_600	600
+#define L2CC_CLK_450	450
+#define L2CC_CLK_375	375
+#define L2CC_CLK_325	325
+#define HFE_CLK_500	500
+#define HFE_CLK_400	400
+#define GEMTX_CLK_125	125
+#define EXTPHY0_CLK_125	125
+#define EXTPHY1_CLK_125	125
+#define EXTPHY2_CLK_125	125
+#define TPI_CLK_250	250
+#define CSYS_CLK_166	166
+
+
+#define read_clk_div_bypass_backup(reg) readl(reg - CLK_REG_DIV_BUG_BASE + IRAM_CLK_REG_MIRROR)
+#define write_clk_div_bypass_backup(val, reg) writel(val, reg - CLK_REG_DIV_BUG_BASE + IRAM_CLK_REG_MIRROR)
+
+#endif /* __CLKCORE_H__ */
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/arch/arm/include/asm/arch-comcerto/comcerto-2000.h u-boot-2013.01.new/arch/arm/include/asm/arch-comcerto/comcerto-2000.h
--- u-boot-2013.01/arch/arm/include/asm/arch-comcerto/comcerto-2000.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/arch/arm/include/asm/arch-comcerto/comcerto-2000.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,147 @@
+/*
+ *  arch/arm/mach-comcerto/include/mach/comcerto-2000.h
+ *
+ *  Copyright (C) 2011 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __COMCERTO_2000_H__
+#define __COMCERTO_2000_H__
+
+/*
+ * IRAM Location to keep C2K Part Number.
+ * This location should be fixed and can not be changed.
+ * Microloader populates this information to be used by Linux.
+ *
+ * This location shouldn't overlap IRAM_CLK_REG_MIRROR space
+ * defined in clkcore.h
+ */
+#define IRAM_C2K_PART_NO_LOCATION	0x8300FE00
+
+/*
+ * IRAM Locations to keep secureboot RSA public key and AES key
+ * This locations should be fixed and can not be changed.
+ */
+
+#define SECBOOT_IRAM_PUBLIC_KEY_OFFSET	0x8300B000
+#define SECBOOT_IRAM_AES_KEY_OFFSET	0x8300B200
+
+
+/*
+ * AXI Bus
+ */
+#define COMCERTO_AXI_DDR_BASE		0x00000000 /* 2G */
+#define COMCERTO_AXI_ACP_BASE		0x80000000 /* 48MB */
+#define COMCERTO_AXI_IRAM_BASE		0x83000000 /* 48MB */
+#define COMCERTO_AXI_IBR_BASE		0x90000000 /* 4MB */
+#define COMCERTO_AXI_APB_CFG_BASE	0x90400000 /* 12MB */
+#define COMCERTO_AXI_SEM_CFG_BASE	0x91000000 /* 16MB */
+#define COMCERTO_AXI_USB2p0_CFG_BASE	0x92000000 /* 16MB */
+#define COMCERTO_AXI_TZ_CFG_BASE	0x93000000 /* 16MB */
+#define COMCERTO_AXI_DPI0_CFG_BASE	0x94000000 /* 16MB */
+#define COMCERTO_AXI_DPI1_CFG_BASE	0x95000000 /* 16MB */
+#define COMCERTO_AXI_UART_SPI_CFG_BASE	0x96000000 /* 16MB */
+#define COMCERTO_AXI_DDR_CFG_BASE	0x97000000 /* 16MB */
+#define COMCERTO_AXI_PCIe0_CFG_BASE	0x98000000 /* 16MB */
+#define COMCERTO_AXI_PCIe1_CFG_BASE	0x99000000 /* 16MB */
+#define COMCERTO_AXI_ESPAH_CFG_BASE	0x9A000000 /* 16MB */
+#define COMCERTO_AXI_SPACC_CFG_BASE	0x9B000000 /* 16MB */
+#define COMCERTO_AXI_HFE_CFG_BASE	0x9C000000 /* 16MB */
+#define COMCERTO_AXI_SATA_CFG_BASE	0x9D000000 /* 16MB */
+#define COMCERTO_AXI_DECT_CFG_BASE	0x9E000000 /* 16MB */
+#define COMCERTO_AXI_USB3p0_CFG_BASE	0x9F000000 /* 16MB */
+#define COMCERTO_AXI_PCIe0_SLV_BASE	0xA0000000 /* 256MB */
+#define COMCERTO_AXI_PCIe1_SLV_BASE	0xB0000000 /* 256MB */
+#define COMCERTO_AXI_EXP_BASE		0xC0000000 /* 256MB */
+#define COMCERTO_AXI_EXP_ECC_BASE	0xCFFF0000 /* 64KB */
+
+/*
+ * APB Bus
+ */
+#define COMCERTO_TDM_BASE			(COMCERTO_AXI_APB_CFG_BASE + 0x000000)
+#define COMCERTO_USB_PHY_SERDES_BASE		(COMCERTO_AXI_APB_CFG_BASE + 0x010000)
+#define COMCERTO_TDMA_BASE			(COMCERTO_AXI_APB_CFG_BASE + 0x020000)
+#define COMCERTO_APB_RESERVED2			(COMCERTO_AXI_APB_CFG_BASE + 0x030000)
+#define COMCERTO_APB_RESERVED3			(COMCERTO_AXI_APB_CFG_BASE + 0x040000)
+#define COMCERTO_TIMER_BASE   			(COMCERTO_AXI_APB_CFG_BASE + 0x050000)
+#define COMCERTO_PCIE_SATA_USB_CTRL_BASE	(COMCERTO_AXI_APB_CFG_BASE + 0x060000)
+#define COMCERTO_GPIO_BASE			(COMCERTO_AXI_APB_CFG_BASE + 0x070000)
+#define COMCERTO_APB_RESERVED5			(COMCERTO_AXI_APB_CFG_BASE + 0x080000)
+#define COMCERTO_UART0_BASE   			(COMCERTO_AXI_APB_CFG_BASE + 0x090000)
+#define COMCERTO_APB_RESERVED6			(COMCERTO_AXI_APB_CFG_BASE + 0x094000)
+#define COMCERTO_SPI_BASE     			(COMCERTO_AXI_APB_CFG_BASE + 0x098000)
+#define COMCERTO_I2C_BASE     			(COMCERTO_AXI_APB_CFG_BASE + 0x09C000)
+#define COMCERTO_USB3_0_BASE  			(COMCERTO_AXI_APB_CFG_BASE + 0x0A0000)
+#define COMCERTO_CLKCORE_BASE 			(COMCERTO_AXI_APB_CFG_BASE + 0x0B0000)
+#define COMCERTO_APB_RESERVED7			(COMCERTO_AXI_APB_CFG_BASE + 0x0C0000)
+#define COMCERTO_APB_RESERVED8			(COMCERTO_AXI_APB_CFG_BASE + 0x0D0000)
+#define COMCERTO_RTC_BASE     			(COMCERTO_AXI_APB_CFG_BASE + 0x0E0000)
+#define COMCERTO_OTP_BASE     			(COMCERTO_AXI_APB_CFG_BASE + 0x0F0000)
+#define COMCERTO_HFEWRAPPER_BASE		(COMCERTO_AXI_APB_CFG_BASE + 0x100000)
+#define COMCERTO_APB_RESERVED10			(COMCERTO_AXI_APB_CFG_BASE + 0x110000)
+#define COMCERTO_APB_RESERVED11			(COMCERTO_AXI_APB_CFG_BASE + 0x120000)
+#define COMCERTO_APB_RESERVED12			(COMCERTO_AXI_APB_CFG_BASE + 0x130000)
+#define COMCERTO_APB_RESERVED13			(COMCERTO_AXI_APB_CFG_BASE + 0x140000)
+#define COMCERTO_APB_RESERVED14			(COMCERTO_AXI_APB_CFG_BASE + 0x150000)
+#define COMCERTO_APB_RESERVED15			(COMCERTO_AXI_APB_CFG_BASE + 0x160000)
+#define COMCERTO_APB_RESERVED16			(COMCERTO_AXI_APB_CFG_BASE + 0x170000)
+#define COMCERTO_APB_RESERVED17			(COMCERTO_AXI_APB_CFG_BASE + 0x180000)
+#define COMCERTO_SERDES_CFG_BASE		(COMCERTO_AXI_APB_CFG_BASE + 0x190000)
+#define COMCERTO_EXP_CONF_BASE			(COMCERTO_AXI_APB_CFG_BASE + 0x1A0000)
+#define COMCERTO_DDR_PHY			(COMCERTO_AXI_APB_CFG_BASE + 0x1B0000)
+#define COMCERTO_APB_RESERVED20			(COMCERTO_AXI_APB_CFG_BASE + 0x1C0000)
+#define COMCERTO_TDMA2_BASE			(COMCERTO_AXI_APB_CFG_BASE + 0x1D0000)
+#define COMCERTO_MDMA_BASE			(COMCERTO_AXI_APB_CFG_BASE + 0x1E0000)
+#define COMCERTO_A9_CORESIGHT_BASE		(COMCERTO_AXI_APB_CFG_BASE + 0x200000)
+
+#define COMCERTO_APB_USBPHY_SERDES_STAT_BASE	0x90410000
+#define COMCERTO_APB_GPIO_BASE		0x90470000
+#define COMCERTO_APB_CLK_BASE		0x904B0000
+#define COMCERTO_APB_SERDES_BASE	0x90590000
+#define COMCERTO_APB_EXP_BASE		0x905A0000
+#define COMCERTO_APB_DDR_BASE		0x97000000
+#define COMCERTO_APB_DDR_PHY_BASE	0x905B0000
+#define COMCERTO_SATA_AHCI_BASE		0x9D000000
+
+#define COMCERTO_L2CC_BASE       0xFFF10000
+#define COMCERTO_A9_PERIPH_BASE     0xFFF00000
+#define COMCERTO_A9_SCU_BASE		(COMCERTO_A9_PERIPH_BASE + 0x0000)
+#define COMCERTO_A9_IC_INT_BASE		(COMCERTO_A9_PERIPH_BASE + 0x100)
+#define COMCERTO_A9_TIMER_BASE		(COMCERTO_A9_PERIPH_BASE + 0x600)
+#define COMCERTO_A9_IC_DIST_BASE	(COMCERTO_A9_PERIPH_BASE + 0x1000)
+
+#define COMCERTO_APB_SERDES0_BASE	(COMCERTO_APB_SERDES_BASE)
+#define COMCERTO_APB_SERDES1_BASE	(COMCERTO_APB_SERDES_BASE + 0x4000)
+#define COMCERTO_APB_SERDES2_BASE	(COMCERTO_APB_SERDES_BASE + 0x8000)
+#define COMCERTO_SER_DES0_PHY_CFG_BASE 	0x9041002C
+
+#define EXP_SWRST	(COMCERTO_APB_EXP_BASE + 0x0)
+#define EXP_CSEN	(COMCERTO_APB_EXP_BASE + 0x4)
+#define EXP_CS0_BASE 	(COMCERTO_APB_EXP_BASE + 0x8)
+#define EXP_CS0_SEG 	(COMCERTO_APB_EXP_BASE + 0x1c)
+#define EXP_CSO_CFG	(COMCERTO_APB_EXP_BASE + 0x30)
+
+#define DECT_SYS_CFG0	(COMCERTO_APB_GPIO_BASE + 0xb0)
+#define DECT_SYS_CFG1	(COMCERTO_APB_GPIO_BASE + 0xb4)
+#define DECT_CTRL	(COMCERTO_APB_GPIO_BASE + 0xb8)
+
+#define COMCERTO_SERDES_REG( _num, _ofst) ((COMCERTO_APB_SERDES_BASE + (0x4000 * _num)) + _ofst)
+
+#define TEMP_STACK     0x8300C000
+
+#define UART_BASEADDR	0x96400000
+
+#endif /* __COMCERTO_2000_H__ */
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/arch/arm/include/asm/arch-comcerto/comcerto-common.h u-boot-2013.01.new/arch/arm/include/asm/arch-comcerto/comcerto-common.h
--- u-boot-2013.01/arch/arm/include/asm/arch-comcerto/comcerto-common.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/arch/arm/include/asm/arch-comcerto/comcerto-common.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,84 @@
+/*
+ *  arch/arm/mach-comcerto/include/mach/comcerto-common.h
+ *
+ *  Copyright (C) 2004,2005 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_COMCERTO_COMMON_H__
+#define __ASM_COMCERTO_COMMON_H__
+
+#include <asm/types.h>
+
+#define  BIT_0_MSK   0x00000001
+#define  BIT_1_MSK   0x00000002
+#define  BIT_2_MSK   0x00000004
+#define  BIT_3_MSK   0x00000008
+#define  BIT_4_MSK   0x00000010
+#define  BIT_5_MSK   0x00000020
+#define  BIT_6_MSK   0x00000040
+#define  BIT_7_MSK   0x00000080
+#define  BIT_8_MSK   0x00000100
+#define  BIT_9_MSK   0x00000200
+#define  BIT_10_MSK  0x00000400
+#define  BIT_11_MSK  0x00000800
+#define  BIT_12_MSK  0x00001000
+#define  BIT_13_MSK  0x00002000
+#define  BIT_14_MSK  0x00004000
+#define  BIT_15_MSK  0x00008000
+#define  BIT_16_MSK  0x00010000
+#define  BIT_17_MSK  0x00020000
+#define  BIT_18_MSK  0x00040000
+#define  BIT_19_MSK  0x00080000
+#define  BIT_20_MSK  0x00100000
+#define  BIT_21_MSK  0x00200000
+#define  BIT_22_MSK  0x00400000
+#define  BIT_23_MSK  0x00800000
+#define  BIT_24_MSK  0x01000000
+#define  BIT_25_MSK  0x02000000
+#define  BIT_26_MSK  0x04000000
+#define  BIT_27_MSK  0x08000000
+#define  BIT_28_MSK  0x10000000
+#define  BIT_29_MSK  0x20000000
+#define  BIT_30_MSK  0x40000000
+#define  BIT_31_MSK  0x80000000
+
+#define RETCODE_OK      0
+#define RETCODE_ERROR   1
+
+/* Bit 20 */
+#define SPI_SC_POLARITY_MASK                            (BIT_20_MSK)
+#define SPI_SC_POLARITY_SHIFT                           20
+
+/*
+ * GPIO
+ */
+	/* Set gpio pins specified by gpiomask to be inputs */
+	#define comcerto_gpio_enable_input(gpiomask)	__raw_writel(__raw_readl(COMCERTO_GPIO_OE_REG) & ~(gpiomask), COMCERTO_GPIO_OE_REG)
+
+	/* Set gpio pins specified by gpiomask to be outputs */
+	#define comcerto_gpio_enable_output(gpiomask)	__raw_writel(__raw_readl(COMCERTO_GPIO_OE_REG) | (gpiomask), COMCERTO_GPIO_OE_REG)
+
+	/* Set output pins specified by gpiomask to low */
+	#define comcerto_gpio_set_0(gpiomask)	__raw_writel(__raw_readl(COMCERTO_GPIO_OUTPUT_REG) & ~(gpiomask), COMCERTO_GPIO_OUTPUT_REG)
+
+	/* Set output pins specified by gpiomask to high */
+	#define comcerto_gpio_set_1(gpiomask)	__raw_writel(__raw_readl(COMCERTO_GPIO_OUTPUT_REG) | (gpiomask), COMCERTO_GPIO_OUTPUT_REG)
+
+	/* Read status of input pins specified by gpiomask */
+	#define comcerto_gpio_read(gpiomask)	(__raw_readl(COMCERTO_GPIO_INPUT_REG) & (gpiomask))
+
+#endif /* __ASM_COMCERTO_COMMON_H__ */
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/arch/arm/include/asm/arch-comcerto/comcerto_spi.h u-boot-2013.01.new/arch/arm/include/asm/arch-comcerto/comcerto_spi.h
--- u-boot-2013.01/arch/arm/include/asm/arch-comcerto/comcerto_spi.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/arch/arm/include/asm/arch-comcerto/comcerto_spi.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,93 @@
+/*
+ *  linux/drivers/spi/busses/comcerto_spi.h
+ *
+ *  Copyright (C) Mindspeed Technologies
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#ifndef _COMCERTO_SPI_H
+#define _COMCERTO_SPI_H
+
+#include <linux/list.h>
+#include <spi.h>
+#include <asm/arch/comcerto-2000.h>
+#include <asm/arch/clkcore.h>
+
+#define SPI_BASEADDR		COMCERTO_SPI_BASE
+
+#define	FAST_SPI_OFFSET		0x500000
+#define FAST_SPI_BASEADDR	COMCERTO_AXI_UART_SPI_CFG_BASE + FAST_SPI_OFFSET
+
+#define COMCERTO_SPI_DRIVER_NAME	"Comcerto SPI"
+
+
+#define COMCERTO_SPI_CTRLR0               0x00
+#define COMCERTO_SPI_CTRLR1               0x04
+#define COMCERTO_SPI_SSIENR               0x08
+#define COMCERTO_SPI_MWCR                 0x0C
+#define COMCERTO_SPI_SER                  0x10
+#define COMCERTO_SPI_BAUDR                0x14
+#define COMCERTO_SPI_TXFTLR               0x18
+#define COMCERTO_SPI_RXFTLR               0x1C
+#define COMCERTO_SPI_TXFLR                0x20
+#define COMCERTO_SPI_RXFLR                0x24
+#define COMCERTO_SPI_SR                   0x28
+#define COMCERTO_SPI_IMR                  0x2C
+#define COMCERTO_SPI_ISR                  0x30
+#define COMCERTO_SPI_RISR                 0x34
+#define COMCERTO_SPI_TXOICR               0x38
+#define COMCERTO_SPI_RXOICR               0x3C
+#define COMCERTO_SPI_RXUICR               0x40
+#define COMCERTO_SPI_MSTICR               0x44
+#define COMCERTO_SPI_ICR                  0x48
+#define COMCERTO_SPI_DMACR                0x4C
+#define COMCERTO_SPI_DMATDLR              0x50
+#define COMCERTO_SPI_DMARDLR              0x54
+#define COMCERTO_SPI_IDR                  0x58
+#define COMCERTO_SPI_DR                   0x60
+
+
+/* SR - status register bits */
+#define BUSY		(1<<0)	/* SSI busy flag, serial transfer in progress */
+#define TFNF		(1<<1)	/* Transmit FIFO not full */
+#define TFE		(1<<2)	/* Transmit FIFO empty */
+#define RFNE		(1<<3)	/* Receive FIFO not empty */
+#define RFF		(1<<4)	/* Receive FIFO full */
+#define TXE		(1<<5)	/* Transmission error */
+#define DCOL		(1<<6)	/* Data collision error */
+
+/* Interrupt status after being masked */
+#define TXEIS		(1<<0)	/* Transmit FIFO empty interrupt status */
+#define TXOIS		(1<<1)	/* Transmit FIFO overflow interrupt status */
+#define RXUIS		(1<<2)	/* Receive FIFO underflow interrupt status */
+#define RXOIS		(1<<3)	/* Receive FIFO overflow interrupt status */
+#define RXFIS		(1<<4)	/* Receive FIFO full interrupt status */
+#define MSTIS		(1<<5)	/* Multi-Master contention interrupt status */
+
+/* Interrupt status before being masked */
+#define TXEIR		(1<<0)	/* Transmit FIFO empty interrupt status */
+#define TXOIR		(1<<1)	/* Transmit FIFO overflow interrupt status */
+#define RXUIR		(1<<2)	/* Receive FIFO underflow interrupt status */
+#define RXOIR		(1<<3)	/* Receive FIFO overflow interrupt status */
+#define RXFIR		(1<<4)	/* Receive FIFO full interrupt status */
+#define MSTIR		(1<<5)	/* Multi-Master contention interrupt status */
+
+
+/* Interrupt mask register */
+#define TXEIM		(1<<0)	/* Transmit FIFO empty interrupt status */
+#define TXOIM		(1<<1)	/* Transmit FIFO overflow interrupt status */
+#define RXUIM		(1<<2)	/* Receive FIFO underflow interrupt status */
+#define RXOIM		(1<<3)	/* Receive FIFO overflow interrupt status */
+#define RXFIM		(1<<4)	/* Receive FIFO full interrupt status */
+#define MSTIM		(1<<5)	/* Multi-Master contention interrupt status */
+
+
+#define SPI_TRANSFER_MODE_WRITE_ONLY	0x01
+#define SPI_TRANSFER_MODE_READ_ONLY	0x02
+#define SPI_TRANSFER_MODE_WRITE_READ	0x03
+#define SPI_TRANSFER_MODE_EEPROM_READ	0x04
+
+#endif /* _COMCERTO_SPI_H */
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/arch/arm/include/asm/arch-comcerto/ddr.h u-boot-2013.01.new/arch/arm/include/asm/arch-comcerto/ddr.h
--- u-boot-2013.01/arch/arm/include/asm/arch-comcerto/ddr.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/arch/arm/include/asm/arch-comcerto/ddr.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,857 @@
+#ifndef __DDR_H__
+#define __DDR_H__
+
+#include "comcerto-2000.h"
+
+#if defined(CONFIG_M86261_NAS)
+#define DDR_CFG_16BIT
+#else
+#undef  DDR_CFG_16BIT
+#endif
+
+
+/* DDR Controller Registers */
+#define DDRC_CTL_00_REG          (COMCERTO_APB_DDR_BASE + 0x00)
+#define DDRC_CTL_01_REG          (COMCERTO_APB_DDR_BASE + 0x04)
+#define DDRC_CTL_02_REG          (COMCERTO_APB_DDR_BASE + 0x08)
+#define DDRC_CTL_03_REG          (COMCERTO_APB_DDR_BASE + 0x0c)
+#define DDRC_CTL_04_REG          (COMCERTO_APB_DDR_BASE + 0x10)
+#define DDRC_CTL_05_REG          (COMCERTO_APB_DDR_BASE + 0x14)
+#define DDRC_CTL_06_REG          (COMCERTO_APB_DDR_BASE + 0x18)
+#define DDRC_CTL_07_REG          (COMCERTO_APB_DDR_BASE + 0x1c)
+#define DDRC_CTL_08_REG          (COMCERTO_APB_DDR_BASE + 0x20)
+#define DDRC_CTL_09_REG          (COMCERTO_APB_DDR_BASE + 0x24)
+#define DDRC_CTL_10_REG          (COMCERTO_APB_DDR_BASE + 0x28)
+#define DDRC_CTL_11_REG          (COMCERTO_APB_DDR_BASE + 0x2c)
+#define DDRC_CTL_12_REG          (COMCERTO_APB_DDR_BASE + 0x30)
+#define DDRC_CTL_13_REG          (COMCERTO_APB_DDR_BASE + 0x34)
+#define DDRC_CTL_14_REG          (COMCERTO_APB_DDR_BASE + 0x38)
+#define DDRC_CTL_15_REG          (COMCERTO_APB_DDR_BASE + 0x3c)
+#define DDRC_CTL_16_REG          (COMCERTO_APB_DDR_BASE + 0x40)
+#define DDRC_CTL_17_REG          (COMCERTO_APB_DDR_BASE + 0x44)
+#define DDRC_CTL_18_REG          (COMCERTO_APB_DDR_BASE + 0x48)
+#define DDRC_CTL_19_REG          (COMCERTO_APB_DDR_BASE + 0x4c)
+#define DDRC_CTL_20_REG          (COMCERTO_APB_DDR_BASE + 0x50)
+#define DDRC_CTL_21_REG          (COMCERTO_APB_DDR_BASE + 0x54)
+#define DDRC_CTL_22_REG          (COMCERTO_APB_DDR_BASE + 0x58)
+#define DDRC_CTL_23_REG          (COMCERTO_APB_DDR_BASE + 0x5c)
+#define DDRC_CTL_24_REG          (COMCERTO_APB_DDR_BASE + 0x60)
+#define DDRC_CTL_25_REG          (COMCERTO_APB_DDR_BASE + 0x64)
+#define DDRC_CTL_26_REG          (COMCERTO_APB_DDR_BASE + 0x68)
+#define DDRC_CTL_27_REG          (COMCERTO_APB_DDR_BASE + 0x6c)
+#define DDRC_CTL_28_REG          (COMCERTO_APB_DDR_BASE + 0x70)
+#define DDRC_CTL_29_REG          (COMCERTO_APB_DDR_BASE + 0x74)
+#define DDRC_CTL_30_REG          (COMCERTO_APB_DDR_BASE + 0x78)
+#define DDRC_CTL_31_REG          (COMCERTO_APB_DDR_BASE + 0x7c)
+#define DDRC_CTL_32_REG          (COMCERTO_APB_DDR_BASE + 0x80)
+#define DDRC_CTL_33_REG          (COMCERTO_APB_DDR_BASE + 0x84)
+#define DDRC_CTL_34_REG          (COMCERTO_APB_DDR_BASE + 0x88)
+#define DDRC_CTL_35_REG          (COMCERTO_APB_DDR_BASE + 0x8c)
+#define DDRC_CTL_36_REG          (COMCERTO_APB_DDR_BASE + 0x90)
+#define DDRC_CTL_37_REG          (COMCERTO_APB_DDR_BASE + 0x94)
+#define DDRC_CTL_38_REG          (COMCERTO_APB_DDR_BASE + 0x98)
+#define DDRC_CTL_39_REG          (COMCERTO_APB_DDR_BASE + 0x9c)
+#define DDRC_CTL_40_REG          (COMCERTO_APB_DDR_BASE + 0xa0)
+#define DDRC_CTL_41_REG          (COMCERTO_APB_DDR_BASE + 0xa4)
+#define DDRC_CTL_42_REG          (COMCERTO_APB_DDR_BASE + 0xa8)
+#define DDRC_CTL_43_REG          (COMCERTO_APB_DDR_BASE + 0xac)
+#define DDRC_CTL_44_REG          (COMCERTO_APB_DDR_BASE + 0xb0)
+#define DDRC_CTL_45_REG          (COMCERTO_APB_DDR_BASE + 0xb4)
+#define DDRC_CTL_46_REG          (COMCERTO_APB_DDR_BASE + 0xb8)
+#define DDRC_CTL_47_REG          (COMCERTO_APB_DDR_BASE + 0xbc)
+#define DDRC_CTL_48_REG          (COMCERTO_APB_DDR_BASE + 0xc0)
+#define DDRC_CTL_49_REG          (COMCERTO_APB_DDR_BASE + 0xc4)
+#define DDRC_CTL_50_REG          (COMCERTO_APB_DDR_BASE + 0xc8)
+#define DDRC_CTL_51_REG          (COMCERTO_APB_DDR_BASE + 0xcc)
+#define DDRC_CTL_52_REG          (COMCERTO_APB_DDR_BASE + 0xd0)
+#define DDRC_CTL_53_REG          (COMCERTO_APB_DDR_BASE + 0xd4)
+#define DDRC_CTL_54_REG          (COMCERTO_APB_DDR_BASE + 0xd8)
+#define DDRC_CTL_55_REG          (COMCERTO_APB_DDR_BASE + 0xdc)
+#define DDRC_CTL_56_REG          (COMCERTO_APB_DDR_BASE + 0xe0)
+#define DDRC_CTL_57_REG          (COMCERTO_APB_DDR_BASE + 0xe4)
+#define DDRC_CTL_58_REG          (COMCERTO_APB_DDR_BASE + 0xe8)
+#define DDRC_CTL_59_REG          (COMCERTO_APB_DDR_BASE + 0xec)
+#define DDRC_CTL_60_REG          (COMCERTO_APB_DDR_BASE + 0xf0)
+#define DDRC_CTL_61_REG          (COMCERTO_APB_DDR_BASE + 0xf4)
+#define DDRC_CTL_62_REG          (COMCERTO_APB_DDR_BASE + 0xf8)
+#define DDRC_CTL_63_REG          (COMCERTO_APB_DDR_BASE + 0xfc)
+#define DDRC_CTL_64_REG          (COMCERTO_APB_DDR_BASE + 0x100)
+#define DDRC_CTL_65_REG          (COMCERTO_APB_DDR_BASE + 0x104)
+#define DDRC_CTL_66_REG          (COMCERTO_APB_DDR_BASE + 0x108)
+#define DDRC_CTL_67_REG          (COMCERTO_APB_DDR_BASE + 0x10c)
+#define DDRC_CTL_68_REG          (COMCERTO_APB_DDR_BASE + 0x110)
+#define DDRC_CTL_69_REG          (COMCERTO_APB_DDR_BASE + 0x114)
+#define DDRC_CTL_70_REG          (COMCERTO_APB_DDR_BASE + 0x118)
+#define DDRC_CTL_71_REG          (COMCERTO_APB_DDR_BASE + 0x11c)
+#define DDRC_CTL_72_REG          (COMCERTO_APB_DDR_BASE + 0x120)
+#define DDRC_CTL_73_REG          (COMCERTO_APB_DDR_BASE + 0x124)
+#define DDRC_CTL_74_REG          (COMCERTO_APB_DDR_BASE + 0x128)
+#define DDRC_CTL_75_REG          (COMCERTO_APB_DDR_BASE + 0x12c)
+#define DDRC_CTL_76_REG          (COMCERTO_APB_DDR_BASE + 0x130)
+#define DDRC_CTL_77_REG          (COMCERTO_APB_DDR_BASE + 0x134)
+#define DDRC_CTL_78_REG          (COMCERTO_APB_DDR_BASE + 0x138)
+#define DDRC_CTL_79_REG          (COMCERTO_APB_DDR_BASE + 0x13c)
+#define DDRC_CTL_80_REG          (COMCERTO_APB_DDR_BASE + 0x140)
+#define DDRC_CTL_81_REG          (COMCERTO_APB_DDR_BASE + 0x144)
+#define DDRC_CTL_82_REG          (COMCERTO_APB_DDR_BASE + 0x148)
+#define DDRC_CTL_83_REG          (COMCERTO_APB_DDR_BASE + 0x14c)
+#define DDRC_CTL_84_REG          (COMCERTO_APB_DDR_BASE + 0x150)
+#define DDRC_CTL_85_REG          (COMCERTO_APB_DDR_BASE + 0x154)
+#define DDRC_CTL_86_REG          (COMCERTO_APB_DDR_BASE + 0x158)
+#define DDRC_CTL_87_REG          (COMCERTO_APB_DDR_BASE + 0x15c)
+#define DDRC_CTL_88_REG          (COMCERTO_APB_DDR_BASE + 0x160)
+#define DDRC_CTL_89_REG          (COMCERTO_APB_DDR_BASE + 0x164)
+#define DDRC_CTL_90_REG          (COMCERTO_APB_DDR_BASE + 0x168)
+#define DDRC_CTL_91_REG          (COMCERTO_APB_DDR_BASE + 0x16c)
+#define DDRC_CTL_92_REG          (COMCERTO_APB_DDR_BASE + 0x170)
+#define DDRC_CTL_93_REG          (COMCERTO_APB_DDR_BASE + 0x174)
+#define DDRC_CTL_94_REG          (COMCERTO_APB_DDR_BASE + 0x178)
+#define DDRC_CTL_95_REG          (COMCERTO_APB_DDR_BASE + 0x17c)
+#define DDRC_CTL_96_REG          (COMCERTO_APB_DDR_BASE + 0x180)
+#define DDRC_CTL_97_REG          (COMCERTO_APB_DDR_BASE + 0x184)
+#define DDRC_CTL_98_REG          (COMCERTO_APB_DDR_BASE + 0x188)
+#define DDRC_CTL_99_REG          (COMCERTO_APB_DDR_BASE + 0x18c)
+#define DDRC_CTL_100_REG          (COMCERTO_APB_DDR_BASE + 0x190)
+#define DDRC_CTL_101_REG          (COMCERTO_APB_DDR_BASE + 0x194)
+#define DDRC_CTL_102_REG          (COMCERTO_APB_DDR_BASE + 0x198)
+#define DDRC_CTL_103_REG          (COMCERTO_APB_DDR_BASE + 0x19c)
+#define DDRC_CTL_104_REG          (COMCERTO_APB_DDR_BASE + 0x1a0)
+#define DDRC_CTL_105_REG          (COMCERTO_APB_DDR_BASE + 0x1a4)
+#define DDRC_CTL_106_REG          (COMCERTO_APB_DDR_BASE + 0x1a8)
+#define DDRC_CTL_107_REG          (COMCERTO_APB_DDR_BASE + 0x1ac)
+#define DDRC_CTL_108_REG          (COMCERTO_APB_DDR_BASE + 0x1b0)
+#define DDRC_CTL_109_REG          (COMCERTO_APB_DDR_BASE + 0x1b4)
+#define DDRC_CTL_110_REG          (COMCERTO_APB_DDR_BASE + 0x1b8)
+#define DDRC_CTL_111_REG          (COMCERTO_APB_DDR_BASE + 0x1bc)
+#define DDRC_CTL_112_REG          (COMCERTO_APB_DDR_BASE + 0x1c0)
+#define DDRC_CTL_113_REG          (COMCERTO_APB_DDR_BASE + 0x1c4)
+#define DDRC_CTL_114_REG          (COMCERTO_APB_DDR_BASE + 0x1c8)
+#define DDRC_CTL_115_REG          (COMCERTO_APB_DDR_BASE + 0x1cc)
+#define DDRC_CTL_116_REG          (COMCERTO_APB_DDR_BASE + 0x1d0)
+#define DDRC_CTL_117_REG          (COMCERTO_APB_DDR_BASE + 0x1d4)
+#define DDRC_CTL_118_REG          (COMCERTO_APB_DDR_BASE + 0x1d8)
+#define DDRC_CTL_119_REG          (COMCERTO_APB_DDR_BASE + 0x1dc)
+#define DDRC_CTL_120_REG          (COMCERTO_APB_DDR_BASE + 0x1e0)
+#define DDRC_CTL_121_REG          (COMCERTO_APB_DDR_BASE + 0x1e4)
+#define DDRC_CTL_122_REG          (COMCERTO_APB_DDR_BASE + 0x1e8)
+#define DDRC_CTL_123_REG          (COMCERTO_APB_DDR_BASE + 0x1ec)
+#define DDRC_CTL_124_REG          (COMCERTO_APB_DDR_BASE + 0x1f0)
+#define DDRC_CTL_125_REG          (COMCERTO_APB_DDR_BASE + 0x1f4)
+#define DDRC_CTL_126_REG          (COMCERTO_APB_DDR_BASE + 0x1f8)
+
+/* DDR PHY Registers */
+#define DDR_PHY_CTL_00_REG	(COMCERTO_APB_DDR_PHY_BASE + 0x00)
+#define DDR_PHY_CTL_01_REG	(COMCERTO_APB_DDR_PHY_BASE + 0x04)
+#define DDR_PHY_CTL_02_REG	(COMCERTO_APB_DDR_PHY_BASE + 0x08)
+#define DDR_PHY_CTL_03_REG	(COMCERTO_APB_DDR_PHY_BASE + 0x0C)
+#define DDR_PHY_CTL_04_REG	(COMCERTO_APB_DDR_PHY_BASE + 0x10)
+#define DDR_PHY_CTL_05_REG	(COMCERTO_APB_DDR_PHY_BASE + 0x14)
+#define DDR_PHY_CTL_06_REG	(COMCERTO_APB_DDR_PHY_BASE + 0x18)
+#define DDR_PHY_CTL_07_REG	(COMCERTO_APB_DDR_PHY_BASE + 0x1C)
+#define DDR_PHY_DLL_STAT_REG	(COMCERTO_APB_DDR_PHY_BASE + 0x70)
+#define DDR_PHY_ZQ_STAT_REG	(COMCERTO_APB_DDR_PHY_BASE + 0x74)
+
+//DDR2@ 400MHz
+#define DDRC_CTL_DDR2_00_VAL_CFG1  0x00000400
+//#define DDRC_CTL_DDR2_01_VAL_CFG1 0x00000000
+#define DDRC_CTL_DDR2_02_VAL_CFG1  0x00000050
+#define DDRC_CTL_DDR2_03_VAL_CFG1  0x00000050
+#define DDRC_CTL_DDR2_04_VAL_CFG1  0x000000c8
+#define DDRC_CTL_DDR2_05_VAL_CFG1  0x02050c02
+#define DDRC_CTL_DDR2_06_VAL_CFG1  0x10160302
+#define DDRC_CTL_DDR2_07_VAL_CFG1  0x02030603
+#define DDRC_CTL_DDR2_08_VAL_CFG1  0x006d6005
+#define DDRC_CTL_DDR2_09_VAL_CFG1  0x00000303
+#define DDRC_CTL_DDR2_10_VAL_CFG1  0x06060101
+#define DDRC_CTL_DDR2_11_VAL_CFG1  0x0000c80c
+#define DDRC_CTL_DDR2_12_VAL_CFG1  0x00a00e02
+#define DDRC_CTL_DDR2_13_VAL_CFG1  0x00000007
+#define DDRC_CTL_DDR2_14_VAL_CFG1  0x00330100
+#define DDRC_CTL_DDR2_15_VAL_CFG1  0x00000c2d
+#define DDRC_CTL_DDR2_16_VAL_CFG1  0x000a0003
+#define DDRC_CTL_DDR2_17_VAL_CFG1  0x000a0003
+#define DDRC_CTL_DDR2_18_VAL_CFG1  0x003700c8
+#define DDRC_CTL_DDR2_19_VAL_CFG1  0x00010000
+#define DDRC_CTL_DDR2_20_VAL_CFG1  0x00030300
+#define DDRC_CTL_DDR2_21_VAL_CFG1  0x00000000
+#define DDRC_CTL_DDR2_22_VAL_CFG1  0x00000000
+#define DDRC_CTL_DDR2_23_VAL_CFG1  0x00000000
+#define DDRC_CTL_DDR2_24_VAL_CFG1  0x00000000
+#define DDRC_CTL_DDR2_25_VAL_CFG1  0x00000000
+#define DDRC_CTL_DDR2_26_VAL_CFG1  0x00000000
+#define DDRC_CTL_DDR2_27_VAL_CFG1  0x000a6200
+#define DDRC_CTL_DDR2_28_VAL_CFG1  0x00000004
+#define DDRC_CTL_DDR2_29_VAL_CFG1  0x00000000
+#define DDRC_CTL_DDR2_30_VAL_CFG1  0x00040a62
+#define DDRC_CTL_DDR2_31_VAL_CFG1  0x00000000
+#define DDRC_CTL_DDR2_32_VAL_CFG1  0x00020000
+#define DDRC_CTL_DDR2_33_VAL_CFG1  0x00000000
+//#define DDRC_CTL_DDR2_34_VAL_CFG1 0x00000000
+//#define DDRC_CTL_DDR2_35_VAL_CFG1 0x00000000
+//#define DDRC_CTL_DDR2_36_VAL_CFG1 0x00000000
+//#define DDRC_CTL_DDR2_37_VAL_CFG1 0x00000000
+//#define DDRC_CTL_DDR2_38_VAL_CFG1 0x00000000
+//#define DDRC_CTL_DDR2_39_VAL_CFG1 0x00000000
+//#define DDRC_CTL_DDR2_40_VAL_CFG1 0x00000000
+//#define DDRC_CTL_DDR2_41_VAL_CFG1 0x00000000
+//#define DDRC_CTL_DDR2_42_VAL_CFG1 0x00000000
+#define DDRC_CTL_DDR2_43_VAL_CFG1  0x01000200
+#define DDRC_CTL_DDR2_44_VAL_CFG1  0x02000040
+#define DDRC_CTL_DDR2_45_VAL_CFG1  0x00010040
+#define DDRC_CTL_DDR2_46_VAL_CFG1  0xff0a0203
+#define DDRC_CTL_DDR2_47_VAL_CFG1  0x010101ff
+#define DDRC_CTL_DDR2_48_VAL_CFG1  0x01010101
+#define DDRC_CTL_DDR2_49_VAL_CFG1  0x000c0100
+#define DDRC_CTL_DDR2_50_VAL_CFG1  0x00010000
+//#define DDRC_CTL_DDR2_51_VAL_CFG1 0x00000000
+#define DDRC_CTL_DDR2_52_VAL_CFG1  0x00000000
+#define DDRC_CTL_DDR2_53_VAL_CFG1  0x00000000
+//#define DDRC_CTL_DDR2_54_VAL_CFG1 0x00000000
+//#define DDRC_CTL_DDR2_55_VAL_CFG1 0x00000000
+//#define DDRC_CTL_DDR2_56_VAL_CFG1 0x00000000
+//#define DDRC_CTL_DDR2_57_VAL_CFG1 0x00000000
+//#define DDRC_CTL_DDR2_58_VAL_CFG1 0x00000000
+#define DDRC_CTL_DDR2_59_VAL_CFG1  0x01010000
+#define DDRC_CTL_DDR2_60_VAL_CFG1  0x00000202
+#define DDRC_CTL_DDR2_61_VAL_CFG1  0x02020302
+#define DDRC_CTL_DDR2_62_VAL_CFG1  0x01000101
+#define DDRC_CTL_DDR2_63_VAL_CFG1  0x00000000
+#define DDRC_CTL_DDR2_64_VAL_CFG1  0x00000000
+//#define DDRC_CTL_DDR2_65_VAL_CFG1 0x00000000
+#define DDRC_CTL_DDR2_66_VAL_CFG1  0x00000000
+#define DDRC_CTL_DDR2_67_VAL_CFG1  0x00281900
+#define DDRC_CTL_DDR2_68_VAL_CFG1  0x00000000
+#define DDRC_CTL_DDR2_69_VAL_CFG1  0x00000000
+#define DDRC_CTL_DDR2_70_VAL_CFG1  0x00000000
+#define DDRC_CTL_DDR2_71_VAL_CFG1  0x00000000
+#define DDRC_CTL_DDR2_72_VAL_CFG1  0x00000000
+#define DDRC_CTL_DDR2_73_VAL_CFG1  0x00000000
+//#define DDRC_CTL_DDR2_74_VAL_CFG1 0x00000000
+#define DDRC_CTL_DDR2_75_VAL_CFG1  0x00000000
+#define DDRC_CTL_DDR2_76_VAL_CFG1  0x001d1d00
+#define DDRC_CTL_DDR2_77_VAL_CFG1  0x00000000
+//#define DDRC_CTL_DDR2_78_VAL_CFG1 0x00000000
+#define DDRC_CTL_DDR2_79_VAL_CFG1  0x00000000
+#define DDRC_CTL_DDR2_80_VAL_CFG1  0x00001d1d
+//#define DDRC_CTL_DDR2_81_VAL_CFG1 0x00000000
+#define DDRC_CTL_DDR2_82_VAL_CFG1  0x00000000
+#define DDRC_CTL_DDR2_83_VAL_CFG1  0x001d1d00
+#define DDRC_CTL_DDR2_84_VAL_CFG1  0x00000000
+//#define DDRC_CTL_DDR2_85_VAL_CFG1 0x00000000
+#define DDRC_CTL_DDR2_86_VAL_CFG1  0x00000000
+#define DDRC_CTL_DDR2_87_VAL_CFG1  0x00001d1d
+//#define DDRC_CTL_DDR2_88_VAL_CFG1 0x00000000
+#define DDRC_CTL_DDR2_89_VAL_CFG1  0x00000000
+#define DDRC_CTL_DDR2_90_VAL_CFG1  0x001d1d00
+#define DDRC_CTL_DDR2_91_VAL_CFG1  0xffff0000
+#define DDRC_CTL_DDR2_92_VAL_CFG1  0x00000202
+#define DDRC_CTL_DDR2_93_VAL_CFG1  0x0101ffff
+#define DDRC_CTL_DDR2_94_VAL_CFG1  0x02ffff00
+#define DDRC_CTL_DDR2_95_VAL_CFG1  0xffff0002
+#define DDRC_CTL_DDR2_96_VAL_CFG1  0x00000202
+#define DDRC_CTL_DDR2_97_VAL_CFG1  0x01320300
+#define DDRC_CTL_DDR2_98_VAL_CFG1  0x00013200
+#define DDRC_CTL_DDR2_99_VAL_CFG1  0x32000132
+#define DDRC_CTL_DDR2_100_VAL_CFG1  0x00000001
+#define DDRC_CTL_DDR2_101_VAL_CFG1  0x00000000
+#define DDRC_CTL_DDR2_102_VAL_CFG1  0x00000700
+#define DDRC_CTL_DDR2_103_VAL_CFG1  0x000c2d00
+#define DDRC_CTL_DDR2_104_VAL_CFG1  0x02000200
+#define DDRC_CTL_DDR2_105_VAL_CFG1  0x02000200
+#define DDRC_CTL_DDR2_106_VAL_CFG1  0x00000c2d
+#define DDRC_CTL_DDR2_107_VAL_CFG1  0x00003ce1
+#define DDRC_CTL_DDR2_108_VAL_CFG1  0x0002050C
+#define DDRC_CTL_DDR2_109_VAL_CFG1  0x03800001
+#define DDRC_CTL_DDR2_110_VAL_CFG1  0x00040703
+#define DDRC_CTL_DDR2_111_VAL_CFG1  0x0000000a
+#define DDRC_CTL_DDR2_112_VAL_CFG1  0x00000c2d
+#define DDRC_CTL_DDR2_113_VAL_CFG1  0x00000000
+#define DDRC_CTL_DDR2_114_VAL_CFG1  0x0010ffff
+#define DDRC_CTL_DDR2_115_VAL_CFG1  0x11070303
+#define DDRC_CTL_DDR2_116_VAL_CFG1  0x0000000f
+#define DDRC_CTL_DDR2_117_VAL_CFG1  0x00000c2d
+#define DDRC_CTL_DDR2_118_VAL_CFG1  0x00000000
+#define DDRC_CTL_DDR2_119_VAL_CFG1  0x00000000
+#define DDRC_CTL_DDR2_120_VAL_CFG1  0x00000000
+#define DDRC_CTL_DDR2_121_VAL_CFG1  0x00000000
+#define DDRC_CTL_DDR2_122_VAL_CFG1  0x00000c2d
+#define DDRC_CTL_DDR2_123_VAL_CFG1  0x00000204
+//#define DDRC_CTL_DDR2_124_VAL_CFG1 0x00000000
+#define DDRC_CTL_DDR2_125_VAL_CFG1  0x00000000
+#define DDRC_CTL_DDR2_126_VAL_CFG1  0x00000001
+
+
+#define DDRC_DDR2_CFG_400 \
+{DDRC_CTL_00_REG, DDRC_CTL_DDR2_00_VAL_CFG1},\
+{DDRC_CTL_03_REG, DDRC_CTL_DDR2_03_VAL_CFG1},\
+{DDRC_CTL_04_REG, DDRC_CTL_DDR2_04_VAL_CFG1},\
+{DDRC_CTL_05_REG, DDRC_CTL_DDR2_05_VAL_CFG1},\
+{DDRC_CTL_06_REG, DDRC_CTL_DDR2_06_VAL_CFG1},\
+{DDRC_CTL_07_REG, DDRC_CTL_DDR2_07_VAL_CFG1},\
+{DDRC_CTL_08_REG, DDRC_CTL_DDR2_08_VAL_CFG1},\
+{DDRC_CTL_09_REG, DDRC_CTL_DDR2_09_VAL_CFG1},\
+{DDRC_CTL_10_REG, DDRC_CTL_DDR2_10_VAL_CFG1},\
+{DDRC_CTL_11_REG, DDRC_CTL_DDR2_11_VAL_CFG1},\
+{DDRC_CTL_12_REG, DDRC_CTL_DDR2_12_VAL_CFG1},\
+{DDRC_CTL_13_REG, DDRC_CTL_DDR2_13_VAL_CFG1},\
+{DDRC_CTL_14_REG, DDRC_CTL_DDR2_14_VAL_CFG1},\
+{DDRC_CTL_15_REG, DDRC_CTL_DDR2_15_VAL_CFG1},\
+{DDRC_CTL_16_REG, DDRC_CTL_DDR2_16_VAL_CFG1},\
+{DDRC_CTL_17_REG, DDRC_CTL_DDR2_17_VAL_CFG1},\
+{DDRC_CTL_18_REG, DDRC_CTL_DDR2_18_VAL_CFG1},\
+{DDRC_CTL_19_REG, DDRC_CTL_DDR2_19_VAL_CFG1},\
+{DDRC_CTL_20_REG, DDRC_CTL_DDR2_20_VAL_CFG1},\
+{DDRC_CTL_21_REG, DDRC_CTL_DDR2_21_VAL_CFG1},\
+{DDRC_CTL_22_REG, DDRC_CTL_DDR2_22_VAL_CFG1},\
+{DDRC_CTL_23_REG, DDRC_CTL_DDR2_23_VAL_CFG1},\
+{DDRC_CTL_24_REG, DDRC_CTL_DDR2_24_VAL_CFG1},\
+{DDRC_CTL_25_REG, DDRC_CTL_DDR2_25_VAL_CFG1},\
+{DDRC_CTL_26_REG, DDRC_CTL_DDR2_26_VAL_CFG1},\
+{DDRC_CTL_27_REG, DDRC_CTL_DDR2_27_VAL_CFG1},\
+{DDRC_CTL_28_REG, DDRC_CTL_DDR2_28_VAL_CFG1},\
+{DDRC_CTL_29_REG, DDRC_CTL_DDR2_29_VAL_CFG1},\
+{DDRC_CTL_30_REG, DDRC_CTL_DDR2_30_VAL_CFG1},\
+{DDRC_CTL_31_REG, DDRC_CTL_DDR2_31_VAL_CFG1},\
+{DDRC_CTL_32_REG, DDRC_CTL_DDR2_32_VAL_CFG1},\
+{DDRC_CTL_33_REG, DDRC_CTL_DDR2_33_VAL_CFG1},\
+{DDRC_CTL_43_REG, DDRC_CTL_DDR2_43_VAL_CFG1},\
+{DDRC_CTL_44_REG, DDRC_CTL_DDR2_44_VAL_CFG1},\
+{DDRC_CTL_45_REG, DDRC_CTL_DDR2_45_VAL_CFG1},\
+{DDRC_CTL_46_REG, DDRC_CTL_DDR2_46_VAL_CFG1},\
+{DDRC_CTL_47_REG, DDRC_CTL_DDR2_47_VAL_CFG1},\
+{DDRC_CTL_48_REG, DDRC_CTL_DDR2_48_VAL_CFG1},\
+{DDRC_CTL_49_REG, DDRC_CTL_DDR2_49_VAL_CFG1},\
+{DDRC_CTL_50_REG, DDRC_CTL_DDR2_50_VAL_CFG1},\
+{DDRC_CTL_52_REG, DDRC_CTL_DDR2_52_VAL_CFG1},\
+{DDRC_CTL_53_REG, DDRC_CTL_DDR2_53_VAL_CFG1},\
+{DDRC_CTL_59_REG, DDRC_CTL_DDR2_59_VAL_CFG1},\
+{DDRC_CTL_60_REG, DDRC_CTL_DDR2_60_VAL_CFG1},\
+{DDRC_CTL_61_REG, DDRC_CTL_DDR2_61_VAL_CFG1},\
+{DDRC_CTL_62_REG, DDRC_CTL_DDR2_62_VAL_CFG1},\
+{DDRC_CTL_63_REG, DDRC_CTL_DDR2_63_VAL_CFG1},\
+{DDRC_CTL_64_REG, DDRC_CTL_DDR2_64_VAL_CFG1},\
+{DDRC_CTL_66_REG, DDRC_CTL_DDR2_66_VAL_CFG1},\
+{DDRC_CTL_67_REG, DDRC_CTL_DDR2_67_VAL_CFG1},\
+{DDRC_CTL_68_REG, DDRC_CTL_DDR2_68_VAL_CFG1},\
+{DDRC_CTL_69_REG, DDRC_CTL_DDR2_69_VAL_CFG1},\
+{DDRC_CTL_70_REG, DDRC_CTL_DDR2_70_VAL_CFG1},\
+{DDRC_CTL_71_REG, DDRC_CTL_DDR2_71_VAL_CFG1},\
+{DDRC_CTL_72_REG, DDRC_CTL_DDR2_72_VAL_CFG1},\
+{DDRC_CTL_73_REG, DDRC_CTL_DDR2_73_VAL_CFG1},\
+{DDRC_CTL_75_REG, DDRC_CTL_DDR2_75_VAL_CFG1},\
+{DDRC_CTL_76_REG, DDRC_CTL_DDR2_76_VAL_CFG1},\
+{DDRC_CTL_77_REG, DDRC_CTL_DDR2_77_VAL_CFG1},\
+{DDRC_CTL_79_REG, DDRC_CTL_DDR2_79_VAL_CFG1},\
+{DDRC_CTL_80_REG, DDRC_CTL_DDR2_80_VAL_CFG1},\
+{DDRC_CTL_82_REG, DDRC_CTL_DDR2_82_VAL_CFG1},\
+{DDRC_CTL_83_REG, DDRC_CTL_DDR2_83_VAL_CFG1},\
+{DDRC_CTL_84_REG, DDRC_CTL_DDR2_84_VAL_CFG1},\
+{DDRC_CTL_86_REG, DDRC_CTL_DDR2_86_VAL_CFG1},\
+{DDRC_CTL_87_REG, DDRC_CTL_DDR2_87_VAL_CFG1},\
+{DDRC_CTL_89_REG, DDRC_CTL_DDR2_89_VAL_CFG1},\
+{DDRC_CTL_90_REG, DDRC_CTL_DDR2_90_VAL_CFG1},\
+{DDRC_CTL_91_REG, DDRC_CTL_DDR2_91_VAL_CFG1},\
+{DDRC_CTL_92_REG, DDRC_CTL_DDR2_92_VAL_CFG1},\
+{DDRC_CTL_93_REG, DDRC_CTL_DDR2_93_VAL_CFG1},\
+{DDRC_CTL_94_REG, DDRC_CTL_DDR2_94_VAL_CFG1},\
+{DDRC_CTL_95_REG, DDRC_CTL_DDR2_95_VAL_CFG1},\
+{DDRC_CTL_96_REG, DDRC_CTL_DDR2_96_VAL_CFG1},\
+{DDRC_CTL_97_REG, DDRC_CTL_DDR2_97_VAL_CFG1},\
+{DDRC_CTL_98_REG, DDRC_CTL_DDR2_98_VAL_CFG1},\
+{DDRC_CTL_99_REG, DDRC_CTL_DDR2_99_VAL_CFG1},\
+{DDRC_CTL_100_REG, DDRC_CTL_DDR2_100_VAL_CFG1},\
+{DDRC_CTL_101_REG, DDRC_CTL_DDR2_101_VAL_CFG1},\
+{DDRC_CTL_102_REG, DDRC_CTL_DDR2_102_VAL_CFG1},\
+{DDRC_CTL_103_REG, DDRC_CTL_DDR2_103_VAL_CFG1},\
+{DDRC_CTL_104_REG, DDRC_CTL_DDR2_104_VAL_CFG1},\
+{DDRC_CTL_105_REG, DDRC_CTL_DDR2_105_VAL_CFG1},\
+{DDRC_CTL_106_REG, DDRC_CTL_DDR2_106_VAL_CFG1},\
+{DDRC_CTL_107_REG, DDRC_CTL_DDR2_107_VAL_CFG1},\
+{DDRC_CTL_108_REG, DDRC_CTL_DDR2_108_VAL_CFG1},\
+{DDRC_CTL_109_REG, DDRC_CTL_DDR2_109_VAL_CFG1},\
+{DDRC_CTL_110_REG, DDRC_CTL_DDR2_110_VAL_CFG1},\
+{DDRC_CTL_111_REG, DDRC_CTL_DDR2_111_VAL_CFG1},\
+{DDRC_CTL_112_REG, DDRC_CTL_DDR2_112_VAL_CFG1},\
+{DDRC_CTL_113_REG, DDRC_CTL_DDR2_113_VAL_CFG1},\
+{DDRC_CTL_114_REG, DDRC_CTL_DDR2_114_VAL_CFG1},\
+{DDRC_CTL_115_REG, DDRC_CTL_DDR2_115_VAL_CFG1},\
+{DDRC_CTL_116_REG, DDRC_CTL_DDR2_116_VAL_CFG1},\
+{DDRC_CTL_117_REG, DDRC_CTL_DDR2_117_VAL_CFG1},\
+{DDRC_CTL_118_REG, DDRC_CTL_DDR2_118_VAL_CFG1},\
+{DDRC_CTL_119_REG, DDRC_CTL_DDR2_119_VAL_CFG1},\
+{DDRC_CTL_120_REG, DDRC_CTL_DDR2_120_VAL_CFG1},\
+{DDRC_CTL_121_REG, DDRC_CTL_DDR2_121_VAL_CFG1},\
+{DDRC_CTL_122_REG, DDRC_CTL_DDR2_122_VAL_CFG1},\
+{DDRC_CTL_123_REG, DDRC_CTL_DDR2_123_VAL_CFG1},\
+{DDRC_CTL_125_REG, DDRC_CTL_DDR2_125_VAL_CFG1},\
+{DDRC_CTL_126_REG, DDRC_CTL_DDR2_126_VAL_CFG1}
+
+
+/******** DDR3 Controller @400MHz *******/
+#define DDRC_CTL_DDR3_000_VAL_CFG1  0x20410600LL
+//
+#define DDRC_CTL_DDR3_002_VAL_CFG1  0x00000006LL
+#define DDRC_CTL_DDR3_003_VAL_CFG1  0x0001388ALL
+#define DDRC_CTL_DDR3_004_VAL_CFG1  0x00030D4ALL
+#define DDRC_CTL_DDR3_005_VAL_CFG1  0x04060E00LL
+#define DDRC_CTL_DDR3_006_VAL_CFG1  0x0F150404LL
+#define DDRC_CTL_DDR3_007_VAL_CFG1  0x08040604LL
+#define DDRC_CTL_DDR3_008_VAL_CFG1  0x006D9C0CLL
+#define DDRC_CTL_DDR3_009_VAL_CFG1  0x00000103LL
+#define DDRC_CTL_DDR3_010_VAL_CFG1  0x06060101LL
+#define DDRC_CTL_DDR3_011_VAL_CFG1  0x0002000CLL
+#define DDRC_CTL_DDR3_012_VAL_CFG1  0x00011403LL
+#define DDRC_CTL_DDR3_013_VAL_CFG1  0x00000001LL
+#define DDRC_CTL_DDR3_014_VAL_CFG1  0x00400100LL
+#define DDRC_CTL_DDR3_015_VAL_CFG1  0x00000C26LL
+#define DDRC_CTL_DDR3_016_VAL_CFG1  0x000A0003LL
+#define DDRC_CTL_DDR3_017_VAL_CFG1  0x00060002LL
+#define DDRC_CTL_DDR3_018_VAL_CFG1  0x00440200LL
+#define DDRC_CTL_DDR3_019_VAL_CFG1  0x00000000LL
+#define DDRC_CTL_DDR3_020_VAL_CFG1  0x00050500LL
+#define DDRC_CTL_DDR3_021_VAL_CFG1  0x00000000LL
+#define DDRC_CTL_DDR3_022_VAL_CFG1  0x00000000LL
+#define DDRC_CTL_DDR3_023_VAL_CFG1  0x00000000LL
+#define DDRC_CTL_DDR3_024_VAL_CFG1  0x00000000LL
+#define DDRC_CTL_DDR3_025_VAL_CFG1  0x00000000LL
+#define DDRC_CTL_DDR3_026_VAL_CFG1  0x00000000LL
+#define DDRC_CTL_DDR3_027_VAL_CFG1  0x00043000LL
+#define DDRC_CTL_DDR3_028_VAL_CFG1  0x00080006LL
+#define DDRC_CTL_DDR3_029_VAL_CFG1  0x00000000LL
+#define DDRC_CTL_DDR3_030_VAL_CFG1  0x00060430LL
+#define DDRC_CTL_DDR3_031_VAL_CFG1  0x00000008LL
+#define DDRC_CTL_DDR3_032_VAL_CFG1  0x00020000LL
+#define DDRC_CTL_DDR3_033_VAL_CFG1  0x00000000LL
+//
+//
+//
+//
+//
+//
+//
+//
+//
+#define DDRC_CTL_DDR3_043_VAL_CFG1  0x01400200LL
+#define DDRC_CTL_DDR3_044_VAL_CFG1  0x02000040LL
+#define DDRC_CTL_DDR3_045_VAL_CFG1  0x01010080LL
+#define DDRC_CTL_DDR3_046_VAL_CFG1  0xFF0A0102LL
+#define DDRC_CTL_DDR3_047_VAL_CFG1  0x010101FFLL
+#define DDRC_CTL_DDR3_048_VAL_CFG1  0x00010001LL
+#define DDRC_CTL_DDR3_049_VAL_CFG1  0x000C0100LL
+#define DDRC_CTL_DDR3_050_VAL_CFG1  0x00010002LL
+//
+#define DDRC_CTL_DDR3_052_VAL_CFG1  0x00000000LL
+#define DDRC_CTL_DDR3_053_VAL_CFG1  0x007FFFFFLL
+//
+//
+//
+//
+//
+#define DDRC_CTL_DDR3_059_VAL_CFG1  0x01000000LL
+#define DDRC_CTL_DDR3_060_VAL_CFG1  0x00020100LL
+#define DDRC_CTL_DDR3_061_VAL_CFG1  0x02010202LL
+#define DDRC_CTL_DDR3_062_VAL_CFG1  0x02000101LL
+#define DDRC_CTL_DDR3_063_VAL_CFG1  0x00000000LL
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+#define DDRC_CTL_DDR3_091_VAL_CFG1  0xFFFF0000LL
+#define DDRC_CTL_DDR3_092_VAL_CFG1  0x00000202LL
+#define DDRC_CTL_DDR3_093_VAL_CFG1  0x0101FFFFLL
+#define DDRC_CTL_DDR3_094_VAL_CFG1  0x03FFFF00LL
+#define DDRC_CTL_DDR3_095_VAL_CFG1  0xFFFF0003LL
+#define DDRC_CTL_DDR3_096_VAL_CFG1  0x00000303LL
+#define DDRC_CTL_DDR3_097_VAL_CFG1  0x01000400LL
+#define DDRC_CTL_DDR3_098_VAL_CFG1  0x00016400LL
+#define DDRC_CTL_DDR3_099_VAL_CFG1  0x00000100LL
+#define DDRC_CTL_DDR3_100_VAL_CFG1  0x00000001LL
+//
+#define DDRC_CTL_DDR3_102_VAL_CFG1  0x00000800LL
+#define DDRC_CTL_DDR3_103_VAL_CFG1  0x00103300LL
+#define DDRC_CTL_DDR3_104_VAL_CFG1  0x02000200LL
+#define DDRC_CTL_DDR3_105_VAL_CFG1  0x02000200LL
+#define DDRC_CTL_DDR3_106_VAL_CFG1  0x00001033LL
+#define DDRC_CTL_DDR3_107_VAL_CFG1  0x000050FFLL
+#define DDRC_CTL_DDR3_108_VAL_CFG1  0x0002060CLL
+#define DDRC_CTL_DDR3_109_VAL_CFG1  0x00000003LL
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+#define DDRC_CTL_DDR3_126_VAL_CFG1  0x00000000LL
+
+/* DDR3 PHY @400 */
+#define DDR3_PHY_CTL_00_VAL_CFG1  0x000F1003LL
+#define DDR3_PHY_CTL_01_VAL_CFG1  0x18201010LL
+#define DDR3_PHY_CTL_02_VAL_CFG1  0x00000006LL
+#define DDR3_PHY_CTL_03_VAL_CFG1  0x00000000LL
+#define DDR3_PHY_CTL_04_VAL_CFG1  0x00000000LL
+#define DDR3_PHY_CTL_05_VAL_CFG1  0x00000000LL
+#define DDR3_PHY_CTL_06_VAL_CFG1  0x04300622LL
+#define DDR3_PHY_CTL_07_VAL_CFG1  0x00000000LL
+
+
+
+#define DDRC_DDR3_CFG_400 \
+{DDRC_CTL_00_REG, DDRC_CTL_DDR3_000_VAL_CFG1},\
+{DDRC_CTL_02_REG, DDRC_CTL_DDR3_002_VAL_CFG1},\
+{DDRC_CTL_03_REG, DDRC_CTL_DDR3_003_VAL_CFG1},\
+{DDRC_CTL_04_REG, DDRC_CTL_DDR3_004_VAL_CFG1},\
+{DDRC_CTL_05_REG, DDRC_CTL_DDR3_005_VAL_CFG1},\
+{DDRC_CTL_06_REG, DDRC_CTL_DDR3_006_VAL_CFG1},\
+{DDRC_CTL_07_REG, DDRC_CTL_DDR3_007_VAL_CFG1},\
+{DDRC_CTL_08_REG, DDRC_CTL_DDR3_008_VAL_CFG1},\
+{DDRC_CTL_09_REG, DDRC_CTL_DDR3_009_VAL_CFG1},\
+{DDRC_CTL_10_REG, DDRC_CTL_DDR3_010_VAL_CFG1},\
+{DDRC_CTL_11_REG, DDRC_CTL_DDR3_011_VAL_CFG1},\
+{DDRC_CTL_12_REG, DDRC_CTL_DDR3_012_VAL_CFG1},\
+{DDRC_CTL_13_REG, DDRC_CTL_DDR3_013_VAL_CFG1},\
+{DDRC_CTL_14_REG, DDRC_CTL_DDR3_014_VAL_CFG1},\
+{DDRC_CTL_15_REG, DDRC_CTL_DDR3_015_VAL_CFG1},\
+{DDRC_CTL_16_REG, DDRC_CTL_DDR3_016_VAL_CFG1},\
+{DDRC_CTL_17_REG, DDRC_CTL_DDR3_017_VAL_CFG1},\
+{DDRC_CTL_18_REG, DDRC_CTL_DDR3_018_VAL_CFG1},\
+{DDRC_CTL_19_REG, DDRC_CTL_DDR3_019_VAL_CFG1},\
+{DDRC_CTL_20_REG, DDRC_CTL_DDR3_020_VAL_CFG1},\
+{DDRC_CTL_21_REG, DDRC_CTL_DDR3_021_VAL_CFG1},\
+{DDRC_CTL_22_REG, DDRC_CTL_DDR3_022_VAL_CFG1},\
+{DDRC_CTL_23_REG, DDRC_CTL_DDR3_023_VAL_CFG1},\
+{DDRC_CTL_24_REG, DDRC_CTL_DDR3_024_VAL_CFG1},\
+{DDRC_CTL_25_REG, DDRC_CTL_DDR3_025_VAL_CFG1},\
+{DDRC_CTL_26_REG, DDRC_CTL_DDR3_026_VAL_CFG1},\
+{DDRC_CTL_27_REG, DDRC_CTL_DDR3_027_VAL_CFG1},\
+{DDRC_CTL_28_REG, DDRC_CTL_DDR3_028_VAL_CFG1},\
+{DDRC_CTL_29_REG, DDRC_CTL_DDR3_029_VAL_CFG1},\
+{DDRC_CTL_30_REG, DDRC_CTL_DDR3_030_VAL_CFG1},\
+{DDRC_CTL_31_REG, DDRC_CTL_DDR3_031_VAL_CFG1},\
+{DDRC_CTL_32_REG, DDRC_CTL_DDR3_032_VAL_CFG1},\
+{DDRC_CTL_33_REG, DDRC_CTL_DDR3_033_VAL_CFG1},\
+{DDRC_CTL_43_REG, DDRC_CTL_DDR3_043_VAL_CFG1},\
+{DDRC_CTL_44_REG, DDRC_CTL_DDR3_044_VAL_CFG1},\
+{DDRC_CTL_45_REG, DDRC_CTL_DDR3_045_VAL_CFG1},\
+{DDRC_CTL_46_REG, DDRC_CTL_DDR3_046_VAL_CFG1},\
+{DDRC_CTL_47_REG, DDRC_CTL_DDR3_047_VAL_CFG1},\
+{DDRC_CTL_48_REG, DDRC_CTL_DDR3_048_VAL_CFG1},\
+{DDRC_CTL_49_REG, DDRC_CTL_DDR3_049_VAL_CFG1},\
+{DDRC_CTL_50_REG, DDRC_CTL_DDR3_050_VAL_CFG1},\
+{DDRC_CTL_52_REG, DDRC_CTL_DDR3_052_VAL_CFG1},\
+{DDRC_CTL_53_REG, DDRC_CTL_DDR3_053_VAL_CFG1},\
+{DDRC_CTL_59_REG, DDRC_CTL_DDR3_059_VAL_CFG1},\
+{DDRC_CTL_60_REG, DDRC_CTL_DDR3_060_VAL_CFG1},\
+{DDRC_CTL_61_REG, DDRC_CTL_DDR3_061_VAL_CFG1},\
+{DDRC_CTL_62_REG, DDRC_CTL_DDR3_062_VAL_CFG1},\
+{DDRC_CTL_63_REG, DDRC_CTL_DDR3_063_VAL_CFG1},\
+{DDRC_CTL_91_REG, DDRC_CTL_DDR3_091_VAL_CFG1},\
+{DDRC_CTL_92_REG, DDRC_CTL_DDR3_092_VAL_CFG1},\
+{DDRC_CTL_93_REG, DDRC_CTL_DDR3_093_VAL_CFG1},\
+{DDRC_CTL_94_REG, DDRC_CTL_DDR3_094_VAL_CFG1},\
+{DDRC_CTL_95_REG, DDRC_CTL_DDR3_095_VAL_CFG1},\
+{DDRC_CTL_96_REG, DDRC_CTL_DDR3_096_VAL_CFG1},\
+{DDRC_CTL_97_REG, DDRC_CTL_DDR3_097_VAL_CFG1},\
+{DDRC_CTL_98_REG, DDRC_CTL_DDR3_098_VAL_CFG1},\
+{DDRC_CTL_99_REG, DDRC_CTL_DDR3_099_VAL_CFG1},\
+{DDRC_CTL_100_REG, DDRC_CTL_DDR3_100_VAL_CFG1},\
+{DDRC_CTL_102_REG, DDRC_CTL_DDR3_102_VAL_CFG1},\
+{DDRC_CTL_103_REG, DDRC_CTL_DDR3_103_VAL_CFG1},\
+{DDRC_CTL_104_REG, DDRC_CTL_DDR3_104_VAL_CFG1},\
+{DDRC_CTL_105_REG, DDRC_CTL_DDR3_105_VAL_CFG1},\
+{DDRC_CTL_106_REG, DDRC_CTL_DDR3_106_VAL_CFG1},\
+{DDRC_CTL_107_REG, DDRC_CTL_DDR3_107_VAL_CFG1},\
+{DDRC_CTL_108_REG, DDRC_CTL_DDR3_108_VAL_CFG1},\
+{DDRC_CTL_109_REG, DDRC_CTL_DDR3_109_VAL_CFG1},\
+{DDRC_CTL_126_REG, DDRC_CTL_DDR3_126_VAL_CFG1}
+
+#define DDR_PHY_CFG_400 \
+{DDR_PHY_CTL_00_REG, DDR3_PHY_CTL_00_VAL_CFG1},\
+{DDR_PHY_CTL_01_REG, DDR3_PHY_CTL_01_VAL_CFG1},\
+{DDR_PHY_CTL_01_REG, DDR3_PHY_CTL_02_VAL_CFG1},\
+{DDR_PHY_CTL_03_REG, DDR3_PHY_CTL_03_VAL_CFG1},\
+{DDR_PHY_CTL_04_REG, DDR3_PHY_CTL_04_VAL_CFG1},\
+{DDR_PHY_CTL_05_REG, DDR3_PHY_CTL_05_VAL_CFG1},\
+{DDR_PHY_CTL_06_REG, DDR3_PHY_CTL_06_VAL_CFG1},\
+{DDR_PHY_CTL_07_REG, DDR3_PHY_CTL_07_VAL_CFG1}
+
+/*****************************/
+
+/* DDR3 Controller @533MHz */
+#define DDRC_CTL_DDR3_000_VAL_CFG2  0x20410600LL
+//
+#define DDRC_CTL_DDR3_002_VAL_CFG2  0x00000006LL
+#define DDRC_CTL_DDR3_003_VAL_CFG2  0x0001A07CLL
+#define DDRC_CTL_DDR3_004_VAL_CFG2  0x00041127LL
+#define DDRC_CTL_DDR3_005_VAL_CFG2  0x04060E00LL
+#define DDRC_CTL_DDR3_006_VAL_CFG2  0x141C0604LL
+#define DDRC_CTL_DDR3_007_VAL_CFG2  0x08040804LL
+#define DDRC_CTL_DDR3_008_VAL_CFG2  0x0092190CLL
+#define DDRC_CTL_DDR3_009_VAL_CFG2  0x00000504LL
+#define DDRC_CTL_DDR3_010_VAL_CFG2  0x08080101LL
+#define DDRC_CTL_DDR3_011_VAL_CFG2  0x00020010LL
+#define DDRC_CTL_DDR3_012_VAL_CFG2  0x00011B03LL
+#define DDRC_CTL_DDR3_013_VAL_CFG2  0x00000009LL
+#define DDRC_CTL_DDR3_014_VAL_CFG2  0x00560100LL
+#define DDRC_CTL_DDR3_015_VAL_CFG2  0x00001034LL
+#define DDRC_CTL_DDR3_016_VAL_CFG2  0x000D0004LL
+#define DDRC_CTL_DDR3_017_VAL_CFG2  0x00060002LL
+#define DDRC_CTL_DDR3_018_VAL_CFG2  0x005B0200LL
+#define DDRC_CTL_DDR3_019_VAL_CFG2  0x00000000LL
+#define DDRC_CTL_DDR3_020_VAL_CFG2  0x00060600LL
+#define DDRC_CTL_DDR3_021_VAL_CFG2  0x00000000LL
+#define DDRC_CTL_DDR3_022_VAL_CFG2  0x00000000LL
+#define DDRC_CTL_DDR3_023_VAL_CFG2  0x00000000LL
+#define DDRC_CTL_DDR3_024_VAL_CFG2  0x00000000LL
+#define DDRC_CTL_DDR3_025_VAL_CFG2  0x00000000LL
+#define DDRC_CTL_DDR3_026_VAL_CFG2  0x00000000LL
+#define DDRC_CTL_DDR3_027_VAL_CFG2  0x00083000LL
+#define DDRC_CTL_DDR3_028_VAL_CFG2  0x00080006LL
+#define DDRC_CTL_DDR3_029_VAL_CFG2  0x00000000LL
+#define DDRC_CTL_DDR3_030_VAL_CFG2  0x00060830LL
+#define DDRC_CTL_DDR3_031_VAL_CFG2  0x00000008LL
+#define DDRC_CTL_DDR3_032_VAL_CFG2  0x00020000LL
+#define DDRC_CTL_DDR3_033_VAL_CFG2  0x00000000LL
+//
+//
+//
+//
+//
+//
+//
+//
+//
+#define DDRC_CTL_DDR3_043_VAL_CFG2  0x01400200LL
+#define DDRC_CTL_DDR3_044_VAL_CFG2  0x02000040LL
+#define DDRC_CTL_DDR3_045_VAL_CFG2  0x01010080LL
+#define DDRC_CTL_DDR3_046_VAL_CFG2  0xFF0A0102LL
+#define DDRC_CTL_DDR3_047_VAL_CFG2  0x010101FFLL
+#define DDRC_CTL_DDR3_048_VAL_CFG2  0x00010001LL
+#if defined(DDR_CFG_16BIT)
+#define DDRC_CTL_DDR3_049_VAL_CFG2  0x010C0100LL
+#else
+#define DDRC_CTL_DDR3_049_VAL_CFG2  0x000C0100LL
+#endif
+#define DDRC_CTL_DDR3_050_VAL_CFG2  0x00010002LL
+//
+#define DDRC_CTL_DDR3_052_VAL_CFG2  0x00000000LL
+#define DDRC_CTL_DDR3_053_VAL_CFG2  0x007FFFFFLL
+//
+//
+//
+//
+//
+#define DDRC_CTL_DDR3_059_VAL_CFG2  0x01000000LL
+#define DDRC_CTL_DDR3_060_VAL_CFG2  0x00020100LL
+#define DDRC_CTL_DDR3_061_VAL_CFG2  0x02010202LL
+#define DDRC_CTL_DDR3_062_VAL_CFG2  0x02000101LL
+#define DDRC_CTL_DDR3_063_VAL_CFG2  0x00000000LL
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+#define DDRC_CTL_DDR3_091_VAL_CFG2  0xFFFF0000LL
+#define DDRC_CTL_DDR3_092_VAL_CFG2  0x00000202LL
+#define DDRC_CTL_DDR3_093_VAL_CFG2  0x0101FFFFLL
+#define DDRC_CTL_DDR3_094_VAL_CFG2  0x03FFFF00LL
+#define DDRC_CTL_DDR3_095_VAL_CFG2  0xFFFF0003LL
+#define DDRC_CTL_DDR3_096_VAL_CFG2  0x00000303LL
+#define DDRC_CTL_DDR3_097_VAL_CFG2  0x01000400LL
+#define DDRC_CTL_DDR3_098_VAL_CFG2  0x00016400LL
+#define DDRC_CTL_DDR3_099_VAL_CFG2  0x00000100LL
+#define DDRC_CTL_DDR3_100_VAL_CFG2  0x00000001LL
+//
+#define DDRC_CTL_DDR3_102_VAL_CFG2  0x00000800LL
+#define DDRC_CTL_DDR3_103_VAL_CFG2  0x00103300LL
+#define DDRC_CTL_DDR3_104_VAL_CFG2  0x02000200LL
+#define DDRC_CTL_DDR3_105_VAL_CFG2  0x02000200LL
+#define DDRC_CTL_DDR3_106_VAL_CFG2  0x00001033LL
+#define DDRC_CTL_DDR3_107_VAL_CFG2  0x000050FFLL
+#define DDRC_CTL_DDR3_108_VAL_CFG2  0x0002060CLL
+#define DDRC_CTL_DDR3_109_VAL_CFG2  0x00000003LL
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+//
+#define DDRC_CTL_DDR3_126_VAL_CFG2  0x00000000LL
+
+
+/* DDR3 PHY @533 */
+#define DDR3_PHY_CTL_00_VAL_CFG2  0x000F1003LL
+#define DDR3_PHY_CTL_01_VAL_CFG2  0x18201010LL
+#define DDR3_PHY_CTL_02_VAL_CFG2  0x00000006LL
+#define DDR3_PHY_CTL_03_VAL_CFG2  0x09090909LL 
+#define DDR3_PHY_CTL_04_VAL_CFG2  0x00000009LL
+#define DDR3_PHY_CTL_05_VAL_CFG2  0x00000000LL
+#define DDR3_PHY_CTL_06_VAL_CFG2  0x04300623LL
+#define DDR3_PHY_CTL_07_VAL_CFG2  0x00000000LL
+
+
+
+#define DDRC_DDR3_CFG_533 \
+{DDRC_CTL_00_REG, DDRC_CTL_DDR3_000_VAL_CFG2},\
+{DDRC_CTL_02_REG, DDRC_CTL_DDR3_002_VAL_CFG2},\
+{DDRC_CTL_03_REG, DDRC_CTL_DDR3_003_VAL_CFG2},\
+{DDRC_CTL_04_REG, DDRC_CTL_DDR3_004_VAL_CFG2},\
+{DDRC_CTL_05_REG, DDRC_CTL_DDR3_005_VAL_CFG2},\
+{DDRC_CTL_06_REG, DDRC_CTL_DDR3_006_VAL_CFG2},\
+{DDRC_CTL_07_REG, DDRC_CTL_DDR3_007_VAL_CFG2},\
+{DDRC_CTL_08_REG, DDRC_CTL_DDR3_008_VAL_CFG2},\
+{DDRC_CTL_09_REG, DDRC_CTL_DDR3_009_VAL_CFG2},\
+{DDRC_CTL_10_REG, DDRC_CTL_DDR3_010_VAL_CFG2},\
+{DDRC_CTL_11_REG, DDRC_CTL_DDR3_011_VAL_CFG2},\
+{DDRC_CTL_12_REG, DDRC_CTL_DDR3_012_VAL_CFG2},\
+{DDRC_CTL_13_REG, DDRC_CTL_DDR3_013_VAL_CFG2},\
+{DDRC_CTL_14_REG, DDRC_CTL_DDR3_014_VAL_CFG2},\
+{DDRC_CTL_15_REG, DDRC_CTL_DDR3_015_VAL_CFG2},\
+{DDRC_CTL_16_REG, DDRC_CTL_DDR3_016_VAL_CFG2},\
+{DDRC_CTL_17_REG, DDRC_CTL_DDR3_017_VAL_CFG2},\
+{DDRC_CTL_18_REG, DDRC_CTL_DDR3_018_VAL_CFG2},\
+{DDRC_CTL_19_REG, DDRC_CTL_DDR3_019_VAL_CFG2},\
+{DDRC_CTL_20_REG, DDRC_CTL_DDR3_020_VAL_CFG2},\
+{DDRC_CTL_21_REG, DDRC_CTL_DDR3_021_VAL_CFG2},\
+{DDRC_CTL_22_REG, DDRC_CTL_DDR3_022_VAL_CFG2},\
+{DDRC_CTL_23_REG, DDRC_CTL_DDR3_023_VAL_CFG2},\
+{DDRC_CTL_24_REG, DDRC_CTL_DDR3_024_VAL_CFG2},\
+{DDRC_CTL_25_REG, DDRC_CTL_DDR3_025_VAL_CFG2},\
+{DDRC_CTL_26_REG, DDRC_CTL_DDR3_026_VAL_CFG2},\
+{DDRC_CTL_27_REG, DDRC_CTL_DDR3_027_VAL_CFG2},\
+{DDRC_CTL_28_REG, DDRC_CTL_DDR3_028_VAL_CFG2},\
+{DDRC_CTL_29_REG, DDRC_CTL_DDR3_029_VAL_CFG2},\
+{DDRC_CTL_30_REG, DDRC_CTL_DDR3_030_VAL_CFG2},\
+{DDRC_CTL_31_REG, DDRC_CTL_DDR3_031_VAL_CFG2},\
+{DDRC_CTL_32_REG, DDRC_CTL_DDR3_032_VAL_CFG2},\
+{DDRC_CTL_33_REG, DDRC_CTL_DDR3_033_VAL_CFG2},\
+{DDRC_CTL_43_REG, DDRC_CTL_DDR3_043_VAL_CFG2},\
+{DDRC_CTL_44_REG, DDRC_CTL_DDR3_044_VAL_CFG2},\
+{DDRC_CTL_45_REG, DDRC_CTL_DDR3_045_VAL_CFG2},\
+{DDRC_CTL_46_REG, DDRC_CTL_DDR3_046_VAL_CFG2},\
+{DDRC_CTL_47_REG, DDRC_CTL_DDR3_047_VAL_CFG2},\
+{DDRC_CTL_48_REG, DDRC_CTL_DDR3_048_VAL_CFG2},\
+{DDRC_CTL_49_REG, DDRC_CTL_DDR3_049_VAL_CFG2},\
+{DDRC_CTL_50_REG, DDRC_CTL_DDR3_050_VAL_CFG2},\
+{DDRC_CTL_52_REG, DDRC_CTL_DDR3_052_VAL_CFG2},\
+{DDRC_CTL_53_REG, DDRC_CTL_DDR3_053_VAL_CFG2},\
+{DDRC_CTL_59_REG, DDRC_CTL_DDR3_059_VAL_CFG2},\
+{DDRC_CTL_60_REG, DDRC_CTL_DDR3_060_VAL_CFG2},\
+{DDRC_CTL_61_REG, DDRC_CTL_DDR3_061_VAL_CFG2},\
+{DDRC_CTL_62_REG, DDRC_CTL_DDR3_062_VAL_CFG2},\
+{DDRC_CTL_63_REG, DDRC_CTL_DDR3_063_VAL_CFG2},\
+{DDRC_CTL_91_REG, DDRC_CTL_DDR3_091_VAL_CFG2},\
+{DDRC_CTL_92_REG, DDRC_CTL_DDR3_092_VAL_CFG2},\
+{DDRC_CTL_93_REG, DDRC_CTL_DDR3_093_VAL_CFG2},\
+{DDRC_CTL_94_REG, DDRC_CTL_DDR3_094_VAL_CFG2},\
+{DDRC_CTL_95_REG, DDRC_CTL_DDR3_095_VAL_CFG2},\
+{DDRC_CTL_96_REG, DDRC_CTL_DDR3_096_VAL_CFG2},\
+{DDRC_CTL_97_REG, DDRC_CTL_DDR3_097_VAL_CFG2},\
+{DDRC_CTL_98_REG, DDRC_CTL_DDR3_098_VAL_CFG2},\
+{DDRC_CTL_99_REG, DDRC_CTL_DDR3_099_VAL_CFG2},\
+{DDRC_CTL_100_REG, DDRC_CTL_DDR3_100_VAL_CFG2},\
+{DDRC_CTL_102_REG, DDRC_CTL_DDR3_102_VAL_CFG2},\
+{DDRC_CTL_103_REG, DDRC_CTL_DDR3_103_VAL_CFG2},\
+{DDRC_CTL_104_REG, DDRC_CTL_DDR3_104_VAL_CFG2},\
+{DDRC_CTL_105_REG, DDRC_CTL_DDR3_105_VAL_CFG2},\
+{DDRC_CTL_106_REG, DDRC_CTL_DDR3_106_VAL_CFG2},\
+{DDRC_CTL_107_REG, DDRC_CTL_DDR3_107_VAL_CFG2},\
+{DDRC_CTL_108_REG, DDRC_CTL_DDR3_108_VAL_CFG2},\
+{DDRC_CTL_109_REG, DDRC_CTL_DDR3_109_VAL_CFG2},\
+{DDRC_CTL_126_REG, DDRC_CTL_DDR3_126_VAL_CFG2}
+
+#define DDR_PHY_CFG_533 \
+{DDR_PHY_CTL_00_REG, DDR3_PHY_CTL_00_VAL_CFG2},\
+{DDR_PHY_CTL_01_REG, DDR3_PHY_CTL_01_VAL_CFG2},\
+{DDR_PHY_CTL_02_REG, DDR3_PHY_CTL_02_VAL_CFG2},\
+{DDR_PHY_CTL_03_REG, DDR3_PHY_CTL_03_VAL_CFG2},\
+{DDR_PHY_CTL_04_REG, DDR3_PHY_CTL_04_VAL_CFG2},\
+{DDR_PHY_CTL_05_REG, DDR3_PHY_CTL_05_VAL_CFG2},\
+{DDR_PHY_CTL_06_REG, DDR3_PHY_CTL_06_VAL_CFG2},\
+{DDR_PHY_CTL_07_REG, DDR3_PHY_CTL_07_VAL_CFG2}, \
+
+//#define DDRC_CFG	DDRC_DDR3_CFG_533
+//#define DDR_PHY_CFG	DDR_PHY_CFG_533
+//For Bringup
+#define DDRC_CFG	DDRC_DDR3_CFG_533
+#define DDR_PHY_CFG	DDR_PHY_CFG_533
+
+struct ddr_reg_val {
+        u32 reg;
+        u32 val;
+};
+
+#define MC_START	0x1
+#define MC_INIT_STAT_MASK	0x200
+
+#define CTRL_RESYNC_EN  (1 << 20)
+#define CTRL_RESYNC_PLS (1 << 21)
+
+
+#define is_16bitDDR_config() ((readl(DDRC_CTL_49_REG)) & (0x01000000))
+
+#endif
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/arch/arm/include/asm/arch-comcerto/ecc.h u-boot-2013.01.new/arch/arm/include/asm/arch-comcerto/ecc.h
--- u-boot-2013.01/arch/arm/include/asm/arch-comcerto/ecc.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/arch/arm/include/asm/arch-comcerto/ecc.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,110 @@
+#ifndef _ECC_H
+#define _ECC_H
+
+/* ECC Register Set */
+/********************/
+/* ECC Control Registers */
+#define ECC_SHIFT_EN_CFG	(COMCERTO_AXI_EXP_ECC_BASE)
+#define ECC_GEN_CFG		(COMCERTO_AXI_EXP_ECC_BASE + 0x4)
+#define ECC_TAG_CFG		(COMCERTO_AXI_EXP_ECC_BASE + 0x8)
+#define ECC_INIT_CFG		(COMCERTO_AXI_EXP_ECC_BASE + 0xC)
+#define ECC_PRTY_OUT_SEL_CFG	(COMCERTO_AXI_EXP_ECC_BASE + 0x10)
+#define ECC_POLY_START_CFG	(COMCERTO_AXI_EXP_ECC_BASE + 0x14)
+#define ECC_CS_SEL_CFG		(COMCERTO_AXI_EXP_ECC_BASE + 0x18)
+/* ECC Status Registers */
+#define ECC_IDLE_STAT		(COMCERTO_AXI_EXP_ECC_BASE + 0x1C)
+#define ECC_POLY_STAT		(COMCERTO_AXI_EXP_ECC_BASE + 0x20)
+#define ECC_CORR_STAT		(COMCERTO_AXI_EXP_ECC_BASE + 0x24)
+#define ECC_CORR_DONE_STAT	(COMCERTO_AXI_EXP_ECC_BASE + 0x28)
+#define ECC_CORR_DATA_STAT	(COMCERTO_AXI_EXP_ECC_BASE + 0x2C)
+
+/* ECC general configuration register parameters */
+#define HAMM_MODE	BIT_28_MSK
+#define BCH_MODE	(~ HAMM_MODE)
+
+#define PRTY_MODE_MASK	BIT_24_MSK
+#define PRTY_CALC	PRTY_MODE_MASK
+#define SYNDROME_CALC	(~ PRTY_CALC)
+
+#define	ECC_LVL_MASK	0x3F0000
+#define ECC_LVL_SHIFT	16
+
+#define BLK_SIZE_MASK 0x7FF
+
+#define ECC_LVL_2 0x2
+#define ECC_LVL_4 0x4
+#define ECC_LVL_6 0x6
+#define ECC_LVL_8 0x8
+#define ECC_LVL_10 0xA
+#define ECC_LVL_12 0xC
+#define ECC_LVL_14 0xE
+#define ECC_LVL_16 0x10
+#define ECC_LVL_18 0x12
+#define ECC_LVL_20 0x14
+#define ECC_LVL_22 0x16
+#define ECC_LVL_24 0x18
+#define ECC_LVL_26 0x1A
+#define ECC_LVL_28 0x1C
+#define ECC_LVL_30 0x1E
+#define ECC_LVL_32 0x20
+
+#if defined (CONFIG_NAND_COMCERTO_ECC_24_HW_BCH)
+       #define ECC_LVL_VAL ECC_LVL_24  /* ECC Level 24 is used */
+#elif defined (CONFIG_NAND_COMCERTO_ECC_8_HW_BCH)
+       #define ECC_LVL_VAL ECC_LVL_8   /* ECC Level 8 is used */
+#endif
+
+/* Block size used in Bytes*/
+#define ECC_BLOCK_SIZE_512 512
+#define ECC_BLOCK_SIZE_1024 1024
+
+/* Maximum value of ECC Block size is 2k-(1+14*ECC_LVL/8) Bytes */
+#define ECC_BLOCK_SIZE		ECC_BLOCK_SIZE_1024
+#define ECC_BLOCK_SIZE_SHIFT	ECC_BLOCK_SIZE_1024_SHIFT
+
+#define ECC_CS4_SEL 0x10
+#define ECC_CS3_SEL 0x08
+#define ECC_CS2_SEL 0x04
+#define ECC_CS1_SEL 0x02
+#define ECC_CS0_SEL 0x01
+
+#define ECC_INIT		0x1
+#define ECC_SHIFT_ENABLE	0x1
+#define ECC_SHIFT_DISABLE	0x0
+#define ECC_PARITY_OUT_EN	0x1
+#define ECC_PARITY_OUT_DISABLE	0x0
+#define ECC_UNCORR_ERR_HAMM	0x4
+
+/* Polynomial Start Configuration (ECC_POLY_START_CFG) */
+#define ECC_POLY_START		(1 << 0)
+
+/* Idle Status (ECC_IDLE_STAT) */
+#define ECC_IDLE		(1 << 0)
+
+/* Polynomial Status (ECC_POLY_STAT) */
+#define ECC_CORR_REQ		(1 << 0)
+#define ECC_ERASED_PAGE		(1 << 1)
+#define ECC_UNCORR_ERR_HAMM	(1 << 2)
+
+/* Correction Status (ECC_CORR_STAT) */
+#define ECC_TAG_MASK		0xFFFF
+#define ECC_NUM_ERR_MASK	0x3F
+#define ECC_NUM_ERR_SHIFT	16
+#define ECC_UNCORR		(1 << 24)
+
+/* Correction Done Status (ECC_CORR_DONE_STAT) */
+#define ECC_DONE		(1 << 0)
+
+/* Correction Data Status (ECC_CORR_DATA_STAT), BCH Mode */
+#define ECC_BCH_MASK		0xFFFF
+#define ECC_BCH_INDEX_MASK	0x7FF
+#define ECC_BCH_INDEX_SHIFT	16
+#define ECC_BCH_VALID		(1 << 31)
+
+/* Correction Data Status (ECC_CORR_DATA_STAT), Hamming Mode */
+#define ECC_HAMM_MASK		0xF
+#define ECC_HAMM_INDEX_MASK	0x1FF
+#define ECC_HAMM_INDEX_SHIFT	16
+#define ECC_HAMM_VALID		(1 << 31)
+
+#endif /*_ECC_H */
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/arch/arm/include/asm/arch-comcerto/exp-bus.h u-boot-2013.01.new/arch/arm/include/asm/arch-comcerto/exp-bus.h
--- u-boot-2013.01/arch/arm/include/asm/arch-comcerto/exp-bus.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/arch/arm/include/asm/arch-comcerto/exp-bus.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,99 @@
+/*
+ *  arch/arm/mach-comcerto/include/mach/exp-bus.h
+ *
+ *  Copyright (C) 2011 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __COMCERTO_EXP_BUS_H__
+#define __COMCERTO_EXP_BUS_H__
+
+/*
+ *  Expansion Bus control registers
+ */
+#define EXP_SWRST_REG            (COMCERTO_EXP_CONF_BASE + 0x00)
+#define EXP_CSEN_REG             (COMCERTO_EXP_CONF_BASE + 0x04)
+#define EXP_CS0_BASE_REG         (COMCERTO_EXP_CONF_BASE + 0x08)
+#define EXP_CS1_BASE_REG         (COMCERTO_EXP_CONF_BASE + 0x0C)
+#define EXP_CS2_BASE_REG         (COMCERTO_EXP_CONF_BASE + 0x10)
+#define EXP_CS3_BASE_REG         (COMCERTO_EXP_CONF_BASE + 0x14)
+#define EXP_CS4_BASE_REG         (COMCERTO_EXP_CONF_BASE + 0x18)
+#define EXP_CS0_SEG_REG          (COMCERTO_EXP_CONF_BASE + 0x1C)
+#define EXP_CS1_SEG_REG          (COMCERTO_EXP_CONF_BASE + 0x20)
+#define EXP_CS2_SEG_REG          (COMCERTO_EXP_CONF_BASE + 0x24)
+#define EXP_CS3_SEG_REG          (COMCERTO_EXP_CONF_BASE + 0x28)
+#define EXP_CS4_SEG_REG          (COMCERTO_EXP_CONF_BASE + 0x2C)
+#define EXP_CS0_CFG_REG		 (COMCERTO_EXP_CONF_BASE + 0x30)
+#define EXP_CS1_CFG_REG		 (COMCERTO_EXP_CONF_BASE + 0x34)
+#define EXP_CS2_CFG_REG		 (COMCERTO_EXP_CONF_BASE + 0x38)
+#define EXP_CS3_CFG_REG		 (COMCERTO_EXP_CONF_BASE + 0x3C)
+#define EXP_CS4_CFG_REG		 (COMCERTO_EXP_CONF_BASE + 0x40)
+#define EXP_CS0_TMG1_REG         (COMCERTO_EXP_CONF_BASE + 0x44)
+#define EXP_CS1_TMG1_REG         (COMCERTO_EXP_CONF_BASE + 0x48)
+#define EXP_CS2_TMG1_REG         (COMCERTO_EXP_CONF_BASE + 0x4C)
+#define EXP_CS3_TMG1_REG         (COMCERTO_EXP_CONF_BASE + 0x50)
+#define EXP_CS4_TMG1_REG         (COMCERTO_EXP_CONF_BASE + 0x54)
+#define EXP_CS0_TMG2_REG         (COMCERTO_EXP_CONF_BASE + 0x58)
+#define EXP_CS1_TMG2_REG         (COMCERTO_EXP_CONF_BASE + 0x5C)
+#define EXP_CS2_TMG2_REG         (COMCERTO_EXP_CONF_BASE + 0x60)
+#define EXP_CS3_TMG2_REG         (COMCERTO_EXP_CONF_BASE + 0x64)
+#define EXP_CS4_TMG2_REG         (COMCERTO_EXP_CONF_BASE + 0x68)
+#define EXP_CS0_TMG3_REG         (COMCERTO_EXP_CONF_BASE + 0x6C)
+#define EXP_CS1_TMG3_REG         (COMCERTO_EXP_CONF_BASE + 0x70)
+#define EXP_CS2_TMG3_REG         (COMCERTO_EXP_CONF_BASE + 0x74)
+#define EXP_CS3_TMG3_REG         (COMCERTO_EXP_CONF_BASE + 0x78)
+#define EXP_CS4_TMG3_REG         (COMCERTO_EXP_CONF_BASE + 0x7C)
+#define EXP_CLOCK_DIV_REG        (COMCERTO_EXP_CONF_BASE + 0x80)
+
+#define EXP_MFSM_REG             (COMCERTO_EXP_CONF_BASE + 0x100)
+#define EXP_CSFSM_REG            (COMCERTO_EXP_CONF_BASE + 0x104)
+#define EXP_WRFSM_REG            (COMCERTO_EXP_CONF_BASE + 0x108)
+#define EXP_RDFSM_REG            (COMCERTO_EXP_CONF_BASE + 0x10C)
+
+#define EXP_SW_RST	 0x00000001
+#define EXP_CLK_EN       0x00000001
+#define EXP_CSBOOT_EN    0x00000002
+#define EXP_CS0_EN       0x00000002
+#define EXP_CS1_EN       0x00000004
+#define EXP_CS2_EN       0x00000008
+#define EXP_CS3_EN       0x00000010
+#define EXP_CS4_EN       0x00000020
+#define EXP_MEM_BUS_8    0x00000000
+#define EXP_MEM_BUS_16   0x00000002
+#define EXP_CS_HIGH      0x00000008
+#define EXP_WE_HIGH      0x00000010
+#define EXP_RE_HIGH      0x00000020
+#define EXP_ALE_MODE     0x00000040
+#define EXP_STRB_MODE    0x00000080
+#define EXP_DM_MODE      0x00000100
+#define EXP_NAND_MODE    0x00000200
+#define EXP_RDY_EN       0x00000400
+#define EXP_RDY_EDGE     0x00000800
+
+#define COMCERTO_NAND_RDY	GPIO_29
+#define COMCERTO_NAND_CE	GPIO_28
+
+#if defined(CONFIG_MACH_COMCERTO_C2K_ASIC) && defined(CONFIG_NAND_TYPE_SLC)
+//SLC NAND on ASIC is 16-bit, and bit[0] of Exp bus is used for data mask
+//hence the ALE and CLE signal is shifted by 1 bit
+#define COMCERTO_NAND_ALE	(BIT_9_MSK << 1)
+#define COMCERTO_NAND_CLE	(BIT_10_MSK << 1)
+#else
+#define COMCERTO_NAND_ALE	BIT_9_MSK
+#define COMCERTO_NAND_CLE	BIT_10_MSK
+#endif
+
+#endif	/* __COMCERTO_EXP_BUS_H__ */
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/arch/arm/include/asm/arch-comcerto/gpio.h u-boot-2013.01.new/arch/arm/include/asm/arch-comcerto/gpio.h
--- u-boot-2013.01/arch/arm/include/asm/arch-comcerto/gpio.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/arch/arm/include/asm/arch-comcerto/gpio.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,101 @@
+/*
+ *  arch/arm/mach-comcerto/include/mach/gpio.h
+ *
+ *  Copyright (C) 2008 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __COMCERTO_GPIO_H__
+#define __COMCERTO_GPIO_H__
+
+/***** GPIO  *****/
+#define COMCERTO_GPIO_OUTPUT_REG			(COMCERTO_APB_GPIO_BASE + 0x00)
+#define COMCERTO_GPIO_OE_REG				(COMCERTO_APB_GPIO_BASE + 0x04)
+#define COMCERTO_GPIO_INT_CFG_REG			(COMCERTO_APB_GPIO_BASE + 0x08)
+#define COMCERTO_GPIO_ARM_UNALIGNED_LOGIC_ENABLE	(COMCERTO_APB_GPIO_BASE + 0x0C)
+#define COMCERTO_GPIO_INPUT_REG				(COMCERTO_APB_GPIO_BASE + 0x10)
+#define COMCERTO_GPIO_APB_WS				(COMCERTO_APB_GPIO_BASE + 0x14)
+#define COMCERTO_GPIO_SYSTEM_CONFIG			(COMCERTO_APB_GPIO_BASE + 0x1C)
+#define COMCERTO_GPIO_MBIST				(COMCERTO_APB_GPIO_BASE + 0x20)
+#define COMCERTO_GPIO_TDM_MUX				(COMCERTO_APB_GPIO_BASE + 0x28)
+#define COMCERTO_GPIO_ARM_ID				(COMCERTO_APB_GPIO_BASE + 0x30)
+#define COMCERTO_GPIO_PAD_CTRL				(COMCERTO_APB_GPIO_BASE + 0x34)
+#define COMCERTO_GPIO_BOOTSTRAP_STATUS			(COMCERTO_APB_GPIO_BASE + 0x40)
+#define COMCERTO_GPIO_BOOTSTRAP_OVERRIDE		(COMCERTO_APB_GPIO_BASE + 0x44)
+#define COMCERTO_GPIO_USB_PHY_BIST_STATUS_REG		(COMCERTO_APB_GPIO_BASE + 0x48)
+#define COMCERTO_GPIO_GENERAL_CONTROL_REG		(COMCERTO_APB_GPIO_BASE + 0x4C)
+#define COMCERTO_GPIO_DEVICE_ID_REG			(COMCERTO_APB_GPIO_BASE + 0x50)
+#define COMCERTO_GPIO_ARM_MEMORY_SENSE_AMP		(COMCERTO_APB_GPIO_BASE + 0x54)
+#define COMCERTO_GPIO_PIN_SELECT_REG			(COMCERTO_APB_GPIO_BASE + 0x58)
+#define COMCERTO_GPIO_MISC_PIN_SELECT_REG		(COMCERTO_APB_GPIO_BASE + 0x60)
+#define COMCERTO_GPIO_PAD_CONFIG0                       (COMCERTO_APB_GPIO_BASE + 0x100)
+#define COMCERTO_GPIO_PAD_CONFIG3                       (COMCERTO_APB_GPIO_BASE + 0x10C)
+#define COMCERTO_GPIO_PAD_CONFIG4                       (COMCERTO_APB_GPIO_BASE + 0x110)
+#define COMCERTO_GPIO_PAD_CONFIG5                       (COMCERTO_APB_GPIO_BASE + 0x114)
+#define COMCERTO_GPIO_MEM_EMA_CONFIG0                       (COMCERTO_APB_GPIO_BASE + 0x1A0)
+#define COMCERTO_GPIO_MEM_EMA_CONFIG1                       (COMCERTO_APB_GPIO_BASE + 0x1A4)
+
+#define GPIO_0		0x00000001
+#define GPIO_1		0x00000002
+#define GPIO_2		0x00000004
+#define GPIO_3		0x00000008
+#define GPIO_4		0x00000010
+#define GPIO_5		0x00000020
+#define GPIO_6	        0x00000040
+#define GPIO_7		0x00000080
+#define GPIO_8		0x00000100
+#define GPIO_9		0x00000200
+#define GPIO_10		0x00000400
+#define GPIO_11		0x00000800
+#define GPIO_12		0x00001000
+#define GPIO_13		0x00002000
+#define GPIO_14		0x00004000
+#define GPIO_15		0x00008000
+#define GPIO_16		0x00010000
+#define GPIO_17		0x00020000
+#define GPIO_18		0x00040000
+#define GPIO_19		0x00080000
+#define GPIO_20		0x00100000
+#define GPIO_21		0x00200000
+#define GPIO_22		0x00400000
+#define GPIO_23		0x00800000
+#define GPIO_24		0x01000000
+#define GPIO_25		0x02000000
+#define GPIO_26		0x04000000
+#define GPIO_27		0x08000000
+#define GPIO_28		0x10000000
+#define GPIO_29		0x20000000
+#define GPIO_30		0x40000000
+#define GPIO_31		0x80000000
+
+
+
+/* Bootstrap configuration bit definitions */
+#define BOOTSTRAP_BOOT_OPT_MASK           0x7
+#define BOOTSTRAP_BOOT_OPT_SHIFT          0
+
+#define BOOTSTRAP_SERDES2_CNF_SGMII	(1 << 10)
+#define BOOTSTRAP_SERDES1_CNF_SATA0	(1 << 11)
+#define BOOTSTRAP_SERDES2_CNF_SATA1	(1 << 12)
+
+
+/* GPIO Pin Select Pins */
+#define EXP_NAND_RDY	GPIO_29
+#define EXP_NAND_CS	GPIO_28
+
+#define DISABLE_FABRIC_REMAP 0x10
+
+#endif
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/arch/arm/include/asm/arch-comcerto/hardware.h u-boot-2013.01.new/arch/arm/include/asm/arch-comcerto/hardware.h
--- u-boot-2013.01/arch/arm/include/asm/arch-comcerto/hardware.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/arch/arm/include/asm/arch-comcerto/hardware.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,31 @@
+/*
+ * arch/arm/include/asm/arch-comcerto/hardware.h
+ *
+ *  Copyright (C) 2013 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+	/***** Device *****/
+	#if defined(CONFIG_COMCERTO_2000)
+		#include <asm/arch/comcerto-2000.h>
+	#else
+		#error "asm/arch/hardware.h :  Unknown architecture"
+	#endif
+
+#endif /* __ASM_ARCH_HARDWARE_H */
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/arch/arm/include/asm/arch-comcerto/ibr_wrapper.h u-boot-2013.01.new/arch/arm/include/asm/arch-comcerto/ibr_wrapper.h
--- u-boot-2013.01/arch/arm/include/asm/arch-comcerto/ibr_wrapper.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/arch/arm/include/asm/arch-comcerto/ibr_wrapper.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,69 @@
+
+typedef enum _retcode
+{
+   RETCODE_OK = 0,
+   RETCODE_ERROR,
+   RETCODE_BAD_PARAMETER,
+   RETCODE_MISMATCH,                /* Security violation. */
+   RETCODE_INVALID_FUSE_SETTING,    /* Security violation. */
+   RETCODE_INVALID_IMAGE_HEADER,    /* Security violation. */
+   RETCODE_RSA_ERROR,               /* Security Violation. */
+   RETCODE_NO_VALID_COPY,
+   RETCODE_HDCP_KEY_LOAD_FAILED,
+   RETCODE_FUSE_PROGRAM_FAILED,
+   RETCODE_OTP_ERR,
+   RETCODE_FAILED,
+   RETCODE_BOOTDEV_UART,
+   RETCODE_BOOTDEV_FLASH,
+   RETCODE_BOOTDEV_INVALID,
+   RETCODE_FLASH_DEVICE_NOT_SUPPORTED,
+   RETCODE_FLASH_BAD_BLOCK,
+   RETCODE_FLASH_UNCORRECTABLE_ERROR,
+   RETCODE_UARTBOOT_ERROR,
+   RETCODE_NOT_SUPPORTED,
+   RETCODE_INVALID_BOOT_DEV,
+   RETCODE_SECURE_BOOT_ENABLE,
+   RETCODE_SECURE_BOOT_DISABLE,
+   RETCODE_YMODEM_HDR_ERROR,
+   RETCODE_YMODEM_PKT_ERROR,
+   RETCODE_YMODEM_DONE_ERROR,
+   RETCODE_PAD_ERROR,
+   RETCODE_ECC_ERR_CORRECTED,
+   RETCODE_ECC_ERR_UNCORRECTABLE,
+   RETCODE_ECC_DATA_ERROR,
+   RETCODE_NAND_BBT_OUT_OF_BOUND
+} retcode;
+
+#define INP32(pReg)		(*(volatile unsigned long *)(pReg))
+#define OUT32(pReg, value)	(*(volatile unsigned long *)(pReg) = (unsigned long)(value))
+
+#define CRYPTO_HASH_SHA1_SIZE            20
+#define CRYPTO_HASH_SHA256_SIZE          32
+#define CRYPTO_HASH_SHA384_SIZE          48
+#define CRYPTO_HASH_SHA512_SIZE          64
+#define CRYPTO_HASH_MD5_SIZE             16
+
+
+#define RSA_KEY_LENGTH_0	0
+#define RSA_KEY_LENGTH_1K	128
+#define RSA_KEY_LENGTH_2K	256
+#define RSA_KEY_LENGTH_4K	512
+
+#define RSA_MAX_KEY_SZ		(RSA_KEY_LENGTH_2K)   /*Bytes*/
+#define RSA_PKCS1_PADDING       1
+
+#define SHA_256_LENGTH		32
+
+extern void ibr_wrapper_init(void);
+extern void ibr_wrapper_spacc_init(void);
+extern int ibr_wrapper_calculate_hash(u8 *buffer, u32 buffer_len, u32 hash_type, u8 *hash, u32 hash_len);
+extern u32 ibr_wrapper_otp_read(u32 s_addr, u8 *read_data, u32 size);
+extern void ibr_wrapper_pka_init(void);
+extern u32 ibr_wrapper_rsa_sig_decrypt(u8 *pub_N, u32 pub_N_len, u8 *sig, u32 siglen, u8 *hash, u32 hash_len, u32 pad_type);
+
+extern u32 ibr_wrapper_secureboot_get_key_length(void);
+extern unsigned int ibr_wrapper_secureboot_get_auth_mode(void);
+extern unsigned int ibr_wrapper_secureboot_is_key_in_header(void);
+extern retcode ibr_wrapper_secureboot_get_hash_key(u8* hash);
+extern retcode ibr_wrapper_secureboot_get_key(u8* key);
+extern retcode ibr_wrapper_secureboot_init(void);
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/arch/arm/include/asm/arch-comcerto/image.h u-boot-2013.01.new/arch/arm/include/asm/arch-comcerto/image.h
--- u-boot-2013.01/arch/arm/include/asm/arch-comcerto/image.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/arch/arm/include/asm/arch-comcerto/image.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,69 @@
+#ifndef _IMAGE_H
+#define _IMAGE_H
+#include "rsa.h"
+
+#define CRC_INIT					0x0
+
+
+/* Structure for Boot Image Header */
+
+typedef enum _hash_algo
+{
+	null_hash=0,
+	sha256,
+	rsa_sha256,
+	aes_rsa_sha256
+} hash_algo;
+
+#define TRUE	1
+#define FALSE	0
+
+#define IMAGE_MAGIC_IDENTIFIER 		0x4D535044 		/* Magic No to identify Header */
+#define IMAGE_HASH_MAX_LENGTH		RSA_KEY_LENGTH_2K       /* when in secure boot */
+								/* Hash length (ie signature) = public key length.*/
+								/* so this field can be 0, 256, 1024,2048,4096 bits */
+#define AES_128_KEY_LENGTH	16 //in bytes
+#define AES_256_KEY_LENGTH	32 //in bytes
+#define AES_KEY_LENGTH_INVALID	0XFFFFFFFF
+#define AES_IV_LENGTH		16 //in bytes
+
+typedef struct _img_hdr
+{
+	u32 magic;		 		/* Magic No to identify Header == 0x4D535044 */
+	u32 timestamp;				/* image creation timestamp in second starting from 01/01/76 */
+	u32 header_crc;				/* 32 bit CRC of Sec Stage Bootloader header */
+	u32 key_length;				/* Length of Public Key 0/1K/2K. Zero means no key */
+	u32 hash_type;				/* Hash Type 0/Sha-256/Rsa-Sha-256.
+						   Zero --  Initialized with all zero [size 32 bytes],
+						   SHA-256 -- SHA-256 hash on the image [size 32 bytes],
+					           RSA-SHA-256 -- RSA encrypted sha-256 hash on the image [size key size].*/
+	u32 image_len;				/* Length of Current Image (excluding header). */
+	/*
+	 * Optional field will be used to store Hash value and Public key and AES key
+	 * Hash value can be of variable length.
+	 * If secure boot is Off the length could be:
+	 * 			0 if image hash computation is not performed
+	 * 			256 bits if Hash is performed with SHA256 algorithm
+	 * if Secure boot is on then the signature (hash value + RSA encryption) length
+	 * is equal to the size of the public key (ie 1024, 2048 or 4096 bits
+	 *
+	 * To make thing easier for the header read function we will require
+	 * for the hash field to always be present. The minimum size will be
+	 * 256 bits (in case of secure boot off) and maximum of 4Kb (in case of secure boot on)
+	 *
+	 * Calculation of the header length is then easier.
+	 * if secure boot on and public key size in header => length = IMAGE_HEADER_SIZE + 2* public key size + aes key size
+	 * if secure boot on and public key size in OTP/eFuse => length = IMAGE_HEADER_SIZE + public key size + aes key size
+	 * if secure boot off => length = IMAGE_HEADER_SIZE + 256 bits
+	 * if image is encrypted then header length = IMAGE_HEADER_SIZE + public key size + AES Key size
+	 *
+	 */
+	u8 optional_field[IMAGE_HASH_MAX_LENGTH + RSA_KEY_LENGTH_2K + AES_256_KEY_LENGTH];
+} img_hdr;
+
+/* We exclude hash and key length here. Total length will be computed in the read_image_header function. */
+#define IMAGE_HEADER_SIZE ((u32) &(((struct _img_hdr *)0)->optional_field))
+
+void * verify_and_authenticate_boot_image(u8 *image_buf);
+
+#endif /* _IMAGE_H */
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/arch/arm/include/asm/arch-comcerto/otp.h u-boot-2013.01.new/arch/arm/include/asm/arch-comcerto/otp.h
--- u-boot-2013.01/arch/arm/include/asm/arch-comcerto/otp.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/arch/arm/include/asm/arch-comcerto/otp.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,40 @@
+#ifndef _OTP_H_
+#define _OTP_H_
+
+#define	OTP_DELAY	1000
+
+// 8K bits
+#define	OTP_SIZE	8 * 1024
+
+#define DOUT_COUNTER_VALUE		0x1F
+
+#define OTP_CONFIG_LOCK_0       (COMCERTO_OTP_BASE + 0x00)
+#define OTP_CONFIG_LOCK_1       (COMCERTO_OTP_BASE + 0x04)
+#define OTP_CEB_SEQUENCE_LOCKS  (COMCERTO_OTP_BASE + 0x08)
+#define OTP_CEB_INPUT           (COMCERTO_OTP_BASE + 0x0C)
+#define OTP_RSTB_INPUT          (COMCERTO_OTP_BASE + 0x10)
+#define OTP_ADDR_INPUT          (COMCERTO_OTP_BASE + 0x14)
+#define OTP_READEN_INPUT        (COMCERTO_OTP_BASE + 0x18)
+#define OTP_DATA_INPUT          (COMCERTO_OTP_BASE + 0x1C)
+#define OTP_DLE_INPUT           (COMCERTO_OTP_BASE + 0x20)
+#define OTP_WEB_INPUT           (COMCERTO_OTP_BASE + 0x24)
+#define OTP_WEB_COUNTER         (COMCERTO_OTP_BASE + 0x28)
+#define OTP_PGMEN_INPUT         (COMCERTO_OTP_BASE + 0x2C)
+#define OTP_PGM2CPUMP_COUNTER   (COMCERTO_OTP_BASE + 0x30)
+#define OTP_CPUMPEN_INPUT       (COMCERTO_OTP_BASE + 0x34)
+#define OTP_CPUMP2WEB_COUNTER   (COMCERTO_OTP_BASE + 0x38)
+#define OTP_WEB2CPUMP_COUNTER   (COMCERTO_OTP_BASE + 0x3C)
+#define OTP_CPUMP2PGM_COUNTER   (COMCERTO_OTP_BASE + 0x40)
+#define OTP_CLE_INPUT           (COMCERTO_OTP_BASE + 0x44)
+#define OTP_SECURE_LOCK_OUTPUT  (COMCERTO_OTP_BASE + 0x48)
+#define OTP_DATA_OUT_COUNTER    (COMCERTO_OTP_BASE + 0x4C)
+#define OTP_DATA_OUTPUT         (COMCERTO_OTP_BASE + 0x50)
+#define OTP_HW_SEC_MODE_STATUS  (COMCERTO_OTP_BASE + 0x54)
+
+void otp_wr(u32 s_addr, u8 *prog_data) ;
+
+int otp_read(u32 s_addr, u8 *read_data, int size) ;
+int otp_write(u32 offset, u8 *prog_data, int size);
+
+#endif
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/arch/arm/include/asm/arch-comcerto/rsa.h u-boot-2013.01.new/arch/arm/include/asm/arch-comcerto/rsa.h
--- u-boot-2013.01/arch/arm/include/asm/arch-comcerto/rsa.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/arch/arm/include/asm/arch-comcerto/rsa.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,17 @@
+
+#ifndef _IBR_RSA_H_
+#define _IBR_RSA_H_
+
+#define RSA_DFL_E_VAL		(0x00010001)
+
+#define RSA_KEY_LENGTH_INVALID	0xFFFFFFFF
+#define RSA_KEY_LENGTH_0	0
+#define RSA_KEY_LENGTH_1K	128
+#define RSA_KEY_LENGTH_2K	256
+#define RSA_KEY_LENGTH_4K	512
+#define SHA_256_LENGTH		32
+
+#define RSA_MAX_KEY_SZ		(RSA_KEY_LENGTH_2K)   /*Bytes*/
+#define RSA_PKCS1_PADDING       1
+
+#endif
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/arch/arm/include/asm/arch-comcerto/secureboot.h u-boot-2013.01.new/arch/arm/include/asm/arch-comcerto/secureboot.h
--- u-boot-2013.01/arch/arm/include/asm/arch-comcerto/secureboot.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/arch/arm/include/asm/arch-comcerto/secureboot.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,14 @@
+#ifndef _SECUREBOOT_H_
+#define _SECUREBOOT_H_
+
+#define BIT_5_MSK	0x00000020
+#define SEC_CONFIG_AES_KEY_SIZE		BIT_5_MSK
+
+#define SECURE_CONFIG_OFFSET_BYTE_0		0
+#define SECURE_CONFIG_OFFSET_BYTE_1		8
+#define SECURE_CONFIG_SIZE_IN_BYTES		1
+
+u32 secureboot_get_aes_key_length(void);
+u8 secureboot_get_aes_key(u8* key, u32 key_length);
+#endif
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/arch/arm/include/asm/arch-comcerto/spacc.h u-boot-2013.01.new/arch/arm/include/asm/arch-comcerto/spacc.h
--- u-boot-2013.01/arch/arm/include/asm/arch-comcerto/spacc.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/arch/arm/include/asm/arch-comcerto/spacc.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,202 @@
+
+#ifndef _IBR_SPACC_H_
+#define _IBR_SPACC_H_
+
+#include "secureboot.h"
+
+#define TIME_OUT_LOOPS		10000
+
+
+/* 
+ * SPAcc Register Offsets
+ */
+#define SPACC_PDU_BASEADDR      0x9B000000 /* 16MB */
+#define SPACC_BASEADDR          (SPACC_PDU_BASEADDR + 0x00040000)       /* 512KB */ /* Need To check Makarand */
+
+#define SPACC_REG_IRQ_EN        (0x00000 + SPACC_BASEADDR)
+#define SPACC_REG_IRQ_STAT      (0x00004 + SPACC_BASEADDR)
+#define SPACC_REG_IRQ_CTRL      (0x00008 + SPACC_BASEADDR)
+#define SPACC_REG_FIFO_STAT     (0x0000C + SPACC_BASEADDR)
+#define SPACC_REG_SDMA_BRST_SZ  (0x00010 + SPACC_BASEADDR)
+#define SPACC_REG_SRC_PTR       (0x00020 + SPACC_BASEADDR)
+#define SPACC_REG_DST_PTR       (0x00024 + SPACC_BASEADDR)
+#define SPACC_REG_OFFSET        (0x00028 + SPACC_BASEADDR)
+#define SPACC_REG_PRE_AAD_LEN   (0x0002c + SPACC_BASEADDR)
+#define SPACC_REG_POST_AAD_LEN  (0x00030 + SPACC_BASEADDR)
+#define SPACC_REG_PROC_LEN      (0x00034 + SPACC_BASEADDR)
+#define SPACC_REG_ICV_LEN       (0x00038 + SPACC_BASEADDR)
+#define SPACC_REG_ICV_OFFSET    (0x0003C + SPACC_BASEADDR)
+#define SPACC_REG_IV_OFFSET     (0x00040 + SPACC_BASEADDR)
+#define SPACC_REG_SW_CTRL       (0x00044 + SPACC_BASEADDR)
+#define SPACC_REG_AUX_INFO      (0x00048 + SPACC_BASEADDR)
+#define SPACC_REG_CTRL          (0x0004C + SPACC_BASEADDR)
+#define SPACC_REG_STAT_POP      (0x00050 + SPACC_BASEADDR)
+#define SPACC_REG_STATUS        (0x00054 + SPACC_BASEADDR)
+#define SPACC_REG_KEY_SZ        (0x00100 + SPACC_BASEADDR)
+#define SPACC_ADDR_CIPH_KEY     (0x04000 + SPACC_BASEADDR)
+#define SPACC_ADDR_HASH_KEY     (0x08000 + SPACC_BASEADDR)
+#define SPACC_ADDR_RC4_CTX      (0x20000 + SPACC_BASEADDR)
+
+#define MAX_SEC_BOOT_IMG_LEN	0x400000
+
+#define pMSG_ADDR_WIDTH         18
+#define SPACC_MAX_PROC_SIZE     ((1 << pMSG_ADDR_WIDTH)- 0x1000)
+
+/*********** CTRL Bitmasks ***********/
+#define _SPACC_CTRL_ENCRYPT         24
+#define _SPACC_CTRL_AAD_COPY        25
+#define _SPACC_CTRL_ICV_PT          26
+#define _SPACC_CTRL_ICV_ENC         27
+#define _SPACC_CTRL_ICV_APPEND      28
+#define _SPACC_CTRL_KEY_EXP         29
+#define _SPACC_CTRL_CTX_IDX         16
+
+#define _SPACC_CTRL_CIPH_ALG       0
+#define _SPACC_CTRL_HASH_ALG       4
+#define _SPACC_CTRL_CIPH_MODE      8
+#define _SPACC_CTRL_HASH_MODE      12
+#define _SPACC_CTRL_MSG_BEGIN      14
+#define _SPACC_CTRL_MSG_END        15
+#define _SPACC_CTRL_CTX_IDX        16
+
+/********* STAT_POP Bitmasks *********/
+
+#define _SPACC_STAT_POP_POP         0
+
+#define SPACC_STAT_POP_POP         (1 << _SPACC_STAT_POP_POP)
+
+/********** STATUS Bitmasks **********/
+
+#define _SPACC_STATUS_SW_ID        0
+#define _SPACC_STATUS_RET_CODE     24
+#define SPACC_GET_STATUS_RET_CODE(s)          (((s)>>_SPACC_STATUS_RET_CODE)&0x7)
+
+/********** KEY_SZ Bitmasks **********/
+
+#define _SPACC_KEY_SZ_SIZE		0
+#define _SPACC_KEY_SZ_CTX_IDX		8
+#define _SPACC_KEY_SZ_CIPHER		31
+
+#define SPACC_KEY_SZ_CIPHER        (1 << _SPACC_KEY_SZ_CIPHER)
+
+
+#define SPACC_SET_CIPHER_KEY_SZ(z,ctx)         (((z) & 0x7F) | (1UL << _SPACC_KEY_SZ_CIPHER) | ((ctx) << _SPACC_KEY_SZ_CTX_IDX))
+#define SPACC_SET_HASH_KEY_SZ(z,ctx)           (((z) & 0x7F) | ((ctx) << _SPACC_KEY_SZ_CTX_IDX))
+
+
+#if defined (BUILD_C2K_EMU)
+#define _SPACC_FIFO_STAT_CMD_CNT     0
+#define _SPACC_FIFO_STAT_CMD_FULL    7
+#define _SPACC_FIFO_STAT_CMD0_CNT   _SPACC_FIFO_STAT_CMD_CNT
+#define _SPACC_FIFO_STAT_CMD0_FULL  _SPACC_FIFO_STAT_CMD_FULL
+#define _SPACC_FIFO_STAT_CMD1_CNT    8
+#define _SPACC_FIFO_STAT_CMD1_FULL  15
+#define _SPACC_FIFO_STAT_CMD2_CNT   16
+#define _SPACC_FIFO_STAT_CMD2_FULL  23
+#define _SPACC_FIFO_STAT_STAT_CNT   24
+#define _SPACC_FIFO_STAT_STAT_EMPTY 31
+#else
+#define _SPACC_FIFO_STAT_CMD_CNT    0
+#define _SPACC_FIFO_STAT_CMD_FULL   15
+#define _SPACC_FIFO_STAT_STAT_CNT   16
+#define _SPACC_FIFO_STAT_STAT_EMPTY 31
+#endif
+
+
+#define CTRL_SET_CIPH_ALG(a)    ((a) << _SPACC_CTRL_CIPH_ALG)
+#define CTRL_SET_CIPH_MODE(a)   ((a) << _SPACC_CTRL_CIPH_MODE)
+#define CTRL_SET_HASH_ALG(a)    ((a) << _SPACC_CTRL_HASH_ALG)
+#define CTRL_SET_HASH_MODE(a)   ((a) << _SPACC_CTRL_HASH_MODE)
+#define CTRL_SET_ENCRYPT        (1U << _SPACC_CTRL_ENCRYPT)
+#define CTRL_SET_AAD_COPY       (1U << _SPACC_CTRL_AAD_COPY)
+#define CTRL_SET_ICV_PT         (1U << _SPACC_CTRL_ICV_PT)
+#define CTRL_SET_ICV_ENC        (1U << _SPACC_CTRL_ICV_ENC)
+#define CTRL_SET_ICV_APPEND     (1U << _SPACC_CTRL_ICV_APPEND)
+#define CTRL_SET_KEY_EXP        (1U << _SPACC_CTRL_KEY_EXP)
+#define CTRL_SET_MSG_BEGIN      (1U << _SPACC_CTRL_MSG_BEGIN)
+#define CTRL_SET_MSG_END        (1U << _SPACC_CTRL_MSG_END)
+#define CTRL_SET_CTX_IDX(a)     ((a) << _SPACC_CTRL_CTX_IDX)
+
+#define SPACC_FIFO_STAT_CMD_FULL   (1 << _SPACC_FIFO_STAT_CMD_FULL)
+#define SPACC_FIFO_STAT_STAT_EMPTY (1 << _SPACC_FIFO_STAT_STAT_EMPTY)
+//#define SPACC_IS_FIFO_STAT_CMD_FULL(f) ((f) >> _SPACC_FIFO_STAT_CMD_FULL) & 0x01)
+#define SPACC_GET_FIFO_STAT_CMD_CNT(f)   (((f)>>_SPACC_FIFO_STAT_CMD_CNT)&0x7f)
+#define SPACC_GET_FIFO_STAT_CNT(f)       (((f)>>_SPACC_FIFO_STAT_STAT_CNT)&0x7f)
+#define SPACC_GET_FIFO_STAT_EMPTY(a)    (((a) >> _SPACC_FIFO_STAT_STAT_EMPTY) & 0x01)
+
+#define SPACC_MAX_PARTICLE_SIZE     65536
+#define MAX_DDT_ENTRIES 10+1 /*good enough for 512kb buffer */
+//Hash types
+
+enum ecipher
+{
+  C_NULL   = 0,
+  C_DES    = 1,
+  C_AES    = 2,
+
+  C_MAX
+};
+
+enum eciphermode
+{
+  CM_ECB = 0,
+  CM_CBC = 1,
+  CM_CTR = 2,
+  CM_CCM = 3,
+  CM_GCM = 5,
+  CM_OFB = 7,
+  CM_CFB = 8,
+  CM_F8  = 9,
+  CM_XTS = 10,
+
+  CM_MAX
+};
+
+enum ehash
+{
+  H_NULL   = 0,
+  H_MD5    = 1,
+  H_SHA1   = 2,
+  H_SHA224 = 3,
+  H_SHA256 = 4,
+  H_SHA384 = 5,
+  H_SHA512 = 6,
+  H_XCBC   = 7,
+  H_CMAC   = 8,
+  H_KF9    = 9,
+
+  H_MAX
+};
+enum ehashmode
+{
+  HM_RAW    = 0,
+  HM_SSLMAC = 1,
+  HM_HMAC   = 2,
+
+  HM_MAX
+};
+
+enum spacc_ret_code
+{
+  SPACC_OK = 0,
+  SPACC_ICVFAIL,
+  SPACC_MEMERR,
+  SPACC_BLOCKERR,
+};
+
+
+#define CRYPTO_HASH_SHA1_SIZE            20
+#define CRYPTO_HASH_SHA256_SIZE          32
+#define CRYPTO_HASH_SHA384_SIZE          48
+#define CRYPTO_HASH_SHA512_SIZE          64
+#define CRYPTO_HASH_MD5_SIZE             16
+
+typedef struct ddt_entry_
+{
+   u32 ptr;
+   u32 len;
+} ddt_entry;
+
+int calculate_hash_bigsize(u8 *buffer, u32 buffer_len, u32 hash_type, u8 *hash, u32 hash_len);
+int spacc_decrypt(u8 *buffer, u32 buffer_len, u32 ciph_algo, u32 ciph_mode, u8 *ciph_key, u32 key_len, u8 *iv, u8 *dst_buffer, u8 is_first_pkt);
+#endif
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/board/mindspeed/c2kasic/board.c u-boot-2013.01.new/board/mindspeed/c2kasic/board.c
--- u-boot-2013.01/board/mindspeed/c2kasic/board.c	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/board/mindspeed/c2kasic/board.c	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,170 @@
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/exp-bus.h>
+#include <asm/arch/clkcore.h>
+#include <asm/arch/comcerto-common.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+void nor_hw_init(void)
+{
+	//CS0 EXP bus Timing tune. It reduces the time to flash NOR
+	writel(0x03034007, EXP_CS0_TMG1_REG);
+	writel(0x04040502, EXP_CS0_TMG2_REG);
+}
+
+#ifdef CONFIG_NAND_COMCERTO
+void nand_hw_init(void)
+{
+	comcerto_gpio_enable_output(EXP_NAND_CS); /* NAND CE */
+	comcerto_gpio_enable_input(EXP_NAND_RDY); /* NAND BR */
+}
+#endif
+
+static void exp_bus_init(void)
+{
+	//Exp bus soft reset
+	writel (0x1, EXP_SWRST_REG);
+	while(readl(EXP_SWRST_REG) & 0x1);
+
+	//16-bit NOR bus is used on C2K ASIC board
+	writel(((0x1) << 1), EXP_CS0_CFG_REG);
+
+	/* IBR, when booting from NOR, is changing expansion bus CS0 Mem Segment size to 1MiB
+	instead of the default reset value of 128MiB. Put back the reset default value */
+	writel(EXP_CS0_SEG_END_VAL, EXP_CS0_SEG_REG);
+
+	writel(EXP_CS1_BASE_VAL, EXP_CS1_BASE_REG);
+	writel(EXP_CS1_SEG_END_VAL, EXP_CS1_SEG_REG);
+
+	writel(EXP_CS2_BASE_VAL, EXP_CS2_BASE_REG);
+	writel(EXP_CS2_SEG_END_VAL, EXP_CS2_SEG_REG);
+
+	writel(EXP_CS3_BASE_VAL, EXP_CS3_BASE_REG);
+	writel(EXP_CS3_SEG_END_VAL, EXP_CS3_SEG_REG);
+
+#ifdef CONFIG_NAND_COMCERTO
+	writel(EXP_CS4_BASE_VAL, EXP_CS4_BASE_REG);
+	writel(EXP_CS4_SEG_END_VAL, EXP_CS4_SEG_REG);
+#ifdef CONFIG_NAND_TYPE_SLC
+        //SLC NAND on ASIC is 16-bit. Enable 16-bit bus
+        writel(readl(EXP_CS4_CFG_REG) | 0x2, EXP_CS4_CFG_REG);
+#else
+        //MLC NAND on ASIC is 8-bit. Enable 8-bit bus
+        writel((readl(EXP_CS4_CFG_REG) & (~0x6)), EXP_CS4_CFG_REG);
+#endif /* CONFIG_NAND_TYPE_SLC */
+#endif /* CONFIG_NAND_COMCERTO */
+
+}
+
+void s_init(void)
+{
+	int val;
+
+#ifdef CONFIG_COMCERTO_PLL
+	SoC_PLL_init();
+
+	/* Populate Part Number Info for Linux */
+	*((unsigned int *) IRAM_C2K_PART_NO_LOCATION) = *((unsigned int *)(COMCERTO_AXI_IRAM_BASE+0x30));
+#endif
+
+	comcerto_pad_config();
+
+	//DDRC ODT Source Select
+	*(volatile u32*) COMCERTO_GPIO_MISC_PIN_SELECT_REG = ( (1 << 6) | (*(volatile u32*) COMCERTO_GPIO_MISC_PIN_SELECT_REG));
+
+#ifdef CONFIG_COMCERTO_DDR
+	/*Double reset HFE helps some times */
+        val = readl(AXI_RESET_1);
+	writel((val | HFE_AXI_RESET), AXI_RESET_1);
+        writel((val & ~(HFE_AXI_RESET)), AXI_RESET_1);
+
+	SoC_DDR_init();
+        /* Disable remapping so that lower address space is mapped to DDR space */
+	writel((DISABLE_FABRIC_REMAP | readl(COMCERTO_GPIO_PAD_CTRL)), COMCERTO_GPIO_PAD_CTRL);
+
+#ifdef CONFIG_COMCERTO_DDR_ECC
+	writel(0x10000, DDRC_CTL_32_REG);
+	writel(0x10000, DDRC_CTL_33_REG);
+	writel(0x1f0023, DDR_PHY_CTL_00_REG);
+	ddr_ecc_init();
+	writel(0x30000, DDRC_CTL_32_REG);
+	writel(0x0, DDRC_CTL_33_REG);
+#endif	/* CONFIG_COMCERTO_DDR_ECC */
+#endif	/* CONFIG_COMCERTO_DDR */
+
+	exp_bus_init();
+
+	nor_hw_init();
+
+	/* External reset to PCIe devices, Atheros Switch and FXS block, GPIO27 is used for TM_EXT_RESET*/
+	/*It seems some pcie wifi card has problem with the way external reset was being
+	  done (reset line high/delay/low/delay/high sequence) earlier. Instead simple
+	  reset pulse works for fine for these card and all the cards and it includes atheros
+	  switch*/
+	writel(readl(COMCERTO_GPIO_OUTPUT_REG) & ~GPIO_27, COMCERTO_GPIO_OUTPUT_REG);
+	writel(readl(COMCERTO_GPIO_OE_REG) | GPIO_27, COMCERTO_GPIO_OE_REG);
+	writel(readl(COMCERTO_GPIO_OUTPUT_REG) | GPIO_27, COMCERTO_GPIO_OUTPUT_REG);
+
+#ifdef CONFIG_NAND_COMCERTO
+	nand_hw_init();
+#endif
+}
+
+int c2000_eth_board_init(char *devname, int eth_port)
+{
+	//eth0 port is chosen as criteria for bringingup out of reset because
+	//all MDIO access can happen through EMAC0 and without bringing eth0 first
+	//no PHY configuration can happen and no point in removing reset without eth0
+	if(eth_port != 0)
+		return 0;
+
+	printf("%s: Bringing PHY out of reset\n",__func__);
+	//Bring all PHYs out of reset. The correct way is to assert, deassert and re-assert the GPIO reset signal
+	//with delay in between
+        writel(readl(COMCERTO_GPIO_OE_REG) | GPIO_3, COMCERTO_GPIO_OE_REG);
+
+	writel(readl(COMCERTO_GPIO_OUTPUT_REG) | GPIO_3, COMCERTO_GPIO_OUTPUT_REG);
+        udelay(100000);
+	writel(readl(COMCERTO_GPIO_OUTPUT_REG) & ~GPIO_3, COMCERTO_GPIO_OUTPUT_REG);
+        udelay(100000);
+	writel(readl(COMCERTO_GPIO_OUTPUT_REG) | GPIO_3, COMCERTO_GPIO_OUTPUT_REG);
+        udelay(100000);
+
+}
+
+#if defined(CONFIG_SHOW_BOOT_PROGRESS)
+void show_boot_progress(int progress)
+{
+	printf("Boot reached stage %d\n", progress);
+}
+#endif /* CONFIG_SHOW_BOOT_PROGRESS */
+
+int dram_init(void)
+{
+        gd->bd->bi_dram[0].start = CONFIG_SYS_SDRAM_BASE;
+        gd->bd->bi_dram[0].size = CONFIG_SYS_SDRAM_SIZE; //512 MB
+	gd->ram_size = get_ram_size((void *) CONFIG_SYS_SDRAM_BASE,
+			CONFIG_SYS_SDRAM_SIZE);
+	return 0;
+
+}
+
+int board_init(void)
+{
+        /* arch number of Mindspeed Comcerto */
+        gd->bd->bi_arch_number = MACH_TYPE_COMCERTO;
+
+        /* adress of boot parameters */
+        gd->bd->bi_boot_params = CONFIG_SYS_SDRAM_BASE + 0x100;
+
+        return 0;
+}
+
+int HAL_get_c2k_revision()
+{
+        return (readl(COMCERTO_GPIO_DEVICE_ID_REG) >> 24) & 0xF;
+}
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/board/mindspeed/c2kasic/Makefile u-boot-2013.01.new/board/mindspeed/c2kasic/Makefile
--- u-boot-2013.01/board/mindspeed/c2kasic/Makefile	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/board/mindspeed/c2kasic/Makefile	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,56 @@
+#
+# (C) Copyright 2006
+# Mindspeed Technologies, Inc. <www.mindspeed.com>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#
+
+include $(TOPDIR)/config.mk
+ifneq ($(OBJTREE),$(SRCTREE))
+$(shell mkdir -p $(obj)../common)
+endif
+
+LIB	= $(obj)lib$(BOARD).o
+
+COBJS	:= board.o
+
+gcclibdir := $(shell dirname `$(CC) -print-libgcc-file-name`)
+
+HOST_CFLAGS = -Wall -pedantic -I$(TOPDIR)/include
+
+OBJS    := $(addprefix $(obj),$(COBJS))
+
+all:	$(LIB)
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+board.o: board.c
+	$(CC) $(CFLAGS) -fpic -c -o $@ $<
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/board/mindspeed/c2kevm/board.c u-boot-2013.01.new/board/mindspeed/c2kevm/board.c
--- u-boot-2013.01/board/mindspeed/c2kevm/board.c	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/board/mindspeed/c2kevm/board.c	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,164 @@
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/exp-bus.h>
+#include <asm/arch/clkcore.h>
+#include <asm/arch/comcerto-common.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+void nor_hw_init(void)
+{
+	//CS0 EXP bus Timing tune. It reduces the time to flash NOR
+	writel(0x03034007, EXP_CS0_TMG1_REG);
+	writel(0x04040502, EXP_CS0_TMG2_REG);
+}
+
+#ifdef CONFIG_NAND_COMCERTO
+void nand_hw_init(void)
+{
+	comcerto_gpio_enable_output(EXP_NAND_CS); /* NAND CE */
+	comcerto_gpio_enable_input(EXP_NAND_RDY); /* NAND BR */
+}
+#endif
+
+static void exp_bus_init(void)
+{
+	//Exp bus soft reset
+	writel (0x1, EXP_SWRST_REG);
+	while(readl(EXP_SWRST_REG) & 0x1);
+
+	//16-bit NOR bus is used on C2K ASIC board
+	writel(((0x1) << 1), EXP_CS0_CFG_REG);
+
+	/* IBR, when booting from NOR, is changing expansion bus CS0 Mem Segment size to 1MiB
+	instead of the default reset value of 128MiB. Put back the reset default value */
+	writel(EXP_CS0_SEG_END_VAL, EXP_CS0_SEG_REG);
+
+	writel(EXP_CS1_BASE_VAL, EXP_CS1_BASE_REG);
+	writel(EXP_CS1_SEG_END_VAL, EXP_CS1_SEG_REG);
+
+	writel(EXP_CS2_BASE_VAL, EXP_CS2_BASE_REG);
+	writel(EXP_CS2_SEG_END_VAL, EXP_CS2_SEG_REG);
+
+	writel(EXP_CS3_BASE_VAL, EXP_CS3_BASE_REG);
+	writel(EXP_CS3_SEG_END_VAL, EXP_CS3_SEG_REG);
+
+#ifdef CONFIG_NAND_COMCERTO
+	writel(EXP_CS4_BASE_VAL, EXP_CS4_BASE_REG);
+	writel(EXP_CS4_SEG_END_VAL, EXP_CS4_SEG_REG);
+        //MLC NAND on EVM is 8-bit. Enable 8-bit bus
+        writel((readl(EXP_CS4_CFG_REG) & (~0x6)), EXP_CS4_CFG_REG);
+#endif /* CONFIG_NAND_COMCERTO */
+
+}
+
+void s_init(void)
+{
+	int val;
+
+#ifdef CONFIG_COMCERTO_PLL
+	SoC_PLL_init();
+
+	/* Populate Part Number Info for Linux */
+	*((unsigned int *) IRAM_C2K_PART_NO_LOCATION) = *((unsigned int *)(COMCERTO_AXI_IRAM_BASE+0x30));
+#endif
+
+	comcerto_pad_config();
+
+	//DDRC ODT Source Select
+	*(volatile u32*) COMCERTO_GPIO_MISC_PIN_SELECT_REG = ( (1 << 6) | (*(volatile u32*) COMCERTO_GPIO_MISC_PIN_SELECT_REG));
+
+#ifdef CONFIG_COMCERTO_DDR
+	/*Double reset HFE helps some times */
+        val = readl(AXI_RESET_1);
+	writel((val | HFE_AXI_RESET), AXI_RESET_1);
+        writel((val & ~(HFE_AXI_RESET)), AXI_RESET_1);
+
+	SoC_DDR_init();
+        /* Disable remapping so that lower address space is mapped to DDR space */
+	writel((DISABLE_FABRIC_REMAP | readl(COMCERTO_GPIO_PAD_CTRL)), COMCERTO_GPIO_PAD_CTRL);
+
+#ifdef CONFIG_COMCERTO_DDR_ECC
+	writel(0x10000, DDRC_CTL_32_REG);
+	writel(0x10000, DDRC_CTL_33_REG);
+	writel(0x1f0023, DDR_PHY_CTL_00_REG);
+	ddr_ecc_init();
+	writel(0x30000, DDRC_CTL_32_REG);
+	writel(0x0, DDRC_CTL_33_REG);
+#endif	/* CONFIG_COMCERTO_DDR_ECC */
+#endif	/* CONFIG_COMCERTO_DDR */
+
+	exp_bus_init();
+
+	nor_hw_init();
+
+	/* External reset to PCIe devices, Atheros Switch and FXS block, GPIO27 is used for TM_EXT_RESET*/
+	/*It seems some pcie wifi card has problem with the way external reset was being
+	  done (reset line high/delay/low/delay/high sequence) earlier. Instead simple
+	  reset pulse works for fine for these card and all the cards and it includes atheros
+	  switch*/
+	writel(readl(COMCERTO_GPIO_OUTPUT_REG) & ~GPIO_27, COMCERTO_GPIO_OUTPUT_REG);
+	writel(readl(COMCERTO_GPIO_OE_REG) | GPIO_27, COMCERTO_GPIO_OE_REG);
+	writel(readl(COMCERTO_GPIO_OUTPUT_REG) | GPIO_27, COMCERTO_GPIO_OUTPUT_REG);
+
+#ifdef CONFIG_NAND_COMCERTO
+	nand_hw_init();
+#endif
+}
+
+int c2000_eth_board_init(char *devname, int eth_port)
+{
+        //eth0 port is chosen as criteria for bringingup out of reset because
+        //all MDIO access can happen through EMAC0 and without bringing eth0 first
+        //no Switch/PHY configuration can happen and no point in removing reset without eth0
+        if(eth_port == 0)
+        {
+                //AR8327 Switch init
+                athrs17_init(devname);
+
+                //AR8327 WAN PHY4 init
+                athrs17_phy_setup(devname,EMAC0_PHY_ADDR);
+        }
+        else
+        {
+                //AR8327 LAN PHYs init
+                athrs17_phy_setup(devname,EMAC1_PHY_ADDR);
+        }
+
+}
+
+#if defined(CONFIG_SHOW_BOOT_PROGRESS)
+void show_boot_progress(int progress)
+{
+	printf("Boot reached stage %d\n", progress);
+}
+#endif /* CONFIG_SHOW_BOOT_PROGRESS */
+
+int dram_init(void)
+{
+        gd->bd->bi_dram[0].start = CONFIG_SYS_SDRAM_BASE;
+        gd->bd->bi_dram[0].size = CONFIG_SYS_SDRAM_SIZE; //512 MB
+	gd->ram_size = get_ram_size((void *) CONFIG_SYS_SDRAM_BASE,
+			CONFIG_SYS_SDRAM_SIZE);
+	return 0;
+
+}
+
+int board_init(void)
+{
+        /* arch number of Mindspeed Comcerto */
+        gd->bd->bi_arch_number = MACH_TYPE_COMCERTO;
+
+        /* adress of boot parameters */
+        gd->bd->bi_boot_params = CONFIG_SYS_SDRAM_BASE + 0x100;
+
+        return 0;
+}
+
+int HAL_get_c2k_revision()
+{
+        return (readl(COMCERTO_GPIO_DEVICE_ID_REG) >> 24) & 0xF;
+}
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/board/mindspeed/c2kevm/Makefile u-boot-2013.01.new/board/mindspeed/c2kevm/Makefile
--- u-boot-2013.01/board/mindspeed/c2kevm/Makefile	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/board/mindspeed/c2kevm/Makefile	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,56 @@
+#
+# (C) Copyright 2006
+# Mindspeed Technologies, Inc. <www.mindspeed.com>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#
+
+include $(TOPDIR)/config.mk
+ifneq ($(OBJTREE),$(SRCTREE))
+$(shell mkdir -p $(obj)../common)
+endif
+
+LIB	= $(obj)lib$(BOARD).o
+
+COBJS	:= board.o
+
+gcclibdir := $(shell dirname `$(CC) -print-libgcc-file-name`)
+
+HOST_CFLAGS = -Wall -pedantic -I$(TOPDIR)/include
+
+OBJS    := $(addprefix $(obj),$(COBJS))
+
+all:	$(LIB)
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+board.o: board.c
+	$(CC) $(CFLAGS) -fpic -c -o $@ $<
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/board/mindspeed/c2kmfcnevm/board.c u-boot-2013.01.new/board/mindspeed/c2kmfcnevm/board.c
--- u-boot-2013.01/board/mindspeed/c2kmfcnevm/board.c	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/board/mindspeed/c2kmfcnevm/board.c	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,164 @@
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/exp-bus.h>
+#include <asm/arch/clkcore.h>
+#include <asm/arch/comcerto-common.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+void nor_hw_init(void)
+{
+	//CS0 EXP bus Timing tune. It reduces the time to flash NOR
+	writel(0x03034007, EXP_CS0_TMG1_REG);
+	writel(0x04040502, EXP_CS0_TMG2_REG);
+}
+
+#ifdef CONFIG_NAND_COMCERTO
+void nand_hw_init(void)
+{
+	comcerto_gpio_enable_output(EXP_NAND_CS); /* NAND CE */
+	comcerto_gpio_enable_input(EXP_NAND_RDY); /* NAND BR */
+}
+#endif
+
+static void exp_bus_init(void)
+{
+	//Exp bus soft reset
+	writel (0x1, EXP_SWRST_REG);
+	while(readl(EXP_SWRST_REG) & 0x1);
+
+	//16-bit NOR bus is used on C2K ASIC board
+	writel(((0x1) << 1), EXP_CS0_CFG_REG);
+
+	/* IBR, when booting from NOR, is changing expansion bus CS0 Mem Segment size to 1MiB
+	instead of the default reset value of 128MiB. Put back the reset default value */
+	writel(EXP_CS0_SEG_END_VAL, EXP_CS0_SEG_REG);
+
+	writel(EXP_CS1_BASE_VAL, EXP_CS1_BASE_REG);
+	writel(EXP_CS1_SEG_END_VAL, EXP_CS1_SEG_REG);
+
+	writel(EXP_CS2_BASE_VAL, EXP_CS2_BASE_REG);
+	writel(EXP_CS2_SEG_END_VAL, EXP_CS2_SEG_REG);
+
+	writel(EXP_CS3_BASE_VAL, EXP_CS3_BASE_REG);
+	writel(EXP_CS3_SEG_END_VAL, EXP_CS3_SEG_REG);
+
+#ifdef CONFIG_NAND_COMCERTO
+	writel(EXP_CS4_BASE_VAL, EXP_CS4_BASE_REG);
+	writel(EXP_CS4_SEG_END_VAL, EXP_CS4_SEG_REG);
+        //MLC NAND on EVM is 8-bit. Enable 8-bit bus
+        writel((readl(EXP_CS4_CFG_REG) & (~0x6)), EXP_CS4_CFG_REG);
+#endif /* CONFIG_NAND_COMCERTO */
+
+}
+
+void s_init(void)
+{
+	int val;
+
+#ifdef CONFIG_COMCERTO_PLL
+	SoC_PLL_init();
+
+	/* Populate Part Number Info for Linux */
+	*((unsigned int *) IRAM_C2K_PART_NO_LOCATION) = *((unsigned int *)(COMCERTO_AXI_IRAM_BASE+0x30));
+#endif
+
+	comcerto_pad_config();
+
+	//DDRC ODT Source Select
+	*(volatile u32*) COMCERTO_GPIO_MISC_PIN_SELECT_REG = ( (1 << 6) | (*(volatile u32*) COMCERTO_GPIO_MISC_PIN_SELECT_REG));
+
+#ifdef CONFIG_COMCERTO_DDR
+	/*Double reset HFE helps some times */
+        val = readl(AXI_RESET_1);
+	writel((val | HFE_AXI_RESET), AXI_RESET_1);
+        writel((val & ~(HFE_AXI_RESET)), AXI_RESET_1);
+
+	SoC_DDR_init();
+        /* Disable remapping so that lower address space is mapped to DDR space */
+	writel((DISABLE_FABRIC_REMAP | readl(COMCERTO_GPIO_PAD_CTRL)), COMCERTO_GPIO_PAD_CTRL);
+
+#ifdef CONFIG_COMCERTO_DDR_ECC
+	writel(0x10000, DDRC_CTL_32_REG);
+	writel(0x10000, DDRC_CTL_33_REG);
+	writel(0x1f0023, DDR_PHY_CTL_00_REG);
+	ddr_ecc_init();
+	writel(0x30000, DDRC_CTL_32_REG);
+	writel(0x0, DDRC_CTL_33_REG);
+#endif	/* CONFIG_COMCERTO_DDR_ECC */
+#endif	/* CONFIG_COMCERTO_DDR */
+
+	exp_bus_init();
+
+	nor_hw_init();
+
+	/* External reset to PCIe devices, Atheros Switch and FXS block, GPIO27 is used for TM_EXT_RESET*/
+	/*It seems some pcie wifi card has problem with the way external reset was being
+	  done (reset line high/delay/low/delay/high sequence) earlier. Instead simple
+	  reset pulse works for fine for these card and all the cards and it includes atheros
+	  switch*/
+	writel(readl(COMCERTO_GPIO_OUTPUT_REG) & ~GPIO_27, COMCERTO_GPIO_OUTPUT_REG);
+	writel(readl(COMCERTO_GPIO_OE_REG) | GPIO_27, COMCERTO_GPIO_OE_REG);
+	writel(readl(COMCERTO_GPIO_OUTPUT_REG) | GPIO_27, COMCERTO_GPIO_OUTPUT_REG);
+
+#ifdef CONFIG_NAND_COMCERTO
+	nand_hw_init();
+#endif
+}
+
+int c2000_eth_board_init(char *devname, int eth_port)
+{
+        //eth0 port is chosen as criteria for bringingup out of reset because
+        //all MDIO access can happen through EMAC0 and without bringing eth0 first
+        //no Switch/PHY configuration can happen and no point in removing reset without eth0
+        if(eth_port == 0)
+        {
+                //AR8327 Switch init
+                athrs17_init(devname);
+
+                //AR8327 WAN PHY4 init
+                athrs17_phy_setup(devname,EMAC0_PHY_ADDR);
+        }
+        else
+        {
+                //AR8327 LAN PHYs init
+                athrs17_phy_setup(devname,EMAC1_PHY_ADDR);
+        }
+
+}
+
+#if defined(CONFIG_SHOW_BOOT_PROGRESS)
+void show_boot_progress(int progress)
+{
+	printf("Boot reached stage %d\n", progress);
+}
+#endif /* CONFIG_SHOW_BOOT_PROGRESS */
+
+int dram_init(void)
+{
+        gd->bd->bi_dram[0].start = CONFIG_SYS_SDRAM_BASE;
+        gd->bd->bi_dram[0].size = CONFIG_SYS_SDRAM_SIZE; //512 MB
+	gd->ram_size = get_ram_size((void *) CONFIG_SYS_SDRAM_BASE,
+			CONFIG_SYS_SDRAM_SIZE);
+	return 0;
+
+}
+
+int board_init(void)
+{
+        /* arch number of Mindspeed Comcerto */
+        gd->bd->bi_arch_number = MACH_TYPE_COMCERTO;
+
+        /* adress of boot parameters */
+        gd->bd->bi_boot_params = CONFIG_SYS_SDRAM_BASE + 0x100;
+
+        return 0;
+}
+
+int HAL_get_c2k_revision()
+{
+        return (readl(COMCERTO_GPIO_DEVICE_ID_REG) >> 24) & 0xF;
+}
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/board/mindspeed/c2kmfcnevm/Makefile u-boot-2013.01.new/board/mindspeed/c2kmfcnevm/Makefile
--- u-boot-2013.01/board/mindspeed/c2kmfcnevm/Makefile	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/board/mindspeed/c2kmfcnevm/Makefile	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,56 @@
+#
+# (C) Copyright 2006
+# Mindspeed Technologies, Inc. <www.mindspeed.com>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#
+
+include $(TOPDIR)/config.mk
+ifneq ($(OBJTREE),$(SRCTREE))
+$(shell mkdir -p $(obj)../common)
+endif
+
+LIB	= $(obj)lib$(BOARD).o
+
+COBJS	:= board.o
+
+gcclibdir := $(shell dirname `$(CC) -print-libgcc-file-name`)
+
+HOST_CFLAGS = -Wall -pedantic -I$(TOPDIR)/include
+
+OBJS    := $(addprefix $(obj),$(COBJS))
+
+all:	$(LIB)
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+board.o: board.c
+	$(CC) $(CFLAGS) -fpic -c -o $@ $<
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/boards.cfg u-boot-2013.01.new/boards.cfg
--- u-boot-2013.01/boards.cfg	2013-01-16 03:17:42.000000000 +0530
+++ u-boot-2013.01.new/boards.cfg	2016-03-23 16:10:34.000000000 +0530
@@ -296,7 +296,13 @@
 kzm9g                        arm         armv7       kzm9g               kmc            rmobile
 armadillo-800eva             arm         armv7       armadillo-800eva    atmark-techno  rmobile
 zynq                         arm         armv7       zynq                xilinx         zynq
-socfpga_cyclone5                arm         armv7          socfpga_cyclone5    altera		    socfpga
+c2kevm                       arm         armv7       c2kevm              mindspeed      comcerto
+c2kmfcnevm                   arm         armv7       c2kmfcnevm          mindspeed      comcerto
+c2kmfcnevm-nand              arm         armv7       c2kmfcnevm          mindspeed      comcerto
+c2kevm-nand                  arm         armv7       c2kevm              mindspeed      comcerto
+c2kasic                      arm         armv7       c2kasic             mindspeed      comcerto
+c2kasic-nand                 arm         armv7       c2kasic             mindspeed      comcerto
+socfpga_cyclone5             arm         armv7       socfpga_cyclone5    altera         socfpga
 actux1_4_16                  arm         ixp         actux1              -              -           actux1:FLASH2X2
 actux1_4_32                  arm         ixp         actux1              -              -           actux1:FLASH2X2,RAM_32MB
 actux1_8_16                  arm         ixp         actux1              -              -           actux1:FLASH1X8
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/common/cmd_bootm.c u-boot-2013.01.new/common/cmd_bootm.c
--- u-boot-2013.01/common/cmd_bootm.c	2013-01-16 03:17:42.000000000 +0530
+++ u-boot-2013.01.new/common/cmd_bootm.c	2016-03-23 16:10:34.000000000 +0530
@@ -38,6 +38,10 @@
 #include <asm/byteorder.h>
 #include <linux/compiler.h>
 
+#ifdef CONFIG_SECUREBOOT
+#include <asm/arch/image.h>
+#endif
+
 #if defined(CONFIG_CMD_USB)
 #include <usb.h>
 #endif
@@ -158,6 +162,10 @@
 #endif
 };
 
+#ifdef CONFIG_SECUREBOOT
+void * kernel_image_addr;
+#endif
+
 bootm_headers_t images;		/* pointers to os/initrd/fdt images */
 
 /* Allow for arch specific config before we boot */
@@ -202,6 +210,14 @@
 
 	bootstage_mark_name(BOOTSTAGE_ID_BOOTM_START, "bootm_start");
 
+#ifdef CONFIG_SECUREBOOT
+	kernel_image_addr = verify_and_authenticate_boot_image((u8 *) simple_strtoul(argv[1], NULL, 16));
+	if (kernel_image_addr == NULL) {
+		puts("ERROR: kernel image validation failed!\n");
+		return 1;
+	}
+#endif
+
 	/* get kernel image header, start address and length */
 	os_hdr = boot_get_kernel(cmdtp, flag, argc, argv,
 			&images, &images.os.image_start, &images.os.image_len);
@@ -880,7 +896,11 @@
 				fit_uname_kernel, img_addr);
 #endif
 	} else {
+#ifdef CONFIG_SECUREBOOT
+		img_addr = (ulong) kernel_image_addr;
+#else
 		img_addr = simple_strtoul(argv[1], NULL, 16);
+#endif
 		debug("*  kernel: cmdline image address = 0x%08lx\n", img_addr);
 	}
 
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/common/cmd_nvedit.c u-boot-2013.01.new/common/cmd_nvedit.c
--- u-boot-2013.01/common/cmd_nvedit.c	2013-01-16 03:17:42.000000000 +0530
+++ u-boot-2013.01.new/common/cmd_nvedit.c	2016-03-23 16:10:34.000000000 +0530
@@ -61,10 +61,11 @@
 	!defined(CONFIG_ENV_IS_IN_NVRAM)	&& \
 	!defined(CONFIG_ENV_IS_IN_ONENAND)	&& \
 	!defined(CONFIG_ENV_IS_IN_SPI_FLASH)	&& \
+	!defined(CONFIG_ENV_IS_IN_C2K_SPI_FLASH) && \
 	!defined(CONFIG_ENV_IS_IN_REMOTE)	&& \
 	!defined(CONFIG_ENV_IS_NOWHERE)
 # error Define one of CONFIG_ENV_IS_IN_{EEPROM|FLASH|DATAFLASH|ONENAND|\
-SPI_FLASH|NVRAM|MMC|FAT|REMOTE} or CONFIG_ENV_IS_NOWHERE
+SPI_FLASH|C2K_SPI_FLASH|NVRAM|MMC|FAT|REMOTE} or CONFIG_ENV_IS_NOWHERE
 #endif
 
 /*
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/common/cmd_pfe_commands.c u-boot-2013.01.new/common/cmd_pfe_commands.c
--- u-boot-2013.01/common/cmd_pfe_commands.c	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/common/cmd_pfe_commands.c	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,845 @@
+/*
+ * (C) Copyright 2012
+ *  Author : Bill Westland (Mindspeed Technologies)
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/**
+ * @file
+ * @brief PFE utility commands
+ */
+
+#include <common.h>
+#include <command.h>
+#include "../drivers/net/c2000_eth/c2000_eth.h"
+#include "../drivers/net/c2000_eth/pfe/pfe.h"
+#include "../drivers/net/c2000_eth/pfe/cbus/class_csr.h"
+
+static void pfe_command_help(void)
+{
+	printf("Usage: pfe [firmware | load | lib | pe | gemac | gem | gpi | class | tmu | util | hif | status | expt | fftest] <options>\n");
+}
+
+static void pfe_command_firmware(int argc, char *argv[])
+{
+	if (argc == 3 && strcmp(argv[2], "init") == 0)
+	{
+		pfe_firmware_init();
+	}
+	else if (argc == 3 && strcmp(argv[2], "exit") == 0)
+	{
+		pfe_firmware_exit();
+	}
+	else
+	{
+		if (argc >= 3 && strcmp(argv[2], "help") != 0)
+		{
+			printf("Unknown option: %s\n", argv[2]);
+		}
+		printf("Usage: pfe firmware [init | exit]\n");
+	}
+}
+
+static void pfe_command_load(int argc, char *argv[])
+{
+	if (argc >= 3 && strcmp(argv[2], "elf") == 0)
+	{
+		if (argc == 5)
+		{
+			u32 mask;
+			u32 image_start;
+			struct firmware fw;
+			mask = simple_strtoul(argv[3], NULL, 0);
+			image_start = simple_strtoul(argv[4], NULL, 16);
+			fw.data = (u8 *)image_start;
+			pfe_load_elf(mask, &fw);
+		}
+		else
+		{
+			printf("Usage: pfe load elf <pe_mask> <image_start>\n");
+		}
+	}
+	else
+	{
+		if (argc >= 3 && strcmp(argv[2], "help") != 0)
+		{
+			printf("Unknown option: %s\n", argv[2]);
+		}
+		printf("Usage: pfe load elf <parameters>\n");
+	}
+}
+
+static void pfe_command_lib(int argc, char *argv[])
+{
+	if (argc >= 3 && strcmp(argv[2], "init") == 0)
+	{
+		if (argc == 3)
+			pfe_lib_init((void *)COMCERTO_AXI_HFE_CFG_BASE, (void *)CONFIG_DDR_BASEADDR, CONFIG_DDR_PHYS_BASEADDR);
+		else if (argc == 6)
+		{
+			u32 cbus_base;
+			u32 ddr_base;
+			u32 ddr_phys_base;
+			cbus_base = simple_strtoul(argv[3], NULL, 16);
+			ddr_base = simple_strtoul(argv[4], NULL, 16);
+			ddr_phys_base = simple_strtoul(argv[5], NULL, 16);
+			pfe_lib_init((void *)cbus_base, (void *)ddr_base, ddr_phys_base);
+		}
+		else
+		{
+			printf("Usage: pfe lib init [<cbus_base> <ddr_base> <ddr_phys_base>]\n");
+		}
+	}
+	else
+	{
+		if (argc >= 3 && strcmp(argv[2], "help") != 0)
+		{
+			printf("Unknown option: %s\n", argv[2]);
+		}
+		printf("Usage: pfe lib init <parameters>\n");
+	}
+}
+
+static void pfe_command_pe(int argc, char *argv[])
+{
+	if (argc >= 3 && strcmp(argv[2], "pmem") == 0)
+	{
+		if (argc >= 4 && strcmp(argv[3], "read") == 0)
+		{
+			int i;
+			int num;
+			int id;
+			u32 addr;
+			u32 size;
+			u32 val;
+			if (argc == 7)
+				num = simple_strtoul(argv[6], NULL, 0);
+			else if (argc == 6)
+				num = 1;
+			else
+			{
+				printf("Usage: pfe pe pmem read <id> <addr> [<num>]\n");
+				return;
+			}
+			id = simple_strtoul(argv[4], NULL, 0);
+			addr = simple_strtoul(argv[5], NULL, 16);
+			size = 4;
+			for (i = 0; i < num; i++, addr += 4)
+			{
+				val = pe_pmem_read(id, addr, size);
+				val = be32_to_cpu(val);
+				printf("%08x%s", val, i == num - 1 || (i & 7) == 7 ? "\n" : " ");
+			}
+		}
+		else
+		{
+			printf("Usage: pfe pe pmem read <parameters>\n");
+		}
+	}
+	else if (argc >= 3 && strcmp(argv[2], "dmem") == 0)
+	{
+		if (argc >= 4 && strcmp(argv[3], "read") == 0)
+		{
+			int i;
+			int num;
+			int id;
+			u32 addr;
+			u32 size;
+			u32 val;
+			if (argc == 7)
+				num = simple_strtoul(argv[6], NULL, 0);
+			else if (argc == 6)
+				num = 1;
+			else
+			{
+				printf("Usage: pfe pe dmem read <id> <addr> [<num>]\n");
+				return;
+			}
+			id = simple_strtoul(argv[4], NULL, 0);
+			addr = simple_strtoul(argv[5], NULL, 16);
+			size = 4;
+			for (i = 0; i < num; i++, addr += 4)
+			{
+				val = pe_dmem_read(id, addr, size);
+				val = be32_to_cpu(val);
+				printf("%08x%s", val, i == num - 1 || (i & 7) == 7 ? "\n" : " ");
+			}
+		}
+		else if (argc >= 4 && strcmp(argv[3], "write") == 0)
+		{
+			int id;
+			u32 val;
+			u32 addr;
+			u32 size;
+			if (argc != 7)
+			{
+				printf("Usage: pfe pe dmem write <id> <val> <addr>\n");
+				return;
+			}
+			id = simple_strtoul(argv[4], NULL, 0);
+			val = simple_strtoul(argv[5], NULL, 16);
+			val = cpu_to_be32(val);
+			addr = simple_strtoul(argv[6], NULL, 16);
+			size = 4;
+			pe_dmem_write(id, val, addr, size);
+		}
+		else
+		{
+			printf("Usage: pfe pe dmem [read | write] <parameters>\n");
+		}
+	}
+	else if (argc >= 3 && strcmp(argv[2], "lmem") == 0)
+	{
+		if (argc >= 4 && strcmp(argv[3], "read") == 0)
+		{
+			int i;
+			int num;
+			u32 val;
+			u32 offset;
+			if (argc == 6)
+				num = simple_strtoul(argv[5], NULL, 0);
+			else if (argc == 5)
+				num = 1;
+			else
+			{
+				printf("Usage: pfe pe lmem read <offset> [<num>]\n");
+				return;
+			}
+			offset = simple_strtoul(argv[4], NULL, 16);
+			for (i = 0; i < num; i++, offset += 4)
+			{
+				pe_lmem_read(&val, 4, offset);
+				val = be32_to_cpu(val);
+				printf("%08x%s", val, i == num - 1 || (i & 7) == 7 ? "\n" : " ");
+			}
+		}
+		else if (argc >= 4 && strcmp(argv[3], "write") == 0)
+		{
+			u32 val;
+			u32 offset;
+			if (argc != 6)
+			{
+				printf("Usage: pfe pe lmem write <val> <offset>\n");
+				return;
+			}
+			val = simple_strtoul(argv[4], NULL, 16);
+			val = cpu_to_be32(val);
+			offset = simple_strtoul(argv[5], NULL, 16);
+			pe_lmem_write(&val, 4, offset);
+		}
+		else
+		{
+			printf("Usage: pfe pe lmem [read | write] <parameters>\n");
+		}
+	}
+	else
+	{
+		if (strcmp(argv[2], "help") != 0)
+		{
+			printf("Unknown option: %s\n", argv[2]);
+		}
+		printf("Usage: pfe lib init <parameters>\n");
+	}
+	//void pe_mem_memcpy_to32(int id, u32 mem_access_addr, const void *src, unsigned int len)
+	//void pe_dmem_memcpy_to32(int id, u32 dst, const void *src, unsigned int len)
+	//void pe_pmem_memcpy_to32(int id, u32 dst, const void *src, unsigned int len)
+	//int pe_load_elf_section(int id, const void *data, Elf32_Shdr *shdr)
+}
+
+#if 0
+static void pfe_command_gemac(int argc, char *argv[])
+{
+void gemac_init(void *base, void *cfg)
+void gemac_set_speed(void *base, MAC_SPEED gem_speed)
+void gemac_set_duplex(void *base, int duplex)
+void gemac_set_mode(void *base, int mode)
+void gemac_reset(void *base)
+void gemac_enable(void *base)
+void gemac_disable(void *base)
+void gemac_set_address(void *base, SPEC_ADDR *addr)
+SPEC_ADDR gemac_get_address(void *base)
+void gemac_set_laddr1(void *base, MAC_ADDR *address)
+void gemac_set_laddr2(void *base, MAC_ADDR *address)
+void gemac_set_laddr3(void *base, MAC_ADDR *address)
+void gemac_set_laddr4(void *base, MAC_ADDR *address)
+void gemac_set_laddrN(void *base, MAC_ADDR *address, unsigned int entry_index)
+void gemac_allow_broadcast(void *base)
+void gemac_no_broadcast(void *base)
+void gemac_enable_unicast(void *base)
+void gemac_disable_unicast(void *base)
+void gemac_enable_multicast(void *base)
+void gemac_disable_multicast(void *base)
+void gemac_enable_fcs_rx(void *base)
+void gemac_disable_fcs_rx(void *base)
+void gemac_enable_1536_rx(void *base)
+void gemac_disable_1536_rx(void *base)
+void gemac_enable_pause_rx(void *base)
+void gemac_disable_pause_rx(void *base)
+void gemac_set_config(void *base, GEMAC_CFG *cfg)
+unsigned int * gemac_get_stats(void *base)
+}
+#endif
+
+#if 0
+static void pfe_command_gem(int argc, char *argv[])
+{
+MAC_ADDR gem_get_laddr1(void *base)
+MAC_ADDR gem_get_laddr2(void *base)
+MAC_ADDR gem_get_laddr3(void *base)
+MAC_ADDR gem_get_laddr4(void *base)
+MAC_ADDR gem_get_laddrN(void *base, unsigned int entry_index)
+}
+#endif
+
+#if 0
+static void pfe_command_gpi(int argc, char *argv[])
+{
+void gpi_init(void *base, GPI_CFG *cfg)
+void gpi_reset(void *base)
+void gpi_enable(void *base)
+void gpi_disable(void *base)
+void gpi_set_config(void *base, GPI_CFG *cfg)
+}
+#endif
+
+static void pfe_command_class(int argc, char *argv[])
+{
+	if (argc >= 3 && strcmp(argv[2], "init") == 0)
+	{
+		CLASS_CFG cfg;
+		if (argc == 3)
+		{
+			cfg.route_table_hash_bits = ROUTE_TABLE_HASH_BITS;
+			cfg.route_table_baseaddr = CONFIG_DDR_PHYS_BASEADDR + ROUTE_TABLE_BASEADDR;
+		}
+		else if (argc == 5)
+		{
+			cfg.route_table_hash_bits = simple_strtoul(argv[3], NULL, 16);
+			cfg.route_table_baseaddr = simple_strtoul(argv[4], NULL, 16);
+		}
+		else
+		{
+			printf("Usage: pfe class init <route_table_hash_bits> <route_table_baseaddr>\n");
+		}
+		class_init(&cfg);
+	}
+	else if (argc == 3 && strcmp(argv[2], "reset") == 0)
+	{
+		class_reset();
+	}
+	else if (argc == 3 && strcmp(argv[2], "enable") == 0)
+	{
+		class_enable();
+	}
+	else if (argc == 3 && strcmp(argv[2], "disable") == 0)
+	{
+		class_disable();
+	}
+	else if (argc >= 3 && strcmp(argv[2], "config") == 0)
+	{
+		CLASS_CFG cfg;
+		if (argc == 3)
+		{
+			cfg.route_table_hash_bits = ROUTE_TABLE_HASH_BITS;
+			cfg.route_table_baseaddr = CONFIG_DDR_PHYS_BASEADDR + ROUTE_TABLE_BASEADDR;
+		}
+		else if (argc == 5)
+		{
+			cfg.route_table_hash_bits = simple_strtoul(argv[3], NULL, 16);
+			cfg.route_table_baseaddr = simple_strtoul(argv[4], NULL, 16);
+		}
+		else
+		{
+			printf("Usage: pfe class config <route_table_hash_bits> <route_table_baseaddr>\n");
+		}
+		class_set_config(&cfg);
+	}
+	else if (argc >= 3 && strcmp(argv[2], "bus") == 0)
+	{
+		if (argc >= 4 && strcmp(argv[3], "read") == 0)
+		{
+			u32 addr;
+			u32 size;
+			u32 val;
+			if (argc != 6)
+			{
+				printf("Usage: pfe class bus read <addr> <size>\n");
+				return;
+			}
+			addr = simple_strtoul(argv[4], NULL, 16);
+			size = simple_strtoul(argv[5], NULL, 16);
+			val = class_bus_read(addr, size);
+			printf("%08x\n", val);
+		}
+		else if (argc >= 4 && strcmp(argv[3], "write") == 0)
+		{
+			u32 val;
+			u32 addr;
+			u32 size;
+			if (argc != 7)
+			{
+				printf("Usage: pfe class bus write <val> <addr> <size>\n");
+				return;
+			}
+			val = simple_strtoul(argv[4], NULL, 16);
+			addr = simple_strtoul(argv[5], NULL, 16);
+			size = simple_strtoul(argv[6], NULL, 16);
+			class_bus_write(val, addr, size);
+		}
+		else
+		{
+			printf("Usage: pfe class bus [read | write] <parameters>\n");
+		}
+	}
+	else
+	{
+		if (argc >= 3 && strcmp(argv[2], "help") != 0)
+		{
+			printf("Unknown option: %s\n", argv[2]);
+		}
+		printf("Usage: pfe class [init | reset | enable | disable | config | bus] <parameters>\n");
+	}
+}
+
+static void pfe_command_tmu(int argc, char *argv[])
+{
+	if (argc >= 3 && strcmp(argv[2], "init") == 0)
+	{
+		if (argc == 5)
+		{
+			TMU_CFG cfg;
+			cfg.llm_base_addr = simple_strtoul(argv[3], NULL, 16);
+			cfg.llm_queue_len = simple_strtoul(argv[4], NULL, 16);
+			tmu_init(&cfg);
+		}
+		else
+		{
+			printf("Usage: pfe tmu init <llm_base_addr> <llm_queue_len>\n");
+		}
+	}
+	else if (argc >= 3 && strcmp(argv[2], "enable") == 0)
+	{
+		if (argc == 4)
+		{
+			u32 mask;
+			mask = simple_strtoul(argv[3], NULL, 16);
+			tmu_enable(mask);
+		}
+		else
+		{
+			printf("Usage: pfe tmu enable <pe_mask>\n");
+		}
+	}
+	else if (argc >= 3 && strcmp(argv[2], "disable") == 0)
+	{
+		if (argc == 4)
+		{
+			u32 mask;
+			mask = simple_strtoul(argv[3], NULL, 16);
+			tmu_disable(mask);
+		}
+		else
+		{
+			printf("Usage: pfe tmu disable <pe_mask>\n");
+		}
+	}
+	else
+	{
+		if (argc >= 3 && strcmp(argv[2], "help") != 0)
+		{
+			printf("Unknown option: %s\n", argv[2]);
+		}
+		printf("Usage: pfe tmu [init | enable | disable] <parameters>\n");
+	}
+}
+
+#define	PESTATUS_ADDR_CLASS	0x800
+#define	PESTATUS_ADDR_TMU	0x80
+#define	PESTATUS_ADDR_UTIL	0x0
+
+static void pfe_command_status(int argc, char *argv[])
+{
+	int do_clear = 0;
+	int j;
+	u32 id;
+	u32 dmem_addr;
+	u32 cpu_state;
+	u32 activity_counter;
+	u32 rx;
+	u32 tx;
+	u32 drop;
+	char statebuf[5];
+	u32 class_debug_reg = 0;
+	u32 debug_indicator;
+	u32 debug[16];
+
+	if (argc == 3 && strcmp(argv[2], "clear") == 0)
+		do_clear = 1;
+	else if (argc != 2)
+	{
+		printf("Usage: pfe status [clear]\n");
+		return;
+	}
+
+	for (id = CLASS0_ID; id <= UTIL_ID; id++)
+	{
+		if (id == UTIL_ID)
+		{
+			printf("util:\n");
+			dmem_addr = PESTATUS_ADDR_UTIL;
+		}
+		else if (id >= TMU0_ID)
+		{
+			if (id == TMU0_ID)
+				printf("tmu:\n");
+			dmem_addr = PESTATUS_ADDR_TMU;
+		}
+		else
+		{
+			if (id == CLASS0_ID)
+				printf("class:\n");
+			dmem_addr = PESTATUS_ADDR_CLASS;
+			class_debug_reg = readl(CLASS_PE0_DEBUG + id * 4);
+		}
+		cpu_state = pe_dmem_read(id, dmem_addr, 4);
+		dmem_addr += 4;
+		memcpy(statebuf, (char *)&cpu_state, 4);
+		statebuf[4] = '\0';
+		activity_counter = pe_dmem_read(id, dmem_addr, 4);
+		dmem_addr += 4;
+		rx = pe_dmem_read(id, dmem_addr, 4);
+		if (do_clear)
+			pe_dmem_write(id, 0, dmem_addr, 4);
+		dmem_addr += 4;
+		tx = pe_dmem_read(id, dmem_addr, 4);
+		if (do_clear)
+			pe_dmem_write(id, 0, dmem_addr, 4);
+		dmem_addr += 4;
+		drop = pe_dmem_read(id, dmem_addr, 4);
+		if (do_clear)
+			pe_dmem_write(id, 0, dmem_addr, 4);
+		dmem_addr += 4;
+		if (id == UTIL_ID)
+		{
+			printf("state=%4s ctr=%08x rx=%x tx=%x\n",
+					statebuf, cpu_to_be32(activity_counter),
+					cpu_to_be32(rx), cpu_to_be32(tx));
+		}
+		else if (id >= TMU0_ID)
+		{
+			printf("%d: state=%4s ctr=%08x rx=%x tx=%x\n",
+					id - TMU0_ID, statebuf, cpu_to_be32(activity_counter),
+					cpu_to_be32(rx), cpu_to_be32(tx));
+		}
+		else
+		{
+			printf("%d: pc=1%04x ldst=%04x state=%4s ctr=%08x rx=%x tx=%x drop=%x\n",
+					id - CLASS0_ID, class_debug_reg & 0xFFFF, class_debug_reg >> 16,
+					statebuf, cpu_to_be32(activity_counter),
+					cpu_to_be32(rx), cpu_to_be32(tx), cpu_to_be32(drop));
+		}
+		debug_indicator = pe_dmem_read(id, dmem_addr, 4);
+		dmem_addr += 4;
+		if (debug_indicator == cpu_to_be32('DBUG'))
+		{
+			int last = 0;
+			for (j = 0; j < 16; j++)
+			{
+				debug[j] = pe_dmem_read(id, dmem_addr, 4);
+				if (debug[j])
+				{
+					last = j + 1;
+					if (do_clear)
+						pe_dmem_write(id, 0, dmem_addr, 4);
+				}
+				dmem_addr += 4;
+			}
+			for (j = 0; j < last; j++)
+			{
+				printf("%08x%s", cpu_to_be32(debug[j]), (j & 0x7) == 0x7 || j == last - 1 ? "\n" : " ");
+			}
+		}
+	}
+
+}
+
+#define EXPT_DUMP_ADDR 0x1fa8
+#define EXPT_REG_COUNT 20
+static const char *register_names[EXPT_REG_COUNT] = {
+		"  pc", "ECAS", " EID", "  ED",
+		"  sp", "  r1", "  r2", "  r3",
+		"  r4", "  r5", "  r6", "  r7",
+		"  r8", "  r9", " r10", " r11",
+		" r12", " r13", " r14", " r15"
+};
+
+static void pfe_command_expt(int argc, char *argv[])
+{
+	unsigned int id, i, val, addr;
+
+	if (argc == 3)
+	{
+		id = simple_strtoul(argv[2], NULL, 0);
+		addr = EXPT_DUMP_ADDR;
+		printf("Exception information for PE %d:\n", id);
+		for (i = 0; i < EXPT_REG_COUNT; i++)
+		{
+			val = pe_dmem_read(id, addr, 4);
+			val = be32_to_cpu(val);
+			printf("%s:%08x%s", register_names[i], val, (i & 3) == 3 ? "\n" : " ");
+			addr += 4;
+		}
+	}
+	else
+	{
+		printf("Usage: pfe expt <id>\n");
+	}
+}
+
+static void pfe_command_util(int argc, char *argv[])
+{
+	if (argc == 3 && strcmp(argv[2], "init") == 0)
+	{
+		UTIL_CFG cfg;
+		util_init(&cfg);
+	}
+	else if (argc == 3 && strcmp(argv[2], "reset") == 0)
+	{
+		util_reset();
+	}
+	else if (argc == 3 && strcmp(argv[2], "enable") == 0)
+	{
+		util_enable();
+	}
+	else if (argc == 3 && strcmp(argv[2], "disable") == 0)
+	{
+		util_disable();
+	}
+	else if (argc >= 3 && strcmp(argv[2], "bus") == 0)
+		{
+			if (argc >= 4 && strcmp(argv[3], "read") == 0)
+			{
+				u32 addr;
+				u32 size;
+				u32 val;
+				if (argc != 6)
+				{
+					printf("Usage: pfe util bus read <addr> <size>\n");
+					return;
+				}
+				addr = simple_strtoul(argv[4], NULL, 16);
+				size = simple_strtoul(argv[5], NULL, 16);
+				val = util_bus_read(addr, size);
+				printf("%08x\n", val);
+			}
+			else if (argc >= 4 && strcmp(argv[3], "write") == 0)
+			{
+				u32 val;
+				u32 addr;
+				u32 size;
+				if (argc != 7)
+				{
+					printf("Usage: pfe util bus write <val> <addr> <size>\n");
+					return;
+				}
+				val = simple_strtoul(argv[4], NULL, 16);
+				addr = simple_strtoul(argv[5], NULL, 16);
+				size = simple_strtoul(argv[6], NULL, 16);
+				util_bus_write(val, addr, size);
+			}
+			else
+			{
+				printf("Usage: pfe util bus [read | write] <parameters>\n");
+			}
+		}
+	else
+	{
+		if (argc >= 3 && strcmp(argv[2], "help") != 0)
+		{
+			printf("Unknown option: %s\n", argv[2]);
+		}
+		printf("Usage: pfe util [init | reset | enable | disable | bus] <parameters>\n");
+	}
+}
+
+#if 0
+static void pfe_command_hif(int argc, char *argv[])
+{
+void hif_nocpy_init(void)
+void hif_init(void)
+void hif_tx_enable(void)
+void hif_tx_disable(void)
+void hif_rx_enable(void)
+void hif_rx_disable(void)
+}
+#endif
+
+/* TODO Implement alternative method of running this test on U-Boot */
+#if 0
+#define ROUTE_TABLE_START	(CONFIG_DDR_PHYS_BASEADDR+ROUTE_TABLE_BASEADDR)
+static void pfe_command_fftest(int argc, char *argv[])
+{
+	int ret;
+	struct eth_device *save_eth_current;
+	struct eth_device *edev_eth0;
+	struct eth_device *edev_eth1;
+
+	if (argc == 3)
+	{
+		// open binary file to load into route table
+		int fd;
+		char *p = (char *)ROUTE_TABLE_START;
+		int n, ntotal;
+		fd = open(argv[2], O_RDONLY);
+		if (fd < 0) {
+			perror("open");
+			return;
+		}
+		memset((char *)ROUTE_TABLE_START, 0, ROUTE_TABLE_SIZE);
+		ntotal = 0;
+		do {
+			n = read(fd, p, (ROUTE_TABLE_SIZE - ntotal) < 1024 ? (ROUTE_TABLE_SIZE - ntotal) : 1024);
+			if (n < 0) {
+				perror("read");
+				close(fd);
+				return;
+			}
+
+			ntotal += n;
+			p += n;
+		} while (n > 0 && ntotal < ROUTE_TABLE_SIZE);
+		printf("Read %d bytes from %s to route table at 0x%x\n", ntotal, argv[1], ROUTE_TABLE_START);
+		close(fd);
+	}
+	else if (argc != 2)
+	{
+		printf("Usage: pfe fftest [<filename>]\n");
+		return;
+	}
+
+	// open eth_current if not already open
+	save_eth_current = eth_get_current();
+	if (save_eth_current && !save_eth_current->active)
+	{
+		ret = save_eth_current->open(save_eth_current);
+		if (ret)
+		{
+			printf("eth_current open error\n");
+			return;
+		}
+		save_eth_current->active = 1;
+	}
+
+
+	// open eth0 and eth1 
+	edev_eth0 = eth_get_byname("eth0");
+	if (!edev_eth0)
+	{
+		printf("Cannot access eth0\n");
+		return;
+	}
+	if (edev_eth0 != save_eth_current)
+	{
+		ret = edev_eth0->open(edev_eth0);
+		if (ret)
+		{
+			printf("eth0 open error\n");
+			return;
+		}
+	}
+	edev_eth1 = eth_get_byname("eth1");
+	if (!edev_eth1)
+	{
+		printf("Cannot access eth1\n");
+		return;
+	}
+
+	if (edev_eth1 != save_eth_current)
+	{
+		ret = edev_eth1->open(edev_eth1);
+		if (ret)
+		{
+			printf("eth0 open error\n");
+			return;
+		}
+	}
+
+}
+#endif
+
+static int pfe_command(cmd_tbl_t *cmdtp, int flag, int argc,
+		       char * const argv[])
+{
+	if (argc == 1 || strcmp(argv[1], "help") == 0)
+	{
+		pfe_command_help();
+		return CMD_RET_SUCCESS;
+	}
+	if (strcmp(argv[1], "firmware") == 0)
+		pfe_command_firmware(argc, argv);
+	else if (strcmp(argv[1], "load") == 0)
+		pfe_command_load(argc, argv);
+	else if (strcmp(argv[1], "lib") == 0)
+		pfe_command_lib(argc, argv);
+	else if (strcmp(argv[1], "pe") == 0)
+		pfe_command_pe(argc, argv);
+#if 0
+	else if (strcmp(argv[1], "gemac") == 0)
+		pfe_command_gemac(argc, argv);
+	else if (strcmp(argv[1], "gem") == 0)
+		pfe_command_gem(argc, argv);
+	else if (strcmp(argv[1], "gpi") == 0)
+		pfe_command_gpi(argc, argv);
+#endif
+	else if (strcmp(argv[1], "class") == 0)
+		pfe_command_class(argc, argv);
+	else if (strcmp(argv[1], "tmu") == 0)
+		pfe_command_tmu(argc, argv);
+	else if (strcmp(argv[1], "status") == 0)
+		pfe_command_status(argc, argv);
+	else if (strcmp(argv[1], "expt") == 0)
+		pfe_command_expt(argc, argv);
+	else if (strcmp(argv[1], "util") == 0)
+		pfe_command_util(argc, argv);
+#if 0
+	else if (strcmp(argv[1], "hif") == 0)
+		pfe_command_hif(argc, argv);
+#endif
+/* TODO Implement alternative method of running this test on U-Boot */
+#if 0
+	else if (strcmp(argv[1], "fftest") == 0)
+		pfe_command_fftest(argc, argv);
+#endif
+	else
+	{
+		printf("Unknown option: %s\n", argv[1]);
+		pfe_command_help();
+		return CMD_RET_FAILURE;
+	}
+	return CMD_RET_SUCCESS;
+}
+
+
+U_BOOT_CMD(
+	pfe,	4,	1,	pfe_command,
+	"Performs PFE lib utility functions",
+	"Usage: \n"
+	"pfe <options>"
+);
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/common/cmd_pfe_stat.c u-boot-2013.01.new/common/cmd_pfe_stat.c
--- u-boot-2013.01/common/cmd_pfe_stat.c	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/common/cmd_pfe_stat.c	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,382 @@
+/*
+ * (C) Copyright 2003
+ *  Author : Laurent Brando (Mindspeed Technologies)
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/**
+ * @file
+ * @brief Retrieve PFE Statistics
+ */
+
+//#define SBL_EMUL	/* for compilation and debug on Linux Station */
+
+#ifndef SBL_EMUL
+
+#include <common.h>
+#include <command.h>
+#include <environment.h>
+#include <net.h>
+#include <fs.h>
+#include <errno.h>
+#include <malloc.h>
+#include "../drivers/net/c2000_eth/c2000_eth.h"
+#include "../drivers/net/c2000_eth/pfe/pfe.h"
+
+#else
+
+#include <malloc.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <strings.h>
+
+#define simple_strtoul(a,b,c) strtoul(a,b,c)
+
+enum {
+	CLASS0_ID = 0,
+	CLASS1_ID,
+	CLASS2_ID,
+	CLASS3_ID,
+	CLASS4_ID,
+	CLASS5_ID,
+	TMU0_ID,
+	TMU1_ID,
+	TMU2_ID,
+	TMU3_ID,
+	UTIL_ID,
+	MAX_PE
+};
+
+#endif
+
+typedef struct pfe_stat_queue_response {
+	u_int32_t	emitted_pkts; 
+	u_int32_t	dropped_pkts;
+	u_int32_t	peak_queue_occ; 
+} pfe_stat_queue_response_t;
+
+typedef struct pfe_stat_interface_pkt_response {
+	u_int32_t	total_bytes_received[2]; /* 64 bit counter stored as 2*32 bit counters */
+	u_int32_t	total_bytes_transmitted[2]; /* 64 bit counter stored as 2*32 bit counters */ 
+	u_int32_t	total_pkts_received;
+	u_int32_t	total_pkts_transmitted;
+} pfe_stat_interface_pkt_response_t;
+
+
+#define NUM_QUEUES 8
+#define NUM_INTERFACES 2
+
+/* used to store either dmem base address of statistics counters structure or
+statistics control register address (for enable/disable stats). Specified as command line argument */
+unsigned int class_dmem_addr = 0;
+unsigned int tmu_dmem_addr = 0;
+
+/* Host copy of the statistics memory layout in PFE classifier */
+typedef struct _tFppStatistics {
+	u_int64_t FS_total_bytes_received[NUM_INTERFACES];
+	u_int64_t FS_total_bytes_transmitted[NUM_INTERFACES];
+	u_int32_t FS_total_pkts_received[NUM_INTERFACES];	
+	u_int32_t FS_total_pkts_transmitted[NUM_INTERFACES];
+	u_int64_t FS_emitted_pkts[NUM_INTERFACES][NUM_QUEUES];
+	u_int64_t FS_dropped_pkts[NUM_INTERFACES][NUM_QUEUES];
+	u_int32_t FS_peak_queue_occ[NUM_INTERFACES][NUM_QUEUES];
+} tFppStatistics;
+
+struct _tFppStatistics host_stats;
+
+
+
+/* redefined here, because declared as static in /lib/vsprintf.c */
+#define is_digit(c)	((c) >= '0' && (c) <= '9')
+static int skip_atoi(char **s)
+{
+	int i=0;
+	
+	while (is_digit(**s))
+		i = i*10 + *((*s)++) - '0';
+	return i;
+}
+
+
+/* compute address of a given statistics counters whithin the PE's memory */
+static unsigned int get_target_counter_address(unsigned int target_base, unsigned int counter)
+{
+	//printf("%s:\n", __FUNCTION__);
+	
+	return (target_base + (counter - (unsigned int)&host_stats));
+}
+
+
+/* retrieves the base address of the statistics structure within the PE memory */
+static unsigned int get_target_dmem_address(unsigned char pe_id)
+{
+	//printf("%s:\n", __FUNCTION__);
+	
+	return (pe_id <= CLASS5_ID)? class_dmem_addr: tmu_dmem_addr;
+}
+
+/* Definitions of Bit Masks for the features */
+#define STAT_QUEUE_BITMASK 		0x00000001
+#define STAT_INTERFACE_BITMASK 		0x00000002
+
+#ifndef caseretstr
+#define caseretstr(x) case x: return #x
+#endif
+char *stats_mask_to_string(unsigned int mask)
+{
+	switch (mask)
+	{
+		caseretstr(STAT_QUEUE_BITMASK);
+		caseretstr(STAT_INTERFACE_BITMASK);
+		default:
+		return "unknown\n";
+	}
+}
+
+unsigned int stats_string_to_mask(char * name)
+{	
+	if(strcmp(name, "queue") == 0)
+		return STAT_QUEUE_BITMASK;
+	if(strcmp(name, "interface") == 0)
+		return STAT_INTERFACE_BITMASK;
+	
+	return 0;
+}
+
+
+
+#ifdef SBL_EMUL
+
+unsigned int dummy_dmem[128] = {0};
+
+static unsigned int pe_dmem_read(int id, unsigned int addr, unsigned char size)
+{
+	printf("%s: read pe %i - @%08x val = %x - %d bytes\n", __FUNCTION__, id, addr, dummy_dmem[0], size);
+	
+	return dummy_dmem[0];
+}
+
+static void pe_dmem_write(int id, unsigned int addr, unsigned int val, unsigned char size)
+{
+	dummy_dmem[0] = val;
+	
+	printf("%s: write pe %i - @%08x val = %x - %d bytes\n", __FUNCTION__, id, addr, val, size);
+}
+
+#define CMD_RET_USAGE (-1)
+
+#else
+
+extern unsigned int pe_dmem_read(int id, unsigned int addr, unsigned char size);
+extern void pe_dmem_write(int id, unsigned int addr, unsigned int val, unsigned char size);
+
+#endif
+
+
+static void class_aggregate_stats(unsigned int *host_addr, unsigned int dmem_addr, unsigned char nbytes)
+{
+	int pe_id;
+	unsigned char nwords;
+	unsigned int *dst;
+ 	unsigned int *src;
+	
+	//printf("%s:\n", __FUNCTION__);
+		
+	for(pe_id = CLASS0_ID; pe_id <= CLASS5_ID; pe_id++)
+	{	
+		nwords = nbytes;
+		dst = host_addr;
+		src = (unsigned int *)dmem_addr;
+		while(nwords--)
+		{	
+			*dst += pe_dmem_read(pe_id, (unsigned int)src, 4); 
+			dst++;
+			src++;
+		}
+	}
+}
+
+static void tmu_aggregate_stats(unsigned int *host_addr, unsigned int dmem_addr, unsigned char nbytes, unsigned char interface)
+{
+	int pe_id;
+	unsigned char nwords;
+	unsigned int *dst;
+	unsigned int *src;
+	
+	//printf("%s:\n", __FUNCTION__);
+
+	if(interface == 0)
+		pe_id = TMU0_ID; 
+	else if(interface == 1)
+		pe_id = TMU1_ID;
+	else
+		pe_id = TMU2_ID;
+	
+	nwords = nbytes;
+	dst = host_addr;
+	src = (unsigned int *)dmem_addr;
+	while(nwords--)
+	{	
+		*dst += pe_dmem_read(pe_id, (unsigned int)src, 4); 
+		dst++;
+		src++;
+	}
+}
+
+
+static void pe_enable_stats(unsigned int mask, unsigned char enable)
+{
+	int pe_id;
+	unsigned int stat_ctrl_addr;
+	unsigned int stat_ctrl;
+	
+	printf("%s: %s %s\n", __FUNCTION__, (enable)? "enable":"disable",stats_mask_to_string(mask));
+	
+	for(pe_id = CLASS0_ID; pe_id <= TMU2_ID; pe_id++)
+	{
+		stat_ctrl_addr = get_target_dmem_address(pe_id);
+		
+		stat_ctrl = pe_dmem_read(pe_id, stat_ctrl_addr, 4);
+		
+		if(enable)
+			stat_ctrl |= mask;
+		else
+			stat_ctrl &= ~mask;
+		
+		pe_dmem_write(pe_id, stat_ctrl_addr, stat_ctrl, 4);
+	}
+
+}
+
+#ifndef SBL_EMUL
+static int pfe_stats(struct command *cmdtp, int argc, char *argv[])
+#else
+int main(int argc, char *argv[])
+#endif
+{
+	pfe_stat_queue_response_t queue_stats = {0};
+	pfe_stat_interface_pkt_response_t interface_pkt_stats = {{0}};
+	unsigned int counter_address, interface, queue;
+	
+	if(argc < 4)
+		return CMD_RET_USAGE;
+	
+	class_dmem_addr = simple_strtoul(argv[1], NULL, 0);
+	tmu_dmem_addr = simple_strtoul(argv[2], NULL, 0);
+	
+	if(strcmp(argv[3], "enable") == 0)
+	{
+		if(argc != 5)
+			return CMD_RET_USAGE;
+		
+		pe_enable_stats(stats_string_to_mask(argv[4]), 1);
+	}
+	else if(strcmp(argv[3], "disable") == 0)
+	{
+		if(argc != 5)
+			return CMD_RET_USAGE;
+		
+		pe_enable_stats(stats_string_to_mask(argv[4]), 0);
+	}
+	
+	else if(strcmp(argv[3], "query") == 0)
+	{		
+		if(strcmp(argv[4], "queue") == 0)
+		{
+			if(argc != 8)
+				return CMD_RET_USAGE;
+			
+			queue = simple_strtoul(argv[5], NULL, 0);
+			interface = simple_strtoul(argv[7], NULL, 0); 
+			
+			printf("QUEUE STATS: tmu dmem base 0x%x queue %d interface %d\n", tmu_dmem_addr, queue, interface);
+			
+			if((queue > (NUM_QUEUES - 1)) || (interface > (NUM_INTERFACES - 1)))
+				return CMD_RET_USAGE;
+			
+			/* get corresponding dmem address */
+			counter_address = get_target_counter_address(tmu_dmem_addr, (unsigned int)&host_stats.FS_emitted_pkts[interface][queue]);
+
+			/* copy and aggregate all queue_stats counters for the selected interface */
+			tmu_aggregate_stats((unsigned int *)&queue_stats, counter_address, sizeof(pfe_stat_queue_response_t)/4, interface);
+			
+			printf("Emitted Pkts: %u \n" 
+			"Dropped Packets: %u\n" 
+			"Peak Queue Occupancy: %u \n",
+				queue_stats.emitted_pkts, queue_stats.dropped_pkts, queue_stats.peak_queue_occ);
+		}
+		else if(strcmp(argv[4], "interface") == 0)
+		{
+			if(argc != 6)
+				return CMD_RET_USAGE;
+			
+			interface = simple_strtoul(argv[5], NULL, 0);
+			
+			printf("INTERFACE STATS: class dmem base 0x%x tmu dmem base 0x%x interface %d\n", class_dmem_addr, tmu_dmem_addr, interface);
+			
+			if(interface > (NUM_INTERFACES - 1))
+				return CMD_RET_USAGE;
+			
+			/* get CLASSIFIER statistics for received counters */
+			counter_address = get_target_counter_address(class_dmem_addr, (unsigned int)&host_stats.FS_total_bytes_received[interface]);
+			class_aggregate_stats((unsigned int *)&interface_pkt_stats.total_bytes_received[0], counter_address, sizeof(u_int64_t));
+			
+			counter_address = get_target_counter_address(class_dmem_addr, (unsigned int)&host_stats.FS_total_pkts_received[interface]);
+			class_aggregate_stats((unsigned int *)&interface_pkt_stats.total_pkts_received, counter_address, sizeof(u_int32_t));
+			
+			/* get TMU statistics for transmit counters */
+			counter_address = get_target_counter_address(tmu_dmem_addr, (unsigned int)&host_stats.FS_total_bytes_transmitted[interface]);
+			tmu_aggregate_stats((unsigned int *)&interface_pkt_stats.total_bytes_transmitted[0], counter_address, sizeof(u_int64_t), interface);
+			
+			counter_address = get_target_counter_address(tmu_dmem_addr, (unsigned int)&host_stats.FS_total_pkts_transmitted[interface]);
+			tmu_aggregate_stats((unsigned int *)&interface_pkt_stats.total_pkts_transmitted, counter_address, sizeof(u_int32_t), interface);
+						
+			printf("Total Bytes Received: %llu \n"
+			"Total Bytes Transmitted: %llu \n"
+			"Total Packets Received: %u \n"
+			"Total Packets Transmitted: %u \n",
+			(unsigned long long)(interface_pkt_stats.total_bytes_received[0] | (interface_pkt_stats.total_bytes_received[1] << 31)), 
+			(unsigned long long)(interface_pkt_stats.total_bytes_transmitted[0] | (interface_pkt_stats.total_bytes_transmitted[1] << 31)), 
+			interface_pkt_stats.total_pkts_received, interface_pkt_stats.total_pkts_transmitted);
+		}
+		else 
+		{
+			printf("statistics type %s not supported\n", argv[1]);
+		}	
+	}
+	else
+	{
+		return CMD_RET_USAGE;
+	}
+	
+	return 0;
+}
+
+#ifndef SBL_EMUL
+U_BOOT_CMD(
+	pfe_stats,	4,	1,	pfe_stats,
+	"retrieve PFE statistics ",
+	"Usage:\n \
+Enable/Disable Statistics:    pfe_stat <class_gFpStatFeatureBitMask> <tmu_gFpStatFeatureBitMask> [enable | disable] [queue | interface]\n \
+Query Queue Statistics:       pfe_stat <class_gFpStatistics> <tmu_gFpStatistics> query queue <queue number> <interface number>\n \
+Query Interface Statistics:   pfe_stat <class_gFpStatistics> <tmu_gFpStatistics> query interface <interface number> "
+);
+#endif
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/common/cmd_socinfo.c u-boot-2013.01.new/common/cmd_socinfo.c
--- u-boot-2013.01/common/cmd_socinfo.c	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/common/cmd_socinfo.c	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,49 @@
+#include <common.h>
+#include <command.h>
+
+extern version_string[];
+
+static int do_socinfo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+        int clk;
+	int c2k_rev;
+#if defined(CONFIG_COMCERTO_DDR_TRAINING)
+	unsigned char wdqs[4];
+	unsigned char rdqs[4];
+#endif
+
+	printf ("-----------------------------\n");
+	printf ("\n%s\n", version_string);
+
+	printf ("PLL0: %0d, PLL1: %0d, PLL2: %0d, PLL3: %0d MHz\n",
+		HAL_get_pll_freq(0), HAL_get_pll_freq(1), HAL_get_pll_freq(2), HAL_get_pll_freq(3));
+
+	clk = HAL_get_arm_clk(); 
+	printf ("ARM Clock: %0d MHz\n", clk);
+
+	clk = HAL_get_axi_clk();
+	printf ("AXI Clock: %d MHz\n", clk);
+
+	clk = HAL_get_ddr_clk();
+	printf ("DDR Clock: %d MHz\n", clk);
+
+	clk = HAL_get_ipsec_clk();
+	printf ("IPSEC Clock: %d MHz\n", clk);
+
+	c2k_rev = HAL_get_c2k_revision();
+
+	if (c2k_rev <= 1)
+		printf ("C2K Revision: %s\n", (c2k_rev == 0) ? "A0":"A1");
+	else
+		printf ("C2K Revision: %04d\n", c2k_rev);
+
+	printf ("-----------------------------\n");
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	socinfo, 1, 0,	do_socinfo,
+	"print SoC info",
+	""
+);
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/common/cmd_update_spi.c u-boot-2013.01.new/common/cmd_update_spi.c
--- u-boot-2013.01/common/cmd_update_spi.c	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/common/cmd_update_spi.c	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,399 @@
+/*
+ * test_spi.c
+ *
+ */
+
+#include <malloc.h>
+#include <spi.h>
+#include <asm/arch/comcerto_spi.h>
+#include <common.h>
+#include <linux/list.h>
+#include <linux/types.h>
+#include <linux/compat.h>
+#include <command.h>
+#include <config.h>
+
+#define BUF_SIZE	4
+#define CHIP_SELECT_S25FL064A	0
+
+unsigned int cs = CHIP_SELECT_S25FL064A;
+
+extern int c2k_spi_read(u8 cs, void *buf, size_t len);
+extern int c2k_spi_write(u8 cs, const void *buf, size_t len);
+extern int c2k_spi_write_then_read(u8 cs, const void *tx_buf, size_t tx_len, void *rx_buf, size_t rx_len);
+
+extern int spi_eeprom_read(/*struct spi_device *spi,\*/
+                const void *txbuf, unsigned n_tx,\
+                void *rxbuf, unsigned n_rx);
+
+static struct spi_device *ls_spi;
+unsigned int erase_glob = 0;
+
+#ifdef	DEBUG
+void print_buffer(char *buf, int s)
+{
+	int i = 0;
+
+	printk ("Buffer: ");
+	while(i < s){
+		printk ("0x%x:", *buf++);
+		i++;
+	}
+	printk ("\n");
+}
+#endif
+
+u8 read_rdsr(u8 cs)
+{
+        int ret = 0;
+        uint8_t s25fl128_rdsr_cmd[4] = {
+                0x05, 0xa, 0xb, 0xc
+        };
+
+        ret = c2k_spi_write_then_read(cs, s25fl128_rdsr_cmd, 2, s25fl128_rdsr_cmd+2, 2);
+        if(ret)
+        {
+                printk ("%s:%d: RDSR failed.\n", __func__, __LINE__);
+                return -1;
+        }
+
+        return s25fl128_rdsr_cmd[3];
+}
+
+/* Erase sector_num sector */
+int nor_s25fl128_sector_erase(u8 cs, int sector_num)
+{
+	/* S25FL128: wren_cmd: |1B_cmd| */
+	uint8_t s25fl128_wren_cmd[BUF_SIZE] = {
+		0x06, 0x00, 0x00, 0x00,
+	};
+ 	/* S25FL128: erase_cmd: |1B_cmd|3B_addr| */
+	uint8_t s25fl128_erase_cmd[BUF_SIZE] = {
+	 	0xd8, 0x00, 0x00, 0x00,
+	};
+
+        int sector_addr = sector_num * SPI_FLASH_SECTOR_SIZE;
+        u8 rdsr = 0x1;
+        int ret = 0;
+
+        s25fl128_erase_cmd[1] = ((sector_addr & 0xff0000)>>16);
+        s25fl128_erase_cmd[2] = ((sector_addr & 0xff00)>>8);
+        s25fl128_erase_cmd[3] = (sector_addr & 0xff);
+
+        do {
+                rdsr = read_rdsr(cs);
+        }while (rdsr & 0x1);
+
+        ret = c2k_spi_write(cs, s25fl128_wren_cmd, 1);
+        if(ret)
+        {
+                printk ("%s:WREN failed.\n", __func__);
+                return ret;
+        }
+
+        do {
+                rdsr = read_rdsr(cs);
+        }while (!(rdsr & 0x2));
+
+	if (!erase_glob) {
+		ret = c2k_spi_write(cs, s25fl128_erase_cmd, 4);
+		if(ret)
+		{
+			printk ("%s:ERASE failed.\n", __func__);
+			return ret;
+		}
+
+		do {
+			rdsr = read_rdsr(cs);
+		}while (rdsr & 0x1);
+
+		printk ("Erasing Done.\n");
+
+		return ret;
+	}else
+		return 0;
+
+}
+
+int spi_sector_erase(int sec, int num_sec)
+{
+	int ret = 0;
+
+	num_sec += sec;
+
+	while(sec < num_sec){
+		printk ("%s: erase sector %d\n", __func__, sec);
+		ret = nor_s25fl128_sector_erase(cs, sec++);
+		if(ret)
+		{
+			printk ("%s: failed.\n", __func__);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(spi_sector_erase);
+
+#define	WRITE_BYTES	8
+int write_bytes_page_addr(struct spi_device *spi, u8 *b, int num_buytes, u8 p, unsigned int a)
+{
+	/* S25FL128: pp_cmd: |1B_cmd|3B_addr|at_least_1B_data|erite_buf| */
+	uint8_t s25fl128_pp_cmd[4+WRITE_BYTES] = {
+		0x02, 0x00, 0x00, 0x00,
+	};
+	/* S25FL128: wren_cmd: |1B_cmd| */
+	uint8_t s25fl128_wren_cmd[BUF_SIZE] = {
+		0x06, 0x00, 0x00, 0x00,
+	};
+
+        int ret = 0;
+        u8 rdsr = 0x1;
+
+        int addr = (SPI_FLASH_SECTOR_SIZE * p)+a;
+        s25fl128_pp_cmd[1] = ((addr & 0xff0000)>>16);
+        s25fl128_pp_cmd[2] = ((addr & 0xff00)>>8);
+        s25fl128_pp_cmd[3] = (addr & 0xff);
+
+	memcpy(s25fl128_pp_cmd+4, b, num_buytes);
+
+        do {
+                rdsr = read_rdsr(cs);
+        }while (rdsr & 0x1);
+
+        ret = c2k_spi_write(cs, s25fl128_wren_cmd, 1);
+        if(ret)
+        {
+                printk ("%s:WREN failed.\n", __func__);
+                return ret;
+        }
+
+        do {
+                rdsr = read_rdsr(cs);
+        }while (!(rdsr & 0x2));
+
+        ret = c2k_spi_write(cs, s25fl128_pp_cmd, 4+num_buytes);
+        if(ret)
+        {
+                printk ("%s:PP failed.\n", __func__);
+                return ret;
+        }
+
+        do {
+                rdsr = read_rdsr(cs);
+        }while (rdsr & 0x1);
+
+        return ret;
+}
+
+#define	READ_BYTES	8
+int read_bytes_page_addr(struct spi_device *spi, u8 *b, int num_buytes, u8 p, unsigned int a)
+{
+        int ret = 0;
+        u8 rdsr = 0x1;
+	/* S25FL128: rd_cmd: |1B_cmd|3B_addr|dummy_bytes| */
+	uint8_t s25fl128_rd_cmd[4+READ_BYTES] = {
+		0x03, 0x00, 0x00, 0x00,
+	};
+
+
+        int addr = (SPI_FLASH_SECTOR_SIZE * p)+a;
+        s25fl128_rd_cmd[1] = ((addr & 0xff0000)>>16);
+        s25fl128_rd_cmd[2] = ((addr & 0xff00)>>8);
+        s25fl128_rd_cmd[3] = (addr & 0xff);
+
+        do {
+                rdsr = read_rdsr(cs);
+        }while (rdsr & 0x1);
+
+        ret = c2k_spi_write_then_read(cs, s25fl128_rd_cmd, 4+num_buytes, b, 4+num_buytes);
+        if(ret)
+        {
+                printk ("%s:Read failed.\n", __func__);
+                return ret;
+        }
+
+        do {
+                rdsr = read_rdsr(cs);
+        }while (rdsr & 0x1);
+
+        return ret;
+}
+
+static int spi_copy_write(char *src, unsigned int len, unsigned int sec, unsigned int off)
+{
+	unsigned int l=0;
+	int ret = 0;
+
+
+	ret = nor_s25fl128_sector_erase(cs, sec);
+	if(ret)
+	{
+		printk ("%s: failed.\n", __func__);
+		return ret;
+	}
+
+	while (l < (len/WRITE_BYTES))
+	{
+		ret = write_bytes_page_addr(cs, src, WRITE_BYTES, sec, off);
+		if(ret)
+		{
+			printk ("%s: failed.\n", __func__);
+			return ret;
+		}
+		src += WRITE_BYTES;
+		off += WRITE_BYTES;
+		l++;
+	}
+
+	if(len%WRITE_BYTES)
+	{
+		l = len%WRITE_BYTES;
+
+		ret = write_bytes_page_addr(ls_spi, src, l, sec, off);
+		if(ret)
+		{
+			printk ("%s: failed.\n", __func__);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+int spi_copy_read(char *dst, unsigned int len, unsigned int sec, unsigned int off)
+{
+	unsigned int l=0;
+	int ret = 0;
+	char tmp[4+READ_BYTES];
+
+	while (l < (len/READ_BYTES))
+	{
+		ret = read_bytes_page_addr(ls_spi, tmp, READ_BYTES, sec, off);
+		if(ret)
+		{
+			printk ("%s: failed.\n", __func__);
+			return ret;
+		}
+
+		memcpy(dst, tmp+4, READ_BYTES);
+
+		dst += READ_BYTES;
+		off += READ_BYTES;
+		l++;
+	}
+
+	if(len%READ_BYTES)
+	{
+		l = len%READ_BYTES;
+
+		ret = read_bytes_page_addr(ls_spi, tmp, l, sec, off);
+		if(ret)
+		{
+			printk ("%s: failed.\n", __func__);
+			return ret;
+		}
+		memcpy(dst, tmp+4, l);
+		dst += l;
+		off += l;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(spi_copy_read);
+
+static void comcerto_spi_flash_write(unsigned char *src, ulong sec, ulong offset, ulong count)
+{
+	int wl = 0;
+	unsigned int off = 0;
+	unsigned int itr = SPI_FLASH_SECTOR_SIZE/SPI_FLASH_NOR_PAGE_SIZE;
+	int write_bytes = SPI_FLASH_NOR_PAGE_SIZE;
+	unsigned int *ptr_w;
+	int s;
+	ulong size;
+
+	ptr_w = (unsigned int *)src;
+	s = sec;
+	size = count;
+	off = offset;
+
+	while(size)
+	{
+		itr = SPI_FLASH_SECTOR_SIZE/SPI_FLASH_NOR_PAGE_SIZE;
+		erase_glob=0;
+
+		if(size < SPI_FLASH_SECTOR_SIZE) {
+			if(size%write_bytes)
+				itr = size/write_bytes + 1;
+			else
+				itr = size/write_bytes;
+
+			size = 0;
+		} else {
+			size -= SPI_FLASH_SECTOR_SIZE;
+		}
+
+		for (wl = 0 ; wl < itr ; wl++)
+		{
+			spi_copy_write((char*)ptr_w, write_bytes, s, off);
+
+			erase_glob=1;
+			ptr_w += 64;
+			off += write_bytes;
+			printk ("#");
+		}
+		printk ("\nWrote %d bytes at sec %d in %d iterations.\n", \
+				write_bytes*itr, s, itr);
+		s++;
+		off = 0;
+	}
+}
+
+int update_spi_flash(unsigned char *src, ulong sec, ulong off, ulong count)
+{
+	comcerto_spi_flash_write(src, sec, off, count);
+
+        return 0;
+}
+
+EXPORT_SYMBOL(update_spi_flash);
+
+static int do_update_spi(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+        ulong   src, offset, count, sec;
+
+        if (argc != 5) {
+                printk ("Usage:\n%s\n", cmdtp->usage);
+                return 1;
+        }
+
+	printk ("Updating SPI-Flash...\n");
+
+        src = simple_strtoul(argv[1], NULL, 16);
+
+        sec = simple_strtoul(argv[2], NULL, 16);
+
+        offset = simple_strtoul(argv[3], NULL, 16);
+
+        count = simple_strtoul(argv[4], NULL, 16);
+
+        if (count == 0) {
+                puts ("Zero length ???\n");
+                return -1;
+        }
+
+	if(update_spi_flash((unsigned char*)src, sec, offset, count) < 0)
+	{
+		printk("ERROR: NOR Update FAIL !!\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	update_spi, 5, 5,	do_update_spi,
+	"Update SPI flash.",
+	"update_spi <src> <sec> <off> <size>"
+);
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/common/env_comcerto_sf.c u-boot-2013.01.new/common/env_comcerto_sf.c
--- u-boot-2013.01/common/env_comcerto_sf.c	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/common/env_comcerto_sf.c	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,79 @@
+#include <common.h>
+#include <environment.h>
+#include <malloc.h>
+#include <spi_flash.h>
+#include <search.h>
+#include <errno.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+char *env_name_spec = "SPI Flash";
+
+extern int spi_copy_read(char *, unsigned int, unsigned int, unsigned int);
+extern int update_spi_flash(unsigned char *, ulong, ulong, ulong);
+extern int spi_sector_erase(int, int);
+
+int saveenv(void)
+{
+	char	*res, *saved_buffer = NULL;
+	int	ret = 1;
+	env_t	env_new;
+	ssize_t	len;
+
+
+	res = (char *)&env_new.data;
+	len = hexport_r(&env_htab, '\0', 0, &res, ENV_SIZE, 0, NULL);
+	if (len < 0) {
+		error("Cannot export environment: errno = %d\n", errno);
+		goto done;
+	}
+	env_new.crc = crc32(0, env_new.data, ENV_SIZE);
+
+	puts("Erasing SPI flash...");
+	ret = spi_sector_erase(CONFIG_ENV_SPI_SECTOR, CONFIG_ENV_SECT_SIZE/SPI_FLASH_SECTOR_SIZE);
+	if (ret)
+		goto done;
+
+	puts("Writing to SPI flash...");
+
+	ret = update_spi_flash(&env_new, CONFIG_ENV_SPI_SECTOR, CONFIG_ENV_OFFSET, CONFIG_ENV_SIZE);
+
+	if (ret)
+		goto done;
+
+	ret = 0;
+	puts("done\n");
+
+ done:
+	if (saved_buffer)
+		free(saved_buffer);
+
+	return ret;
+}
+
+void env_relocate_spec(void)
+{
+	char buf[CONFIG_ENV_SIZE];
+	int ret;
+
+	ret = spi_copy_read(buf, CONFIG_ENV_SIZE, CONFIG_ENV_SPI_SECTOR, CONFIG_ENV_OFFSET);
+	if (ret) {
+		set_default_env("!spi_flash_read() failed");
+		return;
+	}
+
+	ret = env_import(buf, 1);
+	if (ret)
+		gd->env_valid = 1;
+	return;
+}
+
+int env_init(void)
+{
+	/* SPI flash isn't usable before relocation */
+	gd->env_addr = (ulong)&default_environment[0];
+	gd->env_valid = 1;
+
+	return 0;
+}
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/common/Makefile u-boot-2013.01.new/common/Makefile
--- u-boot-2013.01/common/Makefile	2013-01-16 03:17:42.000000000 +0530
+++ u-boot-2013.01.new/common/Makefile	2016-03-23 16:10:34.000000000 +0530
@@ -61,6 +61,7 @@
 COBJS-$(CONFIG_ENV_IS_IN_NVRAM) += env_nvram.o
 COBJS-$(CONFIG_ENV_IS_IN_ONENAND) += env_onenand.o
 COBJS-$(CONFIG_ENV_IS_IN_SPI_FLASH) += env_sf.o
+COBJS-$(CONFIG_ENV_IS_IN_C2K_SPI_FLASH) += env_comcerto_sf.o
 COBJS-$(CONFIG_ENV_IS_IN_REMOTE) += env_remote.o
 COBJS-$(CONFIG_ENV_IS_NOWHERE) += env_nowhere.o
 
@@ -133,6 +134,8 @@
 ifdef CONFIG_PHYLIB
 COBJS-$(CONFIG_CMD_MII) += cmd_mdio.o
 endif
+COBJS-$(CONFIG_CMD_PFE_COMMANDS) += cmd_pfe_commands.o
+COBJS-$(CONFIG_CMD_PFE_STATS) += cmd_pfe_stat.o
 COBJS-$(CONFIG_CMD_MISC) += cmd_misc.o
 COBJS-$(CONFIG_CMD_MMC) += cmd_mmc.o
 COBJS-$(CONFIG_CMD_MMC_SPI) += cmd_mmc_spi.o
@@ -159,6 +162,7 @@
 COBJS-$(CONFIG_CMD_SETEXPR) += cmd_setexpr.o
 COBJS-$(CONFIG_CMD_SPI) += cmd_spi.o
 COBJS-$(CONFIG_CMD_SPIBOOTLDR) += cmd_spibootldr.o
+COBJS-$(CONFIG_CMD_UPDATE_SPI) += cmd_update_spi.o
 COBJS-$(CONFIG_CMD_STRINGS) += cmd_strings.o
 COBJS-$(CONFIG_CMD_TERMINAL) += cmd_terminal.o
 COBJS-$(CONFIG_CMD_TIME) += cmd_time.o
@@ -179,6 +183,7 @@
 COBJS-$(CONFIG_CMD_SPL) += cmd_spl.o
 COBJS-$(CONFIG_CMD_ZIP) += cmd_zip.o
 COBJS-$(CONFIG_CMD_ZFS) += cmd_zfs.o
+COBJS-$(CONFIG_CMD_SOCINFO) += cmd_socinfo.o
 
 # others
 ifdef CONFIG_DDR_SPD
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/common/miiphyutil.c u-boot-2013.01.new/common/miiphyutil.c
--- u-boot-2013.01/common/miiphyutil.c	2013-01-16 03:17:42.000000000 +0530
+++ u-boot-2013.01.new/common/miiphyutil.c	2016-03-23 16:10:34.000000000 +0530
@@ -327,6 +327,58 @@
 	return 1;
 }
 
+#define COMCERTO_RGMII_DELAY
+#ifdef COMCERTO_RGMII_DELAY
+/********** MSPD Change ***********/
+
+int miiphy_debug_read(char *devname, unsigned char addr, unsigned char reg)
+{
+	unsigned int value;
+
+	if (miiphy_write (devname, addr, PHY_DEBUG_PORT_ADDRESS, reg) != 0) {
+		puts ("PHY Debug register failed\n");
+	}
+
+	if (miiphy_read (devname, addr, PHY_DEBUG_PORT_DATA, &value) != 0) {
+		puts ("PHY Debug register failed\n");
+	}
+
+	return value;
+}
+
+
+int miiphy_debug_write(char *devname, unsigned char addr, unsigned char reg, unsigned short value)
+{
+	if (miiphy_write (devname, addr, PHY_DEBUG_PORT_ADDRESS, reg) != 0) {
+		puts ("PHY Debug register failed\n");
+	}
+	if (miiphy_write (devname, addr, PHY_DEBUG_PORT_DATA, value) != 0) {
+		puts ("PHY Debug register failed\n");
+	}
+}
+
+void miiphy_enable_rgmii_rx_delay(char *devname, unsigned char addr)
+{
+        uint16_t val;
+        //enable RxClk delay
+        val = miiphy_debug_read(devname, addr, 0x0);
+        val |= 0x8000;
+        miiphy_debug_write(devname, addr, 0x0, val);
+}
+
+void miiphy_enable_rgmii_tx_delay(char *devname, unsigned char addr)
+{
+        uint16_t val;
+        //enable TxClk delay
+        val = miiphy_debug_read(devname, addr, 0x5);
+        val |= 0x100;
+        miiphy_debug_write(devname, addr, 0x5, val);
+}
+/************/
+#endif
+
+
+
 /*****************************************************************************
  *
  * Print out list of registered MII capable devices.
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/config.mk u-boot-2013.01.new/config.mk
--- u-boot-2013.01/config.mk	2013-01-16 03:17:42.000000000 +0530
+++ u-boot-2013.01.new/config.mk	2016-03-23 16:10:35.000000000 +0530
@@ -252,6 +252,13 @@
 CFLAGS_STACK := $(call cc-option,-fstack-usage)
 CFLAGS += $(CFLAGS_STACK)
 
+ifeq ($(M_NO_UNALIGNED_ACCESS),y)
+# GCC 4.8 linaro toolchain require this option.
+# if -mno-unaligned-access is enabled then words in packed data structures
+# will be accessed a byte at a time.
+CFLAGS += $(call cc-option,-mno-unaligned-access,)
+endif
+
 # $(CPPFLAGS) sets -g, which causes gcc to pass a suitable -g<format>
 # option to the assembler.
 AFLAGS_DEBUG :=
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/mtd/nand/comcerto_nand.c u-boot-2013.01.new/drivers/mtd/nand/comcerto_nand.c
--- u-boot-2013.01/drivers/mtd/nand/comcerto_nand.c	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/mtd/nand/comcerto_nand.c	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,956 @@
+/*
+ *  drivers/mtd/nand/comcerto-nand.c
+ *
+ *  Copyright (C) Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Overview:
+ *   Device driver for the NAND flash device found on the
+ *   Comcerto board.
+ *
+ */
+
+#include <common.h>
+#include <errno.h>
+#include <malloc.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+
+#include <asm/arch/gpio.h>
+#include <asm/arch/comcerto-2000.h>
+#include <asm/arch/comcerto-common.h>
+#include <asm/arch/exp-bus.h>
+#include <asm/arch/ecc.h>
+
+#include "nand.h"
+
+#ifndef CONFIG_COMCERTO_NAND_ULOADER
+
+#define BBD_ID_0		0xDEADBEEF
+#define BBD_ID_1		0xECC0ECC0
+#define MAX_BLOCKS_WITH_BBT	12
+#define MAX_NO_SBL_COPIES	6
+#define MAX_INHERITED_BAD_BLK	16 /* for boot sector */
+
+#define BBT_STRUCT_SIZE_EXCLUDING_BLK_MARK (9 * 4 + sizeof(struct boot_sector_layout))
+#define ECC_BLK_MARK_SET_0_SIZE (1024 - BBT_STRUCT_SIZE_EXCLUDING_BLK_MARK)
+
+#define IRAM_PAYLOAD_SEGMENT_SIZE	0xC000
+
+#endif /* CONFIG_COMCERTO_NAND_ULOADER */
+
+uint32_t temp_nand_ecc_errors[4];
+
+#if defined (CONFIG_NAND_COMCERTO_ECC_24_HW_BCH)
+/*
+ * spare area layout for BCH ECC bytes calculated over 512-Bytes ECC block size
+ */
+static struct nand_ecclayout comcerto_ecc_info_512_bch = {
+	.eccbytes = 42,
+	.eccpos = {0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10,
+		  11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
+		  21, 22, 23, 24, 25, 26, 27, 28, 29, 30,
+		  31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41},
+	.oobfree = {
+		{.offset = 43, .length = 13}
+	}
+};
+
+/*
+ * spare area layout for BCH ECC bytes calculated over 1024-Bytes ECC block size
+ */
+static struct nand_ecclayout comcerto_ecc_info_1024_bch = {
+	.eccbytes = 42,
+	.eccpos = {0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10,
+		  11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
+		  21, 22, 23, 24, 25, 26, 27, 28, 29, 30,
+		  31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41},
+	.oobfree = {
+		{.offset = 43, .length = 13}
+	}
+};
+
+#elif defined (CONFIG_NAND_COMCERTO_ECC_8_HW_BCH)
+
+/*
+ * spare area layout for BCH ECC bytes calculated over 512-Bytes ECC block size
+ */
+static struct nand_ecclayout comcerto_ecc_info_512_bch = {
+	.eccbytes = 14,
+	.eccpos = {0, 1, 2, 3, 4, 5, 6,
+		   7, 8, 9, 10, 11, 12, 13},
+	.oobfree = {
+		{.offset = 14, .length = 2}
+	}
+};
+
+/*
+ * spare area layout for BCH ECC bytes calculated over 1024-Bytes ECC block size
+ */
+static struct nand_ecclayout comcerto_ecc_info_1024_bch = {
+	.eccbytes = 14,
+	.eccpos = {0, 1, 2, 3, 4, 5, 6,
+		   7, 8, 9, 10, 11, 12, 13},
+	.oobfree = {
+		{.offset = 14, .length = 18}
+	}
+};
+#else
+/*
+ * spare area layout for Hamming ECC bytes calculated over 512-Bytes ECC block
+ * size
+ */
+static struct nand_ecclayout comcerto_ecc_info_512_hamm = {
+	.eccbytes = 4,
+	.eccpos = {0, 1, 2, 3},
+	.oobfree = {
+		{.offset = 4, .length = 12}
+	}
+};
+
+/*
+ * spare area layout for Hamming ECC bytes calculated over 1024-Bytes ECC block
+ * size
+ */
+static struct nand_ecclayout comcerto_ecc_info_1024_hamm = {
+	.eccbytes = 4,
+	.eccpos = {0, 1, 2, 3},
+	.oobfree = {
+		{.offset = 4, .length = 28}
+	}
+};
+#endif
+
+#ifndef CONFIG_COMCERTO_NAND_ULOADER
+static uint8_t bbt_pattern[] = { 'B', 'b', 't', '0' };
+static uint8_t mirror_pattern[] = { '1', 't', 'b', 'B' };
+
+static struct nand_bbt_descr bbt_main_no_bbt_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+		| NAND_BBT_8BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP
+		| NAND_BBT_NO_OOB,
+	.len = 4,
+	.veroffs = 4,
+	.maxblocks = 8,
+	.pattern = bbt_pattern
+};
+
+static struct nand_bbt_descr bbt_mirror_no_bbt_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+		| NAND_BBT_8BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP
+		| NAND_BBT_NO_OOB,
+	.len = 4,
+	.veroffs = 4,
+	.maxblocks = 8,
+	.pattern = mirror_pattern
+};
+
+static struct nand_bbt_descr bbt_main_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+		| NAND_BBT_8BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
+	.offs = 44,
+	.len = 4,
+	.veroffs = 48,
+	.maxblocks = 8,
+	.pattern = bbt_pattern,
+};
+
+static struct nand_bbt_descr bbt_mirror_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+		| NAND_BBT_8BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
+	.offs =	44,
+	.len = 4,
+	.veroffs = 48,
+	.maxblocks = 8,
+	.pattern = mirror_pattern,
+};
+#endif /* CONFIG_COMCERTO_NAND_ULOADER */
+
+static uint8_t scan_ff_pattern[] = {0xff};
+
+#if defined (CONFIG_NAND_COMCERTO_ECC_24_HW_BCH)
+static struct nand_bbt_descr c2000_badblock_pattern = {
+	.offs = 42,
+	.len = 1,
+	.pattern = scan_ff_pattern
+};
+#elif defined (CONFIG_NAND_COMCERTO_ECC_8_HW_BCH)
+static struct nand_bbt_descr c2000_badblock_pattern = {
+	.offs = 14,
+	.len = 1,
+	.pattern = scan_ff_pattern
+};
+#else	/* Hamming */
+static struct nand_bbt_descr c2000_badblock_pattern = {
+	.offs = 4,
+	.len = 1,
+	.pattern = scan_ff_pattern
+};
+#endif
+
+
+#ifndef CONFIG_COMCERTO_NAND_ULOADER
+
+struct boot_sector_layout {
+        uint32_t nand_block_size;            /* get from nand_init           */
+        uint32_t ecc_block_size;             /* default : 512                */
+        uint32_t oob_size;                   /* default : 16                 */
+        uint32_t pri_boot_block_start_0;     /* default : 0                  */
+        uint32_t boot_block_size;            /* Multiple of ECC Block size (512) */
+        uint32_t no_of_copies;               /* default : 6                  */
+        uint32_t bbt_start_0;                /* default : 2                  */
+        uint32_t bbt_start_1;                /* default : 3                  */
+        uint32_t complete_bbt_size;          /* should not exceed size of NAND block */
+        uint32_t sec_boot_block_start;       /* default : 4                  */
+        uint32_t sec_boot_sector_size;       /* Multiple of NAND Block size  */
+};
+
+typedef struct boot_sector_layout  boot_sector_layout_t;
+
+/*
+ * Comcerto NAND flash bbt decriptors
+ */
+struct bbt_descriptor {
+        uint32_t bbt_id_0;                           /* unique identifier to identify BBT 0xDEADBEEF */
+        uint32_t bbt_id_1;                           /* unique identifier to identify BBT 0xECC0ECC0 */
+        uint32_t options;                            /* implementation dependent */
+        uint32_t bbt_max_blocks;                     /* maximum no of blocks to search for BBT */
+        uint32_t bbt_max_resv_blocks;                /* maximum no of reserved blocks to search for BBT */
+        uint32_t bbt_trail_location;                 /* */
+        uint8_t bbt_set_id;
+        uint32_t pri_boot_block_location;            /* */
+        uint8_t inherited_bb_flag;                   /* Will be set when inherited bad block is found */
+};
+
+typedef struct bbt_descriptor  bbt_descriptor_t;
+typedef struct bad_block_table bad_block_table_t;
+
+bad_block_table_t bbt_temp;
+bbt_descriptor_t bbt_desc;
+boot_sector_layout_t boot_sector;
+
+struct bad_block_table {
+        uint32_t bbt_id_0;                   /* unique identifier to identify BBT 0xDEADBEEF */
+        uint32_t bbt_id_1;                   /* unique identifier to identify BBT 0xECC0ECC0 */
+        uint8_t inherited_blk[MAX_INHERITED_BAD_BLK]; /* Stors upto 8 locations of Inherited Bad Blocks */
+        uint8_t boot_blk_split[8];
+        boot_sector_layout_t layout;    /* current flash layout structure */
+        uint32_t resrved_bbt_sec_start;      /* start location of reserved BBT sector */
+        uint8_t ecc_block_mark[ECC_BLK_MARK_SET_0_SIZE];/* size of complete BBT should be
+                                           equal to the NAND ECC block size */
+};
+
+#endif /* CONFIG_COMCERTO_NAND_ULOADER */
+/*
+ * MTD structure for Comcerto board
+ */
+struct comcerto_nand_info {
+	struct mtd_info *mtd;
+};
+
+#ifndef CONFIG_COMCERTO_NAND_ULOADER
+
+/*Scan the nand flash to find the stored BBT and copy it into RAM.
+ *
+ */
+int comcerto_scan_bbt(struct mtd_info *mtd)
+{
+	struct nand_chip *nand_device = (struct nand_chip *)(mtd->priv);
+        uint8_t bbt_blks_count;
+        uint32_t bbt_location;
+        uint32_t spare_area_size = 0;
+	uint32_t num_ecc_blks = 0;
+	size_t retlen;
+	uint32_t bbt_start, bbt_start_1;
+
+
+	bbt_start = IRAM_PAYLOAD_SEGMENT_SIZE * MAX_NO_SBL_COPIES;
+
+        if (bbt_start <= mtd->erasesize) {
+		bbt_location = 1;
+	} else {
+                bbt_start_1 = bbt_start / mtd->erasesize;
+                if ((bbt_start_1 * mtd->erasesize) < bbt_start)
+                        bbt_start_1++;
+		bbt_location = bbt_start_1;
+        }
+
+        bbt_desc.bbt_id_0 = BBD_ID_0;
+        bbt_desc.bbt_id_1 = BBD_ID_1;
+        bbt_desc.bbt_max_blocks = MAX_BLOCKS_WITH_BBT;
+
+        bbt_desc.bbt_set_id = 0;
+
+	if (nand_device->ecc.size < 512)
+		spare_area_size = 32;
+
+        num_ecc_blks = mtd->size / nand_device->ecc.size;
+
+	if (num_ecc_blks > mtd->erasesize) {
+                printk(KERN_ERR "comcerto_scan_bbt: Number of ECC blocks exceeds \
+				 single erase block size \n");
+                return 0;
+	}
+
+        /* Allocate memory (1 byte per block) and clear the memory bad block table */
+        nand_device->bbt = kzalloc(num_ecc_blks, GFP_KERNEL);
+        if (!nand_device->bbt) {
+                printk(KERN_ERR "comcerto_scan_bbt: Out of memory\n");
+                return -ENOMEM;
+        }
+
+        for (bbt_blks_count = 0; bbt_blks_count < bbt_desc.bbt_max_blocks; bbt_blks_count++) {
+		if (mtd->read(mtd, bbt_location * mtd->erasesize, nand_device->ecc.size, &retlen, (uint8_t *)&bbt_temp) > 0) {
+                        if ((bbt_temp.bbt_id_0 == bbt_desc.bbt_id_0) && (bbt_temp.bbt_id_1 == bbt_desc.bbt_id_1)) {
+                                /* Got good BBT, now download remaining */
+				memcpy(nand_device->bbt, (&bbt_temp + BBT_STRUCT_SIZE_EXCLUDING_BLK_MARK), ECC_BLK_MARK_SET_0_SIZE);
+				if (mtd->read(mtd, bbt_location * mtd->erasesize + nand_device->ecc.size + spare_area_size, \
+				num_ecc_blks - ECC_BLK_MARK_SET_0_SIZE, &retlen, (uint8_t *) (nand_device->bbt + ECC_BLK_MARK_SET_0_SIZE)) < 0)
+					continue;
+                                return 0;
+                        }else   {
+                        /* Got a good block, but BBT IDs don't match.Assuming
+			this to be a microloader and next location BBT */
+                                boot_sector.bbt_start_0 = ++bbt_location;
+                                continue;
+                        }
+                } else  {
+                        /* Got bad block, jump to next block */
+                        bbt_location++;
+                }
+	}
+
+	printk(KERN_WARNING "Bad block table not found\n");
+        return 0;
+}
+
+/*comcerto_block_isbad
+ *
+ */
+static int comcerto_block_isbad(struct mtd_info *mtd, loff_t offs)
+{
+	struct nand_chip *nand_device = (struct nand_chip *)(mtd->priv);
+	uint32_t block;
+
+
+	/* Check for invalid offset */
+        if (offs > mtd->size)
+                return -EINVAL;
+
+	block = (uint32_t) offs / mtd->erasesize;
+	if (nand_device->bbt[block] != 0xFF)
+		return 1;
+	return 0;
+}
+
+#endif /* CONFIG_COMCERTO_NAND_ULOADER */
+
+/** Disable/Enable shifting of data to parity module
+ *
+ * @param[in] en_dis_shift  Enable or disable shift to parity module.
+ *
+ */
+static void comcerto_ecc_shift(uint8_t en_dis_shift)
+{
+	writel(en_dis_shift, ECC_SHIFT_EN_CFG);
+}
+
+/** Initializes h/w ECC with proper configuration values.
+ *
+ * @param[in] mtd	MTD device structure
+ * @param[in] mode	Select between BCH and Hamming
+ *
+ */
+static void comcerto_enable_hw_ecc(struct mtd_info *mtd, int mode)
+{
+	struct nand_chip *nand_device = (struct nand_chip *)(mtd->priv);
+	uint32_t ecc_gen_cfg_val = 0;
+
+
+	/* CS4 will have the option for ECC calculation */
+	writel(ECC_CS4_SEL, ECC_CS_SEL_CFG);
+
+	/* parity calculation for write, syndrome calculation for read.*/
+	(mode == NAND_ECC_WRITE) ? (ecc_gen_cfg_val |= PRTY_CALC) : (ecc_gen_cfg_val &= SYNDROME_CALC);
+
+#if defined (CONFIG_NAND_COMCERTO_ECC_8_HW_BCH) || defined (CONFIG_NAND_COMCERTO_ECC_24_HW_BCH)
+	ecc_gen_cfg_val &= BCH_MODE;
+	ecc_gen_cfg_val = (ecc_gen_cfg_val & ~(ECC_LVL_MASK)) | (ECC_LVL_VAL << ECC_LVL_SHIFT);
+#else
+	ecc_gen_cfg_val |= HAMM_MODE;
+#endif
+
+	ecc_gen_cfg_val = (ecc_gen_cfg_val & ~(BLK_SIZE_MASK)) | nand_device->ecc.size; ;
+
+	writel(ecc_gen_cfg_val, ECC_GEN_CFG);
+	/* Reset parity module and latch configured values */
+	writel(ECC_INIT, ECC_INIT_CFG);
+	comcerto_ecc_shift(ECC_SHIFT_ENABLE);
+	return;
+}
+
+/** writes ECC bytes generated by the parity module into the flash
+ *
+ * @param[in] mtd	MTD device structure
+ * @param[in] dat	raw data
+ * @param[in] ecc_code	buffer for ECC
+ *
+ */
+static int comcerto_calculate_ecc(struct mtd_info *mtd,
+				  const uint8_t *dat,
+				  uint8_t *ecc_code)
+{
+	struct nand_chip *nand_device = mtd->priv;
+	uint32_t ecc_bytes = nand_device->ecc.bytes;
+	uint8_t dummy_var = 0xFF;
+
+	while (!(readl(ECC_IDLE_STAT)))
+		;
+
+	writel(ECC_PARITY_OUT_EN, ECC_PRTY_OUT_SEL_CFG);
+
+	/* Even though we do a dummy write to NAND flash, actual ECC bytes are
+	 * written to the ECC location in the flash. */
+	for ( ; ecc_bytes; ecc_bytes--)
+		writeb(dummy_var, nand_device->IO_ADDR_W);
+
+	comcerto_ecc_shift(ECC_SHIFT_DISABLE);
+	writel(ECC_PARITY_OUT_DISABLE, ECC_PRTY_OUT_SEL_CFG);
+
+	return 0;
+}
+
+/** Checks ECC registers for errors and will correct them, if correctable
+ *
+ * @param[in] mtd	MTD device structure
+ * @param[in] dat	raw data
+ * @param[in] read_ecc  ECC read out from flash
+ * @param[in] calc_ecc	ECC calculated over the raw data
+ *
+ */
+static int comcerto_correct_ecc(struct mtd_info *mtd, uint8_t *dat,
+		uint8_t *read_ecc, uint8_t *calc_ecc)
+{
+#if !defined (CONFIG_NAND_COMCERTO_ECC_8_HW_BCH) && !defined (CONFIG_NAND_COMCERTO_ECC_24_HW_BCH)
+	struct nand_chip *nand_device = mtd->priv;
+#else
+	uint8_t err_count = 0;
+	uint32_t err_corr_data_prev;
+#endif
+	uint32_t err_corr_data;
+	uint16_t mask, index;
+	uint32_t ecc_corr_stat = 0;
+	uint64_t start = get_timer(0);
+	int timeout = CONFIG_SYS_HZ * 2;
+
+	 /* Wait for syndrome calculation to complete */
+	do {
+		if ((readl(ECC_IDLE_STAT)) & ECC_IDLE)
+			break;
+
+	} while (get_timer(start) < timeout);
+
+	 /* If no correction is required */
+	if (likely(!(readl(ECC_POLY_STAT) & ECC_CORR_REQ))) {
+		return 0;
+	}
+
+	/* Error found! Correction required */
+#if defined (CONFIG_NAND_COMCERTO_ECC_8_HW_BCH) || defined (CONFIG_NAND_COMCERTO_ECC_24_HW_BCH)
+	udelay(15);
+
+	MTDDEBUG(MTD_DEBUG_LEVEL3, "ECC BCH Errors found!\n");
+	/* Initiate correction operation */
+	writel(ECC_POLY_START, ECC_POLY_START_CFG);
+
+	udelay(15);
+	MTDDEBUG(MTD_DEBUG_LEVEL3, "read ECC_CORR_DATA_STAT\n");
+
+	err_corr_data_prev = 0;
+	start = get_timer(0);
+	/* Read Correction data status register till header is 0x7FD */
+	do {
+		err_corr_data_prev = readl(ECC_CORR_DATA_STAT);
+		if ((err_corr_data_prev >> ECC_BCH_INDEX_SHIFT) == 0x87FD)
+			break;
+		udelay(15);
+		udelay(1);
+//		printf("Polling ECC_CORR_DATA_STAT!!!! \n");
+	} while (get_timer(start) < timeout);
+
+//	printf("read ECC_CORR_DATA_STAT!!!! \n");
+	MTDDEBUG(MTD_DEBUG_LEVEL3, "read ECC_CORR_DATA_STAT\n");
+
+	udelay(15);
+	/* start reading error locations */
+	err_corr_data = 0x0;
+
+	while (((err_corr_data >> 16) !=  0x87FE)) {
+		err_corr_data = readl(ECC_CORR_DATA_STAT);
+		if ((err_corr_data >> 16) ==  0x87FE)
+			break;
+		temp_nand_ecc_errors[0] += 1 ;
+		if (err_corr_data == err_corr_data_prev)
+			continue;
+		err_corr_data_prev = err_corr_data;
+		index = (err_corr_data >> 16) & 0x7FF;
+		mask = err_corr_data & 0xFFFF;
+		*((uint16_t *)(dat + (index * 2))) ^= mask;
+		while (mask) {
+			if (mask & 1)
+				err_count++;
+			mask >>= 1;
+		}
+	}
+
+	if (!((readl(ECC_CORR_DONE_STAT)) & ECC_DONE)) {
+		temp_nand_ecc_errors[0] += 1 ;
+		printf("ECC Correction Not done!!!! \n");
+		MTDDEBUG(MTD_DEBUG_LEVEL3, "ECC Correction Not done!!!! \n");
+		MTDDEBUG(MTD_DEBUG_LEVEL3, "No. of errors %d \n", err_count);
+		return -1;
+	}
+
+	if ((readl(ECC_CORR_STAT)) & ECC_UNCORR) {
+		temp_nand_ecc_errors[0] += 1 ;
+		printf("ECC Uncorrectable Errors found!!!! \n");
+		MTDDEBUG(MTD_DEBUG_LEVEL3, "ECC Uncorrectable Errors found!!!! \n");
+		MTDDEBUG(MTD_DEBUG_LEVEL3, "No. of errors %d \n", err_count);
+		return -EIO;
+	}
+
+	temp_nand_ecc_errors[3] += err_count;
+//	printf("No. of errors %d \n", err_count);
+	MTDDEBUG(MTD_DEBUG_LEVEL3, "No. of errors %d \n", err_count);
+	return 0;
+
+#else	/* Hamming Mode */
+	if (readl(ECC_POLY_STAT) == ECC_UNCORR_ERR_HAMM) {
+		MTDDEBUG(MTD_DEBUG_LEVEL3, "ECC Uncorrectable Errors found!!!! \n");
+		/* 2 or more errors detected and hence cannot
+		be corrected */
+		return -1; /* uncorrectable */
+	} else {  /* 1-bit correctable error */
+		MTDDEBUG(MTD_DEBUG_LEVEL3, "ECC Correctable Errors found!!!! \n");
+		err_corr_data = readl(ECC_CORR_DATA_STAT);
+		index = (err_corr_data >> 16) & 0x1FF;
+
+		if (nand_device->options & NAND_BUSWIDTH_16) {
+			mask = 1 << (err_corr_data & 0xF);
+			*((uint16_t *)(dat + index)) ^= mask;
+		} else {
+			mask = 1 << (err_corr_data & 0x7);
+			MTDDEBUG(MTD_DEBUG_LEVEL3, "index = x%x , mask = x%x \n", index, mask);
+			*(dat + index) ^= mask;
+		}
+
+		return 1;
+
+	}
+#endif
+	MTDDEBUG(MTD_DEBUG_LEVEL3, "NO ECC Errors!!!! \n");
+	return 0;
+}
+
+/** writes single page to the NAND device along with the ECC bytes
+ *
+ * @param[in] mtd	MTD device structure
+ * @param[in] chip      nand chip info structure
+ * @param[in] buf	data buffer
+ *
+ */
+static void comcerto_nand_write_page_hwecc(struct mtd_info *mtd,
+					struct nand_chip *chip,
+					const uint8_t *buf)
+{
+	int i, eccsize = chip->ecc.size;
+	int eccbytes = chip->ecc.bytes;
+	int eccsteps = chip->ecc.steps;
+	const uint8_t *p = buf;
+	uint8_t *oob = chip->oob_poi;
+
+	/* CS4 will have the option for ECC calculation */
+	writel(ECC_CS4_SEL, ECC_CS_SEL_CFG);
+
+	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
+
+		chip->ecc.hwctl(mtd, NAND_ECC_WRITE);
+		chip->write_buf(mtd, p, eccsize);
+
+		chip->ecc.calculate(mtd, p, oob);
+		oob += eccbytes;
+
+		if (chip->ecc.postpad) {
+			chip->write_buf(mtd, oob, chip->ecc.postpad);
+			oob += chip->ecc.postpad;
+		}
+	}
+
+	/* Calculate remaining oob bytes */
+	i = mtd->oobsize - (oob - chip->oob_poi);
+	if (i)
+		chip->write_buf(mtd, oob, i);
+}
+
+/** reads single page from the NAND device and will read ECC bytes from flash. A
+ * function call to comcerto_correct_ecc() will be used to validate the data.
+ *
+ * @param[in] mtd	MTD device structure
+ * @param[in] chip      nand chip info structure
+ * @param[in] buf	data buffer
+ *
+ */
+static int comcerto_nand_read_page_hwecc(struct mtd_info *mtd,
+		struct nand_chip *chip, uint8_t *buf)
+{
+	struct nand_chip *nand_device = mtd->priv;
+	int i, eccsize = nand_device->ecc.size;
+	int eccbytes = nand_device->ecc.bytes;
+	int eccsteps = nand_device->ecc.steps;
+	uint8_t *p = buf;
+	uint8_t *ecc_code = nand_device->buffers->ecccode;
+	uint8_t ecc_bytes = nand_device->ecc.bytes;
+	uint8_t stat;
+	uint8_t *oob = nand_device->oob_poi;
+
+	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
+		chip->ecc.hwctl(mtd, NAND_ECC_READ);
+		chip->read_buf(mtd, p, eccsize);
+		chip->read_buf(mtd, ecc_code, ecc_bytes);
+
+		stat = chip->ecc.correct(mtd, p, oob, NULL);
+		if (stat < 0)
+			mtd->ecc_stats.failed++;
+		else
+			mtd->ecc_stats.corrected += stat;
+
+		comcerto_ecc_shift(ECC_SHIFT_DISABLE);
+
+		if (chip->ecc.postpad) {
+			chip->read_buf(mtd, oob, chip->ecc.postpad);
+			oob += chip->ecc.postpad;
+		}
+	}
+	/* Calculate remaining oob bytes */
+	i = mtd->oobsize - (oob - chip->oob_poi);
+	if (i)
+		chip->read_buf(mtd, oob, i);
+
+	return 0;
+}
+
+#ifdef CONFIG_COMCERTO_NAND_ERASE_FBB
+/* Erase False Bad Blocks created due to the difference in ECC layouts */
+int erase_old_nand_fmt(struct mtd_info *mtd, u8 bb_old_layout)
+{
+
+	struct nand_chip *nand_device = mtd->priv;
+	unsigned int page_addr, page;
+	u_char status;
+
+	printf("erase_old_nand_fmt: Erasing old nand format\n");
+
+	if (bb_old_layout == 0) {
+
+	static struct nand_bbt_descr c2000_badblock_pattern_old = {
+		.offs = 14,
+		.len = 1,
+		.pattern = scan_ff_pattern
+	};
+
+	nand_device->badblock_pattern = &c2000_badblock_pattern_old;
+	} else {
+
+		memset(&nand_device->ecc, 0, sizeof(struct nand_ecc_ctrl));
+		nand_device->ecc.mode = NAND_ECC_SOFT_BCH;
+
+		/* Scan to find existence of the device */
+		if (nand_scan_ident(mtd, 1, NULL)) {
+			printf("nand_scan_ident failed \n");
+			return -1;
+		}
+	}
+
+	/* second phase scan */
+	if (nand_scan_tail(mtd)) {
+		printf("nand_scan_tail failed \n");
+	}
+}
+#endif /* CONFIG_COMCERTO_NAND_ERASE_FBB */
+
+
+/** Hardware specific access to NAND control-lines
+ *
+ * @param[in] mtd	MTD device structure
+ * @param[in] cmd	NAND command to the controller
+ * @param[in] ctrl	control address/command latch
+ *
+ */
+static void comcerto_nand_hwcontrol(struct mtd_info *mtd, int cmd,
+						unsigned int ctrl)
+{
+	struct nand_chip *chip = mtd->priv;
+
+
+	if (ctrl & NAND_CTRL_CHANGE) {
+		if (ctrl & NAND_NCE)
+			comcerto_gpio_set_0(COMCERTO_NAND_CE);
+		else
+			comcerto_gpio_set_1(COMCERTO_NAND_CE);
+	}
+
+	if (cmd == NAND_CMD_NONE)
+		return;
+
+	if (ctrl & NAND_CLE)
+		writeb(cmd, chip->IO_ADDR_W + COMCERTO_NAND_CLE);
+	else if (ctrl & NAND_ALE)
+		writeb(cmd,  chip->IO_ADDR_W + COMCERTO_NAND_ALE);
+	else
+		return;
+}
+
+/** Checks whether the NAND flash is ready or not
+ *
+ * @param[in] mtd	MTD device structure
+ *
+ */
+static int comcerto_nand_ready(struct mtd_info *mtd)
+{
+	return comcerto_gpio_read(COMCERTO_NAND_RDY) ? 1 : 0;
+}
+
+/** Probes for NAND device on comcerto board.
+ *
+ * @param[in,out] pdev describes the NAND device in the system
+ *
+ */
+static int comcerto_nand_probe(int devnum/* struct nand_chip *c2000_nand_chip */)
+{
+	struct comcerto_nand_info *info;
+	struct mtd_info *mtd = &nand_info[devnum];
+	struct nand_chip *nand_device;
+	int err = 0;
+
+//	printf("nand_probe: %s base: 0x%08x size: 0x%s\n", pdev->name, pdev->map_base, size_human_readable(pdev->size));
+
+	/* Allocate memory for info structure */
+	info = malloc(sizeof(struct comcerto_nand_info));
+	if (!info) {
+		err = -ENOMEM;
+		goto out;
+	}
+	memset(info, 0, sizeof(struct comcerto_nand_info));
+
+#if 0
+	/* Allocate memory for MTD device structure */
+	mtd = malloc(sizeof(struct mtd_info));
+	if (!mtd) {
+		err = -ENOMEM;
+		goto out_info;
+	}
+	memset(mtd, 0, sizeof(struct mtd_info));
+#endif
+	/* Link info's mtd data with the initialized MTD structure */
+	info->mtd = mtd;
+
+	/* Allocate pointer to nand_device data */
+	nand_device = malloc(sizeof(struct nand_chip));
+	if (!nand_device) {
+		err = -ENOMEM;
+		goto out_mtd;
+	}
+	memset(nand_device, 0, sizeof(struct nand_chip));
+
+	/* Link the private data with the MTD structure */
+	mtd->priv = nand_device;
+
+	nand_device->IO_ADDR_R = (void __iomem *) COMCERTO_EXP_CS4_BASE_ADDR;
+	if (nand_device->IO_ADDR_R == NULL) {
+		err = -EIO;
+		goto out_nand;
+	}
+
+	/* This is the same address to read and write */
+	nand_device->IO_ADDR_W = nand_device->IO_ADDR_R;
+
+	/* Set address of hardware control function */
+	nand_device->cmd_ctrl = comcerto_nand_hwcontrol;
+	nand_device->dev_ready = comcerto_nand_ready;
+
+	/* 20 us command delay time */
+	nand_device->chip_delay = 20;
+	nand_device->ecc.mode = NAND_ECC_HW_SYNDROME;
+
+#if defined(CONFIG_MACH_COMCERTO_C2K_ASIC) && defined(CONFIG_NAND_TYPE_SLC)
+	nand_device->options = NAND_BUSWIDTH_16;
+#else
+	nand_device->options = 0;
+#endif
+	/* Scan to find existence of the device */
+	if (nand_scan_ident(mtd, 1, NULL)) {
+		err = -ENXIO;
+		goto out_nand;
+	}
+
+	if (nand_device->ecc.mode == NAND_ECC_HW_SYNDROME) {
+
+		nand_device->ecc.hwctl = comcerto_enable_hw_ecc;
+		nand_device->ecc.write_page = comcerto_nand_write_page_hwecc;
+		nand_device->ecc.read_page = comcerto_nand_read_page_hwecc;
+		nand_device->ecc.calculate = comcerto_calculate_ecc;
+		nand_device->ecc.correct = comcerto_correct_ecc;
+
+		switch (mtd->writesize) {
+		case 512:
+			nand_device->ecc.size = mtd->writesize;
+#if defined (CONFIG_NAND_COMCERTO_ECC_24_HW_BCH)
+			nand_device->ecc.layout = &comcerto_ecc_info_512_bch;
+			nand_device->ecc.bytes = 42;
+			nand_device->ecc.prepad = 0;
+			nand_device->ecc.postpad = 14;
+#elif defined (CONFIG_NAND_COMCERTO_ECC_8_HW_BCH)
+			nand_device->ecc.layout = &comcerto_ecc_info_512_bch;
+			nand_device->ecc.bytes = 14;
+			nand_device->ecc.prepad = 0;
+			nand_device->ecc.postpad = 2;
+#else
+			nand_device->ecc.layout = &comcerto_ecc_info_512_hamm;
+			nand_device->ecc.bytes = 4;
+			nand_device->ecc.prepad = 0;
+			nand_device->ecc.postpad = 2;
+#endif
+			break;
+		case 1024:
+			nand_device->ecc.size = mtd->writesize;
+#if defined (CONFIG_NAND_COMCERTO_ECC_24_HW_BCH)
+			nand_device->ecc.layout = &comcerto_ecc_info_1024_bch;
+			nand_device->ecc.bytes = 42;
+			nand_device->ecc.prepad = 0;
+			nand_device->ecc.postpad = 14;
+#elif defined (CONFIG_NAND_COMCERTO_ECC_8_HW_BCH)
+			nand_device->ecc.layout = &comcerto_ecc_info_1024_bch;
+			nand_device->ecc.bytes = 14;
+			nand_device->ecc.prepad = 0;
+			nand_device->ecc.postpad = 18;
+#else
+			nand_device->ecc.layout = &comcerto_ecc_info_1024_hamm;
+			nand_device->ecc.bytes = 4;
+			nand_device->ecc.prepad = 0;
+			nand_device->ecc.postpad = 18;
+#endif
+			break;
+		default:
+			printf("Using default values \n");
+			nand_device->ecc.size =  1024;
+#if defined (CONFIG_NAND_COMCERTO_ECC_24_HW_BCH)
+			nand_device->ecc.layout = &comcerto_ecc_info_1024_bch;
+			nand_device->ecc.bytes = 42;
+			nand_device->ecc.prepad = 0;
+			nand_device->ecc.postpad = 14;
+#elif defined (CONFIG_NAND_COMCERTO_ECC_8_HW_BCH)
+			nand_device->ecc.layout = &comcerto_ecc_info_1024_bch;
+			nand_device->ecc.bytes = 14;
+			nand_device->ecc.prepad = 0;
+			nand_device->ecc.postpad = 18;
+#else
+			nand_device->ecc.layout = &comcerto_ecc_info_1024_hamm;
+			nand_device->ecc.bytes = 4;
+			nand_device->ecc.prepad = 0;
+			nand_device->ecc.postpad = 18;
+#endif
+			break;
+		}
+	nand_device->ecc.steps = mtd->writesize / nand_device->ecc.size;
+	if(nand_device->ecc.steps * nand_device->ecc.size != mtd->writesize) {
+		printk(KERN_WARNING "Invalid ecc parameters\n");
+		BUG();
+	}
+	nand_device->ecc.total = nand_device->ecc.steps * nand_device->ecc.bytes;
+
+	nand_device->badblock_pattern = &c2000_badblock_pattern;
+
+#ifndef CONFIG_COMCERTO_NAND_ULOADER
+	nand_device->bbt_td = &bbt_main_no_bbt_descr;
+	nand_device->bbt_md = &bbt_mirror_no_bbt_descr;
+	/* update flash based bbt */
+	nand_device->options |= NAND_USE_FLASH_BBT | NAND_USE_FLASH_BBT_NO_OOB;
+#endif /* CONFIG_COMCERTO_NAND_ULOADER */
+	}
+
+#ifdef CONFIG_COMCERTO_NAND_BBT
+	nand_device->scan_bbt = comcerto_scan_bbt;
+#endif
+
+#ifndef CONFIG_COMCERTO_NAND_ULOADER
+//	nand_init_ecc_hw_syndrome(nand_device);
+#endif
+
+	nand_device->options |= NAND_NO_SUBPAGE_WRITE;
+
+	/* second phase scan */
+	if (nand_scan_tail(mtd)) {
+		err = -ENXIO;
+		goto out_nand;
+	}
+
+#ifdef CONFIG_COMCERTO_NAND_BBT
+	mtd->block_isbad = comcerto_block_isbad;
+#endif
+	uint8_t i;
+
+	for (i = 0; i < 4; i++)
+		temp_nand_ecc_errors[i] = 0;
+
+	/*Name of the mtd device */
+//	mtd->name = pdev->name;
+
+//	add_mtd_device(mtd);
+	nand_register(devnum);
+
+	err = 0;
+
+	goto out;
+
+out_nand:
+	kfree(nand_device);
+out_mtd:
+	kfree(mtd);
+out_info:
+	kfree(info);
+out:
+	return err;
+
+}
+
+#if 0
+/*
+ * Driver Registration
+ */
+
+static struct driver_d comcerto_nand_driver = {
+	.name = "comcerto_nand",
+	.probe = comcerto_nand_probe,
+};
+
+static int comcerto_nand_drv_init(void)
+{
+	return register_driver(&comcerto_nand_driver);
+}
+
+device_initcall(comcerto_nand_drv_init);
+#endif
+
+void board_nand_init(void)
+{
+//	struct nand_chip *c2000_nand = &c2000_nand_chip[0];
+
+	if (comcerto_nand_probe(0))
+		puts("Comcerto NAND init failed\n");
+}
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/mtd/nand/Makefile u-boot-2013.01.new/drivers/mtd/nand/Makefile
--- u-boot-2013.01/drivers/mtd/nand/Makefile	2013-01-16 03:17:42.000000000 +0530
+++ u-boot-2013.01.new/drivers/mtd/nand/Makefile	2016-03-23 16:10:34.000000000 +0530
@@ -78,6 +78,7 @@
 COBJS-$(CONFIG_TEGRA_NAND) += tegra_nand.o
 COBJS-$(CONFIG_NAND_OMAP_GPMC) += omap_gpmc.o
 COBJS-$(CONFIG_NAND_PLAT) += nand_plat.o
+COBJS-$(CONFIG_NAND_COMCERTO) += comcerto_nand.o
 
 else  # minimal SPL drivers
 
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/net/c2000_eth/ar8328.c u-boot-2013.01.new/drivers/net/c2000_eth/ar8328.c
--- u-boot-2013.01/drivers/net/c2000_eth/ar8328.c	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/net/c2000_eth/ar8328.c	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,459 @@
+#include <common.h>
+#include <miiphy.h>
+#include "ar8328.h"
+
+#define S17_LAN_PORT_VLAN          1
+#define S17_WAN_PORT_VLAN          2
+
+#define ENET_UNIT_GE1 1  
+#define ENET_UNIT_GE0 0 /* Connected to the switch */
+
+#define TRUE    1
+#define FALSE   0
+
+#define S17_PHY0_ADDR   0x0
+#define S17_PHY1_ADDR   0x1
+#define S17_PHY2_ADDR   0x2
+#define S17_PHY3_ADDR   0x3
+#define S17_PHY4_ADDR   0x4
+#define S17_IND_PHY 4
+
+/*
+ * Track per-PHY port information.
+ */
+typedef struct {
+    BOOL   isEnetPort;       /* normal enet port */
+    BOOL   isPhyAlive;       /* last known state of link */
+    int    ethUnit;          /* MAC associated with this phy port */
+    uint32_t phyBase;
+    uint32_t phyAddr;          /* PHY registers associated with this phy port */
+    uint32_t VLANTableSetting; /* Value to be written to VLAN table */
+} athrPhyInfo_t;
+
+/*
+ * Per-PHY information, indexed by PHY unit number
+ * MAC port 0 - CPU port 0x100
+ * All ports are connected to GE0 of the SoC MAC
+ * LAN/WAN seperation by VLAN tags (port 0-3 with VLANID 1; port 4 with VLANID 2
+ */
+static athrPhyInfo_t athrPhyInfo[] = {
+    {TRUE,   /* phy port 0 -- MAC port 1 0x200 */
+     FALSE,
+     ENET_UNIT_GE0,
+     0,
+     S17_PHY0_ADDR,
+     S17_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 1 -- MAC port 2 0x300 */
+     FALSE,
+     ENET_UNIT_GE0,
+     0,
+     S17_PHY1_ADDR,
+     S17_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 2 -- MAC port 3 0x400 */
+     FALSE,
+     ENET_UNIT_GE0,
+     0,
+     S17_PHY2_ADDR, 
+     S17_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 3 -- MAC port 4 0x500 */
+     FALSE,
+     ENET_UNIT_GE0,
+     0,
+     S17_PHY3_ADDR, 
+     S17_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 4 -- WAN port or MAC port 5 0x600 */
+     FALSE,
+     ENET_UNIT_GE1,
+     0,
+     S17_PHY4_ADDR, 
+     S17_WAN_PORT_VLAN   /* set as WAN port */
+    },
+    
+    {FALSE,  /* phy port 5 -- CPU port (no RJ45 connector) */
+     TRUE,
+     ENET_UNIT_GE0,
+     0,
+     0x00, 
+     S17_LAN_PORT_VLAN    /* Send to all ports */
+    },
+};
+
+#define S17_PHY_MAX 5
+
+/* Range of valid PHY IDs is [MIN..MAX] */
+#define S17_ID_MIN 0
+#define S17_ID_MAX (S17_PHY_MAX-1)
+
+/* Convenience macros to access myPhyInfo */
+#define S17_IS_ENET_PORT(phyUnit) (athrPhyInfo[phyUnit].isEnetPort)
+#define S17_IS_PHY_ALIVE(phyUnit) (athrPhyInfo[phyUnit].isPhyAlive)
+#define S17_ETHUNIT(phyUnit) (athrPhyInfo[phyUnit].ethUnit)
+#define S17_PHYBASE(phyUnit) (athrPhyInfo[phyUnit].phyBase)
+#define S17_PHYADDR(phyUnit) (athrPhyInfo[phyUnit].phyAddr)
+#define S17_VLAN_TABLE_SETTING(phyUnit) (athrPhyInfo[phyUnit].VLANTableSetting)
+
+int athrs17_init(char *devname)
+{
+	int phy_addr; 
+	unsigned int dummy;
+
+	//configure the RGMII
+	/* FIXME Configure broadcast ports: the configuration below
+	 * will broadcast on ports 0-5 of the switch.
+	 */
+	athrs17_reg_write(devname, S17_GLOFW_CTRL1_REG, \
+			S17_BROAD_DPALL | S17_MULTI_FLOOD_DPALL | S17_UNI_FLOOD_DPALL);
+	/* FIXME bit 30 of the PWS_REG is marked as reserved in the datasheet. */
+	athrs17_reg_write(devname, S17_PWS_REG, S17_PWS_CHIP_AR8327);
+
+	/* Set delays for MAC0 */
+	athrs17_reg_write(devname, S17_P0PAD_MODE_REG, S17_MAC0_RGMII_EN | S17_MAC0_RGMII_TXCLK_DELAY | \
+			S17_MAC0_RGMII_RXCLK_DELAY | (1 << S17_MAC0_RGMII_TXCLK_SHIFT) | \
+			(1 << S17_MAC0_RGMII_RXCLK_SHIFT));
+	/* Set bit 24 to enable MAC0 RGMII delay; set MAC6 as PHY mode (PHY4), QCA */
+	athrs17_reg_write(devname, S17_P6PAD_MODE_REG, S17_PHY4_RGMII_EN | S17_MAC6_RGMII_RXCLK_DELAY | \
+			(0 << S17_MAC6_RGMII_RXCLK_SHIFT));
+	/* Disable MAC5 and MAC6 (due to PHY4), QCA */
+	athrs17_reg_write(devname, S17_P5STATUS_REG, 0);
+	athrs17_reg_write(devname, S17_P6STATUS_REG, 0);
+
+	athrs17_reg_write(devname, S17_P0STATUS_REG, S17_PORT_STATUS_DEFAULT);
+
+	/* AR8327/AR8328 v1.0 fixup */
+	if ((athrs17_reg_read(devname, S17_MASK_CTRL_REG) & 0xffff) == S17_CHIPID_V1_0)
+	{
+		for (phy_addr = 0x0; phy_addr <= S17_PHY_MAX; phy_addr++)
+		{
+			/* For 100M waveform */
+			miiphy_debug_write(devname, phy_addr, 0x0, 0x02ea);
+			/* Turn On Gigabit Clock */
+			miiphy_debug_write(devname, phy_addr, 0x3d, 0x68a0);
+		}
+	}
+	/* Set delays for PHY4 (connected to MAC5)
+	*/
+	dummy = miiphy_debug_read(devname, S17_PHY4_ADDR, 0x0);
+	dummy |= (1 << 15); // Enable RGMII Rx clock delay
+	miiphy_debug_write(devname, S17_PHY4_ADDR, 0x0, dummy);
+	dummy = miiphy_debug_read(devname, S17_PHY4_ADDR, 0x5);
+	dummy |= (1 << 8); // Enable RGMII Tx clock delay
+	miiphy_debug_write(devname, S17_PHY4_ADDR, 0x5, dummy);
+
+
+	/* enable HOL by default */
+	for (phy_addr = 0; phy_addr < S17_MAC_MAX; phy_addr++)
+	{
+		switch (phy_addr) {
+			case 0:
+			case 5:
+			case 6:
+				athrs17_reg_write(devname, S17_PORT0_HOL_CTRL0 + phy_addr * 8, \
+						S17_HOL_CTRL0_WAN);
+				break;
+
+			default:
+				athrs17_reg_write(devname, S17_PORT0_HOL_CTRL0 + phy_addr * 8, \
+						S17_HOL_CTRL0_LAN);
+				break;
+		}
+
+		athrs17_reg_write(devname, S17_PORT0_HOL_CTRL1 + phy_addr * 8, \
+				S17_HOL_CTRL1_DEFAULT);
+	}
+
+	/* LED control */
+	athrs17_reg_write(devname, S17_LED_CTRL0_REG, 0xffb7ffb7);
+	athrs17_reg_write(devname, S17_LED_CTRL1_REG, 0xffb7ffb7);
+	athrs17_reg_write(devname, S17_LED_CTRL2_REG, 0xffb7ffb7);
+
+	printf ("%s:done\n",__func__);
+
+	return 0;
+
+}
+
+/******************************************************************************
+*
+* athrs17_phy_is_link_alive - test to see if the specified link is alive
+*
+* RETURNS:
+*    TRUE  --> link is alive
+*    FALSE --> link is down
+*/
+BOOL
+athrs17_phy_is_link_alive(char *devname,int phyUnit)
+{
+    uint16_t phyHwStatus;
+    uint32_t phyAddr;
+
+    phyAddr = S17_PHYADDR(phyUnit);
+ 
+    miiphy_read (devname, phyAddr, S17_PHY_SPEC_STATUS, &phyHwStatus);	
+
+    if (phyHwStatus & S17_STATUS_LINK_PASS)
+        return TRUE;
+
+    printf("phy%d link down\n",phyUnit);	
+    return FALSE;
+}
+
+/******************************************************************************
+*
+* athrs17_phy_stat 
+*
+*/
+
+int
+athrs17_phy_stat(char *devname)
+{
+    uint16_t  phyHwStatus;
+    uint32_t  phyAddr;
+    int       phyUnit;	
+    int       ii = 200;
+
+    for (phyUnit=0; phyUnit < S17_PHY_MAX; phyUnit++) {
+
+        phyAddr = S17_PHYADDR(phyUnit);
+
+        if (athrs17_phy_is_link_alive(devname, phyUnit)) {
+
+            do {
+		miiphy_read (devname, phyAddr, S17_PHY_SPEC_STATUS, &phyHwStatus);
+		        if(phyHwStatus & S17_STATUS_RESOLVED)
+			        break;
+                udelay(10*1000);
+            }while(--ii);
+            
+            phyHwStatus = ((phyHwStatus & S17_STATUS_LINK_MASK) >>
+                           S17_STATUS_LINK_SHIFT);
+
+	    printf("phy%d phyhwstat:%x\n",phyUnit,phyHwStatus);
+        } 
+
+    }
+    return 0;
+}
+
+/******************************************************************************
+*
+* athrs17_phy_init - reset and setup the PHY associated 
+*
+* Resets the associated PHY port.
+*
+* RETURNS:
+*    TRUE  --> associated PHY is alive
+*    FALSE --> no LINKs on this ethernet unit
+*/
+
+int
+athrs17_phy_init(char *devname, int phyUnit)
+{
+	uint16_t  phyHwStatus;
+	uint16_t  timeout;
+	int       liveLinks = 0;
+	uint32_t  phyBase = 0;
+	uint32_t  phyAddr = 0;
+
+	printf("athrs17_phy_init %d\n", phyUnit);
+
+	phyBase = S17_PHYBASE(phyUnit);
+	phyAddr = S17_PHYADDR(phyUnit);
+
+	miiphy_write(devname, phyAddr, S17_AUTONEG_ADVERT,
+			S17_ADVERTISE_ALL);
+
+	miiphy_write(devname, phyAddr, S17_1000BASET_CONTROL,
+			S17_ADVERTISE_1000FULL);
+
+	/* Reset PHYs*/
+	miiphy_write(devname, phyAddr, S17_PHY_CONTROL,
+			S17_CTRL_AUTONEGOTIATION_ENABLE 
+			| S17_CTRL_SOFTWARE_RESET);
+
+	/*
+	 * After the phy is reset, it takes a little while before
+	 * it can respond properly.
+	 */
+	//FIXME: Now since this function is called multiple time for each LAN PHY the overrall delay
+	//will also increase. Maybe this is not required as the phy status is being check 
+	//So this is subjected to change during the bringup
+	udelay(1000*1000);
+
+
+	/*
+	 * Wait up to 3 seconds for ALL associated PHYs to finish
+	 * autonegotiation.  The only way we get out of here sooner is
+	 * if ALL PHYs are connected AND finish autonegotiation.
+	 */
+
+	timeout=20;
+	for (;;) {
+		miiphy_read (devname, phyAddr, S17_PHY_CONTROL, &phyHwStatus);
+
+		if (S17_RESET_DONE(phyHwStatus)) {
+			printf(
+					("Port %d, Neg Success\n", phyUnit));
+
+			break;
+		}
+		if (timeout == 0) {
+			printf("Port %d, Negogiation timeout\n", phyUnit);
+			break;
+		}
+		if (--timeout == 0) {
+			printf("Port %d, Negogiation timeout\n", phyUnit);
+			break;
+		}
+
+		udelay(150*1000);
+	}
+
+	/*
+	 * The PHY have had adequate time to autonegotiate.
+	 * Now initialize software status.
+	 *
+	 * It's possible that some ports may take a bit longer
+	 * to autonegotiate; but we can't wait forever.  They'll
+	 * get noticed by mv_phyCheckStatusChange during regular
+	 * polling activities.
+	 */
+
+	/* fine-tune PHY 0 and PHY 1*/
+	if ((phyUnit == 0) || (phyUnit == 1))
+	{
+		miiphy_write(devname, S17_PHYADDR(phyUnit), S17_MMD_CTRL_REG, 0x3);
+		miiphy_write(devname, S17_PHYADDR(phyUnit), S17_MMD_DATA_REG, 0x8007);
+		miiphy_write(devname, S17_PHYADDR(phyUnit), S17_MMD_CTRL_REG, 0x4003);
+		miiphy_write(devname, S17_PHYADDR(phyUnit), S17_MMD_DATA_REG, 0x8315);
+	}
+
+	/* fine-tune PHYs */
+	miiphy_write(devname, S17_PHYADDR(phyUnit), S17_MMD_CTRL_REG, 0x3);
+	miiphy_write(devname, S17_PHYADDR(phyUnit), S17_MMD_DATA_REG, 0x800d);
+	miiphy_write(devname, S17_PHYADDR(phyUnit), S17_MMD_CTRL_REG, 0x4003);
+	miiphy_write(devname, S17_PHYADDR(phyUnit), S17_MMD_DATA_REG, 0x103f);
+
+	miiphy_debug_write(devname, S17_PHYADDR(phyUnit), 0x3d, 0x6860);
+	
+	/* for PHY4, QCA */
+	if (phyUnit == S17_PHY4_ADDR)
+	{
+		miiphy_debug_write(devname, S17_PHYADDR(phyUnit), 0x12, 0x4c0c);
+		miiphy_debug_write(devname, S17_PHYADDR(phyUnit), 0x0, 0x82ee);
+		miiphy_debug_write(devname, S17_PHYADDR(phyUnit), 0x5, 0x3d46);
+		miiphy_debug_write(devname, S17_PHYADDR(phyUnit), 0xb, 0xbc20);
+	}
+
+	if (athrs17_phy_is_link_alive(devname, phyUnit)) {
+		liveLinks++;
+		S17_IS_PHY_ALIVE(phyUnit) = TRUE;
+	} else {
+		S17_IS_PHY_ALIVE(phyUnit) = FALSE;
+	}
+
+//	printf("eth%d: Phy Specific Status=%4.4x\n", mdev->read(mdev, S17_PHYADDR(phyUnit),S17_PHY_SPEC_STATUS));
+//	printk("Phy setup Complete\n"); 
+
+
+}
+
+int
+athrs17_phy_setup(char *devname, int phyUnit)
+{
+	int i;
+
+        if(phyUnit == S17_PHY4_ADDR)
+        {//WAN PHY
+                athrs17_phy_init(devname, phyUnit);
+        }
+        else if(phyUnit < S17_PHY4_ADDR)
+        {//LAN PHYs
+                for(i = 0 ; i <S17_PHY4_ADDR; i++)
+                {
+                        athrs17_phy_init(devname, i);
+                }
+        }
+}
+
+
+unsigned int athrs17_reg_read(char *devname, unsigned int reg_addr)
+{
+	uint32_t reg_word_addr;
+	uint32_t phy_addr, tmp_val, reg_val;
+	uint16_t phy_val;
+	uint8_t phy_reg;
+
+	/* change reg_addr to 16-bit word address, 32-bit aligned */
+	reg_word_addr = (reg_addr & 0xfffffffc) >> 1;
+
+	/* configure register high address */
+	phy_addr = 0x18;
+	phy_reg = 0x0;
+	phy_val = (uint16_t) ((reg_word_addr >> 8) & 0x3ff);  /* bit16-8 of reg address */
+	miiphy_write (devname, phy_addr, phy_reg, phy_val);	
+
+	/* For some registers such as MIBs, since it is read/clear, we should */
+	/* read the lower 16-bit register then the higher one */
+
+	/* read register in lower address */
+	phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+	phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+	miiphy_read (devname, phy_addr, phy_reg, &reg_val);
+
+	/* read register in higher address */
+	reg_word_addr++;
+	phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+	phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+	miiphy_read (devname, phy_addr, phy_reg, &tmp_val);
+	reg_val |= (tmp_val << 16);
+
+//	printf("%s: reg 0x%x val 0x%x\n",__func__, reg_addr, reg_val);
+
+	return reg_val;   
+}
+
+void athrs17_reg_write(char *devname, unsigned int reg_addr, unsigned int reg_val)
+{
+	uint32_t reg_word_addr;
+	uint32_t phy_addr;
+	uint16_t phy_val;
+	uint8_t phy_reg;
+
+//	printf("%s: reg 0x%x val 0x%x\n",__func__, reg_addr, reg_val);
+
+	/* change reg_addr to 16-bit word address, 32-bit aligned */
+	reg_word_addr = (reg_addr & 0xfffffffc) >> 1;
+
+	/* configure register high address */
+    phy_addr = 0x18;
+    phy_reg = 0x0;
+    phy_val = (uint16_t) ((reg_word_addr >> 8) & 0x3ff);  /* bit16-8 of reg address */
+    miiphy_write (devname, phy_addr, phy_reg, phy_val);	
+
+    /* For S17 registers such as ARL and VLAN, since they include BUSY bit */
+    /* in higher address, we should write the lower 16-bit register then the */
+    /* higher one */
+
+    /* write register in lower address */
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+    phy_val = (uint16_t) (reg_val & 0xffff);
+    miiphy_write (devname, phy_addr, phy_reg, phy_val);	
+    
+    /* read register in higher address */
+    reg_word_addr++;
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+    phy_val = (uint16_t) ((reg_val >> 16) & 0xffff);
+    miiphy_write (devname, phy_addr, phy_reg, phy_val);	
+
+}
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/net/c2000_eth/ar8328.h u-boot-2013.01.new/drivers/net/c2000_eth/ar8328.h
--- u-boot-2013.01/drivers/net/c2000_eth/ar8328.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/net/c2000_eth/ar8328.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,499 @@
+#ifndef _ATHRS17_PHY_H
+#define _ATHRS17_PHY_H
+
+/*****************/
+/* PHY Registers */
+/*****************/
+#define S17_PHY_CONTROL                 0
+#define S17_PHY_STATUS                  1
+#define S17_PHY_ID1                     2
+#define S17_PHY_ID2                     3
+#define S17_AUTONEG_ADVERT              4
+#define S17_LINK_PARTNER_ABILITY        5
+#define S17_AUTONEG_EXPANSION           6
+#define S17_NEXT_PAGE_TRANSMIT          7
+#define S17_LINK_PARTNER_NEXT_PAGE      8
+#define S17_1000BASET_CONTROL           9
+#define S17_1000BASET_STATUS            10
+#define S17_MMD_CTRL_REG		13
+#define S17_MMD_DATA_REG    	        14
+#define S17_PHY_SPEC_CONTROL            16
+#define S17_PHY_SPEC_STATUS             17
+#define S17_PHY_INTR_ENABLE             18
+#define S17_PHY_INTR_STATUS             19
+#define S17_DEBUG_PORT_ADDRESS          29
+#define S17_DEBUG_PORT_DATA             30
+
+/* S17 CSR Registers */
+#define S17_MASK_CTRL_REG               0x0000
+#define S17_P0PAD_MODE_REG              0x0004
+#define S17_P5PAD_MODE_REG              0x0008
+#define S17_P6PAD_MODE_REG              0x000c
+#define S17_PWS_REG                     0x0010
+#define S17_GLOBAL_INT0_REG             0x0020
+#define S17_GLOBAL_INT1_REG             0x0024
+#define S17_GLOBAL_INTMASK0             0x0028
+#define S17_GLOBAL_INTMASK1             0x002c
+#define S17_MODULE_EN_REG               0x0030
+#define S17_MIB_REG                     0x0034
+#define S17_INTF_HIADDR_REG             0x0038
+#define S17_MDIO_CTRL_REG               0x003c
+#define S17_BIST_CTRL_REG               0x0040
+#define S17_BIST_REC_REG                0x0044
+#define S17_SERVICE_REG                 0x0048
+#define S17_LED_CTRL0_REG               0x0050
+#define S17_LED_CTRL1_REG               0x0054
+#define S17_LED_CTRL2_REG               0x0058
+#define S17_LED_CTRL3_REG               0x005c
+#define S17_MACADDR0_REG                0x0060
+#define S17_MACADDR1_REG                0x0064
+#define S17_MAX_FRAME_SIZE_REG          0x0078
+#define S17_P0STATUS_REG                0x007c
+#define S17_P1STATUS_REG                0x0080
+#define S17_P2STATUS_REG                0x0084
+#define S17_P3STATUS_REG                0x0088
+#define S17_P4STATUS_REG                0x008c
+#define S17_P5STATUS_REG                0x0090
+#define S17_P6STATUS_REG                0x0094
+#define S17_HDRCTRL_REG                 0x0098
+#define S17_P0HDRCTRL_REG               0x009c
+#define S17_P1HDRCTRL_REG               0x00A0
+#define S17_P2HDRCTRL_REG               0x00a4
+#define S17_P3HDRCTRL_REG               0x00a8
+#define S17_P4HDRCTRL_REG               0x00ac
+#define S17_P5HDRCTRL_REG               0x00b0
+#define S17_P6HDRCTRL_REG               0x00b4
+#define S17_SGMII_CTRL_REG              0x00e0
+#define S17_EEE_CTRL_REG		0x0100
+
+/* ACL Registers */
+#define S17_ACL_FUNC0_REG               0x0400
+#define S17_ACL_FUNC1_REG               0x0404
+#define S17_ACL_FUNC2_REG               0x0408
+#define S17_ACL_FUNC3_REG               0x040c
+#define S17_ACL_FUNC4_REG               0x0410
+#define S17_ACL_FUNC5_REG               0x0414
+#define S17_PRIVATE_IP_REG              0x0418
+#define S17_P0VLAN_CTRL0_REG            0x0420
+#define S17_P0VLAN_CTRL1_REG            0x0424
+#define S17_P1VLAN_CTRL0_REG            0x0428
+#define S17_P1VLAN_CTRL1_REG            0x042c
+#define S17_P2VLAN_CTRL0_REG            0x0430
+#define S17_P2VLAN_CTRL1_REG            0x0434
+#define S17_P3VLAN_CTRL0_REG            0x0438
+#define S17_P3VLAN_CTRL1_REG            0x043c
+#define S17_P4VLAN_CTRL0_REG            0x0440
+#define S17_P4VLAN_CTRL1_REG            0x0444
+#define S17_P5VLAN_CTRL0_REG            0x0448
+#define S17_P5VLAN_CTRL1_REG            0x044c
+#define S17_P6VLAN_CTRL0_REG            0x0450
+#define S17_P6VLAN_CTRL1_REG            0x0454
+
+/* Table Lookup Registers */
+#define S17_ATU_DATA0_REG               0x0600
+#define S17_ATU_DATA1_REG               0x0604
+#define S17_ATU_DATA2_REG               0x0608
+#define S17_ATU_FUNC_REG                0x060C
+#define S17_VTU_FUNC0_REG               0x0610
+#define S17_VTU_FUNC1_REG               0x0614
+#define S17_ARL_CTRL_REG                0x0618
+#define S17_GLOFW_CTRL0_REG             0x0620
+#define S17_GLOFW_CTRL1_REG             0x0624
+#define S17_GLOLEARN_LIMIT_REG          0x0628
+#define S17_TOS_PRIMAP_REG0             0x0630
+#define S17_TOS_PRIMAP_REG1             0x0634
+#define S17_TOS_PRIMAP_REG2             0x0638
+#define S17_TOS_PRIMAP_REG3             0x063c
+#define S17_TOS_PRIMAP_REG4             0x0640
+#define S17_TOS_PRIMAP_REG5             0x0644
+#define S17_TOS_PRIMAP_REG6             0x0648
+#define S17_TOS_PRIMAP_REG7             0x064c
+#define S17_VLAN_PRIMAP_REG0            0x0650
+#define S17_LOOP_CHECK_REG              0x0654
+#define S17_P0LOOKUP_CTRL_REG           0x0660
+#define S17_P0PRI_CTRL_REG              0x0664
+#define S17_P0LEARN_LMT_REG             0x0668
+#define S17_P1LOOKUP_CTRL_REG           0x066c
+#define S17_P1PRI_CTRL_REG              0x0670
+#define S17_P1LEARN_LMT_REG             0x0674
+#define S17_P2LOOKUP_CTRL_REG           0x0678
+#define S17_P2PRI_CTRL_REG              0x067c
+#define S17_P2LEARN_LMT_REG             0x0680
+#define S17_P3LOOKUP_CTRL_REG           0x0684
+#define S17_P3PRI_CTRL_REG              0x0688
+#define S17_P3LEARN_LMT_REG             0x068c
+#define S17_P4LOOKUP_CTRL_REG           0x0690
+#define S17_P4PRI_CTRL_REG              0x0694
+#define S17_P4LEARN_LMT_REG             0x0698
+#define S17_P5LOOKUP_CTRL_REG           0x069c
+#define S17_P5PRI_CTRL_REG              0x06a0
+#define S17_P5LEARN_LMT_REG             0x06a4
+#define S17_P6LOOKUP_CTRL_REG           0x06a8
+#define S17_P6PRI_CTRL_REG              0x06ac
+#define S17_P6LEARN_LMT_REG             0x06b0
+#define S17_GLO_TRUNK_CTRL0_REG         0x0700
+#define S17_GLO_TRUNK_CTRL1_REG         0x0704
+#define S17_GLO_TRUNK_CTRL2_REG         0x0708
+
+/* Queue Management Registers */
+#define S17_PORT0_HOL_CTRL0		0x0970
+#define S17_PORT0_HOL_CTRL1		0x0974
+#define S17_PORT1_HOL_CTRL0		0x0978
+#define S17_PORT1_HOL_CTRL1		0x097c
+#define S17_PORT2_HOL_CTRL0		0x0980
+#define S17_PORT2_HOL_CTRL1		0x0984
+#define S17_PORT3_HOL_CTRL0		0x0988
+#define S17_PORT3_HOL_CTRL1		0x098c
+#define S17_PORT4_HOL_CTRL0		0x0990
+#define S17_PORT4_HOL_CTRL1		0x0994
+#define S17_PORT5_HOL_CTRL0		0x0998
+#define S17_PORT5_HOL_CTRL1		0x099c
+#define S17_PORT6_HOL_CTRL0		0x09a0
+#define S17_PORT6_HOL_CTRL1		0x09a4
+
+/* Port flow control registers */
+#define S17_P0_FLCTL_REG		0x09b0
+#define S17_P1_FLCTL_REG		0x09b4
+#define S17_P2_FLCTL_REG		0x09b8
+#define S17_P3_FLCTL_REG		0x09bc
+#define S17_P4_FLCTL_REG		0x09c0
+#define S17_P5_FLCTL_REG		0x09c4
+
+/* Packet Edit registers */
+#define S17_PKT_EDIT_CTRL		0x0c00
+#define S17_P0Q_REMAP_REG0		0x0c40
+#define S17_P0Q_REMAP_REG1		0x0c44
+#define S17_P1Q_REMAP_REG0		0x0c48
+#define S17_P2Q_REMAP_REG0		0x0c4c
+#define S17_P3Q_REMAP_REG0		0x0c50
+#define S17_P4Q_REMAP_REG0		0x0c54
+#define S17_P5Q_REMAP_REG0		0x0c58
+#define S17_P5Q_REMAP_REG1		0x0c5c
+#define S17_P6Q_REMAP_REG0		0x0c60
+#define S17_P6Q_REMAP_REG1		0x0c64
+#define S17_ROUTER_VID0			0x0c70
+#define S17_ROUTER_VID1			0x0c74
+#define S17_ROUTER_VID2			0x0c78
+#define S17_ROUTER_VID3			0x0c7c
+#define S17_ROUTER_EG_VLAN_MODE		0x0c80
+
+/* L3 Registers */
+#define S17_HROUTER_CTRL_REG            0x0e00
+#define S17_HROUTER_PBCTRL0_REG         0x0e04
+#define S17_HROUTER_PBCTRL1_REG         0x0e08
+#define S17_HROUTER_PBCTRL2_REG         0x0e0c
+#define S17_WCMP_HASH_TABLE0_REG        0x0e10
+#define S17_WCMP_HASH_TABLE1_REG        0x0e14
+#define S17_WCMP_HASH_TABLE2_REG        0x0e18
+#define S17_WCMP_HASH_TABLE3_REG        0x0e1c
+#define S17_WCMP_NHOP_TABLE0_REG        0x0e20
+#define S17_WCMP_NHOP_TABLE1_REG        0x0e24
+#define S17_WCMP_NHOP_TABLE2_REG        0x0e28
+#define S17_WCMP_NHOP_TABLE3_REG        0x0e2c
+#define S17_ARP_ENTRY_CTRL_REG          0x0e30
+#define S17_ARP_USECNT_REG              0x0e34
+#define S17_HNAT_CTRL_REG               0x0e38
+#define S17_NAPT_ENTRY_CTRL0_REG        0x0e3c
+#define S17_NAPT_ENTRY_CTRL1_REG        0x0e40
+#define S17_NAPT_USECNT_REG             0x0e44
+#define S17_ENTRY_EDIT_DATA0_REG        0x0e48
+#define S17_ENTRY_EDIT_DATA1_REG        0x0e4c
+#define S17_ENTRY_EDIT_DATA2_REG        0x0e50
+#define S17_ENTRY_EDIT_DATA3_REG        0x0e54
+#define S17_ENTRY_EDIT_CTRL_REG         0x0e58
+#define S17_HNAT_PRIVATE_IP_REG         0x0e5c
+
+/* MIB counters */
+#define S17_MIB_PORT0			0x1000
+#define S17_MIB_PORT1			0x1100
+#define S17_MIB_PORT2			0x1200
+#define S17_MIB_PORT3			0x1300
+#define S17_MIB_PORT4			0x1400
+#define S17_MIB_PORT5			0x1500
+#define S17_MIB_PORT6			0x1600
+
+#define S17_MIB_RXBROAD			0x0
+#define S17_MIB_RXPAUSE			0x4
+#define S17_MIB_RXMULTI			0x8
+#define S17_MIB_RXFCSERR		0xC
+#define S17_MIB_RXALIGNERR		0x10
+#define S17_MIB_RXUNDERSIZE		0x14
+#define S17_MIB_RXFRAG			0x18
+#define S17_MIB_RX64B			0x1C
+#define S17_MIB_RX128B			0x20
+#define S17_MIB_RX256B			0x24
+#define S17_MIB_RX512B			0x28
+#define S17_MIB_RX1024B			0x2C
+#define S17_MIB_RX1518B			0x30
+#define S17_MIB_RXMAXB			0x34
+#define S17_MIB_RXTOOLONG		0x38
+#define S17_MIB_RXBYTE1			0x3C
+#define S17_MIB_RXBYTE2			0x40
+#define S17_MIB_RXOVERFLOW		0x4C
+#define S17_MIB_FILTERED		0x50
+#define S17_MIB_TXBROAD			0x54
+#define S17_MIB_TXPAUSE			0x58
+#define S17_MIB_TXMULTI			0x5C
+#define S17_MIB_TXUNDERRUN		0x60
+#define S17_MIB_TX64B			0x64
+#define S17_MIB_TX128B			0x68
+#define S17_MIB_TX256B			0x6c
+#define S17_MIB_TX512B			0x70
+#define S17_MIB_TX1024B			0x74
+#define S17_MIB_TX1518B			0x78
+#define S17_MIB_TXMAXB			0x7C
+#define S17_MIB_TXOVERSIZE		0x80
+#define S17_MIB_TXBYTE1			0x84
+#define S17_MIB_TXBYTE2			0x88
+#define S17_MIB_TXCOL			0x8C
+#define S17_MIB_TXABORTCOL		0x90
+#define S17_MIB_TXMULTICOL		0x94
+#define S17_MIB_TXSINGLECOL		0x98
+#define S17_MIB_TXEXCDEFER		0x9C
+#define S17_MIB_TXDEFER			0xA0
+#define S17_MIB_TXLATECOL		0xA4
+
+/* Register fields */
+#define S17_CHIPID_V1_0			0x1201
+#define S17_CHIPID_V1_1			0x1202
+
+#define S17_MAC0_MAC_MII_RXCLK_SEL	(1 << 0)
+#define S17_MAC0_MAC_MII_TXCLK_SEL	(1 << 1)
+#define S17_MAC0_MAC_MII_EN		(1 << 2)
+#define S17_MAC0_MAC_GMII_RXCLK_SEL	(1 << 4)
+#define S17_MAC0_MAC_GMII_TXCLK_SEL	(1 << 5)
+#define S17_MAC0_MAC_GMII_EN		(1 << 6)
+#define S17_MAC0_SGMII_EN		(1 << 7)
+#define S17_MAC0_PHY_MII_RXCLK_SEL	(1 << 8)
+#define S17_MAC0_PHY_MII_TXCLK_SEL	(1 << 9)
+#define S17_MAC0_PHY_MII_EN		(1 << 10)
+#define S17_MAC0_PHY_MII_PIPE_SEL	(1 << 11)
+#define S17_MAC0_PHY_GMII_RXCLK_SEL	(1 << 12)
+#define S17_MAC0_PHY_GMII_TXCLK_SEL	(1 << 13)
+#define S17_MAC0_PHY_GMII_EN		(1 << 14)
+#define S17_MAC0_RGMII_RXCLK_SHIFT	20
+#define S17_MAC0_RGMII_TXCLK_SHIFT	22
+#define S17_MAC0_RGMII_RXCLK_DELAY	(1 << 24)
+#define S17_MAC0_RGMII_TXCLK_DELAY	(1 << 25)
+#define S17_MAC0_RGMII_EN		(1 << 26)
+
+#define S17_MAC5_MAC_MII_RXCLK_SEL	(1 << 0)
+#define S17_MAC5_MAC_MII_TXCLK_SEL	(1 << 1)
+#define S17_MAC5_MAC_MII_EN		(1 << 2)
+#define S17_MAC5_PHY_MII_RXCLK_SEL	(1 << 8)
+#define S17_MAC5_PHY_MII_TXCLK_SEL	(1 << 9)
+#define S17_MAC5_PHY_MII_EN		(1 << 10)
+#define S17_MAC5_PHY_MII_PIPE_SEL	(1 << 11)
+#define S17_MAC5_RGMII_RXCLK_SHIFT	20
+#define S17_MAC5_RGMII_TXCLK_SHIFT	22
+#define S17_MAC5_RGMII_RXCLK_DELAY	(1 << 24)
+#define S17_MAC5_RGMII_TXCLK_DELAY	(1 << 25)
+#define S17_MAC5_RGMII_EN		(1 << 26)
+
+#define S17_MAC6_MAC_MII_RXCLK_SEL	(1 << 0)
+#define S17_MAC6_MAC_MII_TXCLK_SEL	(1 << 1)
+#define S17_MAC6_MAC_MII_EN		(1 << 2)
+#define S17_MAC6_MAC_GMII_RXCLK_SEL	(1 << 4)
+#define S17_MAC6_MAC_GMII_TXCLK_SEL	(1 << 5)
+#define S17_MAC6_MAC_GMII_EN		(1 << 6)
+#define S17_MAC6_SGMII_EN		(1 << 7)
+#define S17_MAC6_PHY_MII_RXCLK_SEL	(1 << 8)
+#define S17_MAC6_PHY_MII_TXCLK_SEL	(1 << 9)
+#define S17_MAC6_PHY_MII_EN		(1 << 10)
+#define S17_MAC6_PHY_MII_PIPE_SEL	(1 << 11)
+#define S17_MAC6_PHY_GMII_RXCLK_SEL	(1 << 12)
+#define S17_MAC6_PHY_GMII_TXCLK_SEL	(1 << 13)
+#define S17_MAC6_PHY_GMII_EN		(1 << 14)
+#define S17_PHY4_GMII_EN		(1 << 16)
+#define S17_PHY4_RGMII_EN		(1 << 17)
+#define S17_PHY4_MII_EN			(1 << 18)
+#define S17_MAC6_RGMII_RXCLK_SHIFT	20
+#define S17_MAC6_RGMII_TXCLK_SHIFT	22
+#define S17_MAC6_RGMII_RXCLK_DELAY	(1 << 24)
+#define S17_MAC6_RGMII_TXCLK_DELAY	(1 << 25)
+#define S17_MAC6_RGMII_EN		(1 << 26)
+
+#define S17_SPEED_10M			(0 << 0)
+#define S17_SPEED_100M			(1 << 0)
+#define S17_SPEED_1000M			(2 << 0)
+#define S17_TXMAC_EN			(1 << 2)
+#define S17_RXMAC_EN			(1 << 3)
+#define S17_TX_FLOW_EN			(1 << 4)
+#define S17_RX_FLOW_EN			(1 << 5)
+#define S17_DUPLEX_FULL			(1 << 6)
+#define S17_DUPLEX_HALF			(0 << 6)
+#define S17_TX_HALF_FLOW_EN		(1 << 7)
+#define S17_LINK_EN			(1 << 9)
+#define S17_FLOW_LINK_EN		(1 << 12)
+#define S17_PORT_STATUS_DEFAULT		(S17_SPEED_1000M | S17_TXMAC_EN | \
+                                        S17_RXMAC_EN | S17_TX_FLOW_EN | \
+                                        S17_RX_FLOW_EN | S17_DUPLEX_FULL | \
+                                        S17_TX_HALF_FLOW_EN)
+
+#define S17_PORT_STATUS_AZ_DEFAULT	(S17_SPEED_1000M | S17_TXMAC_EN | \
+                                        S17_RXMAC_EN | S17_TX_FLOW_EN | \
+                                        S17_RX_FLOW_EN | S17_DUPLEX_FULL)
+
+
+#define S17_HDRLENGTH_SEL		(1 << 16)
+#define S17_HDR_VALUE			0xAAAA
+
+#define S17_TXHDR_MODE_NO		0
+#define S17_TXHDR_MODE_MGM		1
+#define S17_TXHDR_MODE_ALL		2
+#define S17_RXHDR_MODE_NO		(0 << 2)
+#define S17_RXHDR_MODE_MGM		(1 << 2)
+#define S17_RXHDR_MODE_ALL		(2 << 2)
+
+#define S17_CPU_PORT_EN			(1 << 10)
+#define S17_PPPOE_REDIR_EN		(1 << 8)
+#define S17_MIRROR_PORT_SHIFT		4
+#define S17_IGMP_COPY_EN		(1 << 3)
+#define S17_RIP_COPY_EN			(1 << 2)
+#define S17_EAPOL_REDIR_EN		(1 << 0)
+
+#define S17_IGMP_JOIN_LEAVE_DP_SHIFT	24
+#define S17_BROAD_DP_SHIFT		16
+#define S17_MULTI_FLOOD_DP_SHIFT	8
+#define S17_UNI_FLOOD_DP_SHIFT		0
+#define S17_IGMP_JOIN_LEAVE_DPALL	(0x3f << S17_IGMP_JOIN_LEAVE_DP_SHIFT)
+#define S17_BROAD_DPALL			(0x3f << S17_BROAD_DP_SHIFT)
+#define S17_MULTI_FLOOD_DPALL		(0x3f << S17_MULTI_FLOOD_DP_SHIFT)
+#define S17_UNI_FLOOD_DPALL		(0x3f << S17_UNI_FLOOD_DP_SHIFT)
+
+#define S17_PWS_CHIP_AR8327             (1 << 30)
+
+/* S17_PHY_CONTROL fields */
+#define S17_CTRL_SOFTWARE_RESET                    0x8000
+#define S17_CTRL_SPEED_LSB                         0x2000
+#define S17_CTRL_AUTONEGOTIATION_ENABLE            0x1000
+#define S17_CTRL_RESTART_AUTONEGOTIATION           0x0200
+#define S17_CTRL_SPEED_FULL_DUPLEX                 0x0100
+#define S17_CTRL_SPEED_MSB                         0x0040
+
+/* For EEE_CTRL_REG */
+#define S17_LPI_DISABLE_P1		     (1 << 4)
+#define S17_LPI_DISABLE_P2		     (1 << 6)
+#define S17_LPI_DISABLE_P3		     (1 << 8)
+#define S17_LPI_DISABLE_P4		     (1 << 10)
+#define S17_LPI_DISABLE_P5		     (1 << 12)
+#define S17_LPI_DISABLE_ALL		     0x1550
+
+/* For MMD register control */
+#define S17_MMD_FUNC_ADDR			(0 << 14)
+#define S17_MMD_FUNC_DATA			(1 << 14)
+#define S17_MMD_FUNC_DATA_2			(2 << 14)
+#define S17_MMD_FUNC_DATA_3			(3 << 14)
+
+/* For phyInfo_t azFeature */
+#define S17_8023AZ_PHY_ENABLED			(1 << 0)
+#define S17_8023AZ_PHY_LINKED                   (1 << 1)
+
+/* Queue Management registe fields */
+#define S17_HOL_CTRL0_LAN		0x2a008888 /* egress priority 8, eg_portq = 0x2a */
+#define S17_HOL_CTRL0_WAN		0x2a666666 /* egress priority 6, eg_portq = 0x2a */
+#define S17_HOL_CTRL1_DEFAULT		0xc6	   /* enable HOL control */
+
+/* Packet Edit register fields */
+#define S17_ROUTER_EG_UNMOD		0x0	/* unmodified */
+#define S17_ROUTER_EG_WOVLAN		0x1	/* without VLAN */
+#define S17_ROUTER_EG_WVLAN		0x2	/* with VLAN */
+#define S17_ROUTER_EG_UNTOUCH		0x3	/* untouched */
+#define S17_ROUTER_EG_MODE_DEFAULT	0x01111111 /* all ports without VLAN */
+
+#define S17_RESET_DONE(phy_control)                   \
+    (((phy_control) & (S17_CTRL_SOFTWARE_RESET)) == 0)
+    
+/* Phy status fields */
+#define S17_STATUS_AUTO_NEG_DONE                   0x0020
+
+#define S17_AUTONEG_DONE(ip_phy_status)                   \
+    (((ip_phy_status) &                                  \
+        (S17_STATUS_AUTO_NEG_DONE)) ==                    \
+        (S17_STATUS_AUTO_NEG_DONE))
+
+/* Link Partner ability */
+#define S17_LINK_100BASETX_FULL_DUPLEX       0x0100
+#define S17_LINK_100BASETX                   0x0080
+#define S17_LINK_10BASETX_FULL_DUPLEX        0x0040
+#define S17_LINK_10BASETX                    0x0020
+
+/* Advertisement register. */
+#define S17_ADVERTISE_NEXT_PAGE              0x8000
+#define S17_ADVERTISE_ASYM_PAUSE             0x0800
+#define S17_ADVERTISE_PAUSE                  0x0400
+#define S17_ADVERTISE_100FULL                0x0100
+#define S17_ADVERTISE_100HALF                0x0080  
+#define S17_ADVERTISE_10FULL                 0x0040  
+#define S17_ADVERTISE_10HALF                 0x0020  
+
+#define S17_ADVERTISE_ALL (S17_ADVERTISE_ASYM_PAUSE | S17_ADVERTISE_PAUSE | \
+                            S17_ADVERTISE_10HALF | S17_ADVERTISE_10FULL | \
+                            S17_ADVERTISE_100HALF | S17_ADVERTISE_100FULL)
+                       
+/* 1000BASET_CONTROL */
+#define S17_ADVERTISE_1000FULL               0x0200
+
+/* Phy Specific status fields */
+#define S17_STATUS_LINK_MASK                0xC000
+#define S17_STATUS_LINK_SHIFT               14
+#define S17_STATUS_FULL_DEPLEX              0x2000
+#define S17_STATUS_LINK_PASS                 0x0400 
+#define S17_STATUS_RESOLVED                  0x0800
+#define S17_STATUS_LINK_10M			 0
+#define S17_STATUS_LINK_100M			 1
+#define S17_STATUS_LINK_1000M			 2
+
+#define S17_GLOBAL_INT_PHYMASK	 	     (1 << 15)
+
+#define S17_PHY_LINK_UP 		     0x400
+#define S17_PHY_LINK_DOWN 		     0x800
+#define S17_PHY_LINK_DUPLEX_CHANGE 	     0x2000
+#define S17_PHY_LINK_SPEED_CHANGE	     0x4000
+#define S17_PHY_LINK_INTRS		     (S17_PHY_LINK_UP | S17_PHY_LINK_DOWN \
+                                              | S17_PHY_LINK_DUPLEX_CHANGE | S17_PHY_LINK_SPEED_CHANGE)
+
+/* For Port flow control registers */
+#define S17_PORT_FLCTL_XON_DEFAULT		(0x3a << 16)
+#define S17_PORT_FLCTL_XOFF_DEFAULT		(0x4a)
+
+/* Module enable Register */
+#define S17_MODULE_L3_EN		(1 << 2)
+#define S17_MODULE_ACL_EN		(1 << 1)
+#define S17_MODULE_MIB_EN		(1 << 0)
+
+/* MIB Function Register 1 */
+#define S17_MIB_FUNC_ALL		(3 << 24)
+#define S17_MIB_CPU_KEEP		(1 << 20)
+#define S17_MIB_BUSY			(1 << 17)
+#define S17_MIB_AT_HALF_EN		(1 << 16)
+#define S17_MIB_TIMER_DEFAULT		0x100
+
+#define S17_MAC_MAX			7
+
+/* enable 802.3az */
+#define S17_8023AZ_FEATURE
+
+#ifndef BOOL
+#define BOOL    int
+#endif
+
+/*add feature define here*/
+/* To enable the SSDK full feature set */
+//#define S17_FULL_FEATURE
+/* AR8327/8328N HNAT feature */
+//#define CONFIG_ATHRS17_HNAT
+/* dump MIB counters */
+#define S17_DUMP_MIB
+
+int athrs17_init(char *devname);
+int athrs17_phy_setup(char *devname, int phyUnit);
+unsigned int athrs17_reg_read(char *devname, unsigned int reg_addr);
+void athrs17_reg_write(char *devname, unsigned int reg_addr, unsigned int reg_val);
+unsigned int athrs17_phy_debug_read(char *devname, unsigned int phy_addr, unsigned int reg_addr);
+void athrs17_phy_debug_write(char *devname, unsigned int phy_addr, unsigned int reg_addr, unsigned int reg_val);
+
+#endif
+
+
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/net/c2000_eth/c2000_ethernet.c u-boot-2013.01.new/drivers/net/c2000_eth/c2000_ethernet.c
--- u-boot-2013.01/drivers/net/c2000_eth/c2000_ethernet.c	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/net/c2000_eth/c2000_ethernet.c	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,479 @@
+#include <common.h>
+#include <config.h>
+#include <asm/arch/hardware.h>
+#include <asm/byteorder.h>
+#include <net.h>
+#include <command.h>
+#include <miiphy.h>
+#include <asm/arch/clkcore.h>
+#include <asm/arch/gpio.h>
+#include "c2000_eth.h"
+#ifdef CONFIG_AR8328_SWITCH
+#include "ar8328.h"
+#endif
+
+struct gemac_s gem_info[] = {
+        /* PORT_0 configuration */
+        {
+                /* GEMAC config */
+                .gemac_mode = RGMII,
+                .gemac_speed = SPEED_1000M,
+                .gemac_duplex = DUPLEX_FULL,
+                .flags = EMAC0_FLAGS,
+
+                /* phy iface */
+                .phy_reg_index = EMAC_PORT_0,
+                .phy_address = EMAC0_PHY_ADDR,
+        },
+        /* PORT_1 configuration */
+        {
+                /* GEMAC config */
+                .gemac_mode = RGMII,
+                .gemac_speed = SPEED_1000M,
+                .gemac_duplex = DUPLEX_FULL,
+                .flags = EMAC1_FLAGS,
+
+                /* phy iface */
+                .phy_reg_index = EMAC_PORT_0,
+                .phy_address = EMAC1_PHY_ADDR,
+        },
+
+        /* PORT_2 configuration */
+        {
+                /* GEMAC config */
+                .gemac_mode = RGMII,
+                .gemac_speed = SPEED_1000M,
+                .gemac_duplex = DUPLEX_FULL,
+                .flags = EMAC2_FLAGS,
+
+                /* phy iface */
+                .phy_reg_index = EMAC_PORT_0,
+                .phy_address = 0,
+        },
+};
+
+#define MAX_GEMACS      3
+
+static struct c2000_eth_dev *gemac_list[MAX_GEMACS];
+
+/********************************************************************
+ * Helper functions for phy read/write
+ *******************************************************************/
+
+/* Max MII register/address (we support) */
+#define MII_REGISTER_MAX  31
+#define MII_ADDRESS_MAX   31
+
+#define MDIO_TIMEOUT    5000
+
+/********************************************************************
+ * gem_phy_man_rd :
+ *      Performs phy management read operation.
+ *******************************************************************/
+static int gem_phy_man_rd(struct c2000_eth_dev *priv, u32 phy_addr, u32 phy_reg)
+{
+        u32 write_data;
+
+        write_data = 0x60020000 | ( (phy_addr & (u32) 0x1f) << 23) | ( (phy_reg & (u32) 0x1f) << 18); // read_op
+        writel(write_data, priv->phyregisters + EMAC_PHY_MANAGEMENT);
+
+        return 0;
+}
+
+static int gem_phy_man_wr(struct c2000_eth_dev *priv, u32 phy_addr, u32 phy_reg, u32 val)
+{
+        u32 write_data;
+
+        write_data =  0x50020000 | ( (phy_addr & (u32) 0x1f) << 23) | ( (phy_reg & (u32) 0x1f) << 18) | (val & (u32) 0xffff); // write_op
+        writel(write_data, priv->phyregisters + EMAC_PHY_MANAGEMENT);
+
+        return 0;
+}
+
+/** gem_phy_man_data
+ *      Read the data section of phy management register.
+ *    After a successful read opeeration the data will be stored in
+ *    in this register in lower 16bits.
+ */
+static u32 gem_phy_man_data(struct c2000_eth_dev *priv)
+{
+        u32 value;
+
+        value = readl(priv->phyregisters + EMAC_PHY_MANAGEMENT) & 0xFFFF;
+        return value;
+}
+
+#define EMAC_PHY_IDLE   (1 << 2)
+
+static int gem_phy_man_idle(struct c2000_eth_dev *priv)
+{
+        u32 value;
+
+        value = readl(priv->phyregisters + EMAC_NETWORK_STATUS);
+        return ((value & EMAC_PHY_IDLE) == EMAC_PHY_IDLE);
+}
+
+static int gem_phy_timeout(struct c2000_eth_dev *priv, int timeout)
+{
+        while(!gem_phy_man_idle(priv)) {
+
+                if (timeout-- <= 0) {
+                        printf("Phy MDIO read/write timeout\n");
+                        return -1;
+                }
+
+                //udelay(1);
+        }
+        return 0;
+}
+
+static struct c2000_eth_dev* get_gemac(char *devname)
+{
+        int i;
+
+        for (i = 0; i < MAX_GEMACS; i++) {
+                if (!strcmp(gemac_list[i]->dev->name, devname))
+                        return gemac_list[i];
+        }
+
+        return NULL;
+}
+
+
+/** PHY read function
+ * Reads a 16bit value from a MII register
+ *
+ * @param[in] mdev              Pointer to MII device structure
+ * @param[in] phy_addr
+ * @param[in] phy_reg
+ *
+ * @return  16bit value on success, a negivie value (-1) on error
+ */
+static int c2000_phy_read(char *devname, unsigned char phy_addr, unsigned char phy_reg, unsigned short *value)
+{
+        struct c2000_eth_dev *priv = get_gemac(devname);
+
+        if (!priv) {
+                printf("Unknown device %s\n", devname);
+                return -1;
+        }
+
+        if ((phy_addr > MII_ADDRESS_MAX) || (phy_reg > MII_REGISTER_MAX))
+                return -1;
+
+        gem_phy_man_rd(priv, phy_addr, phy_reg);
+        if (gem_phy_timeout(priv, MDIO_TIMEOUT))
+                return -1;
+
+        *value = gem_phy_man_data(priv);
+
+        dprint("%s: Addr: %d, Reg: %d, Val: 0x%x\n",
+                                              __func__, phy_addr, phy_reg, *value);
+
+        return 0;
+}
+
+/** PHY write function
+ * Writes a 16bit value to a MII register
+ *
+ * @param[in] mdev              Pointer to MII device structure
+ * @param[in] phy_addr
+ * @param[in] phy_reg
+ * @param[in] value     Value to be written to Phy
+ *
+ * @return              On success returns 0, a negative value (-1) on error
+ */
+static int c2000_phy_write(char *devname, unsigned char phy_addr, unsigned char phy_reg, unsigned short value)
+{
+        struct c2000_eth_dev *priv = get_gemac(devname);
+
+        if (!priv) {
+                printf("Unknown device %s\n", devname);
+                return -1;
+        }
+        if ((phy_addr > MII_ADDRESS_MAX) || (phy_reg > MII_REGISTER_MAX))
+                return -1;
+
+        gem_phy_man_wr(priv, phy_addr, phy_reg, value);
+        if (gem_phy_timeout(priv, MDIO_TIMEOUT))
+                return -1;
+
+        dprint("%s: Addr: %d, Reg: %d, Val: 0x%x\n",
+                                              __func__, phy_addr, phy_reg, value);
+
+        return 0;
+}
+
+/** MAC Address converter
+ * Convert standard byte style ethernet address to format compatible with MAC.
+ *
+ * @param[in] enet_byte_addr    Pointer to the mac address in byte format
+ * @param[out] Pointer to MAC_ADDR structure
+ *
+ * @return      0 on success, -1 on failure
+ */
+int gemac_enet_addr_byte_mac(u8 *enet_byte_addr, MAC_ADDR *enet_addr)
+{
+    if ((enet_byte_addr == NULL) || (enet_addr == NULL))
+    {
+        return -1;
+    }
+    else
+    {
+        enet_addr->bottom = enet_byte_addr[0] |
+                            (enet_byte_addr[1] << 8) |
+                            (enet_byte_addr[2] << 16) |
+                            (enet_byte_addr[3] << 24);
+        enet_addr->top = enet_byte_addr[4] |
+                         (enet_byte_addr[5] << 8);
+        return 0;
+    }
+}
+
+/** Configures ethernet address to GEMAC ADDR1 location.
+ *
+ * @param[in] edev      Pointer to the eth device structure
+ * @param[in] addr      Pointer to ethernet address in byte order
+ *
+ * @return  0 on success (always success)
+ */
+static int c2000_set_ethaddr(struct eth_device *dev, u8 *enet_byte_addr)
+{
+        struct c2000_eth_dev *priv = (struct c2000_eth_dev *)dev->priv;
+        MAC_ADDR enet_address = {0x0, 0x0};
+
+
+        gemac_enet_addr_byte_mac(enet_byte_addr, &enet_address);
+        gemac_set_laddr1(priv->gem->gemac_base, &enet_address);
+
+        return 0;
+}
+
+/** Get/Read configured ethernet mac address from GEMAC.
+ *
+ * @param[in] edev      Pointer to eth device structure
+ * @param[out] addr     Pointer to ethernet address to be copied
+ *
+ * @return      0 on success, always success.
+ */
+static int c2000_get_ethaddr(struct eth_device *edev, unsigned char *addr)
+{
+        struct c2000_eth_dev *priv = (struct c2000_eth_dev *)edev->priv;
+        MAC_ADDR enet_address = {0x0, 0x0};
+        u16 *p = (u16 *)addr;
+
+        enet_address = gem_get_laddr1(priv->gem->gemac_base);
+        p[0] = enet_address.bottom & 0xffff;
+        p[1] = (enet_address.bottom >> 16) & 0xffff;
+        p[2] = enet_address.top & 0xffff;
+
+        return 0;
+}
+
+
+/** Stops or Disables GEMAC pointing to this eth iface.
+ *
+ * @param[in]   edev    Pointer to eth device structure.
+ *
+ * @return      none
+ */
+static void c2000_eth_halt(struct eth_device *edev)
+{
+        struct c2000_eth_dev *priv = (struct c2000_eth_dev *)edev->priv;
+
+        gemac_disable(priv->gem->gemac_base);
+
+        gpi_disable(priv->gem->egpi_base);
+
+        return;
+}
+
+static int c2000_eth_init(struct eth_device *dev, bd_t * bd)
+{
+        struct c2000_eth_dev *priv = (struct c2000_eth_dev *)dev->priv;
+        struct gemac_s *gem = priv->gem;
+	u32 phyaddr;
+
+        /* GEMAC init */
+        pfe_gemac_init(gem->gemac_base, gem->gemac_mode, gem->gemac_speed, gem->gemac_duplex);
+
+        /* set ethernet mac address */
+        c2000_set_ethaddr(dev, dev->enetaddr);
+
+	phyaddr = gem_info[priv->gemac_port].phy_address;
+
+        if (!(gem->flags & GEMAC_NO_PHY) && (gem->gemac_mode == RGMII) )
+        {
+                miiphy_enable_rgmii_rx_delay(dev->name, phyaddr);
+                miiphy_enable_rgmii_tx_delay(dev->name, phyaddr);
+        }
+
+
+        /* Re-negotiate speed and duplex */
+        if (!(gem->flags & GEMAC_NO_PHY))
+        {
+                int speed = gem->gemac_speed;
+                int duplex = gem->gemac_duplex;
+
+		speed = miiphy_speed(dev->name, phyaddr);
+		duplex = miiphy_duplex(dev->name, phyaddr);
+
+                switch (speed)
+                {
+                        case _10BASET:
+                                speed = SPEED_10M;
+                                break;
+
+                        case _100BASET:
+                                speed = SPEED_100M;
+                                break;
+
+                        case _1000BASET:
+                                speed = SPEED_1000M;
+                                break;
+                }
+
+                duplex = (duplex == HALF) ? DUPLEX_HALF:DUPLEX_FULL;
+                gemac_set_speed(gem->gemac_base, speed);
+                gemac_set_duplex(gem->gemac_base, duplex);
+        }
+
+        /* Enable GPI */
+        gpi_enable(priv->gem->egpi_base);
+
+        /* Enable GEMAC for tx and rx */
+        gemac_enable(priv->gem->gemac_base);
+
+        return 0;
+}
+
+static int c2000_eth_send(struct eth_device *dev, volatile void *data, int length)
+{
+        struct c2000_eth_dev *priv = (struct c2000_eth_dev *)dev->priv;
+
+        int rc;
+        uint64_t tx_tmo;
+	int i;
+
+        rc = pfe_send(priv->gemac_port, data, length);
+
+        if (rc < 0) {
+                printf("Tx Q full\n");
+                return 0;
+        }
+
+        while (1) {
+                rc = pfe_tx_done();
+                if (rc == 0)
+                        break;
+		
+		udelay(100);
+		i++;
+		if(i == 30000)
+			printf("Tx timeout, send failed\n");
+			break;
+
+	}
+
+	return 0;
+}
+
+static int c2000_eth_recv(struct eth_device *dev)
+{
+        struct c2000_eth_dev *priv = (struct c2000_eth_dev *)dev->priv;
+        u32 pkt_buf;
+        int len;
+        int phy_port;
+
+        len = pfe_recv(&pkt_buf, &phy_port);
+
+        if (len < 0)
+                return 0; //no packet in rx
+
+        dprint("Rx pkt: pkt_buf(%08x), phy_port(%d), len(%d)\n", pkt_buf, phy_port, len);
+        if (phy_port != priv->gemac_port)  {
+                printf("Rx pkt not on expected port\n");
+                return 0;
+        }
+
+	// Pass the packet up to the protocol layers.
+	NetReceive((unsigned char *)pkt_buf, len);
+
+
+	return 0;
+}
+
+int c2000_gemac_initialize(bd_t * bis, int index, char *devname)
+{
+        struct eth_device *dev;
+        struct c2000_eth_dev *priv;
+        struct pfe *pfe;
+	int i;
+
+        //Bring HFE and GEMTX out of reset
+        writel(0x0, HFE_RESET);
+        writel(0x0, GEMTX_RESET);
+
+        dev = (struct eth_device *)malloc(sizeof(struct eth_device));
+        if (!dev)
+                return -1;
+
+        memset(dev, 0, sizeof(struct eth_device));
+
+        priv = (struct c2000_eth_dev *)malloc(sizeof(struct c2000_eth_dev));
+        if (!priv)
+                return -1;
+
+        gemac_list[index] = priv;
+	priv->gemac_port = index;
+        priv->gem = &gem_info[priv->gemac_port];
+        priv->dev = dev;
+
+        pfe = &priv->pfe;
+
+        pfe->cbus_baseaddr = (void *)COMCERTO_AXI_HFE_CFG_BASE;
+        pfe->ddr_baseaddr = (void *)CONFIG_DDR_BASEADDR;
+        pfe->ddr_phys_baseaddr = (unsigned long)CONFIG_DDR_PHYS_BASEADDR;
+
+	sprintf(dev->name, devname);
+        dev->priv = priv;
+        dev->init = c2000_eth_init;
+        dev->halt = c2000_eth_halt;
+        dev->send = c2000_eth_send;
+        dev->recv = c2000_eth_recv;
+
+        /* Tell u-boot to get the addr from the env */
+        for (i = 0; i < 6; i++)
+                dev->enetaddr[i] = 0;
+
+
+        switch(priv->gemac_port)  {
+                case EMAC_PORT_0:
+                default:
+                        priv->gem->gemac_base = EMAC1_BASE_ADDR;
+                        priv->gem->egpi_base = EGPI1_BASE_ADDR;
+                break;
+                case EMAC_PORT_1:
+                        priv->gem->gemac_base = EMAC2_BASE_ADDR;
+                        priv->gem->egpi_base = EGPI2_BASE_ADDR;
+                break;
+                case EMAC_PORT_2:
+                        priv->gem->gemac_base = EMAC3_BASE_ADDR;
+                        priv->gem->egpi_base = EGPI3_BASE_ADDR;
+                break;
+        }
+
+        pfe_probe(pfe);
+        priv->phyregisters = (void *)gem_info[gem_info[priv->gemac_port].phy_reg_index].gemac_base;
+
+        if(priv->gemac_port == 0)
+        {
+                gemac_set_mdc_div(priv->gem->gemac_base, MDC_DIV_96);
+                gemac_enable_mdio(priv->gem->gemac_base);
+                miiphy_register(dev->name, c2000_phy_read, c2000_phy_write);
+        }
+
+	c2000_eth_board_init(dev->name, priv->gemac_port);
+
+        eth_register(dev);
+}
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/net/c2000_eth/c2000_eth.h u-boot-2013.01.new/drivers/net/c2000_eth/c2000_eth.h
--- u-boot-2013.01/drivers/net/c2000_eth/c2000_eth.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/net/c2000_eth/c2000_eth.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,175 @@
+/*
+ *  (C) Copyright 2011
+ *  Author : Mindspeed Technologes
+ *  
+ *  See file CREDITS for list of people who contributed to this
+ *  project.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License as
+ *  published by the Free Software Foundation; either version 2 of
+ *  the License, or (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA 02111-1307 USA
+ * */
+
+#ifndef _C2000_ETH_H_
+#define _C2000_ETH_H_
+
+
+#include "pfe_driver.h"
+
+#ifndef SZ_1K
+#define SZ_1K 1024
+#endif
+
+#ifndef SZ_1M
+#define SZ_1M (1024 * 1024)
+#endif
+
+#define BMU2_DDR_BASEADDR	0
+#define BMU2_BUF_COUNT		(3 * SZ_1K)
+#define BMU2_DDR_SIZE		(DDR_BUF_SIZE * BMU2_BUF_COUNT)
+
+#define TMU_LLM_BASEADDR	(BMU2_DDR_BASEADDR + BMU2_DDR_SIZE)
+#define TMU_LLM_QUEUE_LEN	(16 * 256)			/**< Must be power of two and at least 16 * 8 = 128 bytes */
+#define TMU_LLM_SIZE		(4 * 16 * TMU_LLM_QUEUE_LEN)	/**< (4 TMU's x 16 queues x queue_len) */
+
+#define HIF_RX_PKT_DDR_BASEADDR (TMU_LLM_BASEADDR + TMU_LLM_SIZE)
+#define HIF_RX_PKT_DDR_SIZE     (HIF_RX_DESC_NT * DDR_BUF_SIZE)
+#define HIF_TX_PKT_DDR_BASEADDR (HIF_RX_PKT_DDR_BASEADDR + HIF_RX_PKT_DDR_SIZE)
+#define HIF_TX_PKT_DDR_SIZE     (HIF_TX_DESC_NT * DDR_BUF_SIZE)
+
+#define HIF_DESC_BASEADDR       (HIF_TX_PKT_DDR_BASEADDR + HIF_TX_PKT_DDR_SIZE)
+#define HIF_RX_DESC_SIZE        (16*HIF_RX_DESC_NT)
+#define HIF_TX_DESC_SIZE        (16*HIF_TX_DESC_NT)
+#define HIF_DESC_SIZE           (HIF_RX_DESC_SIZE + HIF_TX_DESC_SIZE)
+
+//#define FPPDIAG_CTL_BASE_ADDR	(HIF_DESC_BASEADDR + HIF_DESC_SIZE)
+#define FPPDIAG_CTL_BASE_ADDR	0x700000
+#define FPPDIAG_CTL_SIZE		256	/**< Must be at least 11*8 bytes */
+#define FPPDIAG_PAGE_BASE_ADDR	(FPPDIAG_CTL_BASE_ADDR + FPPDIAG_CTL_SIZE)
+#define FPPDIAG_PAGE_TOTAL_SIZE	(11 * 256) /**< 256 bytes per PE, 11 PEs */
+
+//#define UTIL_CODE_BASEADDR	(FPPDIAG_PAGE_BASE_ADDR + FPPDIAG_PAGE_TOTAL_SIZE)
+#define UTIL_CODE_BASEADDR	0x780000
+#define UTIL_CODE_SIZE		(128 * SZ_1K)
+
+#define UTIL_DDR_DATA_BASEADDR	(UTIL_CODE_BASEADDR + UTIL_CODE_SIZE)
+#define UTIL_DDR_DATA_SIZE	(64 * SZ_1K)
+
+#define CLASS_DDR_DATA_BASEADDR	(UTIL_DDR_DATA_BASEADDR + UTIL_DDR_DATA_SIZE)
+#define CLASS_DDR_DATA_SIZE	(32 * SZ_1K)
+
+#define TMU_DDR_DATA_BASEADDR	(CLASS_DDR_DATA_BASEADDR + CLASS_DDR_DATA_SIZE)
+#define TMU_DDR_DATA_SIZE	(32 * SZ_1K)
+
+//#define ROUTE_TABLE_BASEADDR	(TMU_DDR_DATA_BASEADDR + TMU_DDR_DATA_SIZE)
+#define ROUTE_TABLE_BASEADDR	0x800000
+#define ROUTE_TABLE_HASH_BITS_MAX	15	/**< 32K entries */
+#define ROUTE_TABLE_HASH_BITS	8	/**< 256 entries */
+#define ROUTE_TABLE_SIZE	((1 << ROUTE_TABLE_HASH_BITS_MAX) * CLASS_ROUTE_SIZE)
+
+#define	PFE_TOTAL_DATA_SIZE	(ROUTE_TABLE_BASEADDR + ROUTE_TABLE_SIZE)
+
+#if PFE_TOTAL_DATA_SIZE > (12 * SZ_1M)
+#error DDR mapping above 12MiB
+#endif
+
+/* LMEM Mapping */
+#define BMU1_LMEM_BASEADDR	0
+#define BMU1_BUF_COUNT		256
+#define BMU1_LMEM_SIZE		(LMEM_BUF_SIZE * BMU1_BUF_COUNT)
+
+
+#define CONFIG_DDR_PHYS_BASEADDR 0x03800000
+#define CONFIG_DDR_BASEADDR      CONFIG_DDR_PHYS_BASEADDR
+
+#if 0
+
+#define RX_PKT_DDR_BASEADDR  0x300000   //4 pkts of each 2k size
+#define TX_PKT_DDR_BASEADDR  0x302000  //4 pkts of each 2K size
+
+#define RX_BD_BASEADDR       0x214000 
+#define TX_BD_BASEADDR       0x214200 
+
+#define BMU1_LMEM_BASEADDR   0
+#define BMU1_BUF_COUNT       32
+
+#define BMU2_BUF_COUNT       32
+#define BMU2_DDR_BASEADDR    0x200000
+
+
+#define ROUTE_TABLE_BASEADDR	0x215000 
+#define ROUTE_TABLE_HASH_BITS	2	/**< 2 entries */
+
+#define TMU_LLM_BASEADDR   0x216000 
+#define TMU_LLM_QUEUE_LEN  (16 * 256)
+
+#endif
+
+#define GEMAC_NO_PHY 		1
+#define GEMAC_HAVE_SWITCH_PHY     2
+#define GEMAC_HAVE_SWITCH       	4
+
+
+typedef struct gemac_s {
+
+	void *gemac_base; 
+	void *egpi_base;
+
+	/* GEMAC config */
+	int gemac_mode;
+	int gemac_speed;
+	int gemac_duplex;
+        int flags;
+	/* phy iface */
+	int phy_reg_index;
+	int phy_address;
+
+} gemac_t;
+
+struct pfe {
+	unsigned long ddr_phys_baseaddr;
+	void *ddr_baseaddr;
+	void *cbus_baseaddr;
+};
+
+
+typedef struct c2000_eth_dev {
+
+	int gemac_port;
+	void *phyregisters;
+
+	struct gemac_s *gem;
+	struct pfe      pfe;
+
+        struct eth_device *dev;
+
+} c2000_eth_dev_t;
+
+
+struct firmware {
+	u8 *data;
+};
+
+
+int pfe_probe(struct pfe *pfe);
+int pfe_remove(struct pfe *pfe);
+
+
+//#define dprint(fmt, arg...)	pr_info(fmt, ##arg)
+#define dprint(fmt, arg...)
+//#define dprint	printf
+
+
+#endif //_C2000_ETH_H_
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/net/c2000_eth/class_sbl_c2000_elf.fw u-boot-2013.01.new/drivers/net/c2000_eth/class_sbl_c2000_elf.fw
--- u-boot-2013.01/drivers/net/c2000_eth/class_sbl_c2000_elf.fw	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/net/c2000_eth/class_sbl_c2000_elf.fw	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1 @@
+0x7f,0x45,0x4c,0x46,0x01,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x6f,0x00,0x00,0x00,0x01,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x34,0x00,0x00,0x12,0xc4,0x00,0x04,0x00,0x05,0x00,0x34,0x00,0x20,0x00,0x03,0x00,0x28,0x00,0x0a,0x00,0x09,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0a,0x0c,0x00,0x00,0x0a,0x0c,0x00,0x00,0x00,0x06,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x0f,0x80,0x00,0x00,0x1f,0x80,0x00,0x00,0x1f,0x80,0x00,0x00,0x00,0x28,0x00,0x00,0x00,0x28,0x00,0x00,0x00,0x04,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x10,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x02,0x54,0x00,0x00,0x02,0x54,0x00,0x00,0x00,0x05,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x2a,0x2a,0x2a,0x2a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x3c,0x00,0x00,0x08,0x00,0x00,0x00,0x08,0x5c,0x00,0x00,0x08,0x4c,0x00,0x00,0x00,0x01,0x00,0x00,0x01,0x00,0x00,0x01,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x01,0x80,0x00,0x00,0x02,0x80,0x00,0x00,0x03,0x80,0x44,0x45,0x41,0x44,0x53,0x54,0x4f,0x50,0xc0,0x25,0x00,0x34,0xc1,0x02,0x00,0x10,0xc1,0x02,0x00,0x0c,0xc1,0x02,0x00,0x08,0x69,0x6e,0x69,0x74,0x72,0x75,0x6e,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x40,0x00,0x01,0x00,0x40,0x00,0x01,0x00,0x40,0x00,0x01,0x00,0x40,0x00,0x01,0x00,0x40,0x00,0x01,0x00,0x40,0x00,0x01,0x00,0x40,0x00,0x01,0x00,0x40,0x00,0x01,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x10,0x80,0x11,0x00,0x11,0x80,0x12,0x00,0x12,0x80,0x13,0x00,0x13,0x80,0x14,0x00,0x14,0x80,0x15,0x00,0x15,0x80,0x16,0x00,0x16,0x80,0x17,0x00,0x17,0x80,0xea,0x00,0xc8,0x00,0xe0,0x14,0xc8,0x08,0xea,0x00,0xcb,0x80,0xe0,0x10,0xcb,0xa0,0xe0,0x60,0x3c,0x00,0xcc,0x02,0xe0,0x60,0x3c,0x10,0xe0,0x00,0xd1,0x02,0x3a,0x80,0xea,0x00,0xcb,0x80,0xe0,0x3f,0xcb,0xa8,0xb8,0x47,0xb8,0xd7,0xb9,0x67,0xb9,0xf7,0xe0,0x01,0xba,0x07,0xe0,0x01,0xba,0x97,0xe0,0x01,0xbb,0x27,0xe0,0x01,0xbb,0xb7,0xe0,0x01,0xbc,0x47,0xe0,0x01,0xbc,0xd7,0xe0,0x01,0xbd,0x67,0xe0,0x01,0xbd,0xf7,0xe0,0x02,0xbe,0x07,0xe0,0x02,0xbe,0x97,0xe0,0x02,0xbf,0x27,0xe0,0x02,0xbf,0xb7,0xe0,0x60,0x3e,0x09,0xe0,0x60,0x3e,0x8a,0xe0,0x60,0x3f,0x0b,0xe0,0x60,0x3f,0x8c,0xbe,0x07,0xbe,0x97,0xbf,0x27,0xbf,0xb7,0xe0,0x00,0x00,0x82,0xe0,0x00,0x1c,0x04,0xe0,0x00,0x1c,0x93,0xbc,0x88,0xe0,0x00,0x1c,0x94,0xbc,0x88,0x3a,0x80,0x00,0xff,0xa5,0x08,0xe0,0x00,0x1c,0x15,0xbd,0x08,0x00,0x00,0xe0,0x00,0x1c,0x03,0xe0,0x29,0xa4,0xf8,0xe0,0x00,0x1c,0x16,0xbc,0x88,0x00,0x00,0xe0,0x00,0x1c,0x84,0xa4,0x49,0xc4,0x01,0xbc,0x49,0x38,0x82,0x15,0x80,0x00,0x86,0xe1,0x80,0xa6,0x19,0xc5,0x84,0xe1,0x80,0xbe,0x18,0x3d,0xfa,0x04,0xfa,0x38,0x82,0xc0,0x64,0x78,0x86,0x79,0x05,0x79,0x84,0x7a,0x03,0x7a,0x82,0x7b,0x01,0xe0,0x00,0x19,0x83,0x12,0x00,0xe0,0x24,0xa5,0xf3,0xe0,0x00,0x1d,0x04,0xa4,0x1a,0xeb,0x82,0xce,0x02,0xc4,0x01,0xbc,0x1a,0xe0,0x00,0x1c,0x84,0xa4,0x0c,0xe0,0x08,0x3d,0xd8,0x24,0x76,0xa4,0x29,0xc4,0x01,0xbc,0x29,0xe0,0x00,0x1c,0x05,0xe0,0x24,0xa4,0x78,0x9c,0xb8,0xe2,0x00,0xcc,0x83,0x01,0x85,0x9d,0x28,0xe2,0x00,0xcd,0x37,0x05,0x85,0xa5,0x28,0xeb,0xe0,0xc5,0x01,0x25,0x05,0x3c,0xe4,0xdf,0xb6,0xe0,0x00,0x00,0xf0,0xe2,0x00,0xcc,0x83,0x01,0x04,0x95,0x28,0xc5,0x7c,0xb5,0x28,0x9d,0xa8,0x3e,0x68,0xe2,0x00,0xcd,0xef,0xe0,0x00,0x15,0x70,0xc6,0x10,0xe0,0x6a,0x3d,0xab,0xe2,0x00,0xcc,0x83,0x3d,0x1c,0xa6,0x08,0x01,0x8f,0xe0,0x02,0x89,0x08,0x14,0x80,0xe2,0x00,0xc9,0x03,0xe0,0x69,0x3c,0xa2,0x3a,0xe8,0xc5,0xfa,0x39,0x69,0xc2,0x96,0xe3,0xff,0xc5,0xff,0x00,0x90,0x3a,0xe8,0xc2,0x8a,0xe0,0x01,0xac,0xa8,0x14,0x00,0xac,0x15,0x14,0x00,0xac,0x25,0xc5,0x86,0xac,0x35,0xe3,0xff,0xc5,0xff,0xac,0x45,0x11,0x03,0xac,0x55,0xe0,0x00,0x1c,0x06,0x14,0xf8,0xe0,0x09,0x3a,0xd9,0xe0,0x24,0xa3,0x78,0xc4,0xf8,0xe3,0xff,0xc4,0xf8,0x14,0x01,0xac,0x06,0x3c,0x69,0x3d,0x29,0xe2,0x01,0xc4,0x7f,0xe2,0x01,0xc5,0x7f,0xe0,0x0c,0x3c,0x1c,0xb4,0x96,0xe2,0x01,0xcd,0x00,0xad,0x16,0xbe,0x16,0x05,0x8e,0x3c,0x6c,0xe0,0x01,0xc4,0x00,0xe0,0x01,0xc4,0x80,0xe1,0xff,0xc5,0x00,0x7d,0x87,0xdf,0x73,0xe7,0xff,0x14,0x00,0xac,0x16,0x65,0x87,0x9c,0x16,0x3c,0xe8,0xe2,0x01,0xc4,0xff,0xac,0x98,0x3a,0xa9,0x14,0x80,0xac,0xd8,0xaa,0x88,0xa9,0x48,0xb5,0x98,0xe0,0x00,0x1c,0x97,0xe0,0x24,0xa4,0x73,0xbc,0x09,0x00,0x00,0xe0,0x00,0x1c,0x84,0xa4,0x39,0xc4,0x01,0xbc,0x39,0xe0,0x24,0xa4,0x73,0xe0,0x00,0x1e,0x18,0xbc,0x0c,0x00,0x00,0xc2,0x01,0xe2,0x00,0xc2,0x03,0xe7,0xfe,0x00,0xe3,0x38,0x82,0xc0,0x7c,0x78,0x81,0xe0,0x00,0x1c,0x04,0xe0,0x00,0x1c,0x99,0xbc,0x88,0xe0,0x00,0x1c,0x9a,0xbc,0x88,0xdf,0x4c,0x47,0x43,0x43,0x3a,0x20,0x28,0x47,0x4e,0x55,0x29,0x20,0x34,0x2e,0x36,0x2e,0x31,0x00,0x00,0x2e,0x73,0x68,0x73,0x74,0x72,0x74,0x61,0x62,0x00,0x2e,0x70,0x6d,0x65,0x6d,0x00,0x2e,0x64,0x6d,0x65,0x6d,0x5f,0x70,0x65,0x73,0x74,0x61,0x74,0x75,0x73,0x00,0x2e,0x64,0x6d,0x65,0x6d,0x5f,0x67,0x6f,0x74,0x00,0x2e,0x64,0x6d,0x65,0x6d,0x5f,0x73,0x64,0x61,0x74,0x61,0x00,0x2e,0x64,0x6d,0x65,0x6d,0x5f,0x6c,0x69,0x74,0x34,0x00,0x2e,0x64,0x6d,0x65,0x6d,0x5f,0x73,0x74,0x61,0x63,0x6b,0x00,0x2e,0x76,0x65,0x63,0x74,0x6f,0x72,0x00,0x2e,0x63,0x6f,0x6d,0x6d,0x65,0x6e,0x74,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0b,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x06,0x00,0x01,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x02,0x54,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x11,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x03,0x00,0x00,0x08,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x03,0x00,0x00,0x08,0x20,0x00,0x00,0x08,0x20,0x00,0x00,0x00,0x1c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x2a,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x03,0x00,0x00,0x08,0x3c,0x00,0x00,0x08,0x3c,0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x36,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x12,0x00,0x00,0x08,0x6c,0x00,0x00,0x08,0x6c,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x41,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x03,0x00,0x00,0x08,0x8c,0x00,0x00,0x08,0x8c,0x00,0x00,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x4d,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x02,0x00,0x00,0x1f,0x80,0x00,0x00,0x0f,0x80,0x00,0x00,0x00,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x55,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x12,0x54,0x00,0x00,0x00,0x11,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x12,0x65,0x00,0x00,0x00,0x5e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,
\ No newline at end of file
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/net/c2000_eth/hal.h u-boot-2013.01.new/drivers/net/c2000_eth/hal.h
--- u-boot-2013.01/drivers/net/c2000_eth/hal.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/net/c2000_eth/hal.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,65 @@
+/*
+ *  (C) Copyright 2011
+ *  Author : Mindspeed Technologes
+ *  
+ *  See file CREDITS for list of people who contributed to this
+ *  project.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License as
+ *  published by the Free Software Foundation; either version 2 of
+ *  the License, or (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA 02111-1307 USA
+ * */
+
+#ifndef _HAL_H_
+#define _HAL_H_
+
+#if defined(CONFIG_PLATFORM_PCI)  
+/* For ChipIT */
+
+#include <linux/types.h>
+#include <linux/elf.h>
+#include <linux/errno.h>
+#include <linux/pci.h>
+#include <asm/io.h>
+#include <linux/slab.h>
+#include <linux/firmware.h>
+
+#include "pfe_mod.h"
+
+#define free(x)  kfree(x)
+#define xzalloc(x)  kmalloc(x, GFP_DMA)
+#define printf  printk
+
+//#define dprint(fmt, arg...)	printk(fmt, ##arg)
+#define dprint(fmt, arg...)	
+
+#else
+
+#include <linux/types.h>
+#include <elf.h>
+#include <common.h>
+//#include <errno.h>
+#include <asm/byteorder.h>
+#include <miiphy.h>
+#include <malloc.h>
+#include <asm/io.h>
+
+
+#include "c2000_eth.h"
+
+#endif
+
+
+#endif /* _HAL_H_ */
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/net/c2000_eth/Makefile u-boot-2013.01.new/drivers/net/c2000_eth/Makefile
--- u-boot-2013.01/drivers/net/c2000_eth/Makefile	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/net/c2000_eth/Makefile	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,47 @@
+#
+# (C) Copyright 2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB 	:= $(obj)libcomcerto_pfe.o
+
+COBJS 	:= c2000_ethernet.o pfe_firmware.o pfe.o pfe_driver.o ar8328.o
+
+SRCS 	:= $(COBJS:.o=.c)
+OBJS 	:= $(addprefix $(obj),$(COBJS))
+
+all:	$(obj).depend $(LIB)
+
+$(LIB): $(OBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/net/c2000_eth/pfe/cbus/bmu.h u-boot-2013.01.new/drivers/net/c2000_eth/pfe/cbus/bmu.h
--- u-boot-2013.01/drivers/net/c2000_eth/pfe/cbus/bmu.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/net/c2000_eth/pfe/cbus/bmu.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,37 @@
+#ifndef _BMU_H_
+#define _BMU_H_
+
+#define BMU_VERSION		0x000
+#define BMU_CTRL		0x004
+#define BMU_UCAST_CONFIG	0x008
+#define BMU_UCAST_BASE_ADDR	0x00c
+#define BMU_BUF_SIZE		0x010
+#define BMU_BUF_CNT		0x014
+#define BMU_THRES		0x018
+#define BMU_INT_SRC		0x020
+#define BMU_INT_ENABLE		0x024
+#define BMU_ALLOC_CTRL		0x030
+#define BMU_FREE_CTRL		0x034
+#define BMU_FREE_ERR_ADDR	0x038
+#define BMU_CURR_BUF_CNT	0x03c
+#define BMU_MCAST_CNT		0x040
+#define BMU_MCAST_ALLOC_CTRL	0x044
+#define BMU_REM_BUF_CNT		0x048
+#define BMU_LOW_WATERMARK	0x050
+#define BMU_HIGH_WATERMARK	0x054
+#define BMU_INT_MEM_ACCESS	0x100
+
+typedef struct {
+	u32 baseaddr;
+	u32 count;
+	u32 size;
+} BMU_CFG;
+
+
+#define BMU1_BUF_SIZE	LMEM_BUF_SIZE_LN2
+#define BMU2_BUF_SIZE	DDR_BUF_SIZE_LN2
+
+#define BMU2_MCAST_ALLOC_CTRL	BMU2_BASE_ADDR + BMU_MCAST_ALLOC_CTRL
+
+#endif /* _BMU_H_ */
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/net/c2000_eth/pfe/cbus/class_csr.h u-boot-2013.01.new/drivers/net/c2000_eth/pfe/cbus/class_csr.h
--- u-boot-2013.01/drivers/net/c2000_eth/pfe/cbus/class_csr.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/net/c2000_eth/pfe/cbus/class_csr.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,206 @@
+#ifndef _CLASS_CSR_H_
+#define _CLASS_CSR_H_
+
+/** @file class_csr.h.
+ * class_csr - block containing all the classifier control and status register. Mapped on CBUS and accessible from all PE's and ARM.
+ */
+
+
+#define CLASS_VERSION			(CLASS_CSR_BASE_ADDR + 0x000)
+#define CLASS_TX_CTRL			(CLASS_CSR_BASE_ADDR + 0x004)
+#define CLASS_INQ_PKTPTR		(CLASS_CSR_BASE_ADDR + 0x010)
+#define CLASS_HDR_SIZE			(CLASS_CSR_BASE_ADDR + 0x014)	/**< (ddr_hdr_size[24:16], lmem_hdr_size[5:0]) */
+#define CLASS_HDR_SIZE_LMEM(off)	((off) & 0x3f)			/**< LMEM header size for the Classifier block.\ Data in the LMEM is written from this offset. */
+#define CLASS_HDR_SIZE_DDR(off)		(((off) & 0x1ff) << 16)		/**< DDR header size for the Classifier block.\ Data in the DDR is written from this offset. */
+
+#define CLASS_PE0_QB_DM_ADDR0		(CLASS_CSR_BASE_ADDR + 0x020)	/**< DMEM address of first [15:0] and second [31:16] buffers on QB side. */
+#define CLASS_PE0_QB_DM_ADDR1		(CLASS_CSR_BASE_ADDR + 0x024)	/**< DMEM address of third [15:0] and fourth [31:16] buffers on QB side. */
+
+#define CLASS_PE0_RO_DM_ADDR0		(CLASS_CSR_BASE_ADDR + 0x060)	/**< DMEM address of first [15:0] and second [31:16] buffers on RO side. */
+#define CLASS_PE0_RO_DM_ADDR1		(CLASS_CSR_BASE_ADDR + 0x064)	/**< DMEM address of third [15:0] and fourth [31:16] buffers on RO side. */
+
+/** @name Class PE memory access. Allows external PE's and HOST to read/write PMEM/DMEM memory ranges for each classifier PE.
+ */
+//@{
+#define CLASS_MEM_ACCESS_ADDR		(CLASS_CSR_BASE_ADDR + 0x100)	/**< {sr_pe_mem_cmd[31], csr_pe_mem_wren[27:24], csr_pe_mem_addr[23:0]}, See \ref XXX_MEM_ACCESS_ADDR for details. */ 
+#define CLASS_MEM_ACCESS_WDATA		(CLASS_CSR_BASE_ADDR + 0x104)	/**< Internal Memory Access Write Data [31:0] */
+#define CLASS_MEM_ACCESS_RDATA		(CLASS_CSR_BASE_ADDR + 0x108)	/**< Internal Memory Access Read Data [31:0] */
+//@}
+#define CLASS_TM_INQ_ADDR		(CLASS_CSR_BASE_ADDR + 0x114)
+#define CLASS_PE_STATUS			(CLASS_CSR_BASE_ADDR + 0x118)
+
+#define CLASS_PHY1_RX_PKTS		(CLASS_CSR_BASE_ADDR + 0x11c)
+#define CLASS_PHY1_TX_PKTS		(CLASS_CSR_BASE_ADDR + 0x120)
+#define CLASS_PHY1_LP_FAIL_PKTS		(CLASS_CSR_BASE_ADDR + 0x124)
+#define CLASS_PHY1_INTF_FAIL_PKTS	(CLASS_CSR_BASE_ADDR + 0x128)
+#define CLASS_PHY1_INTF_MATCH_PKTS	(CLASS_CSR_BASE_ADDR + 0x12c)
+#define CLASS_PHY1_L3_FAIL_PKTS		(CLASS_CSR_BASE_ADDR + 0x130)
+#define CLASS_PHY1_V4_PKTS		(CLASS_CSR_BASE_ADDR + 0x134)
+#define CLASS_PHY1_V6_PKTS		(CLASS_CSR_BASE_ADDR + 0x138)
+#define CLASS_PHY1_CHKSUM_ERR_PKTS	(CLASS_CSR_BASE_ADDR + 0x13c)
+#define CLASS_PHY1_TTL_ERR_PKTS		(CLASS_CSR_BASE_ADDR + 0x140)
+#define CLASS_PHY2_RX_PKTS		(CLASS_CSR_BASE_ADDR + 0x144)
+#define CLASS_PHY2_TX_PKTS		(CLASS_CSR_BASE_ADDR + 0x148)
+#define CLASS_PHY2_LP_FAIL_PKTS		(CLASS_CSR_BASE_ADDR + 0x14c)
+#define CLASS_PHY2_INTF_FAIL_PKTS	(CLASS_CSR_BASE_ADDR + 0x150)
+#define CLASS_PHY2_INTF_MATCH_PKTS	(CLASS_CSR_BASE_ADDR + 0x154)
+#define CLASS_PHY2_L3_FAIL_PKTS		(CLASS_CSR_BASE_ADDR + 0x158)
+#define CLASS_PHY2_V4_PKTS		(CLASS_CSR_BASE_ADDR + 0x15c)
+#define CLASS_PHY2_V6_PKTS		(CLASS_CSR_BASE_ADDR + 0x160)
+#define CLASS_PHY2_CHKSUM_ERR_PKTS	(CLASS_CSR_BASE_ADDR + 0x164)
+#define CLASS_PHY2_TTL_ERR_PKTS		(CLASS_CSR_BASE_ADDR + 0x168)
+#define CLASS_PHY3_RX_PKTS		(CLASS_CSR_BASE_ADDR + 0x16c)
+#define CLASS_PHY3_TX_PKTS		(CLASS_CSR_BASE_ADDR + 0x170)
+#define CLASS_PHY3_LP_FAIL_PKTS		(CLASS_CSR_BASE_ADDR + 0x174)
+#define CLASS_PHY3_INTF_FAIL_PKTS	(CLASS_CSR_BASE_ADDR + 0x178)
+#define CLASS_PHY3_INTF_MATCH_PKTS	(CLASS_CSR_BASE_ADDR + 0x17c)
+#define CLASS_PHY3_L3_FAIL_PKTS		(CLASS_CSR_BASE_ADDR + 0x180)
+#define CLASS_PHY3_V4_PKTS		(CLASS_CSR_BASE_ADDR + 0x184)
+#define CLASS_PHY3_V6_PKTS		(CLASS_CSR_BASE_ADDR + 0x188)
+#define CLASS_PHY3_CHKSUM_ERR_PKTS	(CLASS_CSR_BASE_ADDR + 0x18c)
+#define CLASS_PHY3_TTL_ERR_PKTS		(CLASS_CSR_BASE_ADDR + 0x190)
+#define CLASS_PHY1_ICMP_PKTS		(CLASS_CSR_BASE_ADDR + 0x194)
+#define CLASS_PHY1_IGMP_PKTS		(CLASS_CSR_BASE_ADDR + 0x198)
+#define CLASS_PHY1_TCP_PKTS		(CLASS_CSR_BASE_ADDR + 0x19c)
+#define CLASS_PHY1_UDP_PKTS		(CLASS_CSR_BASE_ADDR + 0x1a0)
+#define CLASS_PHY2_ICMP_PKTS		(CLASS_CSR_BASE_ADDR + 0x1a4)
+#define CLASS_PHY2_IGMP_PKTS		(CLASS_CSR_BASE_ADDR + 0x1a8)
+#define CLASS_PHY2_TCP_PKTS		(CLASS_CSR_BASE_ADDR + 0x1ac)
+#define CLASS_PHY2_UDP_PKTS		(CLASS_CSR_BASE_ADDR + 0x1b0)
+#define CLASS_PHY3_ICMP_PKTS		(CLASS_CSR_BASE_ADDR + 0x1b4)
+#define CLASS_PHY3_IGMP_PKTS		(CLASS_CSR_BASE_ADDR + 0x1b8)
+#define CLASS_PHY3_TCP_PKTS		(CLASS_CSR_BASE_ADDR + 0x1bc)
+#define CLASS_PHY3_UDP_PKTS		(CLASS_CSR_BASE_ADDR + 0x1c0)
+#define CLASS_PHY4_ICMP_PKTS		(CLASS_CSR_BASE_ADDR + 0x1c4)
+#define CLASS_PHY4_IGMP_PKTS		(CLASS_CSR_BASE_ADDR + 0x1c8)
+#define CLASS_PHY4_TCP_PKTS		(CLASS_CSR_BASE_ADDR + 0x1cc)
+#define CLASS_PHY4_UDP_PKTS		(CLASS_CSR_BASE_ADDR + 0x1d0)
+#define CLASS_PHY4_RX_PKTS		(CLASS_CSR_BASE_ADDR + 0x1d4)
+#define CLASS_PHY4_TX_PKTS		(CLASS_CSR_BASE_ADDR + 0x1d8)
+#define CLASS_PHY4_LP_FAIL_PKTS		(CLASS_CSR_BASE_ADDR + 0x1dc)
+#define CLASS_PHY4_INTF_FAIL_PKTS	(CLASS_CSR_BASE_ADDR + 0x1e0)
+#define CLASS_PHY4_INTF_MATCH_PKTS	(CLASS_CSR_BASE_ADDR + 0x1e4)
+#define CLASS_PHY4_L3_FAIL_PKTS		(CLASS_CSR_BASE_ADDR + 0x1e8)
+#define CLASS_PHY4_V4_PKTS		(CLASS_CSR_BASE_ADDR + 0x1ec)
+#define CLASS_PHY4_V6_PKTS		(CLASS_CSR_BASE_ADDR + 0x1f0)
+#define CLASS_PHY4_CHKSUM_ERR_PKTS	(CLASS_CSR_BASE_ADDR + 0x1f4)
+#define CLASS_PHY4_TTL_ERR_PKTS		(CLASS_CSR_BASE_ADDR + 0x1f8)
+
+#define CLASS_PE_SYS_CLK_RATIO		(CLASS_CSR_BASE_ADDR + 0x200)
+#define CLASS_AFULL_THRES		(CLASS_CSR_BASE_ADDR + 0x204)
+#define CLASS_GAP_BETWEEN_READS		(CLASS_CSR_BASE_ADDR + 0x208)
+#define CLASS_MAX_BUF_CNT		(CLASS_CSR_BASE_ADDR + 0x20c)
+#define CLASS_TSQ_FIFO_THRES		(CLASS_CSR_BASE_ADDR + 0x210)
+#define CLASS_TSQ_MAX_CNT		(CLASS_CSR_BASE_ADDR + 0x214)
+#define CLASS_IRAM_DATA_0		(CLASS_CSR_BASE_ADDR + 0x218)
+#define CLASS_IRAM_DATA_1		(CLASS_CSR_BASE_ADDR + 0x21c)
+#define CLASS_IRAM_DATA_2		(CLASS_CSR_BASE_ADDR + 0x220)
+#define CLASS_IRAM_DATA_3		(CLASS_CSR_BASE_ADDR + 0x224)
+
+#define CLASS_BUS_ACCESS_ADDR		(CLASS_CSR_BASE_ADDR + 0x228)
+#define CLASS_BUS_ACCESS_ADDR_MASK	(0x0001FFFF)	//bit 23:0 of PE peripheral address are stored in CLASS_BUS_ACCESS_ADDR
+
+#define CLASS_BUS_ACCESS_WDATA		(CLASS_CSR_BASE_ADDR + 0x22c)
+#define CLASS_BUS_ACCESS_RDATA		(CLASS_CSR_BASE_ADDR + 0x230)
+
+#define CLASS_ROUTE_HASH_ENTRY_SIZE	(CLASS_CSR_BASE_ADDR + 0x234)		/**< (route_entry_size[9:0], route_hash_size[23:16] (this is actually ln2(size))) */
+#define CLASS_ROUTE_ENTRY_SIZE(size)	 ((size) & 0x1ff)
+#define CLASS_ROUTE_HASH_SIZE(hash_bits) (((hash_bits) & 0xff) << 16)
+
+#define CLASS_ROUTE_TABLE_BASE		(CLASS_CSR_BASE_ADDR + 0x238)
+
+#define CLASS_ROUTE_MULTI		(CLASS_CSR_BASE_ADDR + 0x23c)
+#define CLASS_SMEM_OFFSET		(CLASS_CSR_BASE_ADDR + 0x240)
+#define CLASS_LMEM_BUF_SIZE		(CLASS_CSR_BASE_ADDR + 0x244)
+#define CLASS_VLAN_ID			(CLASS_CSR_BASE_ADDR + 0x248)
+#define CLASS_BMU1_BUF_FREE		(CLASS_CSR_BASE_ADDR + 0x24c)
+#define CLASS_USE_TMU_INQ		(CLASS_CSR_BASE_ADDR + 0x250)
+#define CLASS_VLAN_ID1			(CLASS_CSR_BASE_ADDR + 0x254)
+
+#define CLASS_BUS_ACCESS_BASE		(CLASS_CSR_BASE_ADDR + 0x258)
+#define CLASS_BUS_ACCESS_BASE_MASK	(0xFF000000)	//bit 31:24 of PE peripheral address are stored in CLASS_BUS_ACCESS_BASE
+
+#define CLASS_HIF_PARSE			(CLASS_CSR_BASE_ADDR + 0x25c)
+
+#define CLASS_HOST_PE0_GP		(CLASS_CSR_BASE_ADDR + 0x260)
+#define CLASS_PE0_GP			(CLASS_CSR_BASE_ADDR + 0x264)
+#define CLASS_HOST_PE1_GP		(CLASS_CSR_BASE_ADDR + 0x268)
+#define CLASS_PE1_GP			(CLASS_CSR_BASE_ADDR + 0x26c)
+#define CLASS_HOST_PE2_GP		(CLASS_CSR_BASE_ADDR + 0x270)
+#define CLASS_PE2_GP			(CLASS_CSR_BASE_ADDR + 0x274)
+#define CLASS_HOST_PE3_GP		(CLASS_CSR_BASE_ADDR + 0x278)
+#define CLASS_PE3_GP			(CLASS_CSR_BASE_ADDR + 0x27c)
+#define CLASS_HOST_PE4_GP		(CLASS_CSR_BASE_ADDR + 0x280)
+#define CLASS_PE4_GP			(CLASS_CSR_BASE_ADDR + 0x284)
+#define CLASS_HOST_PE5_GP		(CLASS_CSR_BASE_ADDR + 0x288)
+#define CLASS_PE5_GP			(CLASS_CSR_BASE_ADDR + 0x28c)
+
+#define CLASS_PE_INT_SRC		(CLASS_CSR_BASE_ADDR + 0x290)
+#define CLASS_PE_INT_ENABLE		(CLASS_CSR_BASE_ADDR + 0x294)
+
+#define CLASS_TPID0_TPID1		(CLASS_CSR_BASE_ADDR + 0x298)
+#define CLASS_TPID2			(CLASS_CSR_BASE_ADDR + 0x29c)
+
+#define CLASS_L4_CHKSUM_ADDR		(CLASS_CSR_BASE_ADDR + 0x2a0)
+
+#define CLASS_PE0_DEBUG			(CLASS_CSR_BASE_ADDR + 0x2a4)
+#define CLASS_PE1_DEBUG			(CLASS_CSR_BASE_ADDR + 0x2a8)
+#define CLASS_PE2_DEBUG			(CLASS_CSR_BASE_ADDR + 0x2ac)
+#define CLASS_PE3_DEBUG			(CLASS_CSR_BASE_ADDR + 0x2b0)
+#define CLASS_PE4_DEBUG			(CLASS_CSR_BASE_ADDR + 0x2b4)
+#define CLASS_PE5_DEBUG			(CLASS_CSR_BASE_ADDR + 0x2b8)
+
+#define CLASS_STATE			(CLASS_CSR_BASE_ADDR + 0x2bc)
+
+/* CLASS defines */
+#define CLASS_PBUF_SIZE			0x100	/* Fixed by hardware */
+#define CLASS_PBUF_HEADER_OFFSET	0x80	/* Can be configured */
+
+#define CLASS_PBUF0_BASE_ADDR		0x000						/* Can be configured */
+#define CLASS_PBUF1_BASE_ADDR		(CLASS_PBUF0_BASE_ADDR + CLASS_PBUF_SIZE)	/* Can be configured */
+#define CLASS_PBUF2_BASE_ADDR		(CLASS_PBUF1_BASE_ADDR + CLASS_PBUF_SIZE)	/* Can be configured */
+#define CLASS_PBUF3_BASE_ADDR		(CLASS_PBUF2_BASE_ADDR + CLASS_PBUF_SIZE)	/* Can be configured */
+
+#define CLASS_PBUF0_HEADER_BASE_ADDR	(CLASS_PBUF0_BASE_ADDR + CLASS_PBUF_HEADER_OFFSET)
+#define CLASS_PBUF1_HEADER_BASE_ADDR	(CLASS_PBUF1_BASE_ADDR + CLASS_PBUF_HEADER_OFFSET)
+#define CLASS_PBUF2_HEADER_BASE_ADDR	(CLASS_PBUF2_BASE_ADDR + CLASS_PBUF_HEADER_OFFSET)
+#define CLASS_PBUF3_HEADER_BASE_ADDR	(CLASS_PBUF3_BASE_ADDR + CLASS_PBUF_HEADER_OFFSET)
+
+#define CLASS_PE0_RO_DM_ADDR0_VAL	((CLASS_PBUF1_BASE_ADDR << 16) | CLASS_PBUF0_BASE_ADDR)
+#define CLASS_PE0_RO_DM_ADDR1_VAL	((CLASS_PBUF3_BASE_ADDR << 16) | CLASS_PBUF2_BASE_ADDR)
+
+#define CLASS_PE0_QB_DM_ADDR0_VAL	((CLASS_PBUF1_HEADER_BASE_ADDR << 16) | CLASS_PBUF0_HEADER_BASE_ADDR)
+#define CLASS_PE0_QB_DM_ADDR1_VAL	((CLASS_PBUF3_HEADER_BASE_ADDR << 16) | CLASS_PBUF2_HEADER_BASE_ADDR)
+
+#define CLASS_ROUTE_SIZE		128
+#define CLASS_ROUTE_HASH_BITS		20
+#define CLASS_ROUTE_HASH_MASK		((1 << CLASS_ROUTE_HASH_BITS) - 1)
+
+#define	CLASS_ROUTE0_BASE_ADDR	0x400						/* Can be configured */
+#define CLASS_ROUTE1_BASE_ADDR	(CLASS_ROUTE0_BASE_ADDR + CLASS_ROUTE_SIZE)	/* Can be configured */
+#define CLASS_ROUTE2_BASE_ADDR	(CLASS_ROUTE1_BASE_ADDR + CLASS_ROUTE_SIZE)	/* Can be configured */
+#define CLASS_ROUTE3_BASE_ADDR	(CLASS_ROUTE2_BASE_ADDR + CLASS_ROUTE_SIZE)	/* Can be configured */
+
+#define TWO_LEVEL_ROUTE		(1 << 0)
+#define PHYNO_IN_HASH		(1 << 1)
+#define HW_ROUTE_FETCH		(1 << 3)
+#define HW_BRIDGE_FETCH		(1 << 5)
+#define IP_ALIGNED		(1 << 6)
+#define ARC_HIT_CHECK_EN	(1 << 7)
+#define CLASS_TOE		(1 << 11)
+#define HASH_NORMAL		(0 << 12)
+#define HASH_CRC_PORT		(1 << 12)
+#define HASH_CRC_IP		(2 << 12)
+#define HASH_CRC_PORT_IP	(3 << 12)
+#define QB2BUS_LE		(1 << 15)
+
+#define	TCP_CHKSUM_DROP		(1 << 0)
+#define	UDP_CHKSUM_DROP		(1 << 1)
+#define	IPV4_CHKSUM_DROP	(1 << 9)
+
+typedef struct {
+	u32 route_table_baseaddr;
+	u32 route_table_hash_bits;
+} CLASS_CFG;
+
+#endif /* _CLASS_CSR_H_ */
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/net/c2000_eth/pfe/cbus/emac.h u-boot-2013.01.new/drivers/net/c2000_eth/pfe/cbus/emac.h
--- u-boot-2013.01/drivers/net/c2000_eth/pfe/cbus/emac.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/net/c2000_eth/pfe/cbus/emac.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,246 @@
+#ifndef _EMAC_H_
+#define _EMAC_H_
+
+#define EMAC_NETWORK_CONTROL		0x000
+#define EMAC_NETWORK_CONFIG		0x004
+#define EMAC_NETWORK_STATUS		0x008
+
+#define EMAC_PHY_MANAGEMENT		0x034
+
+#define EMAC_SPEC1_ADD_BOT		0x088
+#define EMAC_SPEC1_ADD_TOP		0x08c
+#define EMAC_SPEC2_ADD_BOT		0x090
+#define EMAC_SPEC2_ADD_TOP		0x094
+#define EMAC_SPEC3_ADD_BOT		0x098
+#define EMAC_SPEC3_ADD_TOP		0x09c
+#define EMAC_SPEC4_ADD_BOT		0x0a0
+#define EMAC_SPEC4_ADD_TOP		0x0a4
+
+#define EMAC_SPEC1_ADD_MASK_BOT		0x0c8
+#define EMAC_SPEC1_ADD_MASK_TOP		0x0cc
+
+#define EMAC_OCT_TX_BOT			0x100
+#define EMAC_OCT_TX_TOP			0x104
+#define EMAC_STATS_FRAMES_TX		0x108
+#define EMAC_BROADCAST_TX		0x10C
+#define EMAC_MULTICAST_TX		0x110
+#define EMAC_STATS_PAUSE_TX		0x114
+#define EMAC_FRAME64_TX			0x118
+#define EMAC_FRAME65_TX			0x11C
+#define EMAC_FRAME128_TX		0x120
+#define EMAC_FRAME256_TX		0x124
+#define EMAC_FRAME512_TX		0x128
+#define EMAC_FRAME1024_TX		0x12C
+#define EMAC_FRAME1519_TX		0x130
+#define EMAC_STATS_TX_URUN		0x134
+#define EMAC_STATS_SINGLE_COL		0x138
+#define EMAC_STATS_MULTI_COL		0x13C
+#define EMAC_STATS_EXCESS_COL		0x140
+#define EMAC_STATS_LATE_COL		0x144
+#define EMAC_STATS_DEF_TX		0x148
+#define EMAC_STATS_CRS_ERRORS		0x14C
+#define EMAC_OCT_RX_BOT			0x150
+#define EMAC_OCT_RX_TOP			0x154
+#define EMAC_STATS_FRAMES_RX		0x158
+#define EMAC_BROADCAST_RX		0x15C
+#define EMAC_MULTICAST_RX		0x160
+#define EMAC_STATS_PAUSE_RX		0x164
+#define EMAC_FRAME64_RX			0x168
+#define EMAC_FRAME65_RX			0x16C
+#define EMAC_FRAME128_RX		0x170
+#define EMAC_FRAME256_RX		0x174
+#define EMAC_FRAME512_RX		0x178
+#define EMAC_FRAME1024_RX		0x17C
+#define EMAC_FRAME1519_RX		0x180
+#define EMAC_STATS_USIZE_FRAMES		0x184
+#define EMAC_STATS_EXCESS_LEN		0x188
+#define EMAC_STATS_JABBERS		0x18C
+#define EMAC_STATS_FCS_ERRORS		0x190
+#define EMAC_STATS_LENGTH_ERRORS	0x194
+#define EMAC_STATS_RX_SYM_ERR		0x198
+#define EMAC_STATS_ALIGN_ERRORS		0x19C
+#define EMAC_STATS_RX_RES_ERR		0x1a0
+#define EMAC_STATS_RX_ORUN		0x1a4
+
+#define EMAC_SPEC5_ADD_BOT		0x300
+#define EMAC_SPEC5_ADD_TOP		0x304
+#define EMAC_SPEC6_ADD_BOT		0x308
+#define EMAC_SPEC6_ADD_TOP		0x30c
+#define EMAC_SPEC7_ADD_BOT		0x310
+#define EMAC_SPEC7_ADD_TOP		0x314
+#define EMAC_SPEC8_ADD_BOT		0x318
+#define EMAC_SPEC8_ADD_TOP		0x31c
+#define EMAC_SPEC9_ADD_BOT		0x320
+#define EMAC_SPEC9_ADD_TOP		0x324
+#define EMAC_SPEC10_ADD_BOT		0x328
+#define EMAC_SPEC10_ADD_TOP		0x32c
+#define EMAC_SPEC11_ADD_BOT		0x330
+#define EMAC_SPEC11_ADD_TOP		0x334
+#define EMAC_SPEC12_ADD_BOT		0x338
+#define EMAC_SPEC12_ADD_TOP		0x33c
+#define EMAC_SPEC13_ADD_BOT		0x340
+#define EMAC_SPEC13_ADD_TOP		0x344
+#define EMAC_SPEC14_ADD_BOT		0x348
+#define EMAC_SPEC14_ADD_TOP		0x34c
+#define EMAC_SPEC15_ADD_BOT		0x350
+#define EMAC_SPEC15_ADD_TOP		0x354
+#define EMAC_SPEC16_ADD_BOT		0x358
+#define EMAC_SPEC16_ADD_TOP		0x35c
+#define EMAC_SPEC17_ADD_BOT		0x360
+#define EMAC_SPEC17_ADD_TOP		0x364
+#define EMAC_SPEC18_ADD_BOT		0x368
+#define EMAC_SPEC18_ADD_TOP		0x36c
+#define EMAC_SPEC19_ADD_BOT		0x370
+#define EMAC_SPEC19_ADD_TOP		0x374
+#define EMAC_SPEC20_ADD_BOT		0x378
+#define EMAC_SPEC20_ADD_TOP		0x37c
+#define EMAC_SPEC21_ADD_BOT		0x380
+#define EMAC_SPEC21_ADD_TOP		0x384
+#define EMAC_SPEC22_ADD_BOT		0x388
+#define EMAC_SPEC22_ADD_TOP		0x38c
+#define EMAC_SPEC23_ADD_BOT		0x390
+#define EMAC_SPEC23_ADD_TOP		0x394
+#define EMAC_SPEC24_ADD_BOT		0x398
+#define EMAC_SPEC24_ADD_TOP		0x39c
+#define EMAC_SPEC25_ADD_BOT		0x3a0
+#define EMAC_SPEC25_ADD_TOP		0x3a4
+#define EMAC_SPEC26_ADD_BOT		0x3a8
+#define EMAC_SPEC26_ADD_TOP		0x3ac
+#define EMAC_SPEC27_ADD_BOT		0x3b0
+#define EMAC_SPEC27_ADD_TOP		0x3b4
+#define EMAC_SPEC28_ADD_BOT		0x3b8
+#define EMAC_SPEC28_ADD_TOP		0x3bc
+#define EMAC_SPEC29_ADD_BOT		0x3c0
+#define EMAC_SPEC29_ADD_TOP		0x3c4
+#define EMAC_SPEC30_ADD_BOT		0x3c8
+#define EMAC_SPEC30_ADD_TOP		0x3cc
+#define EMAC_SPEC31_ADD_BOT		0x3d0
+#define EMAC_SPEC31_ADD_TOP		0x3d4
+#define EMAC_SPEC32_ADD_BOT		0x3d8
+#define EMAC_SPEC32_ADD_TOP		0x3dc
+
+#define EMAC_CONTROL			0x7a0
+
+
+/* GEMAC definitions and settings */
+
+#define EMAC_PORT_0			0
+#define EMAC_PORT_1			1
+#define EMAC_PORT_2			2
+
+/* The possible operating speeds of the MAC, currently supporting 10, 100 and
+ * 1000Mb modes.
+ */
+typedef enum {SPEED_10M, SPEED_100M, SPEED_1000M, SPEED_1000M_PCS} MAC_SPEED;
+
+#define GMII	1
+#define MII	2
+#define RMII	3
+#define RGMII	4
+#define SGMII	5
+
+#define DUPLEX_HALF	0x00
+#define DUPLEX_FULL	0x01
+
+/* EMAC_NETWORK_CONTROL bits definition */
+#define EMAC_RX_ENABLE			(1 << 2)
+#define EMAC_TX_ENABLE			(1 << 3)
+#define EMAC_MDIO_EN                    (1 << 4)
+
+
+/* EMAC_NETWORK_CONFIG bits definition */
+#define EMAC_SPEED_100		(1 << 0)
+#define EMAC_HALF_DUP		(0 << 1)
+#define EMAC_FULL_DUP		(1 << 1)
+#define EMAC_DUPLEX_MASK	(1 << 1)
+#define EMAC_ENABLE_JUMBO_FRAME (1 << 3)
+#define EMAC_ENABLE_COPY_ALL	(1 << 4)	
+#define EMAC_NO_BROADCAST	(1 << 5)
+#define EMAC_ENABLE_MULTICAST	(1 << 6)
+#define EMAC_ENABLE_UNICAST	(1 << 7)
+#define EMAC_ENABLE_1536_RX	(1 << 8)
+#define EMAC_SPEED_1000		(1 << 10)
+#define EMAC_PCS_ENABLE		(1 << 11)
+#define EMAC_ENABLE_PAUSE_RX	(1 << 13)
+#define EMAC_REMOVE_FCS		(1 << 17)
+#define EMAC_ENABLE_CHKSUM_RX	(1 << 24)
+#define EMAC_ENABLE_FCS_RX	(1 << 26)
+#define EMAC_SGMII_MODE_ENABLE	(1 << 27)
+#define EMAC_DATA_BUS_WIDTH_SHIFT	21
+#define EMAC_DATA_BUS_WIDTH_MASK (0x3 << EMAC_DATA_BUS_WIDTH_SHIFT)
+#define EMAC_DATA_BUS_WIDTH_32	(0x00 << EMAC_DATA_BUS_WIDTH_SHIFT)
+#define EMAC_DATA_BUS_WIDTH_64	(0x01 << EMAC_DATA_BUS_WIDTH_SHIFT)
+#define EMAC_DATA_BUS_WIDTH_128	(0x10 << EMAC_DATA_BUS_WIDTH_SHIFT)
+
+#define EMAC_SPEED_MASK		(EMAC_SPEED_100 | EMAC_SPEED_1000)
+
+/* EMAC_CONTROL bits definition */
+#define EMAC_TWO_BYTES_IP_ALIGN		(1 << 0) // two bytes IP alignement
+
+//RMII enable  bit 1 / RGMII enable  bit 2
+#define EMAC_RMII_MODE_ENABLE		((1 << 1) | (0 << 2))
+#define EMAC_RMII_MODE_DISABLE		(0 << 1)
+#define EMAC_RGMII_MODE_ENABLE		((0 << 1) | (1 << 2))
+#define EMAC_RGMII_MODE_DISABLE		(0 << 2)
+#define EMAC_MII_MODE_ENABLE		(EMAC_RMII_MODE_DISABLE | EMAC_RGMII_MODE_DISABLE)
+#define EMAC_GMII_MODE_ENABLE		(EMAC_RMII_MODE_DISABLE | EMAC_RGMII_MODE_DISABLE)
+#define EMAC_MODE_MASK			(0x3 << 1)
+
+/* Default configuration */
+#define EMAC0_DEFAULT_DUPLEX_MODE	FULLDUPLEX 
+#define EMAC0_DEFAULT_EMAC_MODE		RGMII      
+#define EMAC0_DEFAULT_EMAC_SPEED	SPEED_1000M   
+
+#define EMAC1_DEFAULT_DUPLEX_MODE	FULLDUPLEX 
+#define EMAC1_DEFAULT_EMAC_MODE		RGMII      
+#define EMAC1_DEFAULT_EMAC_SPEED	SPEED_1000M   
+
+#define EMAC2_DEFAULT_DUPLEX_MODE	FULLDUPLEX 
+#define EMAC2_DEFAULT_EMAC_MODE		RGMII      
+#define EMAC2_DEFAULT_EMAC_SPEED	SPEED_1000M   
+
+/* The possible MDC clock division of the MAC, currently supporting 8, 16 , 32,
+ * 48, 64, 96, 128, 224.
+ */
+typedef enum { MDC_DIV_8, MDC_DIV_16, MDC_DIV_32, MDC_DIV_48, MDC_DIV_64,
+        MDC_DIV_96, MDC_DIV_128, MDC_DIV_224
+} MAC_MDC_DIV;
+
+#define MDC_DIV_MASK    0x7
+#define MDC_DIV_SHIFT   18
+
+/* The Address organisation for the MAC device.  All addresses are split into
+ * two 32-bit register fields.  The first one (bottom) is the lower 32-bits of
+ * the address and the other field are the high order bits - this may be 16-bits
+ * in the case of MAC addresses, or 32-bits for the hash address.
+ * In terms of memory storage, the first item (bottom) is assumed to be at a
+ * lower address location than 'top'. i.e. top should be at address location of
+ * 'bottom' + 4 bytes.
+ */
+typedef struct {
+	u32 bottom;     /* Lower 32-bits of address. */
+	u32 top;        /* Upper 32-bits of address. */
+} MAC_ADDR;
+
+
+/* The following is the organisation of the address filters section of the MAC
+ * registers.  The Cadence MAC contains four possible specific address match
+ * addresses, if an incoming frame corresponds to any one of these four
+ * addresses then the frame will be copied to memory.
+ * It is not necessary for all four of the address match registers to be
+ * programmed, this is application dependant.
+ */
+typedef struct {
+	MAC_ADDR one;        /* Specific address register 1. */
+	MAC_ADDR two;        /* Specific address register 2. */
+	MAC_ADDR three;      /* Specific address register 3. */
+	MAC_ADDR four;       /* Specific address register 4. */
+} SPEC_ADDR;
+
+typedef struct {
+	u32 mode; 
+	u32 speed;
+	u32 duplex;
+} GEMAC_CFG;
+
+#endif /* _EMAC_H_ */
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/net/c2000_eth/pfe/cbus/gpi.h u-boot-2013.01.new/drivers/net/c2000_eth/pfe/cbus/gpi.h
--- u-boot-2013.01/drivers/net/c2000_eth/pfe/cbus/gpi.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/net/c2000_eth/pfe/cbus/gpi.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,58 @@
+#ifndef _GPI_H_
+#define _GPI_H_
+
+#define GPI_VERSION			0x00
+#define GPI_CTRL			0x04
+#define GPI_RX_CONFIG			0x08
+#define GPI_HDR_SIZE			0x0c
+#define GPI_BUF_SIZE			0x10
+#define GPI_LMEM_ALLOC_ADDR		0x14
+#define GPI_LMEM_FREE_ADDR		0x18
+#define GPI_DDR_ALLOC_ADDR		0x1c
+#define GPI_DDR_FREE_ADDR		0x20
+#define GPI_CLASS_ADDR			0x24
+#define GPI_DRX_FIFO			0x28
+#define GPI_TRX_FIFO			0x2c
+#define GPI_INQ_PKTPTR			0x30
+#define GPI_DDR_DATA_OFFSET		0x34
+#define GPI_LMEM_DATA_OFFSET		0x38
+#define GPI_TMLF_TX			0x4c
+#define GPI_DTX_ASEQ			0x50
+#define GPI_FIFO_STATUS_ADDR		0x54
+#define GPI_FIFO_DEBUG			0x58
+#define GPI_TX_PAUSE_TIME		0x5c
+#define GPI_LMEM_SEC_BUF_DATA_OFFSET	0x60
+#define GPI_DDR_SEC_BUF_DATA_OFFSET	0x64
+
+typedef struct {
+	u32 lmem_rtry_cnt;
+	u32 tmlf_txthres;
+	u32 aseq_len;
+} GPI_CFG;
+
+
+/* GPI commons defines */ 
+#define GPI_LMEM_BUF_EN		0x1
+#define GPI_DDR_BUF_EN		0x1
+
+/* EGPI 1 defines */ 
+#define EGPI1_LMEM_RTRY_CNT	0x40
+#define EGPI1_TMLF_TXTHRES	0xBC
+#define EGPI1_ASEQ_LEN		0x50
+
+/* EGPI 2 defines */ 
+#define EGPI2_LMEM_RTRY_CNT	0x40
+#define EGPI2_TMLF_TXTHRES	0xBC
+#define EGPI2_ASEQ_LEN		0x40
+
+/* EGPI 3 defines */ 
+#define EGPI3_LMEM_RTRY_CNT	0x40
+#define EGPI3_TMLF_TXTHRES	0xBC
+#define EGPI3_ASEQ_LEN		0x40
+
+/* HGPI defines */ 
+#define HGPI_LMEM_RTRY_CNT	0x40
+#define HGPI_TMLF_TXTHRES	0xBC
+#define HGPI_ASEQ_LEN		0x40
+
+#endif /* _GPI_H_ */
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/net/c2000_eth/pfe/cbus/gpt.h u-boot-2013.01.new/drivers/net/c2000_eth/pfe/cbus/gpt.h
--- u-boot-2013.01/drivers/net/c2000_eth/pfe/cbus/gpt.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/net/c2000_eth/pfe/cbus/gpt.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,11 @@
+#ifndef _CBUS_GPT_H_
+#define _CBUS_GPT_H_
+
+#define CBUS_GPT_VERSION	 (CBUS_GPT_BASE_ADDR + 0x00)
+#define CBUS_GPT_STATUS		 (CBUS_GPT_BASE_ADDR + 0x04)
+#define CBUS_GPT_CONFIG		 (CBUS_GPT_BASE_ADDR + 0x08)
+#define CBUS_GPT_COUNTER	 (CBUS_GPT_BASE_ADDR + 0x0c)
+#define CBUS_GPT_PERIOD		 (CBUS_GPT_BASE_ADDR + 0x10)
+#define CBUS_GPT_WIDTH		 (CBUS_GPT_BASE_ADDR + 0x14)
+
+#endif /* _CBUS_GPT_H_ */
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/net/c2000_eth/pfe/cbus/hif.h u-boot-2013.01.new/drivers/net/c2000_eth/pfe/cbus/hif.h
--- u-boot-2013.01/drivers/net/c2000_eth/pfe/cbus/hif.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/net/c2000_eth/pfe/cbus/hif.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,62 @@
+#ifndef _HIF_H_
+#define _HIF_H_
+
+/** @file hif.h.
+ * hif - PFE hif block control and status register. Mapped on CBUS and accessible from all PE's and ARM.
+ */
+#define HIF_VERSION		(HIF_BASE_ADDR + 0x00)
+#define HIF_TX_CTRL		(HIF_BASE_ADDR + 0x04)
+#define HIF_TX_CURR_BD_ADDR	(HIF_BASE_ADDR + 0x08)
+#define HIF_TX_ALLOC		(HIF_BASE_ADDR + 0x0c)
+#define HIF_TX_BDP_ADDR		(HIF_BASE_ADDR + 0x10)
+#define HIF_TX_STATUS		(HIF_BASE_ADDR + 0x14)
+#define HIF_RX_CTRL		(HIF_BASE_ADDR + 0x20)
+#define HIF_RX_BDP_ADDR		(HIF_BASE_ADDR + 0x24)
+#define HIF_RX_STATUS		(HIF_BASE_ADDR + 0x30)
+#define HIF_INT_SRC		(HIF_BASE_ADDR + 0x34)
+#define HIF_INT_ENABLE		(HIF_BASE_ADDR + 0x38)
+#define HIF_POLL_CTRL		(HIF_BASE_ADDR + 0x3c)
+#define HIF_RX_CURR_BD_ADDR	(HIF_BASE_ADDR + 0x40)
+#define HIF_RX_ALLOC		(HIF_BASE_ADDR + 0x44)
+#define HIF_TX_DMA_STATUS	(HIF_BASE_ADDR + 0x48)
+#define HIF_RX_DMA_STATUS	(HIF_BASE_ADDR + 0x4c)
+#define HIF_INT_COAL		(HIF_BASE_ADDR + 0x50)
+
+/*HIF_INT_SRC/ HIF_INT_ENABLE control bits */
+#define HIF_INT        		(1 << 0)
+#define HIF_RXBD_INT   		(1 << 1)
+#define HIF_RXPKT_INT  		(1 << 2)
+#define HIF_TXBD_INT   		(1 << 3)
+#define HIF_TXPKT_INT  		(1 << 4)
+
+/*HIF_TX_CTRL bits */
+#define HIF_CTRL_DMA_EN			(1<<0)
+#define HIF_CTRL_BDP_POLL_CTRL_EN	(1<<1)
+#define HIF_CTRL_BDP_CH_START_WSTB	(1<<2)
+
+/*HIF_INT_ENABLE bits */
+#define HIF_INT_EN		(1 << 0)
+#define HIF_RXBD_INT_EN		(1 << 1)
+#define HIF_RXPKT_INT_EN	(1 << 2)
+#define HIF_TXBD_INT_EN		(1 << 3)
+#define HIF_TXPKT_INT_EN	(1 << 4)
+
+/*HIF_POLL_CTRL bits*/
+#define HIF_RX_POLL_CTRL_CYCLE	0x0400
+#define HIF_TX_POLL_CTRL_CYCLE	0x0400
+
+/*Buffer descriptor control bits */
+#define BD_CTRL_BUFLEN_MASK	(0xffff)
+#define BD_BUF_LEN(x)		(x & BD_CTRL_BUFLEN_MASK)
+#define BD_CTRL_CBD_INT_EN	(1 << 16)
+#define BD_CTRL_PKT_INT_EN	(1 << 17)
+#define BD_CTRL_LIFM		(1 << 18)
+#define BD_CTRL_LAST_BD		(1 << 19)
+#define BD_CTRL_DIR		(1 << 20)
+#define BD_CTRL_PKT_XFER	(1 << 24)
+#define BD_CTRL_DESC_EN		(1 << 31)
+#define BD_CTRL_PARSE_DISABLE	(1 << 25)
+#define BD_CTRL_BRFETCH_DISABLE	(1 << 26)
+#define BD_CTRL_RTFETCH_DISABLE	(1 << 27)
+
+#endif /* _HIF_H_ */
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/net/c2000_eth/pfe/cbus/hif_nocpy.h u-boot-2013.01.new/drivers/net/c2000_eth/pfe/cbus/hif_nocpy.h
--- u-boot-2013.01/drivers/net/c2000_eth/pfe/cbus/hif_nocpy.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/net/c2000_eth/pfe/cbus/hif_nocpy.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,33 @@
+#ifndef _HIF_NOCPY_H_
+#define _HIF_NOCPY_H_
+
+#define HIF_NOCPY_VERSION		(HIF_NOCPY_BASE_ADDR + 0x00)
+#define HIF_NOCPY_TX_CTRL		(HIF_NOCPY_BASE_ADDR + 0x04)
+#define HIF_NOCPY_TX_CURR_BD_ADDR	(HIF_NOCPY_BASE_ADDR + 0x08)
+#define HIF_NOCPY_TX_ALLOC		(HIF_NOCPY_BASE_ADDR + 0x0c)
+#define HIF_NOCPY_TX_BDP_ADDR		(HIF_NOCPY_BASE_ADDR + 0x10)
+#define HIF_NOCPY_TX_STATUS		(HIF_NOCPY_BASE_ADDR + 0x14)
+#define HIF_NOCPY_RX_CTRL		(HIF_NOCPY_BASE_ADDR + 0x20)
+#define HIF_NOCPY_RX_BDP_ADDR		(HIF_NOCPY_BASE_ADDR + 0x24)
+#define HIF_NOCPY_RX_STATUS		(HIF_NOCPY_BASE_ADDR + 0x30)
+#define HIF_NOCPY_INT_SRC		(HIF_NOCPY_BASE_ADDR + 0x34)
+#define HIF_NOCPY_INT_ENABLE		(HIF_NOCPY_BASE_ADDR + 0x38)
+#define HIF_NOCPY_POLL_CTRL		(HIF_NOCPY_BASE_ADDR + 0x3c)
+#define HIF_NOCPY_RX_CURR_BD_ADDR	(HIF_NOCPY_BASE_ADDR + 0x40)
+#define HIF_NOCPY_RX_ALLOC		(HIF_NOCPY_BASE_ADDR + 0x44)
+#define HIF_NOCPY_TX_DMA_STATUS		(HIF_NOCPY_BASE_ADDR + 0x48)
+#define HIF_NOCPY_RX_DMA_STATUS		(HIF_NOCPY_BASE_ADDR + 0x4c)
+#define HIF_NOCPY_RX_INQ0_PKTPTR	(HIF_NOCPY_BASE_ADDR + 0x50)
+#define HIF_NOCPY_RX_INQ1_PKTPTR	(HIF_NOCPY_BASE_ADDR + 0x54)
+#define HIF_NOCPY_TX_PORT_NO		(HIF_NOCPY_BASE_ADDR + 0x60)
+#define HIF_NOCPY_LMEM_ALLOC_ADDR	(HIF_NOCPY_BASE_ADDR + 0x64)
+#define HIF_NOCPY_CLASS_ADDR		(HIF_NOCPY_BASE_ADDR + 0x68)
+#define HIF_NOCPY_TMU_PORT0_ADDR	(HIF_NOCPY_BASE_ADDR + 0x70)
+#define HIF_NOCPY_TMU_PORT1_ADDR	(HIF_NOCPY_BASE_ADDR + 0x74)
+#define HIF_NOCPY_TMU_PORT2_ADDR	(HIF_NOCPY_BASE_ADDR + 0x7c)
+#define HIF_NOCPY_TMU_PORT3_ADDR	(HIF_NOCPY_BASE_ADDR + 0x80)
+#define HIF_NOCPY_TMU_PORT4_ADDR	(HIF_NOCPY_BASE_ADDR + 0x84)
+#define HIF_NOCPY_INT_COAL		(HIF_NOCPY_BASE_ADDR + 0x90)
+
+
+#endif /* _HIF_NOCPY_H_ */
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/net/c2000_eth/pfe/cbus/tmu_csr.h u-boot-2013.01.new/drivers/net/c2000_eth/pfe/cbus/tmu_csr.h
--- u-boot-2013.01/drivers/net/c2000_eth/pfe/cbus/tmu_csr.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/net/c2000_eth/pfe/cbus/tmu_csr.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,93 @@
+#ifndef _TMU_CSR_H_
+#define _TMU_CSR_H_
+
+#define TMU_VERSION			(TMU_CSR_BASE_ADDR + 0x000)
+#define TMU_INQ_WATERMARK		(TMU_CSR_BASE_ADDR + 0x004)
+#define TMU_PHY_INQ_PKTPTR		(TMU_CSR_BASE_ADDR + 0x008)
+#define TMU_PHY_INQ_PKTINFO		(TMU_CSR_BASE_ADDR + 0x00c)
+#define TMU_PHY_INQ_FIFO_CNT		(TMU_CSR_BASE_ADDR + 0x010)
+#define TMU_SYS_GENERIC_CONTROL		(TMU_CSR_BASE_ADDR + 0x014)
+#define TMU_SYS_GENERIC_STATUS		(TMU_CSR_BASE_ADDR + 0x018)
+#define TMU_SYS_GEN_CON0		(TMU_CSR_BASE_ADDR + 0x01c)
+#define TMU_SYS_GEN_CON1		(TMU_CSR_BASE_ADDR + 0x020)
+#define TMU_SYS_GEN_CON2		(TMU_CSR_BASE_ADDR + 0x024)
+#define TMU_SYS_GEN_CON3		(TMU_CSR_BASE_ADDR + 0x028)
+#define TMU_SYS_GEN_CON4		(TMU_CSR_BASE_ADDR + 0x02c)
+#define TMU_TEQ_DISABLE_DROPCHK		(TMU_CSR_BASE_ADDR + 0x030)
+#define TMU_TEQ_CTRL			(TMU_CSR_BASE_ADDR + 0x034)
+#define TMU_TEQ_QCFG			(TMU_CSR_BASE_ADDR + 0x038)
+#define TMU_TEQ_QCUR			(TMU_CSR_BASE_ADDR + 0x03c)
+#define TMU_TEQ_QAVG			(TMU_CSR_BASE_ADDR + 0x040)
+#define TMU_TEQ_WREG_PROB		(TMU_CSR_BASE_ADDR + 0x044)
+#define TMU_TEQ_QAVG_WGT		(TMU_CSR_BASE_ADDR + 0x048)
+#define TMU_TEQ_HW_PROB_CFG0		(TMU_CSR_BASE_ADDR + 0x04c)
+#define TMU_TEQ_HW_PROB_CFG1		(TMU_CSR_BASE_ADDR + 0x050)
+#define TMU_TEQ_HW_PROB_CFG2		(TMU_CSR_BASE_ADDR + 0x054)
+#define TMU_TEQ_HW_PROB_CFG3		(TMU_CSR_BASE_ADDR + 0x058)
+#define TMU_TEQ_HW_PROB_CFG4		(TMU_CSR_BASE_ADDR + 0x05c)
+#define TMU_TEQ_HW_PROB_CFG5		(TMU_CSR_BASE_ADDR + 0x060)
+#define TMU_TEQ_HW_PROB_CFG6		(TMU_CSR_BASE_ADDR + 0x064)
+#define TMU_TEQ_HW_PROB_CFG7		(TMU_CSR_BASE_ADDR + 0x068)
+#define TMU_TEQ_HW_PROB_CFG8		(TMU_CSR_BASE_ADDR + 0x06c)
+#define TMU_TEQ_HW_PROB_CFG9		(TMU_CSR_BASE_ADDR + 0x070)
+#define TMU_TEQ_HW_PROB_CFG10		(TMU_CSR_BASE_ADDR + 0x074)
+#define TMU_TEQ_HW_PROB_CFG11		(TMU_CSR_BASE_ADDR + 0x078)
+#define TMU_TEQ_HW_PROB_CFG12		(TMU_CSR_BASE_ADDR + 0x07c)
+#define TMU_TEQ_HW_PROB_CFG13		(TMU_CSR_BASE_ADDR + 0x080)
+#define TMU_TEQ_HW_PROB_CFG14		(TMU_CSR_BASE_ADDR + 0x084)
+#define TMU_TEQ_HW_PROB_CFG15		(TMU_CSR_BASE_ADDR + 0x088)
+#define TMU_TEQ_HW_PROB_CFG16		(TMU_CSR_BASE_ADDR + 0x08c)
+#define TMU_TEQ_HW_PROB_CFG17		(TMU_CSR_BASE_ADDR + 0x090)
+#define TMU_TEQ_HW_PROB_CFG18		(TMU_CSR_BASE_ADDR + 0x094)
+#define TMU_TEQ_HW_PROB_CFG19		(TMU_CSR_BASE_ADDR + 0x098)
+#define TMU_TEQ_HW_PROB_CFG20		(TMU_CSR_BASE_ADDR + 0x09c)
+#define TMU_TEQ_HW_PROB_CFG21		(TMU_CSR_BASE_ADDR + 0x0a0)
+#define TMU_TEQ_HW_PROB_CFG22		(TMU_CSR_BASE_ADDR + 0x0a4)
+#define TMU_TEQ_HW_PROB_CFG23		(TMU_CSR_BASE_ADDR + 0x0a8)
+#define TMU_TEQ_HW_PROB_CFG24		(TMU_CSR_BASE_ADDR + 0x0ac)
+#define TMU_TEQ_HW_PROB_CFG25		(TMU_CSR_BASE_ADDR + 0x0b0)
+#define TMU_TDQ_IIFG_CFG		(TMU_CSR_BASE_ADDR + 0x0b4)
+#define TMU_TDQ0_SCH_CTRL		(TMU_CSR_BASE_ADDR + 0x0b8)	/**< [9:0] Scheduler Enable for each of the scheduler in the TDQ. This is a global Enable for all schedulers in PHY0 */
+#define TMU_LLM_CTRL			(TMU_CSR_BASE_ADDR + 0x0bc)
+#define TMU_LLM_BASE_ADDR		(TMU_CSR_BASE_ADDR + 0x0c0)
+#define TMU_LLM_QUE_LEN			(TMU_CSR_BASE_ADDR + 0x0c4)
+#define TMU_LLM_QUE_HEADPTR		(TMU_CSR_BASE_ADDR + 0x0c8)
+#define TMU_LLM_QUE_TAILPTR		(TMU_CSR_BASE_ADDR + 0x0cc)
+#define TMU_LLM_QUE_DROPCNT		(TMU_CSR_BASE_ADDR + 0x0d0)
+#define TMU_INT_EN			(TMU_CSR_BASE_ADDR + 0x0d4)
+#define TMU_INT_SRC			(TMU_CSR_BASE_ADDR + 0x0d8)
+#define TMU_INQ_STAT			(TMU_CSR_BASE_ADDR + 0x0dc)
+#define TMU_CTRL			(TMU_CSR_BASE_ADDR + 0x0e0)
+
+#define TMU_MEM_ACCESS_ADDR		(TMU_CSR_BASE_ADDR + 0x0e4)	/**< [31] Mem Access Command. 0 = Internal Memory Read, 1 = Internal memory Write [27:24] Byte Enables of the Internal memory access [23:0] Address of the internal memory. This address is used to access both the PM and DM of all the PE's */
+#define TMU_MEM_ACCESS_WDATA		(TMU_CSR_BASE_ADDR + 0x0e8)	/**< Internal Memory Access Write Data */
+#define TMU_MEM_ACCESS_RDATA		(TMU_CSR_BASE_ADDR + 0x0ec)	/**< Internal Memory Access Read Data. The commands are blocked at the mem_access only */
+
+#define TMU_PHY0_INQ_ADDR		(TMU_CSR_BASE_ADDR + 0x0f0)	/**< [31:0] PHY0 in queue address (must be initialized with one of the xxx_INQ_PKTPTR cbus addresses) */
+#define TMU_PHY1_INQ_ADDR		(TMU_CSR_BASE_ADDR + 0x0f4)	/**< [31:0] PHY1 in queue address (must be initialized with one of the xxx_INQ_PKTPTR cbus addresses) */
+#define TMU_PHY2_INQ_ADDR		(TMU_CSR_BASE_ADDR + 0x0f8)	/**< [31:0] PHY2 in queue address (must be initialized with one of the xxx_INQ_PKTPTR cbus addresses) */
+#define TMU_PHY3_INQ_ADDR		(TMU_CSR_BASE_ADDR + 0x0fc)	/**< [31:0] PHY3 in queue address (must be initialized with one of the xxx_INQ_PKTPTR cbus addresses) */
+#define TMU_BMU_INQ_ADDR		(TMU_CSR_BASE_ADDR + 0x100)
+#define TMU_TX_CTRL			(TMU_CSR_BASE_ADDR + 0x104)
+
+#define TMU_BUS_ACCESS_WDATA		(TMU_CSR_BASE_ADDR + 0x108)
+#define TMU_BUS_ACCESS			(TMU_CSR_BASE_ADDR + 0x10c)
+#define TMU_BUS_ACCESS_RDATA		(TMU_CSR_BASE_ADDR + 0x110)
+
+#define TMU_PE_SYS_CLK_RATIO		(TMU_CSR_BASE_ADDR + 0x114)
+#define TMU_PE_STATUS			(TMU_CSR_BASE_ADDR + 0x118)
+#define TMU_TEQ_MAX_THRESHOLD		(TMU_CSR_BASE_ADDR + 0x11c)
+#define TMU_PHY4_INQ_ADDR		(TMU_CSR_BASE_ADDR + 0x134)	/**< [31:0] PHY4 in queue address (must be initialized with one of the xxx_INQ_PKTPTR cbus addresses) */
+#define TMU_TDQ1_SCH_CTRL		(TMU_CSR_BASE_ADDR + 0x138)	/**< [9:0] Scheduler Enable for each of the scheduler in the TDQ. This is a global Enable for all schedulers in PHY1 */
+#define TMU_TDQ2_SCH_CTRL		(TMU_CSR_BASE_ADDR + 0x13c)	/**< [9:0] Scheduler Enable for each of the scheduler in the TDQ. This is a global Enable for all schedulers in PHY2 */
+#define TMU_TDQ3_SCH_CTRL		(TMU_CSR_BASE_ADDR + 0x140)	/**< [9:0] Scheduler Enable for each of the scheduler in the TDQ. This is a global Enable for all schedulers in PHY3 */
+#define TMU_BMU_BUF_SIZE		(TMU_CSR_BASE_ADDR + 0x144)
+#define TMU_PHY5_INQ_ADDR		(TMU_CSR_BASE_ADDR + 0x148)	/**< [31:0] PHY5 in queue address (must be initialized with one of the xxx_INQ_PKTPTR cbus addresses) */
+
+
+typedef struct {
+	u32 llm_base_addr;
+	u32 llm_queue_len;
+} TMU_CFG;
+
+#endif /* _TMU_CSR_H_ */
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/net/c2000_eth/pfe/cbus/util_csr.h u-boot-2013.01.new/drivers/net/c2000_eth/pfe/cbus/util_csr.h
--- u-boot-2013.01/drivers/net/c2000_eth/pfe/cbus/util_csr.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/net/c2000_eth/pfe/cbus/util_csr.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,42 @@
+#ifndef _UTIL_CSR_H_
+#define _UTIL_CSR_H_
+
+#define UTIL_VERSION			(UTIL_CSR_BASE_ADDR + 0x000)
+#define UTIL_TX_CTRL			(UTIL_CSR_BASE_ADDR + 0x004)
+#define UTIL_INQ_PKTPTR			(UTIL_CSR_BASE_ADDR + 0x010)
+
+#define UTIL_HDR_SIZE			(UTIL_CSR_BASE_ADDR + 0x014)
+
+#define UTIL_PE0_QB_DM_ADDR0		(UTIL_CSR_BASE_ADDR + 0x020)
+#define UTIL_PE0_QB_DM_ADDR1		(UTIL_CSR_BASE_ADDR + 0x024)
+#define UTIL_PE0_RO_DM_ADDR0		(UTIL_CSR_BASE_ADDR + 0x060)
+#define UTIL_PE0_RO_DM_ADDR1		(UTIL_CSR_BASE_ADDR + 0x064)
+
+#define UTIL_MEM_ACCESS_ADDR		(UTIL_CSR_BASE_ADDR + 0x100)
+#define UTIL_MEM_ACCESS_WDATA		(UTIL_CSR_BASE_ADDR + 0x104)
+#define UTIL_MEM_ACCESS_RDATA		(UTIL_CSR_BASE_ADDR + 0x108)
+
+#define UTIL_TM_INQ_ADDR		(UTIL_CSR_BASE_ADDR + 0x114)
+#define UTIL_PE_STATUS			(UTIL_CSR_BASE_ADDR + 0x118)
+
+#define UTIL_PE_SYS_CLK_RATIO		(UTIL_CSR_BASE_ADDR + 0x200)
+#define UTIL_AFULL_THRES		(UTIL_CSR_BASE_ADDR + 0x204)
+#define UTIL_GAP_BETWEEN_READS		(UTIL_CSR_BASE_ADDR + 0x208)
+#define UTIL_MAX_BUF_CNT		(UTIL_CSR_BASE_ADDR + 0x20c)
+#define UTIL_TSQ_FIFO_THRES		(UTIL_CSR_BASE_ADDR + 0x210)
+#define UTIL_TSQ_MAX_CNT		(UTIL_CSR_BASE_ADDR + 0x214)
+#define UTIL_IRAM_DATA_0		(UTIL_CSR_BASE_ADDR + 0x218)
+#define UTIL_IRAM_DATA_1		(UTIL_CSR_BASE_ADDR + 0x21c)
+#define UTIL_IRAM_DATA_2		(UTIL_CSR_BASE_ADDR + 0x220)
+#define UTIL_IRAM_DATA_3		(UTIL_CSR_BASE_ADDR + 0x224)
+
+#define UTIL_BUS_ACCESS_ADDR		(UTIL_CSR_BASE_ADDR + 0x228)
+#define UTIL_BUS_ACCESS_WDATA		(UTIL_CSR_BASE_ADDR + 0x22c)
+#define UTIL_BUS_ACCESS_RDATA		(UTIL_CSR_BASE_ADDR + 0x230)
+
+#define UTIL_INQ_AFULL_THRES		(UTIL_CSR_BASE_ADDR + 0x234)
+
+typedef struct {
+} UTIL_CFG;
+
+#endif /* _UTIL_CSR_H_ */
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/net/c2000_eth/pfe/cbus.h u-boot-2013.01.new/drivers/net/c2000_eth/pfe/cbus.h
--- u-boot-2013.01/drivers/net/c2000_eth/pfe/cbus.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/net/c2000_eth/pfe/cbus.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,72 @@
+#ifndef _CBUS_H_
+#define _CBUS_H_
+
+#define EMAC1_BASE_ADDR		(CBUS_BASE_ADDR + 0x200000)
+#define EGPI1_BASE_ADDR		(CBUS_BASE_ADDR + 0x210000)
+#define EMAC2_BASE_ADDR		(CBUS_BASE_ADDR + 0x220000)
+#define EGPI2_BASE_ADDR		(CBUS_BASE_ADDR + 0x230000)
+#define BMU1_BASE_ADDR		(CBUS_BASE_ADDR + 0x240000)
+#define BMU2_BASE_ADDR		(CBUS_BASE_ADDR + 0x250000)
+#define ARB_BASE_ADDR		(CBUS_BASE_ADDR + 0x260000) /* FIXME not documented */
+#define DDR_CONFIG_BASE_ADDR	(CBUS_BASE_ADDR + 0x270000) /* FIXME not documented */
+#define HIF_BASE_ADDR		(CBUS_BASE_ADDR + 0x280000)
+#define HGPI_BASE_ADDR		(CBUS_BASE_ADDR + 0x290000)
+#define LMEM_BASE_ADDR		(CBUS_BASE_ADDR + 0x300000)
+#define LMEM_SIZE		0x10000
+#define LMEM_END		(LMEM_BASE_ADDR + LMEM_SIZE)
+#define TMU_CSR_BASE_ADDR	(CBUS_BASE_ADDR + 0x310000)
+#define CLASS_CSR_BASE_ADDR	(CBUS_BASE_ADDR + 0x320000)
+#define EMAC3_BASE_ADDR		(CBUS_BASE_ADDR + 0x330000)
+#define EGPI3_BASE_ADDR		(CBUS_BASE_ADDR + 0x340000)
+#define HIF_NOCPY_BASE_ADDR	(CBUS_BASE_ADDR + 0x350000)
+#define UTIL_CSR_BASE_ADDR	(CBUS_BASE_ADDR + 0x360000)
+#define CBUS_GPT_BASE_ADDR	(CBUS_BASE_ADDR + 0x370000)
+
+#define IS_LMEM(addr, len)	(((unsigned long)(addr) >= LMEM_BASE_ADDR) && (((unsigned long)(addr) + (len)) <= LMEM_END))
+
+/** 
+* \defgroup XXX_MEM_ACCESS_ADDR PE memory access through CSR 
+* XXX_MEM_ACCESS_ADDR register bit definitions. 
+* @{
+*/
+#define PE_MEM_ACCESS_WRITE		(1<<31)			/**< Internal Memory Write. */
+#define PE_MEM_ACCESS_READ		(0<<31)			/**< Internal Memory Read. */
+#define PE_MEM_ACCESS_IMEM		(1<<15)
+#define PE_MEM_ACCESS_DMEM		(1<<16)
+#define PE_MEM_ACCESS_BYTE_ENABLE(offset,size)	(((((1 << (size)) - 1) << (4 - (offset) - (size))) & 0xf) << 24)	/**< Byte Enables of the Internal memory access. These are interpred in BE */
+// @}
+#include "cbus/emac.h"
+#include "cbus/gpi.h"
+#include "cbus/bmu.h"
+#include "cbus/hif.h"
+#include "cbus/tmu_csr.h"
+#include "cbus/class_csr.h"
+#include "cbus/hif_nocpy.h"
+#include "cbus/util_csr.h"
+#include "cbus/gpt.h"
+
+
+/* PFE cores states */
+#define CORE_DISABLE	0x00000000 
+#define CORE_ENABLE	0x00000001
+#define CORE_SW_RESET	0x00000002
+
+/* LMEM defines */
+#define LMEM_HDR_SIZE		0x0010
+#define LMEM_BUF_SIZE_LN2	0x7
+#define LMEM_BUF_SIZE		(1 << LMEM_BUF_SIZE_LN2)
+
+/* DDR defines */
+#define DDR_HDR_SIZE		0x0100
+#define DDR_BUF_SIZE_LN2	0xb
+#define DDR_BUF_SIZE		(1 << DDR_BUF_SIZE_LN2)
+
+
+/* Clock generation through PLL */
+#if defined(CONFIG_PLATFORM_PCI)
+#define PLL_CLK_EN	0
+#else
+#define PLL_CLK_EN	1
+#endif
+
+#endif /* _CBUS_H_ */
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/net/c2000_eth/pfe/class/ccu.h u-boot-2013.01.new/drivers/net/c2000_eth/pfe/class/ccu.h
--- u-boot-2013.01/drivers/net/c2000_eth/pfe/class/ccu.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/net/c2000_eth/pfe/class/ccu.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,10 @@
+#ifndef _CCU_H_
+#define _CCU_H_
+
+#define CCU_ADDR	(CCU_BASE_ADDR + 0x00)
+#define CCU_CNT		(CCU_BASE_ADDR + 0x04)
+#define CCU_STATUS	(CCU_BASE_ADDR + 0x08)
+#define CCU_VAL		(CCU_BASE_ADDR + 0x0c)
+
+#endif /* _CCU_H_ */
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/net/c2000_eth/pfe/class/efet.h u-boot-2013.01.new/drivers/net/c2000_eth/pfe/class/efet.h
--- u-boot-2013.01/drivers/net/c2000_eth/pfe/class/efet.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/net/c2000_eth/pfe/class/efet.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,21 @@
+#ifndef _CLASS_EFET_H_
+#define _CLASS_EFET_H_
+
+#define CLASS_EFET_ENTRY_ADDR		(EFET_BASE_ADDR + 0x00)
+#define CLASS_EFET_ENTRY_SIZE		(EFET_BASE_ADDR + 0x04)
+#define CLASS_EFET_ENTRY_DMEM_ADDR	(EFET_BASE_ADDR + 0x08)
+#define CLASS_EFET_ENTRY_STATUS		(EFET_BASE_ADDR + 0x0c)
+#define CLASS_EFET_ENTRY_ENDIAN		(EFET_BASE_ADDR + 0x10)
+
+#define CBUS2DMEM	0
+#define DMEM2CBUS	1
+
+#define EFET2BUS_LE     (1 << 0)
+#define PE2BUS_LE	(1 << 1)
+
+void class_efet(u32 cbus_addr, u32 dmem_addr, u32 len, u32 dir);
+void class_efet_wait(void);
+void class_efet_sync(u32 cbus_addr, u32 dmem_addr, u32 len, u32 dir);
+
+#endif /* _CLASS_EFET_H_ */
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/net/c2000_eth/pfe/class/mac_hash.h u-boot-2013.01.new/drivers/net/c2000_eth/pfe/class/mac_hash.h
--- u-boot-2013.01/drivers/net/c2000_eth/pfe/class/mac_hash.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/net/c2000_eth/pfe/class/mac_hash.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,28 @@
+#ifndef _MAC_HASH_H_
+#define _MAC_HASH_H_
+
+#define MAC_HASH_REQ1_BASE_ADDR		(MAC_HASH_BASE_ADDR + 0x000)
+#define MAC_HASH_REQ2_BASE_ADDR		(MAC_HASH_BASE_ADDR + 0x020)
+#define MAC_HASH_REQ3_BASE_ADDR		(MAC_HASH_BASE_ADDR + 0x040)
+#define MAC_HASH_REQ4_BASE_ADDR		(MAC_HASH_BASE_ADDR + 0x060)
+#define MAC_HASH_REQ5_BASE_ADDR		(MAC_HASH_BASE_ADDR + 0x080)
+#define MAC_HASH_REQ6_BASE_ADDR		(MAC_HASH_BASE_ADDR + 0x0a0)
+#define MAC_HASH_REQ7_BASE_ADDR		(MAC_HASH_BASE_ADDR + 0x0c0)
+#define MAC_HASH_REQ8_BASE_ADDR		(MAC_HASH_BASE_ADDR + 0x0e0)
+
+#define MAC_HASH_REQ_CMD(i)		(MAC_HASH_REQ##i##_BASE_ADDR + 0x000)
+#define MAC_HASH_REQ_MAC1_ADDR(i)	(MAC_HASH_REQ##i##_BASE_ADDR + 0x004)
+#define MAC_HASH_REQ_MAC2_ADDR(i)	(MAC_HASH_REQ##i##_BASE_ADDR + 0x008)
+#define MAC_HASH_REQ_MASK1_ADDR(i)	(MAC_HASH_REQ##i##_BASE_ADDR + 0x00c)
+#define MAC_HASH_REQ_MASK2_ADDR(i)	(MAC_HASH_REQ##i##_BASE_ADDR + 0x010)
+#define MAC_HASH_REQ_ENTRY(i)		(MAC_HASH_REQ##i##_BASE_ADDR + 0x014)
+#define MAC_HASH_REQ_STATUS(i)		(MAC_HASH_REQ##i##_BASE_ADDR + 0x018)
+#define MAC_HASH_REQ_ENTRY_MAYCH(i)	(MAC_HASH_REQ##i##_BASE_ADDR + 0x01c)
+
+
+#define MAC_HASH_FREELIST_PTR_HEAD	(MAC_HASH_BASE_ADDR + 0x100)
+#define MAC_HASH_FREELIST_PTR_TAIL	(MAC_HASH_BASE_ADDR + 0x104)
+#define MAC_HASH_FREELIST_ENTRIES_ADDR	(MAC_HASH_BASE_ADDR + 0x108)
+
+#endif /* _MAC_HASH_H_ */
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/net/c2000_eth/pfe/class/perg.h u-boot-2013.01.new/drivers/net/c2000_eth/pfe/class/perg.h
--- u-boot-2013.01/drivers/net/c2000_eth/pfe/class/perg.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/net/c2000_eth/pfe/class/perg.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,21 @@
+#ifndef _PERG_H_
+#define _PERG_H_
+
+#define PERG_QB_BUF_STATUS		(PERG_BASE_ADDR + 0x00)
+#define PERG_RO_BUF_STATUS		(PERG_BASE_ADDR + 0x04)
+#define PERG_CLR_QB_BUF_STATUS		(PERG_BASE_ADDR + 0x08)
+#define PERG_SET_RO_BUF_STATUS		(PERG_BASE_ADDR + 0x0c)
+#define PERG_CLR_RO_ERR_PKT		(PERG_BASE_ADDR + 0x10)
+#define PERG_CLR_BMU2_ERR_PKT		(PERG_BASE_ADDR + 0x14)
+
+#define PERG_ID				(PERG_BASE_ADDR + 0x18)
+#define PERG_TIMER1			(PERG_BASE_ADDR + 0x1c)
+#define PERG_TIMER2			(PERG_BASE_ADDR + 0x20)
+#define PERG_BUF1			(PERG_BASE_ADDR + 0x24)
+#define PERG_BUF2			(PERG_BASE_ADDR + 0x28)
+#define PERG_HOST_GP			(PERG_BASE_ADDR + 0x2c)
+#define PERG_PE_GP			(PERG_BASE_ADDR + 0x30)
+#define PERG_INT_ENABLE			(PERG_BASE_ADDR + 0x34)
+#define PERG_INT_SRC			(PERG_BASE_ADDR + 0x38)
+
+#endif /* _PERG_H_ */
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/net/c2000_eth/pfe/class/vlan_hash.h u-boot-2013.01.new/drivers/net/c2000_eth/pfe/class/vlan_hash.h
--- u-boot-2013.01/drivers/net/c2000_eth/pfe/class/vlan_hash.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/net/c2000_eth/pfe/class/vlan_hash.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,28 @@
+#ifndef _VLAN_HASH_H_
+#define _VLAN_HASH_H_
+
+#define VLAN_HASH_REQ1_BASE_ADDR	(VLAN_HASH_BASE_ADDR + 0x000)
+#define VLAN_HASH_REQ2_BASE_ADDR	(VLAN_HASH_BASE_ADDR + 0x020)
+#define VLAN_HASH_REQ3_BASE_ADDR	(VLAN_HASH_BASE_ADDR + 0x040)
+#define VLAN_HASH_REQ4_BASE_ADDR	(VLAN_HASH_BASE_ADDR + 0x060)
+#define VLAN_HASH_REQ5_BASE_ADDR	(VLAN_HASH_BASE_ADDR + 0x080)
+#define VLAN_HASH_REQ6_BASE_ADDR	(VLAN_HASH_BASE_ADDR + 0x0a0)
+#define VLAN_HASH_REQ7_BASE_ADDR	(VLAN_HASH_BASE_ADDR + 0x0c0)
+#define VLAN_HASH_REQ8_BASE_ADDR	(VLAN_HASH_BASE_ADDR + 0x0e0)
+
+#define VLAN_HASH_REQ_CMD(i)		(VLAN_HASH_REQ##i##_BASE_ADDR + 0x000)
+#define VLAN_HASH_REQ_MAC1_ADDR(i)	(VLAN_HASH_REQ##i##_BASE_ADDR + 0x004)
+#define VLAN_HASH_REQ_MAC2_ADDR(i)	(VLAN_HASH_REQ##i##_BASE_ADDR + 0x008)
+#define VLAN_HASH_REQ_MASK1_ADDR(i)	(VLAN_HASH_REQ##i##_BASE_ADDR + 0x00c)
+#define VLAN_HASH_REQ_MASK2_ADDR(i)	(VLAN_HASH_REQ##i##_BASE_ADDR + 0x010)
+#define VLAN_HASH_REQ_ENTRY(i)		(VLAN_HASH_REQ##i##_BASE_ADDR + 0x014)
+#define VLAN_HASH_REQ_STATUS(i)		(VLAN_HASH_REQ##i##_BASE_ADDR + 0x018)
+#define VLAN_HASH_REQ_ENTRY_MAYCH(i)	(VLAN_HASH_REQ##i##_BASE_ADDR + 0x01c)
+
+
+#define VLAN_HASH_FREELIST_PTR_HEAD	(VLAN_HASH_BASE_ADDR + 0x100)
+#define VLAN_HASH_FREELIST_PTR_TAIL	(VLAN_HASH_BASE_ADDR + 0x104)
+#define VLAN_HASH_FREELIST_ENTRIES_ADDR	(VLAN_HASH_BASE_ADDR + 0x108)
+
+#endif /* _VLAN_HASH_H_ */
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/net/c2000_eth/pfe/class.h u-boot-2013.01.new/drivers/net/c2000_eth/pfe/class.h
--- u-boot-2013.01/drivers/net/c2000_eth/pfe/class.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/net/c2000_eth/pfe/class.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,142 @@
+#ifndef _CLASS_H_
+#define _CLASS_H_
+
+#define CLASS_DMEM_BASE_ADDR	0x00000000
+#define CLASS_DMEM_SIZE		0x2000
+#define CLASS_DMEM_END		(CLASS_DMEM_BASE_ADDR + CLASS_DMEM_SIZE)
+#define CLASS_PMEM_BASE_ADDR	0x00010000
+
+#define CBUS_BASE_ADDR		0xc0000000
+#define CLASS_APB_BASE_ADDR	0xc1000000
+#define CLASS_AHB1_BASE_ADDR	0xc2000000
+#define CLASS_AHB2_BASE_ADDR	0xc3000000
+
+#include "cbus.h"
+
+#define GPT_BASE_ADDR		(CLASS_APB_BASE_ADDR + 0x00000)
+#define UART_BASE_ADDR		(CLASS_APB_BASE_ADDR + 0x10000)
+#define PERG_BASE_ADDR		(CLASS_APB_BASE_ADDR + 0x20000)
+#define EFET_BASE_ADDR		(CLASS_APB_BASE_ADDR + 0x40000)
+
+#define MAC_HASH_BASE_ADDR	(CLASS_AHB1_BASE_ADDR + 0x30000)
+#define VLAN_HASH_BASE_ADDR	(CLASS_AHB1_BASE_ADDR + 0x50000)
+
+#define PE_LMEM_BASE_ADDR	(CLASS_AHB2_BASE_ADDR + 0x10000)
+#define PE_LMEM_SIZE		0x8000
+#define PE_LMEM_END		(PE_LMEM_BASE_ADDR + PE_LMEM_SIZE)
+#define CCU_BASE_ADDR		(CLASS_AHB2_BASE_ADDR + 0x20000)
+
+#define IS_DMEM(addr, len)	(((unsigned long)(addr) >= CLASS_DMEM_BASE_ADDR) && (((unsigned long)(addr) + (len)) <= CLASS_DMEM_END))
+#define IS_PE_LMEM(addr, len)	(((unsigned long)(addr) >= PE_LMEM_BASE_ADDR) && (((unsigned long)(addr) + (len)) <= PE_LMEM_END))
+
+
+#include "gpt.h"
+#include "uart.h"
+#include "class/perg.h"
+#include "class/efet.h"
+#include "class/mac_hash.h"
+#include "class/vlan_hash.h"
+#include "class/ccu.h"
+
+
+#define CLASS_MAX_PBUFFERS	4
+
+#define PBUF_HWPARSE_OFFSET	0x10	/* Fixed by hardware */
+
+#define PAYLOAD_DMEM_MAX_SIZE	(CLASS_PBUF_SIZE - CLASS_PBUF_HEADER_OFFSET - sizeof(class_rx_hdr_t))
+
+#define PHYPORT_0               0x0
+#define PHYPORT_1               0x1
+#define HOST_PORT_NO		0x3
+
+#define   ACT_SRC_MAC_REPLACE 	(1 << (4+0))
+#define   ACT_VLAN_REPLACE		(1 << (4+3))
+#define   ACT_TCPCHKSUM_REPLACE	(1 << (4+2))
+#define   ACT_VLAN_ADD			(1 << (4+1))
+
+#define MIN_PKT_SIZE		56
+
+#define PARSE_ETH_TYPE		(1 << 0)
+#define PARSE_VLAN_TYPE		(1 << 1)
+#define PARSE_PPPOE_TYPE	(1 << 2)
+#define PARSE_ARP_TYPE		(1 << 3)
+#define PARSE_MCAST_TYPE	(1 << 4)
+#define PARSE_IP_TYPE		(1 << 5)
+#define PARSE_IPV6_TYPE		(1 << 6)
+#define PARSE_IPV4_TYPE		(1 << 7)
+
+#define PARSE_IPX_TYPE		(1 << 9)
+
+#define PARSE_UDP_FLOW		(1 << 11)
+#define PARSE_TCP_FLOW		(1 << 12)
+#define PARSE_ICMP_FLOW		(1 << 13)
+#define PARSE_IGMP_FLOW		(1 << 14)
+#define PARSE_FRAG_FLOW		(1 << 15)
+
+#define PARSE_HIF_PKT		(1 << 23)
+#define PARSE_ARC_HIT		(1 << 24)
+#define PARSE_PKT_OVERFLOW	(1 << 25)
+
+#define PARSE_PROTO_MISMATCH	(1 << 28)
+#define PARSE_L3_MISMATCH	(1 << 29)
+#define PARSE_L2_MISMATCH	(1 << 30)
+#define PARSE_INCOMPLETE	(1 << 31)
+
+
+typedef struct _hwparse_t {
+	u16	sid;
+	u16	connid;
+	u8	toevec;
+	u8	pLayer2Hdr;
+	u8	pLayer3Hdr;
+	u8	pLayer4Hdr;
+	u16	vlanid;
+	u16	ifParseFlags;
+	u32	parseFlags;
+	u16	srcport;
+	u16	dstport;
+	u32	proto:8;
+	u32	port:4;
+	u32	hash:20;
+	u64	rte_res_valid:1;
+	u64	vlan_res_valid:1;
+	u64	dst_res_valid:1;
+	u64	src_res_valid:1;
+	u64	vlan_lookup:20;
+	u64	dst_lookup:20;
+	u64	src_lookup:20;
+} hwparse_t;
+
+
+typedef struct {
+	u32	next_ptr;	/* ptr to the start of the first DDR buffer */
+	u16	length;		/* total packet length */
+	u16	phyno;		/* input physical port number */
+	u32	status;		/* gemac status bits */
+	u32	res;		/* reserved for software usage */
+} class_rx_hdr_t;
+
+
+typedef struct {
+	u8	num_cpy;	/* no of copies to send out from RO block, for each there must be a corresponding tx pre-header */
+	u8	dma_len;	/* len to be DMAed to DDR mem, including all tx pre-headers */
+	u16	src_addr;	/* class dmem source address, pointing to first tx pre-header */
+	u32	dst_addr;	/* DDR memory destination address of first tx pre-header, must be so packet data is continuous in DDR */
+	u32	res1;		/* reserved for software usage - queue number? */
+	u16	res2;		/* reserved for software usage */
+	u16	tsv;		/* time stamp val */
+} class_tx_desc_t;
+
+
+typedef struct {
+	u8	start_data_off;		/* packet data start offset, relative to start of this tx pre-header */
+	u8	start_buf_off;		/* this tx pre-header start offset, relative to start of DDR buffer */
+	u16	pkt_length;		/* total packet lenght */
+	u8	act_phyno;		/* action phy number */
+	u8	queueno;		/* queueno */
+	u16	src_mac_msb;		/* indicates src_mac 47:32 */
+	u32	src_mac_lsb;		/* indicates src_mac 31:0 */
+	u32	vlanid;			/* vlanid */
+} class_tx_hdr_t;
+
+#endif /* _CLASS_H_ */
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/net/c2000_eth/pfe/gpt.h u-boot-2013.01.new/drivers/net/c2000_eth/pfe/gpt.h
--- u-boot-2013.01/drivers/net/c2000_eth/pfe/gpt.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/net/c2000_eth/pfe/gpt.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,11 @@
+#ifndef _GPT_H_
+#define _GPT_H_
+
+#define GPT_VERSION		 (GPT_BASE_ADDR + 0x00)
+#define GPT_STATUS		 (GPT_BASE_ADDR + 0x04)
+#define GPT_CONFIG		 (GPT_BASE_ADDR + 0x08)
+#define GPT_COUNTER		 (GPT_BASE_ADDR + 0x0c)
+#define GPT_PERIOD		 (GPT_BASE_ADDR + 0x10)
+#define GPT_WIDTH		 (GPT_BASE_ADDR + 0x14)
+
+#endif /* _GPT_H_ */
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/net/c2000_eth/pfe/pe.h u-boot-2013.01.new/drivers/net/c2000_eth/pfe/pe.h
--- u-boot-2013.01/drivers/net/c2000_eth/pfe/pe.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/net/c2000_eth/pfe/pe.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,147 @@
+#ifndef _PE_H_
+#define _PE_H_
+
+#include "hal.h"
+
+#define DDR_BASE_ADDR		0x00020000
+#define DDR_END			0x86000000 /* This includes ACP and IRAM areas */
+#define IRAM_BASE_ADDR		0x83000000
+
+#define IS_DDR(addr, len)	(((unsigned long)(addr) >= DDR_BASE_ADDR) && (((unsigned long)(addr) + (len)) <= DDR_END))
+
+typedef struct {
+
+} ddr_rx_hdr_t;
+
+typedef struct {
+
+} lmem_rx_hdr_t;
+
+
+typedef struct {
+
+} tmu_rx_hdr_t;
+
+typedef struct {
+
+} tmu_tx_hdr_t;
+
+typedef struct {
+
+} util_rx_hdr_t;
+
+
+struct pe_sync_mailbox
+{
+	u32 stop;
+	u32 stopped;
+};
+
+struct pe_msg_mailbox
+{
+	u32 dst;
+	u32 src;
+	u32 len;
+	u32 request;
+};
+
+/** Basic busy loop delay function
+*
+* @param cycles		Number of cycles to delay (actual cpu cycles should be close to 3 x cycles)
+*
+*/
+static inline void delay(u32 cycles)
+{
+	volatile int i;
+
+	for (i = 0; i < cycles; i++);
+}
+
+
+/** Read PE id
+*
+* @return	PE id (0 - 5 for CLASS-PE's, 6 - 9 for TMU-PE's, 10 for UTIL-PE)
+*
+*/
+static inline u32 esi_get_mpid(void)
+{
+	u32 mpid;
+
+	asm ("rcsr %0, Configuration, MPID" : "=d" (mpid));
+
+	return mpid;
+}
+
+/** 64bit aligned memory copy using efet.
+* Either the source or destination address must be in DMEM, the other address can be in LMEM or DDR.
+* Source, destination addresses and len must all be 64bit aligned.
+* Uses efet synchronous interface to copy the data.
+*
+* @param dst	Destination address to write to (must be 64bit aligned)
+* @param src	Source address to read from (must be 64bit aligned)
+* @param len	Number of bytes to copy (must be 64bit aligned)
+*
+*/
+void efet_memcpy64(void *dst, void *src, unsigned int len);
+
+
+/** Aligned memory copy using efet.
+* Either the source or destination address must be in DMEM, the other address can be in LMEM or DDR.
+* Both the source and destination must have the same 64bit alignment, there is no restriction on length.
+*
+* @param dst	Destination address to write to (must have the same 64bit alignment as src)
+* @param src	Source address to read from (must have the same 64bit alignment as dst)
+* @param len	Number of bytes to copy
+*
+*/
+void efet_memcpy(void *dst, void *src, unsigned int len);
+
+
+/** 32bit aligned memory copy.
+* Source and destination addresses must be 32bit aligned, there is no restriction on the length.
+*
+* @param dst		Destination address (must be 32bit aligned)
+* @param src		Source address (must be 32bit aligned)
+* @param len		Number of bytes to copy
+*
+*/
+void memcpy_aligned32(void *dst, void *src, unsigned int len);
+
+/** Aligned memory copy.
+* Source and destination addresses must have the same alignment
+* relative to 32bit boundaries (but otherwsie may have any alignment),
+* there is no restriction on the length.
+*
+* @param dst		Destination address
+* @param src		Source address (must have same 32bit alignment as dst)
+* @param len		Number of bytes to copy
+*
+*/
+void memcpy_aligned(void *dst, void *src, unsigned int len);
+
+
+/** Generic memory set.
+* Implements a generic memory set. Not very optimal (uses byte writes for the entire range)
+*
+*
+* @param dst		Destination address
+* @param val		Value to set memory to
+* @param len		Number of bytes to set
+*
+*/
+void memset(void *dst, u8 val, unsigned int len);
+
+/** Generic memory copy.
+* Implements generic memory copy. If source and destination have the same
+* alignment memcpy_aligned() is used, otherwise, we first align the destination
+* to a 32bit boundary (using byte copies) then the src, and finally use a loop
+* of read, shift, write
+*
+* @param dst		Destination address
+* @param src		Source address
+* @param len		Number of bytes to copy
+*
+*/
+void memcpy(void *dst, void *src, unsigned int len);
+
+#endif /* _PE_H_ */
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/net/c2000_eth/pfe/pfe.h u-boot-2013.01.new/drivers/net/c2000_eth/pfe/pfe.h
--- u-boot-2013.01/drivers/net/c2000_eth/pfe/pfe.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/net/c2000_eth/pfe/pfe.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,258 @@
+#ifndef _PFE_H_
+#define _PFE_H_
+
+#define CLASS_DMEM_BASE_ADDR(i)	(0x00000000 | ((i) << 20))
+#define CLASS_IMEM_BASE_ADDR(i)	(0x00000000 | ((i) << 20)) /* Only valid for mem access register interface */
+#define CLASS_DMEM_SIZE		0x00002000
+#define CLASS_IMEM_SIZE		0x00008000
+
+#define TMU_DMEM_BASE_ADDR(i)	(0x00000000 + ((i) << 20))
+#define TMU_IMEM_BASE_ADDR(i)	(0x00000000 + ((i) << 20)) /* Only valid for mem access register interface */
+#define TMU_DMEM_SIZE		0x00000800
+#define TMU_IMEM_SIZE		0x00002000
+
+#define UTIL_DMEM_BASE_ADDR	0x00000000
+#define UTIL_DMEM_SIZE		0x00002000
+
+#define PE_LMEM_BASE_ADDR	0xc3010000
+#define PE_LMEM_SIZE		0x8000
+#define PE_LMEM_END		(PE_LMEM_BASE_ADDR + PE_LMEM_SIZE)
+
+#define DMEM_BASE_ADDR		0x00000000
+#define DMEM_SIZE		0x2000		/**< TMU has less... */
+#define DMEM_END		(DMEM_BASE_ADDR + DMEM_SIZE)
+
+#define PMEM_BASE_ADDR		0x00010000
+#define PMEM_SIZE		0x8000		/**< TMU has less... */
+#define PMEM_END		(PMEM_BASE_ADDR + PMEM_SIZE)
+
+
+/* These check memory ranges from PE point of view/memory map */
+#define IS_DMEM(addr, len)	(((unsigned long)(addr) >= DMEM_BASE_ADDR) && (((unsigned long)(addr) + (len)) <= DMEM_END))
+#define IS_PMEM(addr, len)	(((unsigned long)(addr) >= PMEM_BASE_ADDR) && (((unsigned long)(addr) + (len)) <= PMEM_END))
+#define IS_PE_LMEM(addr, len)	(((unsigned long)(addr) >= PE_LMEM_BASE_ADDR) && (((unsigned long)(addr) + (len)) <= PE_LMEM_END))
+
+#define IS_PFE_LMEM(addr, len)	(((unsigned long)(addr) >= CBUS_VIRT_TO_PFE(LMEM_BASE_ADDR)) && (((unsigned long)(addr) + (len)) <= CBUS_VIRT_TO_PFE(LMEM_END)))
+#define IS_PHYS_DDR(addr, len)	(((unsigned long)(addr) >= DDR_PHYS_BASE_ADDR) && (((unsigned long)(addr) + (len)) <= DDR_PHYS_END))
+
+/* If using a run-time virtual address for the cbus base address use this code */
+extern void *cbus_base_addr;
+extern void *ddr_base_addr;
+extern unsigned long ddr_phys_base_addr;
+
+#if 0
+/* If using a run-time virtual address for the cbus base address use this code */
+extern void *cbus_base_addr;
+#define CBUS_BASE_ADDR		cbus_base_addr
+#else
+#define CBUS_BASE_ADDR		0x9c000000
+#endif
+
+#define DDR_PHYS_BASE_ADDR	ddr_phys_base_addr
+#define DDR_BASE_ADDR		ddr_base_addr
+
+#define DDR_SIZE	0xC00000
+#define DDR_PHYS_END	(DDR_PHYS_BASE_ADDR + DDR_SIZE)
+
+#define PFE_CBUS_PHYS_BASE_ADDR	0xc0000000	/**< CBUS physical base address as seen by PE's. */
+
+
+//#define CBUS_PHYS_TO_VIRT(p)	(((p) - CBUS_PHYS_BASE_ADDR) + CBUS_BASE_ADDR)
+//#define CBUS_VIRT_TO_PHYS(v)	(((v) - CBUS_BASE_ADDR) + CBUS_PHYS_BASE_ADDR)
+
+#define DDR_PHYS_TO_VIRT(p)	(((p) - DDR_PHYS_BASE_ADDR) + DDR_BASE_ADDR)
+#define DDR_VIRT_TO_PHYS(v)	(((v) - DDR_BASE_ADDR) + DDR_PHYS_BASE_ADDR)
+
+#define CBUS_VIRT_TO_PFE(v)	(((v) - CBUS_BASE_ADDR) + PFE_CBUS_PHYS_BASE_ADDR)
+#define CBUS_PFE_TO_VIRT(p)	(((p) - PFE_CBUS_PHYS_BASE_ADDR) + CBUS_BASE_ADDR)
+
+#include "cbus.h"
+
+enum {
+	CLASS0_ID = 0,
+	CLASS1_ID,
+	CLASS2_ID,
+	CLASS3_ID,
+#if !defined(CONFIG_PLATFORM_PCI)
+	CLASS4_ID,
+	CLASS5_ID,
+#endif
+#if !defined(CONFIG_TMU_DUMMY)
+	TMU0_ID,
+	TMU1_ID,
+	TMU2_ID,
+	TMU3_ID,
+#else
+	TMU0_ID,
+#endif
+#if !defined(CONFIG_UTIL_PE_DISABLED)
+	UTIL_ID,
+#endif
+	MAX_PE
+};
+
+#if !defined(CONFIG_PLATFORM_PCI)
+#define CLASS_MASK	((1 << CLASS0_ID) | (1 << CLASS1_ID) | (1 << CLASS2_ID) | (1 << CLASS3_ID) | (1 << CLASS4_ID) | (1 << CLASS5_ID))
+#define CLASS_MAX_ID	CLASS5_ID
+#else
+#define CLASS_MASK      ((1 << CLASS0_ID) | (1 << CLASS1_ID) | (1 << CLASS2_ID) | (1 << CLASS3_ID))
+#define CLASS_MAX_ID	CLASS3_ID
+#endif
+
+#if !defined(CONFIG_TMU_DUMMY)
+#define TMU_MASK	((1 << TMU0_ID) | (1 << TMU1_ID) | (1 << TMU2_ID) | (1 << TMU3_ID))
+#define TMU_MAX_ID	TMU3_ID
+#else
+#define TMU_MASK	(1 << TMU0_ID) 
+#define TMU_MAX_ID	TMU0_ID
+#endif
+
+#if !defined(CONFIG_UTIL_PE_DISABLED)
+#define UTIL_MASK	(1 << UTIL_ID)
+#endif
+
+struct pe_sync_mailbox
+{
+	u32 stop;
+	u32 stopped;
+};
+
+struct pe_msg_mailbox
+{
+	u32 dst;
+	u32 src;
+	u32 len;
+	u32 request;
+};
+
+/** PE information.
+ * Structure containing PE's specific information. It is used to create
+ * generic C functions common to all PE's.
+ * Before using the library functions this structure needs to be initialized with the different registers virtual addresses
+ * (according to the ARM MMU mmaping). The default initialization supports a virtual == physical mapping.
+ *
+ */
+struct pe_info
+{
+	u32 dmem_base_addr;		/**< PE's dmem base address */
+	u32 pmem_base_addr;		/**< PE's pmem base address */
+	u32 pmem_size;			/**< PE's pmem size */
+
+	void *mem_access_wdata;		/**< PE's _MEM_ACCESS_WDATA register address */
+	void *mem_access_addr;		/**< PE's _MEM_ACCESS_ADDR register address */
+	void *mem_access_rdata;		/**< PE's _MEM_ACCESS_RDATA register address */
+};
+
+
+void pe_lmem_read(u32 *dst, u32 len, u32 offset);
+void pe_lmem_write(u32 *src, u32 len, u32 offset);
+
+void pe_dmem_memcpy_to32(int id, u32 dst, const void *src, unsigned int len);
+void pe_pmem_memcpy_to32(int id, u32 dst, const void *src, unsigned int len);
+
+u32 pe_pmem_read(int id, u32 addr, u8 size);
+
+void pe_dmem_write(int id, u32 val, u32 addr, u8 size);
+u32 pe_dmem_read(int id, u32 addr, u8 size);
+void class_bus_write(u32 val, u32 addr, u8 size);
+u32 class_bus_read(u32 addr, u8 size);
+void util_bus_write(u32 val, u32 addr, u8 size);
+u32 util_bus_read(u32 addr, u8 size);
+
+#define class_bus_readl(addr)			class_bus_read(addr, 4)
+#define class_bus_readw(addr)			class_bus_read(addr, 2)
+#define class_bus_readb(addr)			class_bus_read(addr, 1)
+
+#define class_bus_writel(val, addr)		class_bus_write(val, addr, 4)
+#define class_bus_writew(val, addr)		class_bus_write(val, addr, 2)
+#define class_bus_writeb(val, addr)		class_bus_write(val, addr, 1)
+
+#define pe_mem_readl(id, addr)			pe_mem_read(id, addr, 4)
+#define pe_mem_readw(id, addr)			pe_mem_read(id, addr, 2)
+#define pe_mem_readb(id, addr)			pe_mem_read(id, addr, 1)
+
+#define pe_mem_writel(id, val, addr)		pe_mem_write(id, val, addr, 4)
+#define pe_mem_writew(id, val, addr)		pe_mem_write(id, val, addr, 2)
+#define pe_mem_writeb(id, val, addr)		pe_mem_write(id, val, addr, 1)
+
+int pe_load_elf_section(int id, const void *data, Elf32_Shdr *shdr);
+
+void pfe_lib_init(void *cbus_base, void *ddr_base, unsigned long ddr_phys_base);
+void bmu_init(void *base, BMU_CFG *cfg);
+void bmu_reset(void *base);
+void bmu_enable(void *base);
+void bmu_disable(void *base);
+void bmu_set_config(void *base, BMU_CFG *cfg);
+
+void gemac_init(void *base, void *config);
+void gemac_set_speed(void *base, MAC_SPEED gem_speed);
+void gemac_set_duplex(void *base, int duplex);
+void gemac_set_mode(void *base, int mode);
+void gemac_enable_mdio(void *base);
+void gemac_disable_mdio(void *base);
+void gemac_set_mdc_div(void *base, MAC_MDC_DIV gem_mdcdiv);
+void gemac_enable(void *base);
+void gemac_disable(void *base);
+void gemac_enable_mdio(void *base);
+void gemac_disable_mdio(void *base);
+void gemac_reset(void *base);
+void gemac_set_address(void *base, SPEC_ADDR *addr);
+SPEC_ADDR gemac_get_address(void *base);
+void gemac_set_laddr1(void *base, MAC_ADDR *address);
+void gemac_set_laddr2(void *base, MAC_ADDR *address);
+void gemac_set_laddr3(void *base, MAC_ADDR *address);
+void gemac_set_laddr4(void *base, MAC_ADDR *address);
+void gemac_set_laddrN(void *base, MAC_ADDR *address, unsigned int entry_index);
+MAC_ADDR gem_get_laddr1(void *base);
+MAC_ADDR gem_get_laddr2(void *base);
+MAC_ADDR gem_get_laddr3(void *base);
+MAC_ADDR gem_get_laddr4(void *base);
+MAC_ADDR gem_get_laddrN(void *base, unsigned int entry_index);
+void gemac_set_config(void *base, GEMAC_CFG *cfg);
+void gemac_enable_copy_all(void *base);
+void gemac_disable_copy_all(void *base);
+void gemac_allow_broadcast(void *base);
+void gemac_no_broadcast(void *base);
+void gemac_enable_unicast(void *base);
+void gemac_disable_unicast(void *base);
+void gemac_enable_multicast(void *base);
+void gemac_disable_multicast(void *base);
+void gemac_enable_fcs_rx(void *base);
+void gemac_disable_fcs_rx(void *base);
+void gemac_enable_1536_rx(void *base);
+void gemac_disable_1536_rx(void *base);
+void gemac_enable_pause_rx(void *base);
+void gemac_disable_pause_rx(void *base);
+void gemac_enable_rx_checksum_offload(void *base);
+void gemac_disable_rx_checksum_offload(void *base);
+unsigned int * gemac_get_stats(void *base);
+void gemac_set_bus_width(void *base, int width);
+
+void gpi_init(void *base, GPI_CFG *cfg);
+void gpi_reset(void *base);
+void gpi_enable(void *base);
+void gpi_disable(void *base);
+void gpi_set_config(void *base, GPI_CFG *cfg);
+
+void class_init(CLASS_CFG *cfg);
+void class_reset(void);
+void class_enable(void);
+void class_disable(void);
+void class_set_config(CLASS_CFG *cfg);
+
+void tmu_init(TMU_CFG *cfg);
+void tmu_enable(u32 pe_mask);
+void tmu_disable(u32 pe_mask);
+
+void util_init(UTIL_CFG *cfg);
+void util_reset(void);
+void util_enable(void);
+void util_disable(void);
+
+void hif_init(void);
+void hif_tx_enable(void);
+void hif_tx_disable(void);
+void hif_rx_enable(void);
+void hif_rx_disable(void);
+
+#endif /* _PFE_H_ */
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/net/c2000_eth/pfe/tmu/phy_queue.h u-boot-2013.01.new/drivers/net/c2000_eth/pfe/tmu/phy_queue.h
--- u-boot-2013.01/drivers/net/c2000_eth/pfe/tmu/phy_queue.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/net/c2000_eth/pfe/tmu/phy_queue.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,31 @@
+#ifndef _PHY_QUEUE_H_
+#define _PHY_QUEUE_H_
+
+#define PHY_QUEUE_SHAPER_STATUS	(PHY_QUEUE_BASE_ADDR + 0x00)	/**< [28:19] same as SHAPER_STATUS, [18:3] same as QUEUE_STATUS, [2:0] must be zero before a new packet may be dequeued */
+#define QUEUE_STATUS		(PHY_QUEUE_BASE_ADDR + 0x04)	/**< [15:0] bit mask of input queues with pending packets */
+
+#define QUEUE0_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x08)
+#define QUEUE1_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x0c)
+#define QUEUE2_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x10)
+#define QUEUE3_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x14)
+#define QUEUE4_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x18)
+#define QUEUE5_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x1c)
+#define QUEUE6_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x20)
+#define QUEUE7_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x24)
+#define QUEUE8_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x28)
+#define QUEUE9_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x2c)
+#define QUEUE10_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x30)
+#define QUEUE11_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x34)
+#define QUEUE12_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x38)
+#define QUEUE13_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x3c)
+#define QUEUE14_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x40)
+#define QUEUE15_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x44)
+#define QUEUE_RESULT0		(PHY_QUEUE_BASE_ADDR + 0x48)	/**< [7] set to one to indicate output PHY (TMU0->PHY0, TMU1->PHY1, TMU2->PHY2, TMU3->PHY3), [6:0] winner input queue number */
+#define QUEUE_RESULT1		(PHY_QUEUE_BASE_ADDR + 0x4c)	/**< [7] set to one to indicate output PHY (TMU0->PHY0, TMU1->PHY1, TMU2->PHY2, TMU3->PHY4), [6:0] winner input queue number */
+#define QUEUE_RESULT2		(PHY_QUEUE_BASE_ADDR + 0x50)	/**< [7] set to one to indicate output PHY (TMU0->PHY0, TMU1->PHY1, TMU2->PHY2, TMU3->PHY5), [6:0] winner input queue number */
+#define QUEUE_GBL_PKTLEN	(PHY_QUEUE_BASE_ADDR + 0x5c)
+#define QUEUE_GBL_PKTLEN_MASK	(PHY_QUEUE_BASE_ADDR + 0x60)
+
+
+
+#endif /* _PHY_QUEUE_H_ */
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/net/c2000_eth/pfe/tmu/sched.h u-boot-2013.01.new/drivers/net/c2000_eth/pfe/tmu/sched.h
--- u-boot-2013.01/drivers/net/c2000_eth/pfe/tmu/sched.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/net/c2000_eth/pfe/tmu/sched.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,47 @@
+#ifndef _SCHED_H_
+#define _SCHED_H_
+
+/* Offsets from SCHEDx_BASE_ADDR */
+#define SCHED_CTRL			0x00
+#define SCHED_SLOT_TIME			0x04
+#define SCHED_RES			0x08
+#define SCHED_QUEUE_ALLOC0		0x0c
+#define SCHED_QUEUE_ALLOC1		0x10
+#define SCHED_BW			0x14
+#define SCHED_GUR_DEF_CTR		0x18
+#define SCHED_AVL_CTR			0x1c
+#define SCHED_QU0_WGHT			0x20
+#define SCHED_QU1_WGHT			0x24
+#define SCHED_QU2_WGHT			0x28
+#define SCHED_QU3_WGHT			0x2c
+#define SCHED_QU4_WGHT			0x30
+#define SCHED_QU5_WGHT			0x34
+#define SCHED_QU6_WGHT			0x38
+#define SCHED_QU7_WGHT			0x3c
+#define SCHED_QUE0_DEFICIT_CNT		0x40
+#define SCHED_QUE1_DEFICIT_CNT		0x44
+#define SCHED_QUE2_DEFICIT_CNT		0x48
+#define SCHED_QUE3_DEFICIT_CNT		0x4c
+#define SCHED_QUE4_DEFICIT_CNT		0x50
+#define SCHED_QUE5_DEFICIT_CNT		0x54
+#define SCHED_QUE6_DEFICIT_CNT		0x58
+#define SCHED_QUE7_DEFICIT_CNT		0x5c
+#define SCHED_PKT_LEN			0x60
+
+#define SCHED_CTRL_ALGOTYPE(x) 		(((x) & 0xf) << 0)
+#define SCHED_CTRL_CALQUOTA(x) 		(((x) & 0x1) << 4)
+#define SCHED_CTRL_ACTIVE_Q(x) 		(((x) & 0xff) << 8)
+#define SCHED_CTRL_SHARE_BW(x) 		(((x) & 0xff) << 16)
+#define SCHED_CTRL_BARROW_BW(x) 	(((x) & 0xff) << 24)
+
+#define SCHED_QUEUE_ALLOC0_QUEUEA(x)	(((x) & 0x1f) << 0)
+#define SCHED_QUEUE_ALLOC0_QUEUEB(x)	(((x) & 0x1f) << 8)
+#define SCHED_QUEUE_ALLOC0_QUEUEC(x)	(((x) & 0x1f) << 16)
+#define SCHED_QUEUE_ALLOC0_QUEUED(x)	(((x) & 0x1f) << 24)
+
+#define SCHED_QUEUE_ALLOC0_RES0(x)	(((x) & 0x7) << 5)
+#define SCHED_QUEUE_ALLOC0_RES1(x)	(((x) & 0x7) << 13)
+#define SCHED_QUEUE_ALLOC0_RES2(x)	(((x) & 0x7) << 21)
+#define SCHED_QUEUE_ALLOC0_RES3(x)	(((x) & 0x7) << 29)
+
+#endif /* _SCHED_H_ */
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/net/c2000_eth/pfe/tmu/shaper.h u-boot-2013.01.new/drivers/net/c2000_eth/pfe/tmu/shaper.h
--- u-boot-2013.01/drivers/net/c2000_eth/pfe/tmu/shaper.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/net/c2000_eth/pfe/tmu/shaper.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,19 @@
+#ifndef _SHAPER_H_
+#define _SHAPER_H_
+
+/* Offsets from SHAPPERx_BASE_ADDR */
+#define SHAPER_CTRL		0x00
+#define SHAPER_WEIGHT		0x04
+#define SHAPER_PKT_LEN		0x08
+
+#define SHAPER_CTRL_ENABLE(x) 	(((x) & 0x1) << 0)
+#define SHAPER_CTRL_QNO(x) 	(((x) & 0x3f) << 1)
+#define SHAPER_CTRL_CLKDIV(x) 	(((x) & 0xffff) << 16)
+
+#define SHAPER_WEIGHT_FRACWT(x) 	(((x) & 0xff) << 0)
+#define SHAPER_WEIGHT_INTWT(x) 		(((x) & 0x3) << 8)
+#define SHAPER_WEIGHT_MAXCREDIT(x) 	(((x) & 0x3fffff) << 10)
+
+#define PORT_SHAPER_MASK (1 << 0)
+
+#endif /* _SHAPER_H_ */
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/net/c2000_eth/pfe/tmu.h u-boot-2013.01.new/drivers/net/c2000_eth/pfe/tmu.h
--- u-boot-2013.01/drivers/net/c2000_eth/pfe/tmu.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/net/c2000_eth/pfe/tmu.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,48 @@
+#ifndef _TMU_H_
+#define _TMU_H_
+
+#define TMU_DMEM_BASE_ADDR	0x00000000
+#define TMU_PMEM_BASE_ADDR	0x00010000
+
+
+#define CBUS_BASE_ADDR		0xc0000000
+#define TMU_APB_BASE_ADDR	0xc1000000
+
+#include "cbus.h"
+
+#define GPT_BASE_ADDR		(TMU_APB_BASE_ADDR + 0x00000)
+#define UART_BASE_ADDR		(TMU_APB_BASE_ADDR + 0x10000)
+
+
+#define SHAPER0_BASE_ADDR	(TMU_APB_BASE_ADDR + 0x020000)
+#define SHAPER1_BASE_ADDR	(TMU_APB_BASE_ADDR + 0x030000)
+#define SHAPER2_BASE_ADDR	(TMU_APB_BASE_ADDR + 0x040000)
+#define SHAPER3_BASE_ADDR	(TMU_APB_BASE_ADDR + 0x050000)
+#define SHAPER4_BASE_ADDR	(TMU_APB_BASE_ADDR + 0x060000)
+#define SHAPER5_BASE_ADDR	(TMU_APB_BASE_ADDR + 0x070000)
+#define SHAPER6_BASE_ADDR	(TMU_APB_BASE_ADDR + 0x080000)
+#define SHAPER7_BASE_ADDR	(TMU_APB_BASE_ADDR + 0x090000)
+#define SHAPER8_BASE_ADDR	(TMU_APB_BASE_ADDR + 0x0a0000)
+#define SHAPER9_BASE_ADDR	(TMU_APB_BASE_ADDR + 0x0b0000)
+
+#define SCHED0_BASE_ADDR	(TMU_APB_BASE_ADDR + 0x1c0000)
+#define SCHED1_BASE_ADDR	(TMU_APB_BASE_ADDR + 0x1d0000)
+#define SCHED2_BASE_ADDR	(TMU_APB_BASE_ADDR + 0x1e0000)
+#define SCHED3_BASE_ADDR	(TMU_APB_BASE_ADDR + 0x1f0000)
+#define SCHED4_BASE_ADDR	(TMU_APB_BASE_ADDR + 0x200000)
+#define SCHED5_BASE_ADDR	(TMU_APB_BASE_ADDR + 0x210000)
+#define SCHED6_BASE_ADDR	(TMU_APB_BASE_ADDR + 0x220000)
+#define SCHED7_BASE_ADDR	(TMU_APB_BASE_ADDR + 0x230000)
+
+
+#define PHY_QUEUE_BASE_ADDR	(TMU_APB_BASE_ADDR + 0x260000)
+#define SHAPER_STATUS		(TMU_APB_BASE_ADDR + 0x270000) /**< [9:0] bitmask of shapers that have positive credit */
+
+
+#include "gpt.h"
+#include "uart.h"
+#include "tmu/shaper.h"
+#include "tmu/sched.h"
+#include "tmu/phy_queue.h"
+
+#endif /* _TMU_H_ */
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/net/c2000_eth/pfe/uart.h u-boot-2013.01.new/drivers/net/c2000_eth/pfe/uart.h
--- u-boot-2013.01/drivers/net/c2000_eth/pfe/uart.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/net/c2000_eth/pfe/uart.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,13 @@
+#ifndef _UART_H_
+#define _UART_H_
+
+#define UART_THR	(UART_BASE_ADDR + 0x00)
+#define UART_IER	(UART_BASE_ADDR + 0x04)
+#define UART_IIR	(UART_BASE_ADDR + 0x08)
+#define UART_LCR	(UART_BASE_ADDR + 0x0c)
+#define UART_MCR	(UART_BASE_ADDR + 0x10)
+#define UART_LSR	(UART_BASE_ADDR + 0x14)
+#define UART_MDR	(UART_BASE_ADDR + 0x18)
+#define UART_SCRATCH	(UART_BASE_ADDR + 0x1c)
+
+#endif /* _UART_H_ */
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/net/c2000_eth/pfe/util/eape.h u-boot-2013.01.new/drivers/net/c2000_eth/pfe/util/eape.h
--- u-boot-2013.01/drivers/net/c2000_eth/pfe/util/eape.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/net/c2000_eth/pfe/util/eape.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,10 @@
+#ifndef _EAPE_H_
+#define _EAPE_H_
+
+#define EAPE_STATUS		(EAPE_BASE_ADDR + 0x0)
+#define EAPE_INT_ENABLE		(EAPE_BASE_ADDR + 0x4)
+#define EAPE_INT_SRC		(EAPE_BASE_ADDR + 0x8)
+#define EAPE_HOST_INT_ENABLE	(EAPE_BASE_ADDR + 0xc)
+
+
+#endif /* _EAPE_H_ */
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/net/c2000_eth/pfe/util/efet.h u-boot-2013.01.new/drivers/net/c2000_eth/pfe/util/efet.h
--- u-boot-2013.01/drivers/net/c2000_eth/pfe/util/efet.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/net/c2000_eth/pfe/util/efet.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,20 @@
+#ifndef _UTIL_EFET_H_
+#define _UTIL_EFET_H_
+
+#define EFET_ENTRY_ADDR		0x00
+#define EFET_ENTRY_SIZE		0x04
+#define EFET_ENTRY_DMEM_ADDR	0x08
+#define EFET_ENTRY_STATUS	0x0c
+#define EFET_ENTRY_ENDIAN	0x10
+
+#define CBUS2DMEM	0
+#define DMEM2CBUS	1
+
+#define EFET2BUS_LE     (1 << 0)
+
+void util_efet(int i, u32 cbus_addr, u32 dmem_addr, u32 len, u8 dir);
+void util_efet_wait(int i);
+void util_efet_sync(int i, u32 cbus_addr, u32 dmem_addr, u32 len, u8 dir);
+
+#endif /* _UTIL_EFET_H_ */
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/net/c2000_eth/pfe/util/inq.h u-boot-2013.01.new/drivers/net/c2000_eth/pfe/util/inq.h
--- u-boot-2013.01/drivers/net/c2000_eth/pfe/util/inq.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/net/c2000_eth/pfe/util/inq.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,10 @@
+#ifndef _INQ_H_
+#define _INQ_H_
+
+#define INQ_HOST_GP	(INQ_BASE_ADDR + 0x00) /* FIXME what are these for ? */
+#define INQ_UPE_GP	(INQ_BASE_ADDR + 0x04) /* FIXME what are these for ? */
+
+#define INQ_QB_PKTPTR	(INQ_BASE_ADDR + 0x08)
+#define INQ_FIFO_CNT	(INQ_BASE_ADDR + 0x0c)
+
+#endif /* _INQ_H_ */
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/net/c2000_eth/pfe/util.h u-boot-2013.01.new/drivers/net/c2000_eth/pfe/util.h
--- u-boot-2013.01/drivers/net/c2000_eth/pfe/util.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/net/c2000_eth/pfe/util.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,30 @@
+#ifndef _UTIL_H_
+#define _UTIL_H_
+
+#define UTIL_DMEM_BASE_ADDR	0x00000000
+#define UTIL_DMEM_SIZE		0x00002000
+#define UTIL_DMEM_END		(UTIL_DMEM_BASE_ADDR + UTIL_DMEM_SIZE)
+
+#define IS_DMEM(addr, len)	(((unsigned long)(addr) >= UTIL_DMEM_BASE_ADDR) && (((unsigned long)(addr) + (len)) <= UTIL_DMEM_END))
+
+#define CBUS_BASE_ADDR		0xc0000000
+#define UTIL_APB_BASE_ADDR	0xc1000000
+
+#include "cbus.h"
+
+#define GPT_BASE_ADDR		(UTIL_APB_BASE_ADDR + 0x00000)
+#define UART_BASE_ADDR		(UTIL_APB_BASE_ADDR + 0x10000)
+#define EAPE_BASE_ADDR		(UTIL_APB_BASE_ADDR + 0x20000)
+#define INQ_BASE_ADDR		(UTIL_APB_BASE_ADDR + 0x30000)
+#define EFET1_BASE_ADDR		(UTIL_APB_BASE_ADDR + 0x40000)
+#define EFET2_BASE_ADDR		(UTIL_APB_BASE_ADDR + 0x50000)
+#define EFET3_BASE_ADDR		(UTIL_APB_BASE_ADDR + 0x60000)
+
+
+#include "gpt.h"
+#include "uart.h"
+#include "util/eape.h"
+#include "util/inq.h"
+#include "util/efet.h"
+
+#endif /* _UTIL_H_ */
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/net/c2000_eth/pfe.c u-boot-2013.01.new/drivers/net/c2000_eth/pfe.c
--- u-boot-2013.01/drivers/net/c2000_eth/pfe.c	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/net/c2000_eth/pfe.c	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,1474 @@
+#include "hal.h"
+#include "pfe/pfe.h"
+
+void *cbus_base_addr;
+void *ddr_base_addr;
+unsigned long ddr_phys_base_addr;
+
+static struct pe_info pe[MAX_PE];
+
+/** Initializes the PFE library.
+* Must be called before using any of the library functions.
+*
+* @param[in] cbus_base		CBUS virtual base address (as mapped in the host CPU address space)
+* @param[in] ddr_base		DDR virtual base address (as mapped in the host CPU address space)
+* @param[in] ddr_phys_base	DDR physical base address (as mapped in platform)
+*/
+void pfe_lib_init(void *cbus_base, void *ddr_base, unsigned long ddr_phys_base)
+{
+	cbus_base_addr = cbus_base;
+	ddr_base_addr = ddr_base;
+	ddr_phys_base_addr = ddr_phys_base;
+
+	pe[CLASS0_ID].dmem_base_addr = CLASS_DMEM_BASE_ADDR(0);
+	pe[CLASS0_ID].pmem_base_addr = CLASS_IMEM_BASE_ADDR(0);
+	pe[CLASS0_ID].pmem_size = CLASS_IMEM_SIZE;
+	pe[CLASS0_ID].mem_access_wdata = CLASS_MEM_ACCESS_WDATA;
+	pe[CLASS0_ID].mem_access_addr = CLASS_MEM_ACCESS_ADDR;
+	pe[CLASS0_ID].mem_access_rdata = CLASS_MEM_ACCESS_RDATA;
+
+	pe[CLASS1_ID].dmem_base_addr = CLASS_DMEM_BASE_ADDR(1);
+	pe[CLASS1_ID].pmem_base_addr = CLASS_IMEM_BASE_ADDR(1);
+	pe[CLASS1_ID].pmem_size = CLASS_IMEM_SIZE;
+	pe[CLASS1_ID].mem_access_wdata = CLASS_MEM_ACCESS_WDATA;
+	pe[CLASS1_ID].mem_access_addr = CLASS_MEM_ACCESS_ADDR;
+	pe[CLASS1_ID].mem_access_rdata = CLASS_MEM_ACCESS_RDATA;
+
+	pe[CLASS2_ID].dmem_base_addr = CLASS_DMEM_BASE_ADDR(2);
+	pe[CLASS2_ID].pmem_base_addr = CLASS_IMEM_BASE_ADDR(2);
+	pe[CLASS2_ID].pmem_size = CLASS_IMEM_SIZE;
+	pe[CLASS2_ID].mem_access_wdata = CLASS_MEM_ACCESS_WDATA;
+	pe[CLASS2_ID].mem_access_addr = CLASS_MEM_ACCESS_ADDR;
+	pe[CLASS2_ID].mem_access_rdata = CLASS_MEM_ACCESS_RDATA;
+
+	pe[CLASS3_ID].dmem_base_addr = CLASS_DMEM_BASE_ADDR(3);
+	pe[CLASS3_ID].pmem_base_addr = CLASS_IMEM_BASE_ADDR(3);
+	pe[CLASS3_ID].pmem_size = CLASS_IMEM_SIZE;
+	pe[CLASS3_ID].mem_access_wdata = CLASS_MEM_ACCESS_WDATA;
+	pe[CLASS3_ID].mem_access_addr = CLASS_MEM_ACCESS_ADDR;
+	pe[CLASS3_ID].mem_access_rdata = CLASS_MEM_ACCESS_RDATA;
+
+#if !defined(CONFIG_PLATFORM_PCI)
+	pe[CLASS4_ID].dmem_base_addr = CLASS_DMEM_BASE_ADDR(4);
+	pe[CLASS4_ID].pmem_base_addr = CLASS_IMEM_BASE_ADDR(4);
+	pe[CLASS4_ID].pmem_size = CLASS_IMEM_SIZE;
+	pe[CLASS4_ID].mem_access_wdata = CLASS_MEM_ACCESS_WDATA;
+	pe[CLASS4_ID].mem_access_addr = CLASS_MEM_ACCESS_ADDR;
+	pe[CLASS4_ID].mem_access_rdata = CLASS_MEM_ACCESS_RDATA;
+
+	pe[CLASS5_ID].dmem_base_addr = CLASS_DMEM_BASE_ADDR(5);
+	pe[CLASS5_ID].pmem_base_addr = CLASS_IMEM_BASE_ADDR(5);
+	pe[CLASS5_ID].pmem_size = CLASS_IMEM_SIZE;
+	pe[CLASS5_ID].mem_access_wdata = CLASS_MEM_ACCESS_WDATA;
+	pe[CLASS5_ID].mem_access_addr = CLASS_MEM_ACCESS_ADDR;
+	pe[CLASS5_ID].mem_access_rdata = CLASS_MEM_ACCESS_RDATA;
+#endif
+	pe[TMU0_ID].dmem_base_addr = TMU_DMEM_BASE_ADDR(0);
+	pe[TMU0_ID].pmem_base_addr = TMU_IMEM_BASE_ADDR(0);
+	pe[TMU0_ID].pmem_size = TMU_IMEM_SIZE;
+	pe[TMU0_ID].mem_access_wdata = TMU_MEM_ACCESS_WDATA;
+	pe[TMU0_ID].mem_access_addr = TMU_MEM_ACCESS_ADDR;
+	pe[TMU0_ID].mem_access_rdata = TMU_MEM_ACCESS_RDATA;
+
+#if !defined(CONFIG_TMU_DUMMY)
+	pe[TMU1_ID].dmem_base_addr = TMU_DMEM_BASE_ADDR(1);
+	pe[TMU1_ID].pmem_base_addr = TMU_IMEM_BASE_ADDR(1);
+	pe[TMU1_ID].pmem_size = TMU_IMEM_SIZE;
+	pe[TMU1_ID].mem_access_wdata = TMU_MEM_ACCESS_WDATA;
+	pe[TMU1_ID].mem_access_addr = TMU_MEM_ACCESS_ADDR;
+	pe[TMU1_ID].mem_access_rdata = TMU_MEM_ACCESS_RDATA;
+
+	pe[TMU2_ID].dmem_base_addr = TMU_DMEM_BASE_ADDR(2);
+	pe[TMU2_ID].pmem_base_addr = TMU_IMEM_BASE_ADDR(2);
+	pe[TMU2_ID].pmem_size = TMU_IMEM_SIZE;
+	pe[TMU2_ID].mem_access_wdata = TMU_MEM_ACCESS_WDATA;
+	pe[TMU2_ID].mem_access_addr = TMU_MEM_ACCESS_ADDR;
+	pe[TMU2_ID].mem_access_rdata = TMU_MEM_ACCESS_RDATA;
+
+	pe[TMU3_ID].dmem_base_addr = TMU_DMEM_BASE_ADDR(3);
+	pe[TMU3_ID].pmem_base_addr = TMU_IMEM_BASE_ADDR(3);
+	pe[TMU3_ID].pmem_size = TMU_IMEM_SIZE;
+	pe[TMU3_ID].mem_access_wdata = TMU_MEM_ACCESS_WDATA;
+	pe[TMU3_ID].mem_access_addr = TMU_MEM_ACCESS_ADDR;
+	pe[TMU3_ID].mem_access_rdata = TMU_MEM_ACCESS_RDATA;
+#endif
+
+#if !defined(CONFIG_UTIL_PE_DISABLED)
+	pe[UTIL_ID].dmem_base_addr = UTIL_DMEM_BASE_ADDR;
+	pe[UTIL_ID].mem_access_wdata = UTIL_MEM_ACCESS_WDATA;
+	pe[UTIL_ID].mem_access_addr = UTIL_MEM_ACCESS_ADDR;
+	pe[UTIL_ID].mem_access_rdata = UTIL_MEM_ACCESS_RDATA;
+#endif
+}
+
+
+/** Writes a buffer to PE internal memory from the host
+ * through indirect access registers.
+ *
+ * @param[in] id		PE identification (CLASS0_ID, ..., TMU0_ID, ..., UTIL_ID)
+ * @param[in] src		Buffer source address
+ * @param[in] mem_access_addr	DMEM destination address (must be 32bit aligned)
+ * @param[in] len		Number of bytes to copy
+ */
+void pe_mem_memcpy_to32(int id, u32 mem_access_addr, const void *src, unsigned int len)
+{
+	u32 offset = 0, val, addr;
+	unsigned int len32 = len >> 2;
+	int i;
+
+	addr = mem_access_addr | PE_MEM_ACCESS_WRITE | PE_MEM_ACCESS_BYTE_ENABLE(0, 4);
+
+	for (i = 0; i < len32; i++, offset += 4, src += 4) {
+		val = *(u32 *)src;
+		writel(cpu_to_be32(val), pe[id].mem_access_wdata);
+		writel(addr + offset, pe[id].mem_access_addr);
+	}
+
+	if ((len = (len & 0x3))) {
+		val = 0;
+
+		addr = (mem_access_addr | PE_MEM_ACCESS_WRITE | PE_MEM_ACCESS_BYTE_ENABLE(0, len)) + offset;
+
+		for (i = 0; i < len; i++, src++)
+			val |= (*(u8 *)src) << (8 * i);
+
+		writel(cpu_to_be32(val), pe[id].mem_access_wdata);
+		writel(addr, pe[id].mem_access_addr);
+	}
+}
+
+/** Writes a buffer to PE internal data memory (DMEM) from the host
+ * through indirect access registers.
+ * @param[in] id		PE identification (CLASS0_ID, ..., TMU0_ID, ..., UTIL_ID)
+ * @param[in] src		Buffer source address
+ * @param[in] dst		DMEM destination address (must be 32bit aligned)
+ * @param[in] len		Number of bytes to copy
+ */
+void pe_dmem_memcpy_to32(int id, u32 dst, const void *src, unsigned int len)
+{
+	pe_mem_memcpy_to32(id, pe[id].dmem_base_addr | dst | PE_MEM_ACCESS_DMEM, src, len);
+}
+
+
+/** Writes a buffer to PE internal program memory (PMEM) from the host
+ * through indirect access registers.
+ * @param[in] id		PE identification (CLASS0_ID, ..., TMU0_ID, ..., TMU3_ID)
+ * @param[in] src		Buffer source address
+ * @param[in] dst		PMEM destination address (must be 32bit aligned)
+ * @param[in] len		Number of bytes to copy
+ */
+void pe_pmem_memcpy_to32(int id, u32 dst, const void *src, unsigned int len)
+{
+	pe_mem_memcpy_to32(id, pe[id].pmem_base_addr | (dst & (pe[id].pmem_size - 1)) | PE_MEM_ACCESS_IMEM, src, len);
+}
+
+
+/** Reads PE internal program memory (IMEM) from the host
+ * through indirect access registers.
+ * @param[in] id		PE identification (CLASS0_ID, ..., TMU0_ID, ..., TMU3_ID)
+ * @param[in] addr		PMEM read address (must be aligned on size)
+ * @param[in] size		Number of bytes to read (maximum 4, must not cross 32bit boundaries)
+ * @return			the data read (in PE endianess, i.e BE).
+ */
+u32 pe_pmem_read(int id, u32 addr, u8 size)
+{
+	u32 offset = addr & 0x3;
+	u32 mask = 0xffffffff >> ((4 - size) << 3);
+	u32 val;
+
+	addr = pe[id].pmem_base_addr | ((addr & ~0x3) & (pe[id].pmem_size - 1)) | PE_MEM_ACCESS_READ | PE_MEM_ACCESS_IMEM | PE_MEM_ACCESS_BYTE_ENABLE(offset, size);
+
+	writel(addr, pe[id].mem_access_addr);
+	val = be32_to_cpu(readl(pe[id].mem_access_rdata));
+
+	return (val >> (offset << 3)) & mask;
+}
+
+
+/** Writes PE internal data memory (DMEM) from the host
+ * through indirect access registers.
+ * @param[in] id		PE identification (CLASS0_ID, ..., TMU0_ID, ..., UTIL_ID)
+ * @param[in] addr		DMEM write address (must be aligned on size)
+ * @param[in] val		Value to write (in PE endianess, i.e BE)
+ * @param[in] size		Number of bytes to write (maximum 4, must not cross 32bit boundaries)
+ */
+void pe_dmem_write(int id, u32 val, u32 addr, u8 size)
+{
+	u32 offset = addr & 0x3;
+
+	addr = pe[id].dmem_base_addr | (addr & ~0x3) | PE_MEM_ACCESS_WRITE | PE_MEM_ACCESS_DMEM | PE_MEM_ACCESS_BYTE_ENABLE(offset, size);
+
+	/* Indirect access interface is byte swapping data being written */
+	writel(cpu_to_be32(val << (offset << 3)), pe[id].mem_access_wdata);
+	writel(addr, pe[id].mem_access_addr);
+}
+
+
+/** Reads PE internal data memory (DMEM) from the host
+ * through indirect access registers.
+ * @param[in] id		PE identification (CLASS0_ID, ..., TMU0_ID, ..., UTIL_ID)
+ * @param[in] addr		DMEM read address (must be aligned on size)
+ * @param[in] size		Number of bytes to read (maximum 4, must not cross 32bit boundaries)
+ * @return			the data read (in PE endianess, i.e BE).
+ */
+u32 pe_dmem_read(int id, u32 addr, u8 size)
+{
+	u32 offset = addr & 0x3;
+	u32 mask = 0xffffffff >> ((4 - size) << 3);
+	u32 val;
+
+	addr = pe[id].dmem_base_addr | (addr & ~0x3) | PE_MEM_ACCESS_READ | PE_MEM_ACCESS_DMEM | PE_MEM_ACCESS_BYTE_ENABLE(offset, size);
+
+	writel(addr, pe[id].mem_access_addr);
+
+	/* Indirect access interface is byte swapping data being read */
+	val = be32_to_cpu(readl(pe[id].mem_access_rdata));
+
+	return (val >> (offset << 3)) & mask;
+}
+
+
+/** Writes UTIL program memory (DDR) from the host.
+ *
+ * @param[in] addr	Address to write (virtual, must be aligned on size)
+ * @param[in] val		Value to write (in PE endianess, i.e BE)
+ * @param[in] size		Number of bytes to write (2 or 4)
+ */
+static void util_pmem_write(u32 val, void *addr, u8 size)
+{
+	void *addr64 = (void *)((unsigned long)addr & ~0x7);
+	unsigned long off = 8 - ((unsigned long)addr & 0x7) - size;
+	
+	//IMEM should  be loaded as a 64bit swapped value in a 64bit aligned location
+	if (size == 4)
+		writel(be32_to_cpu(val), addr64 + off);
+	else
+		writew(be16_to_cpu((u16)val), addr64 + off);
+}
+
+
+/** Writes a buffer to UTIL program memory (DDR) from the host.
+ *
+ * @param[in] dst	Address to write (virtual, must be at least 16bit aligned)
+ * @param[in] src	Buffer to write (in PE endianess, i.e BE, must have same alignment as dst)
+ * @param[in] len	Number of bytes to write (must be at least 16bit aligned)
+ */
+static void util_pmem_memcpy(void *dst, const void *src, unsigned int len)
+{
+	unsigned int len32;
+	int i;
+
+	if ((unsigned long)src & 0x2) {
+		util_pmem_write(*(u16 *)src, dst, 2);
+		src += 2;
+		dst += 2;
+		len -= 2;
+	}
+
+	len32 = len >> 2;
+
+	for (i = 0; i < len32; i++, dst += 4, src += 4)
+		util_pmem_write(*(u32 *)src, dst, 4);
+
+	if (len & 0x2)
+		util_pmem_write(*(u16 *)src, dst, len & 0x2);
+}
+
+
+/** Loads an elf section into pmem
+ * Code needs to be at least 16bit aligned and only PROGBITS sections are supported
+ *
+ * @param[in] id	PE identification (CLASS0_ID, ..., TMU0_ID, ..., TMU3_ID)
+ * @param[in] data	pointer to the elf firmware
+ * @param[in] shdr	pointer to the elf section header
+ *
+ */
+static int pe_load_pmem_section(int id, const void *data, Elf32_Shdr *shdr)
+{
+	u32 offset = be32_to_cpu(shdr->sh_offset);
+	u32 addr = be32_to_cpu(shdr->sh_addr);
+	u32 size = be32_to_cpu(shdr->sh_size);
+	u32 type = be32_to_cpu(shdr->sh_type);
+
+#if !defined(CONFIG_UTIL_PE_DISABLED)
+	if (id == UTIL_ID)
+	{
+		printf("%s: unsuported pmem section for UTIL\n", __func__);
+		return -1;
+	}
+#endif
+
+	if (((unsigned long)(data + offset) & 0x3) != (addr & 0x3))
+	{
+		printf("%s: load address(%x) and elf file address(%lx) don't have the same alignment\n",
+			__func__, addr, (unsigned long) data + offset);
+
+		return -1;
+	}
+
+	if (addr & 0x1)
+	{
+		printf("%s: load address(%x) is not 16bit aligned\n", __func__, addr);
+		return -1;
+	}
+
+	if (size & 0x1)
+	{
+		printf("%s: load size(%x) is not 16bit aligned\n", __func__, size);
+		return -1;
+	}
+
+	switch (type)
+        {
+        case SHT_PROGBITS:
+		pe_pmem_memcpy_to32(id, addr, data + offset, size);
+		break;
+
+	default:
+		printf("%s: unsuported section type(%x)\n", __func__, type);
+		return -1;
+		break;
+	}
+
+	return 0;
+}
+
+
+/** Loads an elf section into dmem
+ * Data needs to be at least 32bit aligned, NOBITS sections are correctly initialized to 0
+ *
+ * @param[in] id		PE identification (CLASS0_ID, ..., TMU0_ID, ..., UTIL_ID)
+ * @param[in] data		pointer to the elf firmware
+ * @param[in] shdr		pointer to the elf section header
+ *
+ */
+static int pe_load_dmem_section(int id, const void *data, Elf32_Shdr *shdr)
+{
+	u32 offset = be32_to_cpu(shdr->sh_offset);
+	u32 addr = be32_to_cpu(shdr->sh_addr);
+	u32 size = be32_to_cpu(shdr->sh_size);
+	u32 type = be32_to_cpu(shdr->sh_type);
+	u32 size32 = size >> 2;
+	int i;
+
+	if (((unsigned long)(data + offset) & 0x3) != (addr & 0x3))
+	{
+		printf("%s: load address(%x) and elf file address(%lx) don't have the same alignment\n",
+			__func__, addr, (unsigned long)data + offset);
+
+		return -1;
+	}
+
+	if (addr & 0x3)
+	{
+		printf("%s: load address(%x) is not 32bit aligned\n", __func__, addr);
+		return -1;
+	}
+
+	switch (type)
+        {
+        case SHT_PROGBITS:
+		pe_dmem_memcpy_to32(id, addr, data + offset, size);
+		break;
+
+	case SHT_NOBITS:
+		for (i = 0; i < size32; i++, addr += 4)
+			pe_dmem_write(id, 0, addr, 4);
+
+		if (size & 0x3)
+			pe_dmem_write(id, 0, addr, size & 0x3);
+
+		break;
+
+	default:
+		printf("%s: unsuported section type(%x)\n", __func__, type);
+		return -1;
+		break;
+	}
+
+	return 0;
+}
+
+
+/** Loads an elf section into DDR
+ * Data needs to be at least 32bit aligned, NOBITS sections are correctly initialized to 0
+ *
+ * @param[in] id		PE identification (CLASS0_ID, ..., TMU0_ID, ..., UTIL_ID)
+ * @param[in] data		pointer to the elf firmware
+ * @param[in] shdr		pointer to the elf section header
+ *
+ */
+static int pe_load_ddr_section(int id, const void *data, Elf32_Shdr *shdr)
+{
+	u32 offset = be32_to_cpu(shdr->sh_offset);
+	u32 addr = be32_to_cpu(shdr->sh_addr);
+	u32 size = be32_to_cpu(shdr->sh_size);
+	u32 type = be32_to_cpu(shdr->sh_type);
+	u32 flags = be32_to_cpu(shdr->sh_flags);
+	u32 size32 = size >> 2;
+	int i;
+
+	switch (type)
+	{
+	case SHT_PROGBITS:
+		if (flags & SHF_EXECINSTR)
+		{
+#if !defined(CONFIG_UTIL_PE_DISABLED)
+			if (id == UTIL_ID)
+			{
+				if (((unsigned long)(data + offset) & 0x3) != (addr & 0x3))
+				{
+					printf("%s: load address(%x) and elf file address(%lx) don't have the same alignment\n",
+								__func__, addr, (unsigned long)data + offset);
+
+					return -1;
+				}
+
+				if (addr & 0x1)
+				{
+					printf("%s: load address(%x) is not 16bit aligned\n", __func__, addr);
+					return -1;
+				}
+
+				if (size & 0x1)
+				{
+					printf("%s: load length(%x) is not 16bit aligned\n", __func__, size);
+					return -1;
+				}
+
+				util_pmem_memcpy(DDR_PHYS_TO_VIRT(addr), data + offset, size);
+			}
+			else
+#endif
+			{
+				printf("%s: unsuported ddr section type(%x) for PE(%d)\n", __func__, type, id);
+				return -1;
+			}
+
+		}
+		else
+		{
+			memcpy(DDR_PHYS_TO_VIRT(addr), data + offset, size);
+		}
+
+		break;
+
+	case SHT_NOBITS:
+		memset(DDR_PHYS_TO_VIRT(addr), 0, size);
+
+		break;
+
+	default:
+		printf("%s: unsuported section type(%x)\n", __func__, type);
+		return -1;
+		break;
+	}
+
+	return 0;
+}
+
+
+/** Loads an elf section into a PE
+ * For now only supports loading a section to dmem (all PE's), pmem (class and tmu PE's),
+ * DDDR (util PE code)
+ *
+ * @param[in] id		PE identification (CLASS0_ID, ..., TMU0_ID, ..., UTIL_ID)
+ * @param[in] data		pointer to the elf firmware
+ * @param[in] shdr		pointer to the elf section header
+ *
+ */
+int pe_load_elf_section(int id, const void *data, Elf32_Shdr *shdr)
+{
+	u32 addr = be32_to_cpu(shdr->sh_addr);
+	u32 size = be32_to_cpu(shdr->sh_size);
+
+	if (IS_DMEM(addr, size))
+		return pe_load_dmem_section(id, data, shdr);
+	else if (IS_PMEM(addr, size))
+		return pe_load_pmem_section(id, data, shdr);
+	else if (IS_PFE_LMEM(addr, size))
+		return 0; /* FIXME */
+	else if (IS_PHYS_DDR(addr, size))
+		return pe_load_ddr_section(id, data, shdr);
+	else if (IS_PE_LMEM(addr, size))
+		return 0; /* FIXME */
+	else {
+		printf("%s: unsuported memory range(%x)\n", __func__, addr);
+//		return -1;
+	}
+
+	return 0;
+}
+
+/** This function is used to write to UTIL internal bus peripherals from the host
+* through indirect access registers.
+* @param[in]	val	32bits value to write
+* @param[in]	addr	Address to write to
+* @param[in]	size	Number of bytes to write
+*
+*/
+void util_bus_write(u32 val, u32 addr, u8 size)
+{
+	u32 offset = addr & 0x3;
+	u32 access_addr;
+
+	access_addr = ((addr & ~0x3) & CLASS_BUS_ACCESS_ADDR_MASK) | PE_MEM_ACCESS_WRITE | PE_MEM_ACCESS_BYTE_ENABLE(offset, size);
+
+//	writel((addr & CLASS_BUS_ACCESS_BASE_MASK), CLASS_BUS_ACCESS_BASE);
+
+	writel(cpu_to_be32(val << (offset << 3)), UTIL_BUS_ACCESS_WDATA);
+	writel(access_addr, UTIL_BUS_ACCESS_ADDR);
+}
+
+
+/** Reads from UTIL internal bus peripherals from the host
+* through indirect access registers.
+* @param[in] addr	Address to read from
+* @param[in] size	Number of bytes to read
+* @return		the read data
+*
+*/
+u32 util_bus_read(u32 addr, u8 size)
+{
+	u32 offset = addr & 0x3;
+	u32 mask = 0xffffffff >> ((4 - size) << 3);
+	u32 access_addr, val;
+
+	access_addr = ((addr & ~0x3) & CLASS_BUS_ACCESS_ADDR_MASK) | PE_MEM_ACCESS_READ | PE_MEM_ACCESS_BYTE_ENABLE(offset, size);
+
+//	writel((addr & CLASS_BUS_ACCESS_BASE_MASK), CLASS_BUS_ACCESS_BASE);
+
+	writel(access_addr, UTIL_BUS_ACCESS_ADDR);
+	val = be32_to_cpu(readl(UTIL_BUS_ACCESS_RDATA));
+
+	return (val >> (offset << 3)) & mask;
+}
+
+/** This function is used to write to CLASS internal bus peripherals (ccu, pe-lem) from the host
+* through indirect access registers.
+* @param[in]	val	32bits value to write
+* @param[in]	addr	Address to write to
+* @param[in]	size	Number of bytes to write
+*
+*/
+void class_bus_write(u32 val, u32 addr, u8 size)
+{
+	u32 offset = addr & 0x3;
+	u32 access_addr;
+
+	access_addr = ((addr & ~0x3) & CLASS_BUS_ACCESS_ADDR_MASK) | PE_MEM_ACCESS_WRITE | PE_MEM_ACCESS_BYTE_ENABLE(offset, size);
+
+	writel((addr & CLASS_BUS_ACCESS_BASE_MASK), CLASS_BUS_ACCESS_BASE);
+
+	writel(cpu_to_be32(val << (offset << 3)), CLASS_BUS_ACCESS_WDATA);
+	writel(access_addr, CLASS_BUS_ACCESS_ADDR);
+}
+
+
+/** Reads from CLASS internal bus peripherals (ccu, pe-lem) from the host
+* through indirect access registers.
+* @param[in] addr	Address to read from
+* @param[in] size	Number of bytes to read
+* @return		the read data
+*
+*/
+u32 class_bus_read(u32 addr, u8 size)
+{
+	u32 offset = addr & 0x3;
+	u32 mask = 0xffffffff >> ((4 - size) << 3);
+	u32 access_addr, val;
+	
+	access_addr = ((addr & ~0x3) & CLASS_BUS_ACCESS_ADDR_MASK) | PE_MEM_ACCESS_READ | PE_MEM_ACCESS_BYTE_ENABLE(offset, size);
+
+	writel((addr & CLASS_BUS_ACCESS_BASE_MASK), CLASS_BUS_ACCESS_BASE);
+
+	writel(access_addr, CLASS_BUS_ACCESS_ADDR);
+	val = be32_to_cpu(readl(CLASS_BUS_ACCESS_RDATA));
+
+	return (val >> (offset << 3)) & mask;
+}
+
+
+/** Reads data from the cluster memory (PE_LMEM)
+* @param[out] dst		pointer to the source buffer data are copied to
+* @param[in] len		length in bytes of the amount of data to read from cluster memory
+* @param[in] offset	offset in bytes in the cluster memory where data are read from
+*/
+void pe_lmem_read(u32 *dst, u32 len, u32 offset)
+{
+	u32 len32 = len >> 2;
+	int i = 0;
+
+	for (i = 0; i < len32; dst++, i++, offset += 4)
+		*dst = class_bus_read(PE_LMEM_BASE_ADDR + offset, 4);
+
+	/* FIXME we may have an out of bounds access on dst */
+	if (len & 0x03)
+		*dst = class_bus_read(PE_LMEM_BASE_ADDR + offset, (len & 0x03));
+}
+
+/** Writes data to the cluster memory (PE_LMEM)
+* @param[in] src	pointer to the source buffer data are copied from
+* @param[in] len	length in bytes of the amount of data to write to the cluster memory
+* @param[in] offset	offset in bytes in the cluster memory where data are written to
+*/
+void pe_lmem_write(u32 *src, u32 len, u32 offset)
+{
+	u32 len32 = len >> 2;
+	int i = 0;
+
+	for (i = 0; i < len32; src++, i++, offset += 4)
+		class_bus_write(*src, PE_LMEM_BASE_ADDR + offset, 4);
+
+	/* FIXME we may have an out of bounds access on src */
+	if (len & 0x03)
+		class_bus_write(*src, PE_LMEM_BASE_ADDR + offset, (len & 0x03));
+}
+
+/**************************** BMU ***************************/
+
+/** Initializes a BMU block.
+* @param[in] base	BMU block base address
+* @param[in] cfg	BMU configuration
+*/
+void bmu_init(void *base, BMU_CFG *cfg)
+{
+	bmu_reset(base);
+
+	bmu_disable(base);
+
+	bmu_set_config(base, cfg);
+}
+
+/** Resets a BMU block.
+* @param[in] base	BMU block base address
+*/
+void bmu_reset(void *base)
+{
+	writel(CORE_SW_RESET, base + BMU_CTRL);
+}
+
+/** Enabled a BMU block.
+* @param[in] base	BMU block base address
+*/
+void bmu_enable(void *base)
+{
+	writel (CORE_ENABLE, base + BMU_CTRL);
+}
+
+/** Disables a BMU block.
+* @param[in] base	BMU block base address
+*/
+void bmu_disable(void *base)
+{
+	writel (CORE_DISABLE, base + BMU_CTRL);
+}
+
+/** Sets the configuration of a BMU block.
+* @param[in] base	BMU block base address
+* @param[in] cfg	BMU configuration
+*/
+void bmu_set_config(void *base, BMU_CFG *cfg)
+{	
+	writel (cfg->baseaddr, base + BMU_UCAST_BASE_ADDR);
+	writel (cfg->count & 0xffff, base + BMU_UCAST_CONFIG);
+	writel (cfg->size & 0xffff, base + BMU_BUF_SIZE);
+//	writel (BMU1_THRES_CNT, base + BMU_THRES);
+
+	/* Interrupts are never used */
+//	writel (0x0, base + BMU_INT_SRC);
+	writel (0x0, base + BMU_INT_ENABLE);
+}
+
+/**************************** GEMAC ***************************/
+
+/** GEMAC block initialization.
+* @param[in] base	GEMAC base address (GEMAC0, GEMAC1, GEMAC2)
+* @param[in] cfg	GEMAC configuration
+*/
+void gemac_init(void *base, void *cfg)
+{
+	gemac_set_config(base, cfg);
+	gemac_set_bus_width(base, 64);
+}
+
+/** GEMAC set speed.
+* @param[in] base	GEMAC base address
+* @param[in] speed	GEMAC speed (10, 100 or 1000 Mbps)
+*/
+void gemac_set_speed(void *base, MAC_SPEED gem_speed)
+{
+	u32 val = readl(base + EMAC_NETWORK_CONFIG);
+
+	val = val & ~EMAC_SPEED_MASK;
+
+	switch (gem_speed)
+	{
+		case SPEED_10M:
+			val &= (~EMAC_PCS_ENABLE);
+			break;
+
+		case SPEED_100M:
+			val = val | EMAC_SPEED_100;
+			val &= (~EMAC_PCS_ENABLE);
+			break;
+
+		case SPEED_1000M:
+			val = val | EMAC_SPEED_1000;
+			val &= (~EMAC_PCS_ENABLE);
+			break;
+
+		case SPEED_1000M_PCS:
+			val = val | EMAC_SPEED_1000;
+			val |= EMAC_PCS_ENABLE;
+			break;
+
+		default:
+			val = val | EMAC_SPEED_100;
+			val &= (~EMAC_PCS_ENABLE);
+		break;
+	}
+	
+	writel (val, base + EMAC_NETWORK_CONFIG);
+}
+
+/** GEMAC set duplex.
+* @param[in] base	GEMAC base address
+* @param[in] duplex	GEMAC duplex mode (Full, Half)
+*/
+void gemac_set_duplex(void *base, int duplex)
+{
+	u32 val = readl(base + EMAC_NETWORK_CONFIG);
+
+	if (duplex == DUPLEX_HALF)
+		val = (val & ~EMAC_DUPLEX_MASK) | EMAC_HALF_DUP;
+	else
+		val = (val & ~EMAC_DUPLEX_MASK) | EMAC_FULL_DUP;
+  
+	writel (val, base + EMAC_NETWORK_CONFIG);
+}
+
+/** GEMAC set mode.
+* @param[in] base	GEMAC base address
+* @param[in] mode	GEMAC operation mode (MII, RMII, RGMII, SGMII)
+*/
+void gemac_set_mode(void *base, int mode)
+{
+	switch (mode)
+	{
+	case GMII:
+		writel ((readl(base + EMAC_CONTROL) & ~EMAC_MODE_MASK) | EMAC_GMII_MODE_ENABLE, base + EMAC_CONTROL);
+		writel (readl(base + EMAC_NETWORK_CONFIG) & (~EMAC_SGMII_MODE_ENABLE), base + EMAC_NETWORK_CONFIG);
+		break;
+
+	case RGMII:
+		writel ((readl(base + EMAC_CONTROL) & ~EMAC_MODE_MASK) | EMAC_RGMII_MODE_ENABLE, base + EMAC_CONTROL);
+		writel (readl(base + EMAC_NETWORK_CONFIG) & (~EMAC_SGMII_MODE_ENABLE), base + EMAC_NETWORK_CONFIG);
+		break;
+
+	case RMII:
+		writel ((readl(base + EMAC_CONTROL) & ~EMAC_MODE_MASK) | EMAC_RMII_MODE_ENABLE, base + EMAC_CONTROL);
+		writel (readl(base + EMAC_NETWORK_CONFIG) & (~EMAC_SGMII_MODE_ENABLE), base + EMAC_NETWORK_CONFIG);
+		break;
+
+	case MII:
+		writel ((readl(base + EMAC_CONTROL) & ~EMAC_MODE_MASK) | EMAC_MII_MODE_ENABLE, base + EMAC_CONTROL);
+		writel (readl(base + EMAC_NETWORK_CONFIG) & (~EMAC_SGMII_MODE_ENABLE), base + EMAC_NETWORK_CONFIG);
+		break;
+
+	case SGMII:
+		writel ((readl(base + EMAC_CONTROL) & ~EMAC_MODE_MASK) | (EMAC_RMII_MODE_DISABLE | EMAC_RGMII_MODE_DISABLE), base + EMAC_CONTROL);
+		writel (readl(base + EMAC_NETWORK_CONFIG) | EMAC_SGMII_MODE_ENABLE, base + EMAC_NETWORK_CONFIG);
+		break;
+
+	default:
+		writel ((readl(base + EMAC_CONTROL) & ~EMAC_MODE_MASK) | EMAC_MII_MODE_ENABLE, base + EMAC_CONTROL);
+		writel (readl(base + EMAC_NETWORK_CONFIG) & (~EMAC_SGMII_MODE_ENABLE), base + EMAC_NETWORK_CONFIG);
+		break;
+	}
+}
+
+/** GEMAC Enable MDIO: Activate the Management interface.  This is required to program the PHY
+ * @param[in] base       GEMAC base address
+ */
+void gemac_enable_mdio(void *base)
+{
+        u32 data;
+
+        data = readl(base + EMAC_NETWORK_CONTROL);
+        data |= EMAC_MDIO_EN;
+        writel(data, base + EMAC_NETWORK_CONTROL);
+}
+
+/** GEMAC Disable MDIO: Disable the Management interface.
+ * @param[in] base       GEMAC base address
+ */
+void gemac_disable_mdio(void *base)
+{
+        u32 data;
+
+        data = readl(base + EMAC_NETWORK_CONTROL);
+        data &= ~EMAC_MDIO_EN;
+        writel(data, base + EMAC_NETWORK_CONTROL);
+}
+
+/** GEMAC Set MDC clock division
+ * @param[in] base       GEMAC base address
+ * @param[in] base       MDC divider value
+ */
+void gemac_set_mdc_div(void *base, MAC_MDC_DIV gem_mdcdiv)
+{
+        u32 data;
+
+        data = readl(base + EMAC_NETWORK_CONFIG);
+	data &= ~(MDC_DIV_MASK << MDC_DIV_SHIFT);
+        data |= (gem_mdcdiv & MDC_DIV_MASK) << MDC_DIV_SHIFT;
+        writel(data, base + EMAC_NETWORK_CONFIG);
+}
+
+/** GEMAC reset function.
+* @param[in] base	GEMAC base address
+*/
+void gemac_reset(void *base)
+{  
+}
+
+/** GEMAC enable function.
+* @param[in] base	GEMAC base address
+*/
+void gemac_enable(void *base)
+{  
+	writel (readl(base + EMAC_NETWORK_CONTROL) | EMAC_TX_ENABLE | EMAC_RX_ENABLE, base + EMAC_NETWORK_CONTROL);
+}
+
+/** GEMAC disable function.
+* @param[in] base	GEMAC base address
+*/
+void gemac_disable(void *base)
+{
+	writel (readl(base + EMAC_NETWORK_CONTROL) & ~(EMAC_TX_ENABLE | EMAC_RX_ENABLE), base + EMAC_NETWORK_CONTROL);
+}
+
+/** GEMAC set mac address configuration.
+* @param[in] base	GEMAC base address
+* @param[in] addr	MAC address to be configured
+*/
+void gemac_set_address(void *base, SPEC_ADDR *addr)
+{ 
+	writel(addr->one.bottom,	base + EMAC_SPEC1_ADD_BOT);
+	writel(addr->one.top,		base + EMAC_SPEC1_ADD_TOP); 
+	writel(addr->two.bottom,	base + EMAC_SPEC2_ADD_BOT);
+	writel(addr->two.top,		base + EMAC_SPEC2_ADD_TOP);
+	writel(addr->three.bottom,	base + EMAC_SPEC3_ADD_BOT);
+	writel(addr->three.top,		base + EMAC_SPEC3_ADD_TOP);
+	writel(addr->four.bottom,	base + EMAC_SPEC4_ADD_BOT);
+	writel(addr->four.top,		base + EMAC_SPEC4_ADD_TOP);
+} 
+
+/** GEMAC get mac address configuration.
+* @param[in] base	GEMAC base address
+*
+* @return		MAC addresses configured
+*/
+SPEC_ADDR gemac_get_address(void *base)
+{
+	SPEC_ADDR addr;
+	
+	addr.one.bottom = 	readl(base + EMAC_SPEC1_ADD_BOT);
+	addr.one.top = 		readl(base + EMAC_SPEC1_ADD_TOP); 
+	addr.two.bottom =	readl(base + EMAC_SPEC2_ADD_BOT);
+	addr.two.top =		readl(base + EMAC_SPEC2_ADD_TOP);
+	addr.three.bottom =	readl(base + EMAC_SPEC3_ADD_BOT);
+	addr.three.top =	readl(base + EMAC_SPEC3_ADD_TOP);
+	addr.four.bottom =	readl(base + EMAC_SPEC4_ADD_BOT);
+	addr.four.top =		readl(base + EMAC_SPEC4_ADD_TOP);
+	
+	return addr;
+}
+
+/** GEMAC set specific local addresses of the MAC.
+* Rather than setting up all four specific addresses, this function sets them up individually.
+*
+* @param[in] base	GEMAC base address
+* @param[in] addr	MAC address to be configured
+*/
+void gemac_set_laddr1(void *base, MAC_ADDR *address)
+{
+	writel(address->bottom,		base + EMAC_SPEC1_ADD_BOT);
+	writel(address->top,		base + EMAC_SPEC1_ADD_TOP); 
+}
+
+
+void gemac_set_laddr2(void *base, MAC_ADDR *address)
+{
+	writel(address->bottom,		base + EMAC_SPEC2_ADD_BOT);
+	writel(address->top,		base + EMAC_SPEC2_ADD_TOP); 
+}
+
+
+void gemac_set_laddr3(void *base, MAC_ADDR *address)
+{
+	writel(address->bottom,		base + EMAC_SPEC3_ADD_BOT);
+	writel(address->top,		base + EMAC_SPEC3_ADD_TOP); 
+}
+
+
+void gemac_set_laddr4(void *base, MAC_ADDR *address)
+{
+	writel(address->bottom,		base + EMAC_SPEC4_ADD_BOT);
+	writel(address->top,		base + EMAC_SPEC4_ADD_TOP); 
+}
+
+void gemac_set_laddrN(void *base, MAC_ADDR *address, unsigned int entry_index)
+{
+	if (entry_index < 5)
+	{	
+		writel(address->bottom,		base + (entry_index * 8) + EMAC_SPEC1_ADD_BOT);
+		writel(address->top,		base + (entry_index * 8) + EMAC_SPEC1_ADD_TOP);
+	} 
+	else 
+	{
+		writel(address->bottom,		base + ((entry_index - 5) * 8) + EMAC_SPEC5_ADD_BOT);
+		writel(address->top,		base + ((entry_index - 5) * 8) + EMAC_SPEC5_ADD_TOP);
+	}
+}
+
+/** Get specific local addresses of the MAC.
+* This allows returning of a single specific address stored in the MAC.
+* @param[in] base	GEMAC base address
+*
+* @return		Specific MAC address 1
+* 
+*/
+MAC_ADDR gem_get_laddr1(void *base)
+{
+	MAC_ADDR addr;
+	addr.bottom = readl(base + EMAC_SPEC1_ADD_BOT);
+	addr.top = readl(base + EMAC_SPEC1_ADD_TOP);
+	return addr;
+}
+
+
+MAC_ADDR gem_get_laddr2(void *base)
+{
+	MAC_ADDR addr;
+	addr.bottom = readl(base + EMAC_SPEC2_ADD_BOT);
+	addr.top = readl(base + EMAC_SPEC2_ADD_TOP);
+	return addr;
+}
+
+
+MAC_ADDR gem_get_laddr3(void *base)
+{
+	MAC_ADDR addr;
+	addr.bottom = readl(base + EMAC_SPEC3_ADD_BOT);
+	addr.top = readl(base + EMAC_SPEC3_ADD_TOP);
+	return addr;
+}
+
+
+MAC_ADDR gem_get_laddr4(void *base)
+{
+	MAC_ADDR addr;
+	addr.bottom = readl(base + EMAC_SPEC4_ADD_BOT);
+	addr.top = readl(base + EMAC_SPEC4_ADD_TOP);
+	return addr;
+}
+
+
+MAC_ADDR gem_get_laddrN(void *base, unsigned int entry_index)
+{
+	MAC_ADDR addr;
+
+	if (entry_index < 5)
+	{
+		addr.bottom = readl(base + (entry_index * 8) + EMAC_SPEC1_ADD_BOT);
+		addr.top = readl(base + (entry_index * 8) + EMAC_SPEC1_ADD_TOP);
+	}
+	else
+	{
+		addr.bottom = readl(base + ((entry_index - 5) * 8) + EMAC_SPEC5_ADD_BOT);
+		addr.top = readl(base + ((entry_index - 5) * 8) + EMAC_SPEC5_ADD_TOP);
+	}
+
+	return addr;
+}
+
+/** GEMAC allow frames
+* @param[in] base	GEMAC base address
+*/
+void gemac_enable_copy_all(void *base)
+{
+	writel (readl(base + EMAC_NETWORK_CONFIG) & EMAC_ENABLE_COPY_ALL, base + EMAC_NETWORK_CONFIG);
+}
+
+/** GEMAC do not allow frames
+* @param[in] base	GEMAC base address
+*/
+void gemac_disable_copy_all(void *base)
+{
+	writel (readl(base + EMAC_NETWORK_CONFIG) & ~EMAC_ENABLE_COPY_ALL, base + EMAC_NETWORK_CONFIG);
+}
+
+
+
+/** GEMAC allow broadcast function.
+* @param[in] base	GEMAC base address
+*/
+void gemac_allow_broadcast(void *base)
+{
+	writel (readl(base + EMAC_NETWORK_CONFIG) & ~EMAC_NO_BROADCAST, base + EMAC_NETWORK_CONFIG);
+}
+
+/** GEMAC no broadcast function.
+* @param[in] base	GEMAC base address
+*/
+void gemac_no_broadcast(void *base)
+{
+	writel (readl(base + EMAC_NETWORK_CONFIG) | EMAC_NO_BROADCAST, base + EMAC_NETWORK_CONFIG);
+}
+
+/** GEMAC enable unicast function.
+* @param[in] base	GEMAC base address
+*/
+void gemac_enable_unicast(void *base)
+{
+	writel (readl(base + EMAC_NETWORK_CONFIG) | EMAC_ENABLE_UNICAST, base + EMAC_NETWORK_CONFIG);
+}
+
+/** GEMAC disable unicast function.
+* @param[in] base	GEMAC base address
+*/
+void gemac_disable_unicast(void *base)
+{
+	writel (readl(base + EMAC_NETWORK_CONFIG) & ~EMAC_ENABLE_UNICAST, base + EMAC_NETWORK_CONFIG);
+}
+
+/** GEMAC enable multicast function.
+* @param[in] base	GEMAC base address
+*/
+void gemac_enable_multicast(void *base)
+{
+	writel (readl(base + EMAC_NETWORK_CONFIG) | EMAC_ENABLE_MULTICAST, base + EMAC_NETWORK_CONFIG);
+}
+
+/** GEMAC disable multicast function.
+* @param[in]	base	GEMAC base address
+*/
+void gemac_disable_multicast(void *base)
+{
+	writel (readl(base + EMAC_NETWORK_CONFIG) & ~EMAC_ENABLE_MULTICAST, base + EMAC_NETWORK_CONFIG);
+}
+
+/** GEMAC enable fcs rx function.
+* @param[in]	base	GEMAC base address
+*/
+void gemac_enable_fcs_rx(void *base)
+{
+	writel (readl(base + EMAC_NETWORK_CONFIG) | EMAC_ENABLE_FCS_RX, base + EMAC_NETWORK_CONFIG);
+}
+
+/** GEMAC disable fcs rx function.
+* @param[in]	base	GEMAC base address
+*/
+void gemac_disable_fcs_rx(void *base)
+{
+	writel (readl(base + EMAC_NETWORK_CONFIG) & ~EMAC_ENABLE_FCS_RX, base + EMAC_NETWORK_CONFIG);
+}
+
+/** GEMAC enable 1536 rx function.
+* @param[in]	base	GEMAC base address
+*/
+void gemac_enable_1536_rx(void *base)
+{
+	writel (readl(base + EMAC_NETWORK_CONFIG) | EMAC_ENABLE_1536_RX, base + EMAC_NETWORK_CONFIG);
+}
+
+/** GEMAC disable 1536 rx function.
+* @param[in]	base	GEMAC base address
+*/
+void gemac_disable_1536_rx(void *base)
+{
+	writel (readl(base + EMAC_NETWORK_CONFIG) & ~EMAC_ENABLE_1536_RX, base + EMAC_NETWORK_CONFIG);
+}
+
+/** GEMAC enable pause rx function.
+* @param[in] base	GEMAC base address
+*/
+void gemac_enable_pause_rx(void *base)
+{
+	writel (readl(base + EMAC_NETWORK_CONFIG) | EMAC_ENABLE_PAUSE_RX, base + EMAC_NETWORK_CONFIG);
+}
+
+/** GEMAC disable pause rx function.
+* @param[in] base	GEMAC base address
+*/
+void gemac_disable_pause_rx(void *base)
+{
+	writel (readl(base + EMAC_NETWORK_CONFIG) & ~EMAC_ENABLE_PAUSE_RX, base + EMAC_NETWORK_CONFIG);
+}
+
+/** GEMAC enable rx checksum offload function.
+* @param[in] base	GEMAC base address
+*/
+void gemac_enable_rx_checksum_offload(void *base)
+{
+	writel(readl(base + EMAC_NETWORK_CONFIG) | EMAC_ENABLE_CHKSUM_RX, base + EMAC_NETWORK_CONFIG);
+	writel(readl(CLASS_L4_CHKSUM_ADDR) | IPV4_CHKSUM_DROP, CLASS_L4_CHKSUM_ADDR);
+}
+
+/** GEMAC disable rx checksum offload function.
+* @param[in] base	GEMAC base address
+*/
+void gemac_disable_rx_checksum_offload(void *base)
+{
+	writel(readl(base + EMAC_NETWORK_CONFIG) & ~EMAC_ENABLE_CHKSUM_RX, base + EMAC_NETWORK_CONFIG);
+	writel(readl(CLASS_L4_CHKSUM_ADDR) & ~IPV4_CHKSUM_DROP, CLASS_L4_CHKSUM_ADDR);
+}
+
+/** Sets Gemac bus width to 64bit
+ * @param[in] base       GEMAC base address
+ * @param[in] width	gemac bus width to be set possible values are 32/64/128
+ * */
+void gemac_set_bus_width(void *base, int width)
+{
+	u32 val = readl(base + EMAC_NETWORK_CONFIG);
+	switch(width) 
+	{
+	case 32:
+		val = (val & ~EMAC_DATA_BUS_WIDTH_MASK) | EMAC_DATA_BUS_WIDTH_32;
+	case 128:
+		val = (val & ~EMAC_DATA_BUS_WIDTH_MASK) | EMAC_DATA_BUS_WIDTH_128;
+	case 64:
+	default:
+		val = (val & ~EMAC_DATA_BUS_WIDTH_MASK) | EMAC_DATA_BUS_WIDTH_64;
+
+	}
+	writel (val, base + EMAC_NETWORK_CONFIG);
+}
+
+/** Sets Gemac configuration.
+* @param[in] base	GEMAC base address
+* @param[in] cfg	GEMAC configuration
+*/
+void gemac_set_config(void *base, GEMAC_CFG *cfg)
+{
+	gemac_set_mode(base, cfg->mode);
+
+	gemac_set_speed(base, cfg->speed);
+
+	gemac_set_duplex(base,cfg->duplex);
+}
+
+
+/**************************** GPI ***************************/
+
+/** Initializes a GPI block.
+* @param[in] base	GPI base address
+* @param[in] cfg	GPI configuration
+*/
+void gpi_init(void *base, GPI_CFG *cfg)
+{ 
+	gpi_reset(base);
+	
+	gpi_disable(base);
+	
+	gpi_set_config(base, cfg);
+}
+
+/** Resets a GPI block.
+* @param[in] base	GPI base address
+*/
+void gpi_reset(void *base)
+{
+	writel (CORE_SW_RESET, base + GPI_CTRL);
+}
+
+/** Enables a GPI block.
+* @param[in] base	GPI base address
+*/
+void gpi_enable(void *base)
+{
+	writel (CORE_ENABLE, base + GPI_CTRL);
+}
+
+/** Disables a GPI block.
+* @param[in] base	GPI base address
+*/
+void gpi_disable(void *base)
+{
+	writel (CORE_DISABLE, base + GPI_CTRL);
+}
+
+
+/** Sets the configuration of a GPI block.
+* @param[in] base	GPI base address
+* @param[in] cfg	GPI configuration
+*/
+void gpi_set_config(void *base, GPI_CFG *cfg)
+{  
+	writel (CBUS_VIRT_TO_PFE(BMU1_BASE_ADDR + BMU_ALLOC_CTRL),	base + GPI_LMEM_ALLOC_ADDR);
+	writel (CBUS_VIRT_TO_PFE(BMU1_BASE_ADDR + BMU_FREE_CTRL),	base + GPI_LMEM_FREE_ADDR);
+	writel (CBUS_VIRT_TO_PFE(BMU2_BASE_ADDR + BMU_ALLOC_CTRL),	base + GPI_DDR_ALLOC_ADDR);
+	writel (CBUS_VIRT_TO_PFE(BMU2_BASE_ADDR + BMU_FREE_CTRL),	base + GPI_DDR_FREE_ADDR);
+	writel (CBUS_VIRT_TO_PFE(CLASS_INQ_PKTPTR),			base + GPI_CLASS_ADDR);
+ 	writel (DDR_HDR_SIZE,						base + GPI_DDR_DATA_OFFSET);
+	writel (LMEM_HDR_SIZE,						base + GPI_LMEM_DATA_OFFSET);
+	writel (0,							base + GPI_LMEM_SEC_BUF_DATA_OFFSET);
+	writel (0,							base + GPI_DDR_SEC_BUF_DATA_OFFSET);
+	writel ((DDR_HDR_SIZE << 16) | LMEM_HDR_SIZE,			base + GPI_HDR_SIZE);
+	writel ((DDR_BUF_SIZE << 16) | LMEM_BUF_SIZE,			base + GPI_BUF_SIZE);
+	
+	writel (((cfg->lmem_rtry_cnt << 16) | (GPI_DDR_BUF_EN << 1) | GPI_LMEM_BUF_EN),	base + GPI_RX_CONFIG);
+	writel (cfg->tmlf_txthres,					base + GPI_TMLF_TX);
+	writel (cfg->aseq_len,						base + GPI_DTX_ASEQ);
+}
+
+/**************************** CLASSIFIER ***************************/
+
+/** Initializes CLASSIFIER block.
+* @param[in] cfg	CLASSIFIER configuration
+*/
+void class_init(CLASS_CFG *cfg)
+{
+	class_reset();
+	
+	class_disable();
+	
+	class_set_config(cfg);
+}
+
+/** Resets CLASSIFIER block.
+*
+*/
+void class_reset(void)
+{
+	writel(CORE_SW_RESET, CLASS_TX_CTRL);
+}
+
+/** Enables all CLASS-PE's cores.
+*
+*/
+void class_enable(void)
+{
+	writel(CORE_ENABLE, CLASS_TX_CTRL);
+}
+
+/** Disables all CLASS-PE's cores.
+*
+*/
+void class_disable(void)
+{
+	writel(CORE_DISABLE, CLASS_TX_CTRL); 
+}
+
+/** Sets the configuration of the CLASSIFIER block.
+* @param[in] cfg	CLASSIFIER configuration
+*/
+void class_set_config(CLASS_CFG *cfg)
+{
+	if (PLL_CLK_EN == 0)
+		writel(0x0,     CLASS_PE_SYS_CLK_RATIO);        // Clock ratio: for 1:1 the value is 0
+	else
+		writel(0x1,     CLASS_PE_SYS_CLK_RATIO);        // Clock ratio: for 1:2 the value is 1
+
+	writel((DDR_HDR_SIZE << 16) | LMEM_HDR_SIZE,	CLASS_HDR_SIZE);
+	writel(LMEM_BUF_SIZE,				CLASS_LMEM_BUF_SIZE);
+	writel(CLASS_ROUTE_ENTRY_SIZE(CLASS_ROUTE_SIZE) | CLASS_ROUTE_HASH_SIZE(cfg->route_table_hash_bits),	CLASS_ROUTE_HASH_ENTRY_SIZE);
+	writel(HASH_CRC_PORT_IP | QB2BUS_LE, CLASS_ROUTE_MULTI);
+
+	writel(cfg->route_table_baseaddr,		CLASS_ROUTE_TABLE_BASE);
+	memset(cfg->route_table_baseaddr, 0, ROUTE_TABLE_SIZE);
+
+	writel(CLASS_PE0_RO_DM_ADDR0_VAL,		CLASS_PE0_RO_DM_ADDR0);
+	writel(CLASS_PE0_RO_DM_ADDR1_VAL,		CLASS_PE0_RO_DM_ADDR1);
+	writel(CLASS_PE0_QB_DM_ADDR0_VAL,		CLASS_PE0_QB_DM_ADDR0);
+	writel(CLASS_PE0_QB_DM_ADDR1_VAL,		CLASS_PE0_QB_DM_ADDR1);
+	writel(CBUS_VIRT_TO_PFE(TMU_PHY_INQ_PKTPTR),	CLASS_TM_INQ_ADDR);
+
+	writel(31, CLASS_AFULL_THRES);
+	writel(31, CLASS_TSQ_FIFO_THRES);
+}
+
+/**************************** TMU ***************************/
+
+/** Initializes TMU block.
+* @param[in] cfg	TMU configuration
+*/
+void tmu_init(TMU_CFG *cfg)
+{
+	int q, phyno;
+	writel(0x3,						TMU_SYS_GENERIC_CONTROL);
+	writel(750,						TMU_INQ_WATERMARK);
+	writel(CBUS_VIRT_TO_PFE(EGPI1_BASE_ADDR + GPI_INQ_PKTPTR),	TMU_PHY0_INQ_ADDR);
+	writel(CBUS_VIRT_TO_PFE(EGPI2_BASE_ADDR + GPI_INQ_PKTPTR),	TMU_PHY1_INQ_ADDR);
+	writel(CBUS_VIRT_TO_PFE(EGPI3_BASE_ADDR + GPI_INQ_PKTPTR),	TMU_PHY2_INQ_ADDR);
+	writel(CBUS_VIRT_TO_PFE(HGPI_BASE_ADDR + GPI_INQ_PKTPTR),	TMU_PHY3_INQ_ADDR);
+	writel(CBUS_VIRT_TO_PFE(HIF_NOCPY_RX_INQ0_PKTPTR),		TMU_PHY4_INQ_ADDR);
+	writel(CBUS_VIRT_TO_PFE(UTIL_INQ_PKTPTR),			TMU_PHY5_INQ_ADDR);
+	writel(CBUS_VIRT_TO_PFE(BMU2_BASE_ADDR + BMU_FREE_CTRL), 	TMU_BMU_INQ_ADDR);
+
+	writel(0x3FF,	TMU_TDQ0_SCH_CTRL);	// enabling all 10 schedulers [9:0] of each TDQ 
+	writel(0x3FF,	TMU_TDQ1_SCH_CTRL);
+	writel(0x3FF,	TMU_TDQ2_SCH_CTRL);
+	writel(0x3FF,	TMU_TDQ3_SCH_CTRL);
+	
+	if (PLL_CLK_EN == 0)
+		writel(0x0,	TMU_PE_SYS_CLK_RATIO);	// Clock ratio: for 1:1 the value is 0
+	else
+		writel(0x1,	TMU_PE_SYS_CLK_RATIO);	// Clock ratio: for 1:2 the value is 1
+	
+	writel(cfg->llm_base_addr,	TMU_LLM_BASE_ADDR);	// Extra packet pointers will be stored from this address onwards
+	
+	writel(cfg->llm_queue_len,	TMU_LLM_QUE_LEN);
+	writel(0x100,			TMU_CTRL);
+	writel(5,			TMU_TDQ_IIFG_CFG);
+	writel(DDR_BUF_SIZE,		TMU_BMU_BUF_SIZE);
+
+	// set up each queue for tail drop
+	for (phyno = 0; phyno < 4; phyno++)
+	{
+		for (q = 0; q < 16; q++)
+		{
+			u32 qmax;
+			writel((phyno << 8) | q, TMU_TEQ_CTRL);
+			writel(1 << 22, TMU_TEQ_QCFG);
+			qmax = ((phyno == 3) || (q < 8)) ? 255 : 127;
+			writel(qmax << 18, TMU_TEQ_HW_PROB_CFG2);
+			writel(qmax >> 14, TMU_TEQ_HW_PROB_CFG3);
+		}
+	}
+	writel(0x05, TMU_TEQ_DISABLE_DROPCHK);
+}
+
+/** Enables TMU-PE cores.
+* @param[in] pe_mask	TMU PE mask
+*/
+void tmu_enable(u32 pe_mask)
+{
+	writel(readl(TMU_TX_CTRL) | (pe_mask & 0xF), TMU_TX_CTRL);
+}
+
+/** Disables TMU cores.
+* @param[in] pe_mask	TMU PE mask
+*/
+void tmu_disable(u32 pe_mask)
+{
+	writel(readl(TMU_TX_CTRL) & ((~pe_mask) & 0xF), TMU_TX_CTRL);
+}
+
+/**************************** UTIL ***************************/
+
+/** Resets UTIL block.
+*/
+void util_reset(void)
+{
+	writel(CORE_SW_RESET, UTIL_TX_CTRL);
+}
+
+/** Initializes UTIL block.
+* @param[in] cfg	UTIL configuration
+*/
+void util_init(UTIL_CFG *cfg)
+{
+
+	if (PLL_CLK_EN == 0)
+		writel(0x0,     UTIL_PE_SYS_CLK_RATIO);        // Clock ratio: for 1:1 the value is 0
+	else
+		writel(0x1,     UTIL_PE_SYS_CLK_RATIO);        // Clock ratio: for 1:2 the value is 1
+}
+
+/** Enables UTIL-PE core.
+*
+*/
+void util_enable(void)
+{
+	writel(CORE_ENABLE, UTIL_TX_CTRL);
+}
+
+/** Disables UTIL-PE core.
+*
+*/
+void util_disable(void)
+{
+	writel(CORE_DISABLE, UTIL_TX_CTRL);
+}
+
+/** GEMAC PHY Statistics - This function return address of the first statistics register
+* @param[in]	base	GEMAC base address 
+*/
+unsigned int * gemac_get_stats(void *base)
+{
+	return (unsigned int *)(base + EMAC_OCT_TX_BOT);
+}
+
+/**************************** HIF ***************************/
+
+/** Initializes HIF no copy block.
+*
+*/
+void hif_nocpy_init(void)
+{
+	writel(4,							HIF_NOCPY_TX_PORT_NO);
+	writel(CBUS_VIRT_TO_PFE(BMU1_BASE_ADDR + BMU_ALLOC_CTRL),		HIF_NOCPY_LMEM_ALLOC_ADDR);
+	writel(CBUS_VIRT_TO_PFE(CLASS_INQ_PKTPTR),	HIF_NOCPY_CLASS_ADDR);
+	writel(CBUS_VIRT_TO_PFE(TMU_PHY_INQ_PKTPTR),	HIF_NOCPY_TMU_PORT0_ADDR);
+}
+
+/** Initializes HIF copy block.
+*
+*/
+void hif_init(void)
+{
+	/*Initialize HIF registers*/
+	writel(HIF_RX_POLL_CTRL_CYCLE<<16|HIF_TX_POLL_CTRL_CYCLE, HIF_POLL_CTRL); 
+}
+
+/** Enable hif tx DMA and interrupt
+*
+*/
+void hif_tx_enable(void)
+{
+	/*TODO not sure poll_cntrl_en is required or not */
+	writel( HIF_CTRL_DMA_EN, HIF_TX_CTRL);
+	//writel((readl(HIF_INT_ENABLE) | HIF_INT_EN | HIF_TXPKT_INT_EN), HIF_INT_ENABLE);
+}
+
+/** Disable hif tx DMA and interrupt
+*
+*/
+void hif_tx_disable(void)
+{
+	u32	hif_int;
+
+	writel(0, HIF_TX_CTRL);
+
+	hif_int = readl(HIF_INT_ENABLE);
+	hif_int &= HIF_TXPKT_INT_EN;
+	writel(hif_int, HIF_INT_ENABLE);
+}
+
+/** Enable hif rx DMA and interrupt
+*
+*/
+void hif_rx_enable(void)
+{
+	/*TODO not sure poll_cntrl_en is required or not */
+	writel((HIF_CTRL_DMA_EN | HIF_CTRL_BDP_CH_START_WSTB), HIF_RX_CTRL);
+	//writel((readl(HIF_INT_ENABLE) | HIF_INT_EN | HIF_TXPKT_INT_EN), HIF_INT_ENABLE);
+}
+
+/** Disable hif rx DMA and interrupt
+*
+*/
+void hif_rx_disable(void)
+{
+	u32	hif_int;
+
+	writel(0, HIF_RX_CTRL);
+
+	hif_int = readl(HIF_INT_ENABLE);
+	hif_int &= HIF_RXPKT_INT_EN;
+	writel(hif_int, HIF_INT_ENABLE);
+
+}
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/net/c2000_eth/pfe_driver.c u-boot-2013.01.new/drivers/net/c2000_eth/pfe_driver.c
--- u-boot-2013.01/drivers/net/c2000_eth/pfe_driver.c	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/net/c2000_eth/pfe_driver.c	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,687 @@
+/*
+ *  (C) Copyright 2011
+ *  Author : Mindspeed Technologes
+ *
+ *  See file CREDITS for list of people who contributed to this
+ *  project.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License as
+ *  published by the Free Software Foundation; either version 2 of
+ *  the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA 02111-1307 USA
+ * */
+
+
+#include "hal.h"
+#include "pfe/pfe.h"
+#include "pfe_driver.h"
+#include "pfe_firmware.h"
+
+
+static struct tx_desc_s *g_tx_desc = NULL;
+static struct rx_desc_s *g_rx_desc = NULL;
+
+
+/** HIF Rx interface function
+ * Reads the rx descriptor from the current location (rxToRead).
+ * - If the descriptor has a valid data/pkt, then get the data pointer
+ * - check for the input rx phy number
+ * - increments the rx data pointer by pkt_head_room_size
+ * - decrements the data length by pkt_head_room_size
+ * - handover the packet to caller.
+ *
+ * @param[out]	pkt_ptr	Pointer to store rx packet pointer
+ * @param[out] phy_port Pointer to store recv phy port
+ *
+ * @return	-1 if no packet, else returns length of packet.
+ */
+int pfe_recv(unsigned int *pkt_ptr, int *phy_port)
+{
+	struct rx_desc_s *rx_desc = g_rx_desc;
+	struct bufDesc *bd;
+	int len = -1;
+	volatile u32 ctrl;
+	struct hif_header_s *hif_header;
+
+	bd = rx_desc->rxBase + rx_desc->rxToRead;
+
+	if (bd->ctrl & BD_CTRL_DESC_EN)
+		return len; //No pending Rx packet
+
+	/* this len include hif_header(8bytes) */
+	len = bd->ctrl & 0xFFFF;
+
+	hif_header = (struct hif_header_s *)DDR_PHYS_TO_VIRT(bd->data);
+
+
+	/* Get the recive port info from the packet */
+	dprint("Pkt recv'd: Pkt ptr(%p), len(%d), gemac_port(%d) status(%08x)\n",
+				hif_header, len, hif_header->port_no, bd->status);
+
+#if 0
+	{
+		int i;
+		unsigned char *p = (unsigned char *)hif_header;
+		for(i=0; i < len; i++) {
+			if(!(i % 16))
+				printf("\n");
+			printf(" %02x", p[i]);
+		}
+		printf("\n");
+	}
+#endif
+
+	*pkt_ptr = (unsigned int )(hif_header + 1);
+	*phy_port = hif_header->port_no;
+	len -= sizeof(struct hif_header_s);
+
+	/* reset bd control field */
+	ctrl = (MAX_FRAME_SIZE | BD_CTRL_DESC_EN | BD_CTRL_DIR);
+	bd->ctrl = ctrl;
+	bd->status = 0;
+
+	rx_desc->rxToRead = (rx_desc->rxToRead + 1) & (rx_desc->rxRingSize - 1);
+
+	/* Give START_STROBE to BDP to fetch the descriptor __NOW__,
+	 * BDP need not to wait for rx_poll_cycle time to fetch the descriptor,
+	 * In idle state (ie., no rx pkt), BDP will not fetch
+	 * the descriptor even if strobe is given(I think) */
+	writel((readl(HIF_RX_CTRL) | HIF_CTRL_BDP_CH_START_WSTB), HIF_RX_CTRL);
+
+	return len;
+}
+
+
+/** HIF Tx interface function
+ * This function sends a single packet to PFE from HIF interface.
+ * - No interrupt indication on tx completion.
+ * - After tx descriptor is updated and TX DMA is enabled.
+ * - To support both chipit and read c2k environment, data is copied to
+ *   tx buffers. After verification this copied can be avoided.
+ *
+ * @param[in] phy_port	Phy port number to send out this packet
+ * @param[in] data	Pointer to the data
+ * @param[in] length	Length of the ethernet packet to be transfered.
+ *
+ * @return -1 if tx Q is full, else returns the tx location where the pkt is placed.
+ */
+int pfe_send(int phy_port, void *data, int length)
+{
+	struct tx_desc_s *tx_desc = g_tx_desc;
+	struct bufDesc *bd;
+	struct hif_header_s hif_header;
+	u8 *tx_buf_va;
+	volatile u32 ctrl_word;
+
+	dprint("%s:pkt: %p, len: %d, txBase: %p, txToSend: %d\n", __func__,
+			data, length, tx_desc->txBase, tx_desc->txToSend);
+
+	bd = tx_desc->txBase + tx_desc->txToSend;
+
+	/* check queue-full condition */
+	if (bd->ctrl & BD_CTRL_DESC_EN) {
+		printf("Tx queue full\n");
+		return -1;
+	}
+
+	/* PFE checks for min pkt size */
+	if (length < MIN_PKT_SIZE) {
+		length = MIN_PKT_SIZE;
+	}
+
+	tx_buf_va = (u8 *)DDR_PHYS_TO_VIRT(bd->data);
+	dprint("%s: tx_buf_va: %p, tx_buf_pa: %08x\n", __func__, tx_buf_va, bd->data);
+
+	/* Fill the gemac/phy port number to send this packet out */
+	memset(&hif_header, 0 ,  sizeof(struct hif_header_s));
+	hif_header.port_no = phy_port;
+
+	memcpy(tx_buf_va, (u8 *)&hif_header, sizeof(struct hif_header_s));
+	memcpy(tx_buf_va + sizeof(struct hif_header_s), data, length);
+	length += sizeof(struct hif_header_s);
+
+#if 0
+	{
+		int i;
+		unsigned char *p = (unsigned char *)tx_buf_va;
+		for(i=0; i < length; i++) {
+			if (!(i % 16)) printf("\n");
+			printf("%02x ", p[i]);
+		}
+	}
+#endif
+
+	dprint("before0: Tx Done, status: %08x, ctrl: %08x\n", bd->status, bd->ctrl);
+
+	/* fill the tx desc */
+	ctrl_word = (u32)(BD_CTRL_DESC_EN | BD_CTRL_LIFM | (length & 0xFFFF));
+	bd->ctrl = ctrl_word;
+	bd->status = 0;
+
+	/* NOTE: This code can be removed after verification */
+#if 1 //SRAM_RETENTION_BUG
+	ctrl_word = 0;
+	bd->status = 0xF0;
+	ctrl_word = bd->ctrl;
+	//printf("0: contrl word: %08x\n", ctrl_word);
+#endif
+
+	/* Indicate Tx DMA to start fetching the Tx Descriptor,
+    	 * set START_STOBE */
+	//writel((readl(HIF_TX_CTRL) | HIF_TX_BDP_CH_START_WSTB), HIF_TX_CTRL);
+	//writel((readl(HIF_TX_CTRL) | (HIF_TX_DMA_EN | HIF_TX_BDP_CH_START_WSTB)), HIF_TX_CTRL);
+	writel((HIF_CTRL_DMA_EN | HIF_CTRL_BDP_CH_START_WSTB), HIF_TX_CTRL);
+
+	udelay(100);
+
+	return tx_desc->txToSend;
+}
+
+/** HIF to check the Tx done
+ *  This function will chceck the tx done indication of the current txToSend locations
+ *  if success, moves the txToSend to next location.
+ *
+ * @return -1 if TX ownership bit is not cleared by hw.
+			  else on success (tx done copletion) returns zero.
+ */
+int pfe_tx_done(void)
+{
+	struct tx_desc_s *tx_desc = g_tx_desc;
+	struct bufDesc *bd;
+	volatile u32 ctrl_word;
+
+	dprint("%s:txBase: %p, txToSend: %d\n", __func__, tx_desc->txBase, tx_desc->txToSend);
+
+	bd = tx_desc->txBase + tx_desc->txToSend;
+
+	/* check queue-full condition */
+	ctrl_word = bd->ctrl;
+	if (ctrl_word & BD_CTRL_DESC_EN)
+		return -1;
+
+	/* reset the control field */
+	bd->ctrl = 0;
+	//bd->data = (u32)NULL;
+	bd->status = 0;
+
+	dprint("Tx Done : status: %08x, ctrl: %08x\n", bd->status, bd->ctrl);
+
+	/* increment the txtosend index to next location */
+	tx_desc->txToSend = (tx_desc->txToSend + 1) & (tx_desc->txRingSize - 1);
+
+	dprint("Tx next pkt location: %d\n", tx_desc->txToSend);
+
+	return 0;
+}
+
+/** GEMAC initialization
+ * Initializes the GEMAC registers.
+ *
+ * @param[in] gemac_base   Pointer to GEMAC reg base
+ * @param[in] mode GEMAC mode to configure (MII config)
+ * @param[in] speed GEMAC speed
+ * @param[in] duplex
+ */
+void pfe_gemac_init(void *gemac_base, u32 mode, u32 speed, u32 duplex)
+{
+	GEMAC_CFG gemac_cfg  = {
+		.mode = mode,
+		.speed = speed,
+		.duplex = duplex,
+	};
+
+	dprint("%s: gemac_base=%p\n", __func__, gemac_base);
+
+	gemac_init(gemac_base, &gemac_cfg);
+
+	//gemac_set_loop(gemac_base, LB_NONE);
+	//gemac_disable_copy_all(gemac_base);
+	//gemac_disable_rx_checksum_offload(gemac_base);
+
+	gemac_allow_broadcast(gemac_base);
+	gemac_disable_unicast(gemac_base); /* unicast hash disabled  */
+	gemac_disable_multicast(gemac_base); /* multicast hash disabled */
+	gemac_disable_fcs_rx(gemac_base);
+	gemac_disable_1536_rx(gemac_base);
+	gemac_enable_pause_rx(gemac_base);
+	gemac_enable_rx_checksum_offload(gemac_base);
+}
+
+/** Helper function to dump Rx descriptors.
+ */
+void hif_rx_desc_dump(void)
+{
+	struct bufDesc *bd_va;
+	int i;
+	struct rx_desc_s *rx_desc;
+
+	if (g_rx_desc == NULL) {
+		printf("%s: HIF Rx desc no init \n", __func__);
+		return;
+	}
+
+	rx_desc = g_rx_desc;
+	bd_va = rx_desc->rxBase;
+
+	printf("HIF rx desc: base_va: %p, base_pa: %08x\n", rx_desc->rxBase, rx_desc->rxBase_pa);
+	for (i=0; i < rx_desc->rxRingSize; i++) {
+//		printf("status: %08x, ctrl: %08x, data: %08x, next: %p\n",
+//			bd_va->status, bd_va->ctrl, bd_va->data, bd_va->next);
+		bd_va++;
+	}
+}
+
+/** HIF Rx Desc initialization function.
+ */
+static int hif_rx_desc_init(struct pfe *pfe)
+{
+	u32 ctrl;
+	struct bufDesc *bd_va;
+	struct bufDesc *bd_pa;
+	struct rx_desc_s *rx_desc;
+	u32 rx_buf_va;
+	u32 rx_buf_pa;
+	int i;
+
+	/* sanity check */
+	if (g_rx_desc) {
+		printf("%s: HIF Rx desc re-init request\n", __func__);
+		return 0;
+	}
+
+	rx_desc = (struct rx_desc_s *)malloc(sizeof(struct rx_desc_s));
+	if (rx_desc == NULL) {
+		printf("%s:%d:Memory allocation failure\n", __func__, __LINE__);
+		return -1;
+	}
+	memset(rx_desc, 0 , sizeof(struct rx_desc_s));
+
+	/* init: Rx ring buffer */
+	rx_desc->rxRingSize = HIF_RX_DESC_NT;
+
+	/* NOTE: must be 64bit aligned  */
+	bd_va = (struct bufDesc *)(pfe->ddr_baseaddr + RX_BD_BASEADDR);
+	bd_pa = (struct bufDesc *)(pfe->ddr_phys_baseaddr + RX_BD_BASEADDR);
+
+	rx_desc->rxBase = bd_va;
+	rx_desc->rxBase_pa = (unsigned long)bd_pa;
+
+	rx_buf_va = (u32)(pfe->ddr_baseaddr + HIF_RX_PKT_DDR_BASEADDR);
+	rx_buf_pa = pfe->ddr_phys_baseaddr + HIF_RX_PKT_DDR_BASEADDR;
+
+
+	dprint("%s: Rx desc base: %p, base_pa: %08x, desc_count: %d\n",
+		__func__, rx_desc->rxBase, rx_desc->rxBase_pa, rx_desc->rxRingSize);
+
+	memset(bd_va, 0, sizeof(struct bufDesc) * rx_desc->rxRingSize);
+
+	ctrl = (MAX_FRAME_SIZE | BD_CTRL_DESC_EN | BD_CTRL_DIR | BD_CTRL_LIFM);
+	for (i=0; i < rx_desc->rxRingSize; i++) {
+		bd_va->next = bd_pa + 1;
+		bd_va->ctrl = ctrl;
+		bd_va->data = rx_buf_pa + (i * MAX_FRAME_SIZE);
+//		printf("status: %08x, ctrl: %08x, data: %08x, next: %p\n",
+//			bd_va->status, bd_va->ctrl, bd_va->data, bd_va->next);
+		bd_va++;
+		bd_pa++;
+	}
+	--bd_va;
+	bd_va->next = (struct bufDesc *)rx_desc->rxBase_pa;
+
+	/* !!! This is a redundent information for h/w as we are also
+		maintaining next address in the buffer descriptor
+		Posedge: reference code does not using this bit to go back to base address */
+	//bd->ctrl |= BD_CTRL_LAST_BD;
+
+	writel(rx_desc->rxBase_pa, HIF_RX_BDP_ADDR);
+	writel((readl(HIF_RX_CTRL) | HIF_CTRL_BDP_CH_START_WSTB), HIF_RX_CTRL);
+
+	g_rx_desc = rx_desc;
+
+	return 0;
+}
+
+/** Helper function to dump Tx Descriptors.
+ */
+void hif_tx_desc_dump(void)
+{
+	struct tx_desc_s *tx_desc;
+	int i;
+	struct bufDesc *bd_va;
+
+	if (g_tx_desc == NULL) {
+		printf("%s: HIF Tx desc no init \n", __func__);
+		return;
+	}
+
+	tx_desc = g_tx_desc;
+	bd_va = tx_desc->txBase;
+
+	printf("HIF tx desc: base_va: %p, base_pa: %08x\n", tx_desc->txBase, tx_desc->txBase_pa);
+	for (i=0; i < tx_desc->txRingSize; i++) {
+//		printf("status: %08x, ctrl: %08x, data: %08x, next: %p\n",
+//			bd_va->status, bd_va->ctrl, bd_va->data, bd_va->next);
+		bd_va++;
+	}
+}
+
+/** HIF Tx descriptor initialization function.
+ */
+static int hif_tx_desc_init(struct pfe *pfe)
+{
+	struct bufDesc *bd_va;
+	struct bufDesc *bd_pa;
+	int i;
+	struct tx_desc_s *tx_desc;
+	u32 tx_buf_pa;
+
+	/* sanity check */
+	if (g_tx_desc) {
+		printf("%s: HIF Tx desc re-init request\n", __func__);
+		return 0;
+	}
+
+	tx_desc = (struct tx_desc_s *)malloc(sizeof(struct tx_desc_s));
+	if (tx_desc == NULL) {
+		printf("%s:%d:Memory allocation failure\n", __func__, __LINE__);
+		return -1;
+	}
+	memset(tx_desc, 0 , sizeof(struct tx_desc_s));
+
+	/* init: Tx ring buffer */
+	tx_desc->txRingSize = HIF_TX_DESC_NT;
+	/* NOTE: must be 64bit aligned  */
+	bd_va = (struct bufDesc *)(pfe->ddr_baseaddr + TX_BD_BASEADDR);
+	bd_pa = (struct bufDesc *)(pfe->ddr_phys_baseaddr + TX_BD_BASEADDR);
+
+	tx_desc->txBase_pa = (unsigned long)bd_pa;
+	tx_desc->txBase = bd_va;
+
+	dprint("%s: Tx desc_base: %p, base_pa: %08x, desc_count: %d\n",
+			__func__, tx_desc->txBase, tx_desc->txBase_pa, tx_desc->txRingSize);
+
+	memset(bd_va, 0, sizeof(struct bufDesc) * tx_desc->txRingSize);
+
+	tx_buf_pa = pfe->ddr_phys_baseaddr + HIF_TX_PKT_DDR_BASEADDR;
+
+	for (i=0; i < tx_desc->txRingSize; i++) {
+		bd_va->next = bd_pa + 1;
+		bd_va->data = tx_buf_pa + (i * MAX_FRAME_SIZE);
+//		printf("status: %08x, ctrl: %08x, data: %08x, next: %p\n",
+//			bd_va->status, bd_va->ctrl, bd_va->data, bd_va->next);
+		bd_va++;
+		bd_pa++;
+	}
+	--bd_va;
+	bd_va->next = (struct bufDesc *)tx_desc->txBase_pa;
+//	printf("status: %08x, ctrl: %08x, data: %08x, next: %p\n",
+//		bd_va->status, bd_va->ctrl, bd_va->data, bd_va->next);
+
+	/* !!! This is a redundent information for h/w as we are also
+		maintaining next address in the buffer descriptor,
+		Posedge: reference code does not using LAST_BD for moving back to base address */
+	//bd->ctrl |= BD_CTRL_LAST_BD;
+
+	writel(tx_desc->txBase_pa, HIF_TX_BDP_ADDR);
+
+	g_tx_desc = tx_desc;
+
+	return 0;
+}
+
+/** PFE/Class initialization.
+ */
+static void pfe_class_init(struct pfe *pfe)
+{
+	CLASS_CFG class_cfg = {
+		.route_table_baseaddr = pfe->ddr_phys_baseaddr + ROUTE_TABLE_BASEADDR,
+		.route_table_hash_bits = ROUTE_TABLE_HASH_BITS,
+	};
+
+	class_init(&class_cfg);
+	printf("class init complete\n");
+}
+
+/** PFE/TMU initialization.
+ */
+static void pfe_tmu_init(struct pfe *pfe)
+{
+	TMU_CFG tmu_cfg = {
+		.llm_base_addr = pfe->ddr_phys_baseaddr + TMU_LLM_BASEADDR,
+		.llm_queue_len = TMU_LLM_QUEUE_LEN,
+	};
+
+	tmu_init(&tmu_cfg);
+	printf("tmu init complete\n");
+}
+
+/** PFE/BMU (both BMU1 & BMU2) initialization.
+ */
+static void pfe_bmu_init(struct pfe *pfe)
+{
+	BMU_CFG bmu1_cfg = {
+		.baseaddr = CBUS_VIRT_TO_PFE(LMEM_BASE_ADDR + BMU1_LMEM_BASEADDR),
+		.count = BMU1_BUF_COUNT,
+		.size = BMU1_BUF_SIZE,
+	};
+
+	BMU_CFG bmu2_cfg = {
+		.baseaddr = pfe->ddr_phys_baseaddr + BMU2_DDR_BASEADDR,
+		.count = BMU2_BUF_COUNT,
+		.size = BMU2_BUF_SIZE,
+	};
+
+	bmu_init(BMU1_BASE_ADDR, &bmu1_cfg);
+	printf("bmu1 init: done\n");
+
+	bmu_init(BMU2_BASE_ADDR, &bmu2_cfg);
+	printf("bmu2 init: done\n");
+}
+
+#if !defined(CONFIG_UTIL_PE_DISABLED)
+/** PFE/Util initialization function.
+ */
+static void pfe_util_init(struct pfe *pfe)
+{
+	UTIL_CFG util_cfg = { };
+
+	util_init(&util_cfg);
+	printf("util init complete\n");
+}
+#endif
+
+/** PFE/GPI initialization function.
+ *  - egpi1, egpi2, egpi3, hgpi
+ */
+static void pfe_gpi_init(struct pfe *pfe)
+{
+	GPI_CFG egpi1_cfg = {
+		.lmem_rtry_cnt = EGPI1_LMEM_RTRY_CNT,
+		.tmlf_txthres = EGPI1_TMLF_TXTHRES,
+		.aseq_len = EGPI1_ASEQ_LEN,
+	};
+
+	GPI_CFG egpi2_cfg = {
+		.lmem_rtry_cnt = EGPI2_LMEM_RTRY_CNT,
+		.tmlf_txthres = EGPI2_TMLF_TXTHRES,
+		.aseq_len = EGPI2_ASEQ_LEN,
+	};
+
+#if 0
+	GPI_CFG egpi3_cfg = {
+		.lmem_rtry_cnt = EGPI3_LMEM_RTRY_CNT,
+		.tmlf_txthres = EGPI3_TMLF_TXTHRES,
+		.aseq_len = EGPI3_ASEQ_LEN,
+	};
+#endif
+
+	GPI_CFG hgpi_cfg = {
+		.lmem_rtry_cnt = HGPI_LMEM_RTRY_CNT,
+		.tmlf_txthres = HGPI_TMLF_TXTHRES,
+		.aseq_len = HGPI_ASEQ_LEN,
+	};
+
+	gpi_init(EGPI1_BASE_ADDR, &egpi1_cfg);
+	printf("GPI1 init complete\n");
+
+   gpi_init(EGPI2_BASE_ADDR, &egpi2_cfg);
+	printf("GPI2 init complete\n");
+
+#if 0
+   gpi_init(EGPI3_BASE_ADDR, &egpi3_cfg);
+#endif
+
+   gpi_init(HGPI_BASE_ADDR, &hgpi_cfg);
+	printf("HGPI init complete\n");
+}
+
+/** Helper function for PCI init sequence.
+ */
+void pfe_gem_enable_all(void)
+{
+	gpi_enable(EGPI1_BASE_ADDR);
+	gemac_enable(EMAC1_BASE_ADDR);
+
+	gpi_enable(EGPI2_BASE_ADDR);
+	gemac_enable(EMAC2_BASE_ADDR);
+
+#if 0
+	gpi_enable(EGPI3_BASE_ADDR);
+	gemac_enable(EMAC3_BASE_ADDR);
+#endif
+}
+
+/** PFE/HIF initialization function.
+ */
+static void pfe_hif_init(struct pfe *pfe)
+{
+	hif_tx_disable();
+	hif_rx_disable();
+
+	hif_tx_desc_init(pfe);
+	hif_rx_desc_init(pfe);
+
+	hif_init();
+
+	hif_tx_enable();
+	hif_rx_enable();
+
+	hif_rx_desc_dump();
+	hif_tx_desc_dump();
+
+	printf("HIF init complete\n");
+}
+
+/** PFE initialization
+ * - Firmware loading (CLASS-PE and TMU-PE)
+ * - BMU1 and BMU2 init
+ * - GEMAC init
+ * - GPI init
+ * - CLASS-PE init
+ * - TMU-PE init
+ * - HIF tx and rx descriptors init
+ *
+ * @param[in]	edev	Pointer to eth device structure.
+ *
+ * @return 0, on success.
+ */
+static int pfe_hw_init(struct pfe *pfe)
+{
+
+	dprint("%s: start \n", __func__);
+
+	pfe_class_init(pfe);
+
+	pfe_tmu_init(pfe);
+
+	pfe_bmu_init(pfe);
+
+#if !defined(CONFIG_UTIL_PE_DISABLED)
+	pfe_util_init(pfe);
+#endif
+
+	pfe_gpi_init(pfe);
+
+	pfe_hif_init(pfe);
+
+	bmu_enable(BMU1_BASE_ADDR);
+	printf("bmu1 enabled\n");
+
+	bmu_enable(BMU2_BASE_ADDR);
+	printf("bmu2 enabled\n");
+
+	printf("%s: done\n", __func__);
+
+	/* NOTE: Load PE specific data (if any) */
+
+	return 0;
+}
+
+
+/** PFE probe function.
+ * - Initializes pfe_lib
+ * - pfe hw init
+ * - fw loading and enables PEs
+ * - should be executed once.
+ *
+ * @param[in] pfe  Pointer the pfe control block
+ */
+int pfe_probe(struct pfe *pfe)
+{
+	static int init_done = 0;
+
+	if (init_done)
+		return 0;
+
+	printf("cbus_baseaddr: %p, ddr_baseaddr: %p, ddr_phys_baseaddr: %08x\n",
+	             pfe->cbus_baseaddr, pfe->ddr_baseaddr, (u32)pfe->ddr_phys_baseaddr);
+
+	pfe_lib_init(pfe->cbus_baseaddr, pfe->ddr_baseaddr, pfe->ddr_phys_baseaddr);
+
+
+	pfe_hw_init(pfe);
+
+	/* Load the class,TM, Util fw
+    * by now pfe is,
+    * - out of reset + disabled + configured,
+    * Fw loading should be done after pfe_hw_init() */
+	pfe_firmware_init();
+
+	init_done = 1;
+
+	return 0;
+}
+
+
+/** PFE remove function
+ *  - stopes PEs
+ *  - frees tx/rx descriptor resources
+ *  - should be called once.
+ *
+ * @param[in] pfe Pointer to pfe control block.
+ */
+int pfe_remove(struct pfe *pfe)
+{
+	if (g_tx_desc) {
+		free(g_tx_desc);
+	}
+
+	if (g_rx_desc) {
+		free(g_rx_desc);
+	}
+
+	pfe_firmware_exit();
+
+	return 0;
+}
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/net/c2000_eth/pfe_driver.h u-boot-2013.01.new/drivers/net/c2000_eth/pfe_driver.h
--- u-boot-2013.01/drivers/net/c2000_eth/pfe_driver.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/net/c2000_eth/pfe_driver.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,139 @@
+/*
+ *  (C) Copyright 2011
+ *  Author : Mindspeed Technologes
+ *  
+ *  See file CREDITS for list of people who contributed to this
+ *  project.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License as
+ *  published by the Free Software Foundation; either version 2 of
+ *  the License, or (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA 02111-1307 USA
+ * */
+
+#ifndef __PFE_DRIVER_H__
+#define __PFE_DRIVER_H__
+
+#include "hal.h"
+
+#include "pfe/pfe.h"
+#include "pfe/cbus.h"
+#include "pfe/cbus/bmu.h"
+
+
+
+typedef struct bufDesc {
+		  u32 ctrl;
+		  u32 status;
+		  u32 data;
+		  struct bufDesc *next;
+}bufDesc_t;
+
+#if defined(CONFIG_PLATFORM_PCI)
+#define HIF_RX_DESC_NT		4
+#define	HIF_TX_DESC_NT		4
+#else
+#define HIF_RX_DESC_NT		64
+#define	HIF_TX_DESC_NT		64
+#endif
+#define RX_BD_BASEADDR		(HIF_DESC_BASEADDR)
+#define TX_BD_BASEADDR		(HIF_DESC_BASEADDR + HIF_TX_DESC_SIZE)
+
+#define MIN_PKT_SIZE   		56
+#define MAX_FRAME_SIZE     2048
+
+
+typedef struct hif_header_s {
+	u8	port_no; //Carries input port no for host rx packets and output port no for tx pkts
+	u8 reserved0;
+	u32 reserved2;
+} __attribute__((packed)) hif_header_t;
+
+
+typedef struct rx_desc_s {
+	struct bufDesc *rxBase;
+	unsigned int rxBase_pa;
+	int rxToRead;
+	int rxRingSize;
+}rx_desc_t;
+
+typedef struct tx_desc_s {
+	struct bufDesc *txBase;
+	unsigned int txBase_pa;
+	int txToSend;
+	int txRingSize;
+}tx_desc_t;
+
+
+/* The set of statistics registers implemented in the Cadence MAC.
+ * The statistics registers implemented are a subset of all the statistics
+ * available, but contains all the compulsory ones.
+ */
+typedef struct gem_stats{
+    u32 octets_tx_bot;      /* Lower 32-bits for number of octets tx'd */
+    u32 octets_tx_top;      /* Upper 16-bits for number of octets tx'd */
+    u32 frames_tx;          /* Number of frames transmitted OK */
+    u32 broadcast_tx;       /* Number of broadcast frames transmitted */
+    u32 multicast_tx;       /* Number of multicast frames transmitted */
+    u32 pause_tx;           /* Number of pause frames transmitted. */
+    u32 frame64_tx;         /* Number of 64byte frames transmitted */
+    u32 frame65_127_tx;     /* Number of 65-127 byte frames transmitted */
+    u32 frame128_255_tx;    /* Number of 128-255 byte frames transmitted */
+    u32 frame256_511_tx;    /* Number of 256-511 byte frames transmitted */
+    u32 frame512_1023_tx;   /* Number of 512-1023 byte frames transmitted */
+    u32 frame1024_1518_tx;  /* Number of 1024-1518 byte frames transmitted*/
+    u32 frame1519_tx;       /* Number of frames greater than 1518 bytes tx*/
+    u32 tx_urun;            /* Transmit underrun errors due to DMA */
+    u32 single_col;         /* Number of single collision frames */
+    u32 multi_col;          /* Number of multi collision frames */
+    u32 excess_col;         /* Number of excessive collision frames. */
+    u32 late_col;           /* Collisions occuring after slot time */
+    u32 def_tx;             /* Frames deferred due to crs */
+    u32 crs_errors;         /* Errors caused by crs not being asserted. */
+    u32 octets_rx_bot;      /* Lower 32-bits for number of octets rx'd */
+    u32 octets_rx_top;      /* Upper 16-bits for number of octets rx'd */
+    u32 frames_rx;          /* Number of frames received OK */
+    u32 broadcast_rx;       /* Number of broadcast frames received */
+    u32 multicast_rx;       /* Number of multicast frames received */
+    u32 pause_rx;           /* Number of pause frames received. */
+    u32 frame64_rx;         /* Number of 64byte frames received */
+    u32 frame65_127_rx;     /* Number of 65-127 byte frames received */
+    u32 frame128_255_rx;    /* Number of 128-255 byte frames received */
+    u32 frame256_511_rx;    /* Number of 256-511 byte frames received */
+    u32 frame512_1023_rx;   /* Number of 512-1023 byte frames received */
+    u32 frame1024_1518_rx;  /* Number of 1024-1518 byte frames received*/
+    u32 frame1519_rx;       /* Number of frames greater than 1518 bytes rx*/
+    u32 usize_frames;       /* Frames received less than min of 64 bytes */
+    u32 excess_length;      /* Number of excessive length frames rx */
+    u32 jabbers;            /* Excessive length + crc or align errors. */
+    u32 fcs_errors;         /* Number of frames received with crc errors */
+    u32 length_check_errors;/* Number of frames with incorrect length */
+    u32 rx_symbol_errors;   /* Number of times rx_er asserted during rx */
+    u32 align_errors;       /* Frames received without integer no. bytes */
+    u32 rx_res_errors;      /* Number of times buffers ran out during rx */
+    u32 rx_orun;            /* Receive overrun errors due to DMA */
+    u32 ip_cksum;           /* IP header checksum errors */
+    u32 tcp_cksum;           /* TCP checksum errors */
+    u32 udp_cksum;           /* UDP checksum errors */
+} volatile GEM_STATS;
+
+
+int pfe_send(int phy_port, void *data, int length);
+int pfe_recv(unsigned int *pkt_ptr, int *phy_port);
+int pfe_tx_done(void);
+void pfe_gem_enable_all(void);
+void pfe_gemac_init(void *gemac_base, u32 mode, u32 speed, u32 duplex);
+
+
+#endif
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/net/c2000_eth/pfe_firmware.c u-boot-2013.01.new/drivers/net/c2000_eth/pfe_firmware.c
--- u-boot-2013.01/drivers/net/c2000_eth/pfe_firmware.c	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/net/c2000_eth/pfe_firmware.c	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,173 @@
+
+
+/** @file
+ *  Contains all the functions to handle parsing and loading of PE firmware files.
+ */
+
+#include "hal.h"
+#include "pfe_firmware.h"
+#include "pfe/pfe.h"
+
+
+/* CLASS-PE ELF file content */
+unsigned char class_fw_data[] __attribute__((aligned(sizeof(int)))) = {
+#include CLASS_FIRMWARE_FILENAME
+};
+
+/* TMU-PE ELF file content */
+unsigned char tmu_fw_data[] __attribute__((aligned(sizeof(int)))) = {
+#include TMU_FIRMWARE_FILENAME
+};
+
+#if !defined(CONFIG_UTIL_PE_DISABLED)
+unsigned char util_fw_data[] = {
+#include UTIL_FIRMWARE_FILENAME
+};
+#endif
+
+/** PFE elf firmware loader.
+* Loads an elf firmware image into a list of PE's (specified using a bitmask)
+*
+* @param pe_mask	Mask of PE id's to load firmware to
+* @param fw		Pointer to the firmware image
+*
+* @return		0 on sucess, a negative value on error
+*
+*/
+int pfe_load_elf(int pe_mask, const struct firmware *fw)
+{
+	Elf32_Ehdr *elf_hdr = (Elf32_Ehdr *)fw->data;
+	Elf32_Half sections = be16_to_cpu(elf_hdr->e_shnum);
+	Elf32_Shdr *shdr = (Elf32_Shdr *) (fw->data + be32_to_cpu(elf_hdr->e_shoff));
+	int id, section;
+	int rc;
+
+	printf("%s\n", __func__);
+
+	printf("%s no of sections: %d\n", __func__, sections);
+
+	/* Some sanity checks */
+	if (strncmp(&elf_hdr->e_ident[EI_MAG0], ELFMAG, SELFMAG))
+	{
+		printf("%s: incorrect elf magic number\n", __func__);
+		return -1;
+	}
+
+	if (elf_hdr->e_ident[EI_CLASS] != ELFCLASS32)
+	{
+		printf("%s: incorrect elf class(%x)\n", __func__, elf_hdr->e_ident[EI_CLASS]);
+		return -1;
+	}
+
+	if (elf_hdr->e_ident[EI_DATA] != ELFDATA2MSB)
+	{
+		printf("%s: incorrect elf data(%x)\n", __func__, elf_hdr->e_ident[EI_DATA]);
+		return -1;
+	}
+
+	if (be16_to_cpu(elf_hdr->e_type) != ET_EXEC)
+	{
+		printf("%s: incorrect elf file type(%x)\n", __func__, be16_to_cpu(elf_hdr->e_type));
+		return -1;
+	}	
+
+	for (section = 0; section < sections; section++, shdr++)
+	{
+		if (!(be32_to_cpu(shdr->sh_flags) & (SHF_WRITE | SHF_ALLOC | SHF_EXECINSTR)))
+                        continue;
+		
+		for (id = 0; id < MAX_PE; id++)
+			if (pe_mask & (1 << id))
+			{
+				rc = pe_load_elf_section(id, fw->data, shdr);
+				if (rc < 0)
+					goto err;
+			}
+	}
+
+	return 0;
+
+err:
+	return rc;
+}
+
+/** PFE firmware initialization.
+* Loads different firmware files from filesystem.
+* Initializes PE IMEM/DMEM and UTIL-PE DDR
+* Initializes control path symbol addresses (by looking them up in the elf firmware files
+* Takes PE's out of reset
+*
+* @return	0 on sucess, a negative value on error
+*
+*/
+int pfe_firmware_init(void)
+{
+	struct firmware class_fw, tmu_fw;
+#if !defined(CONFIG_UTIL_PE_DISABLED)
+ 	struct firmware util_fw;
+#endif
+	int rc = 0;
+
+	printf("%s\n", __func__);
+
+	class_fw.data = class_fw_data;
+	tmu_fw.data = tmu_fw_data;
+#if !defined(CONFIG_UTIL_PE_DISABLED)
+	util_fw.data = util_fw_data;
+#endif
+	
+	rc = pfe_load_elf(CLASS_MASK, &class_fw);
+	if (rc < 0) {
+		printf("%s: class firmware load failed\n", __func__);
+		goto err3;
+	}
+
+	printf("%s: class firmware loaded\n", __func__);
+
+	rc = pfe_load_elf(TMU_MASK, &tmu_fw);
+	if (rc < 0) {
+		printf("%s: tmu firmware load failed\n", __func__);
+		goto err3;
+	}
+
+	printf("%s: tmu firmware loaded\n", __func__);
+
+#if !defined(CONFIG_UTIL_PE_DISABLED)
+	rc = pfe_load_elf(UTIL_MASK, &util_fw);
+	if (rc < 0) {
+		printf("%s: util firmware load failed\n", __func__);
+		goto err3;
+	}
+
+	printf("%s: util firmware loaded\n", __func__);
+
+	util_enable();
+#endif
+
+	tmu_enable(0xf);
+	class_enable();
+
+	gpi_enable(HGPI_BASE_ADDR);
+
+
+err3:
+	return rc;
+}
+
+/** PFE firmware cleanup
+* Puts PE's in reset
+*
+*
+*/
+void pfe_firmware_exit(void)
+{
+	printf("%s\n", __func__);
+
+	class_disable();
+	tmu_disable(0xf);
+#if !defined(CONFIG_UTIL_PE_DISABLED)
+	util_disable();
+#endif
+	hif_tx_disable();
+	hif_rx_disable();
+}
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/net/c2000_eth/pfe_firmware.h u-boot-2013.01.new/drivers/net/c2000_eth/pfe_firmware.h
--- u-boot-2013.01/drivers/net/c2000_eth/pfe_firmware.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/net/c2000_eth/pfe_firmware.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,20 @@
+
+
+/** @file
+ *  Contains all the defines to handle parsing and loading of PE firmware files.
+ */
+
+#ifndef __PFE_FIRMWARE_H__
+#define __PFE_FIRMWARE_H__
+
+
+#define CLASS_FIRMWARE_FILENAME		"class_sbl_c2000_elf.fw"
+#define TMU_FIRMWARE_FILENAME		   "tmu_sbl_c2000_elf.fw"
+#define UTIL_FIRMWARE_FILENAME		"util_c2000_elf.fw" 
+
+
+int pfe_firmware_init(void);
+void pfe_firmware_exit(void);
+
+
+#endif
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/net/c2000_eth/pfe_mod.h u-boot-2013.01.new/drivers/net/c2000_eth/pfe_mod.h
--- u-boot-2013.01/drivers/net/c2000_eth/pfe_mod.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/net/c2000_eth/pfe_mod.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,140 @@
+/*
+ *  (C) Copyright 2011
+ *  Author : Mindspeed Technologes
+ *  
+ *  See file CREDITS for list of people who contributed to this
+ *  project.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License as
+ *  published by the Free Software Foundation; either version 2 of
+ *  the License, or (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA 02111-1307 USA
+ * */
+
+
+#ifndef _PFE_MOD_H_
+#define _PFE_MOD_H_
+
+#include <linux/device.h>
+
+#include "pfe/pfe.h"
+#include "pfe/cbus.h"
+#include "pfe/cbus/bmu.h"
+
+#include "pfe_driver.h"
+
+struct pfe;
+
+
+struct pfe {
+	unsigned long ddr_phys_baseaddr;
+	void *ddr_baseaddr;
+	void *cbus_baseaddr;
+	void *apb_baseaddr;
+	void *iram_baseaddr;
+	int hif_irq;
+	struct device *dev;
+	struct pci_dev *pdev;
+
+#if 0
+	struct pfe_ctrl ctrl;
+	struct pfe_hif hif;
+	struct pfe_eth eth;
+#endif
+};
+
+extern struct pfe *pfe;
+
+int pfe_probe(struct pfe *pfe);
+int pfe_remove(struct pfe *pfe);
+
+#ifndef SZ_1K
+#define SZ_1K 1024
+#endif
+
+#ifndef SZ_1M
+#define SZ_1M (1024 * 1024)
+#endif
+
+/* DDR Mapping */
+#if !defined(CONFIG_PLATFORM_PCI)
+#define UTIL_CODE_BASEADDR	0
+#define UTIL_CODE_SIZE		(128 * SZ_1K)
+#define UTIL_DDR_DATA_BASEADDR	(UTIL_CODE_BASEADDR + UTIL_CODE_SIZE)
+#define UTIL_DDR_DATA_SIZE	(64 * SZ_1K)
+#define CLASS_DDR_DATA_BASEADDR	(UTIL_DDR_DATA_BASEADDR + UTIL_DDR_DATA_SIZE)
+#define CLASS_DDR_DATA_SIZE	(32 * SZ_1K)
+#define TMU_DDR_DATA_BASEADDR	(CLASS_DDR_DATA_BASEADDR + CLASS_DDR_DATA_SIZE)
+#define TMU_DDR_DATA_SIZE	(32 * SZ_1K)
+#define ROUTE_TABLE_BASEADDR	(TMU_DDR_DATA_BASEADDR + TMU_DDR_DATA_SIZE)
+#define ROUTE_TABLE_HASH_BITS	15	/**< 32K entries */
+#define ROUTE_TABLE_SIZE	((1 << ROUTE_TABLE_HASH_BITS) * CLASS_ROUTE_SIZE)
+#define BMU2_DDR_BASEADDR	(ROUTE_TABLE_BASEADDR + ROUTE_TABLE_SIZE)
+#define BMU2_BUF_COUNT		(4096 - 256)			/**< This is to get a total DDR size of 12MiB */
+#define BMU2_DDR_SIZE		(DDR_BUF_SIZE * BMU2_BUF_COUNT)
+#define TMU_LLM_BASEADDR	(BMU2_DDR_BASEADDR + BMU2_DDR_SIZE)
+#define TMU_LLM_QUEUE_LEN	(16 * 256)			/**< Must be power of two and at least 16 * 8 = 128 bytes */
+#define TMU_LLM_SIZE		(4 * 16 * TMU_LLM_QUEUE_LEN)	/**< (4 TMU's x 16 queues x queue_len) */
+
+#if (TMU_LLM_BASEADDR + TMU_LLM_SIZE) > 0xC00000
+#error DDR mapping above 12MiB
+#endif
+
+#else
+
+#define UTIL_CODE_BASEADDR	0
+#if defined(CONFIG_UTIL_PE_DISABLED)
+#define UTIL_CODE_SIZE		(0 * SZ_1K)
+#else
+#define UTIL_CODE_SIZE		(8 * SZ_1K)
+#endif
+#define UTIL_DDR_DATA_BASEADDR	(UTIL_CODE_BASEADDR + UTIL_CODE_SIZE)
+#define UTIL_DDR_DATA_SIZE	(0 * SZ_1K)
+#define CLASS_DDR_DATA_BASEADDR	(UTIL_DDR_DATA_BASEADDR + UTIL_DDR_DATA_SIZE)
+#define CLASS_DDR_DATA_SIZE	(0 * SZ_1K)
+#define TMU_DDR_DATA_BASEADDR	(CLASS_DDR_DATA_BASEADDR + CLASS_DDR_DATA_SIZE)
+#define TMU_DDR_DATA_SIZE	(0 * SZ_1K)
+#define ROUTE_TABLE_BASEADDR	(TMU_DDR_DATA_BASEADDR + TMU_DDR_DATA_SIZE)
+#define ROUTE_TABLE_HASH_BITS	5	/**< 32 entries */
+#define ROUTE_TABLE_SIZE	((1 << ROUTE_TABLE_HASH_BITS) * CLASS_ROUTE_SIZE)
+#define BMU2_DDR_BASEADDR	(ROUTE_TABLE_BASEADDR + ROUTE_TABLE_SIZE)
+#define BMU2_BUF_COUNT		8
+#define BMU2_DDR_SIZE		(DDR_BUF_SIZE * BMU2_BUF_COUNT)
+#define TMU_LLM_BASEADDR	(BMU2_DDR_BASEADDR + BMU2_DDR_SIZE)
+#define TMU_LLM_QUEUE_LEN	(16 * 8)			/**< Must be power of two and at least 16 * 8 = 128 bytes */
+#define TMU_LLM_SIZE		(4 * 16 * TMU_LLM_QUEUE_LEN)	/**< (4 TMU's x 16 queues x queue_len) */
+#define HIF_DESC_BASEADDR	(TMU_LLM_BASEADDR + TMU_LLM_SIZE)
+#define HIF_RX_DESC_SIZE	(16*HIF_RX_DESC_NT)
+#define HIF_TX_DESC_SIZE	(16*HIF_TX_DESC_NT)
+#define HIF_DESC_SIZE		(HIF_RX_DESC_SIZE + HIF_TX_DESC_SIZE)
+#define HIF_RX_PKT_DDR_BASEADDR	(HIF_DESC_BASEADDR + HIF_DESC_SIZE)
+#define HIF_RX_PKT_DDR_SIZE	(HIF_RX_DESC_NT * DDR_BUF_SIZE)
+#define HIF_TX_PKT_DDR_BASEADDR	(HIF_RX_PKT_DDR_BASEADDR + HIF_RX_PKT_DDR_SIZE)
+#define HIF_TX_PKT_DDR_SIZE	(HIF_TX_DESC_NT * DDR_BUF_SIZE)
+#define ROUTE_BASEADDR		(HIF_TX_PKT_DDR_BASEADDR + HIF_TX_PKT_DDR_SIZE)
+#define ROUTE_SIZE		(2 * CLASS_ROUTE_SIZE)
+
+#if (ROUTE_BASEADDR + ROUTE_SIZE) > 0x10000
+#error DDR mapping above 64KiB
+#endif
+
+#define PFE_HOST_TO_PCI(addr)	(((u32)addr)- ((u32)DDR_BASE_ADDR))
+#define PFE_PCI_TO_HOST(addr)	(((u32)addr)+ ((u32)DDR_BASE_ADDR))
+#endif
+
+/* LMEM Mapping */
+#define BMU1_LMEM_BASEADDR	0
+#define BMU1_BUF_COUNT		256
+#define BMU1_LMEM_SIZE		(LMEM_BUF_SIZE * BMU1_BUF_COUNT)
+
+#endif /* _PFE_MOD_H */
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/net/c2000_eth/pfe_proc.c u-boot-2013.01.new/drivers/net/c2000_eth/pfe_proc.c
--- u-boot-2013.01/drivers/net/c2000_eth/pfe_proc.c	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/net/c2000_eth/pfe_proc.c	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,203 @@
+/*
+ *  (C) Copyright 2011
+ *  Author : Mindspeed Technologes
+ *  
+ *  See file CREDITS for list of people who contributed to this
+ *  project.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License as
+ *  published by the Free Software Foundation; either version 2 of
+ *  the License, or (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA 02111-1307 USA
+ * */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/proc_fs.h>
+#include <linux/fcntl.h>
+#include <linux/seq_file.h>
+#include <asm/uaccess.h>
+
+
+
+static struct proc_dir_entry *pdir = NULL;
+static struct proc_dir_entry *unit = NULL;
+static struct proc_dir_entry *pkt = NULL;
+static struct proc_dir_entry *dump = NULL;
+
+
+extern void pfe_class_read(int id);
+
+ssize_t pfe_unit_read(struct file *file, char __user *buf,
+			size_t count, loff_t *ppos)
+{
+	printk(KERN_INFO "%s:\n", __func__);
+	return 0;
+}
+
+static unsigned char lbuf[20];
+ssize_t pfe_unit_write(struct file *file, char __user *buf,
+			size_t count, loff_t *ppos)
+{
+	int id = -1;
+
+	printk(KERN_INFO "%s:\n", __func__);
+
+	if (copy_from_user(lbuf, buf,count))
+		return -ENOMEM;
+	lbuf[count] = 0;
+
+	id = simple_strtoul(lbuf, NULL, 0);
+	printk(KERN_INFO "id: %d\n", id);
+
+	if ((id >= 0) || (id < 4))
+		pfe_class_read(id);
+	
+	return count;
+}
+
+extern void pfe_print_tx_status(void);
+ssize_t pfe_pkt_read(struct file *file, char __user *buf,
+			size_t count, loff_t *ppos)
+{
+	printk(KERN_INFO "%s:\n", __func__);
+	pfe_print_tx_status();
+	return 0;
+}
+
+extern void pfe_send_pkt(int len);
+
+ssize_t pfe_pkt_write(struct file *file, char __user *buf,
+			size_t count, loff_t *ppos)
+{
+	int len = -1;
+
+	printk(KERN_INFO "%s:\n", __func__);
+
+	if (copy_from_user(lbuf, buf,count))
+		return -ENOMEM;
+	lbuf[count] = 0;
+
+	len = simple_strtoul(lbuf, NULL, 0);
+	printk(KERN_INFO "len: %d\n", len);
+
+	pfe_send_pkt(len);
+
+	return count;
+}
+//============================================================
+extern void	hif_tx_desc_dump(void);
+extern void	hif_rx_desc_dump(void);
+extern void class_pe_dump(void);
+
+ssize_t pfe_dump_read(struct file *file, char __user *buf,
+			size_t count, loff_t *ppos)
+{
+	printk(KERN_INFO "%s:\n", __func__);
+	hif_tx_desc_dump();
+	hif_rx_desc_dump();
+   class_pe_dump();
+	return 0;
+}
+
+extern void class_dmem_dump(int id);
+ssize_t pfe_dump_write(struct file *file, char __user *buf,
+			size_t count, loff_t *ppos)
+{
+	int id;
+	printk(KERN_INFO "%s:\n", __func__);
+
+	if (copy_from_user(lbuf, buf,count))
+		return -ENOMEM;
+	lbuf[count] = 0;
+
+	id = simple_strtoul(lbuf, NULL, 0);
+	printk(KERN_INFO "id: %d\n", id);
+
+	class_dmem_dump(id);
+
+	return count;
+}
+//============================================================
+
+static struct file_operations pfe_unit_fops = {
+	.owner = THIS_MODULE,
+	.read = pfe_unit_read,
+	.write = pfe_unit_write,
+};
+
+static struct file_operations pfe_pkt_fops = {
+	.owner = THIS_MODULE,
+	.read = pfe_pkt_read,
+	.write = pfe_pkt_write,
+};
+
+static struct file_operations pfe_dump_fops = {
+	.owner = THIS_MODULE,
+	.read = pfe_dump_read,
+	.write = pfe_dump_write,
+};
+
+void pfe_proc_init(void)
+{
+	pdir = proc_mkdir("pfe", NULL);	
+	if (pdir == NULL) {
+		printk(KERN_ERR "%s: Unable to create proc dir entry\n", __func__);
+		return;
+	}
+
+	unit = create_proc_entry("unit", S_IFREG, pdir);
+	if (unit == NULL) {
+		printk(KERN_ERR "%s: Unable to create proc entry: unit\n", __func__);
+		remove_proc_entry("pfe", NULL);
+		return;
+	}
+	unit->proc_fops = &pfe_unit_fops;
+
+	pkt = create_proc_entry("pkt", S_IFREG, pdir);
+	if (unit == NULL) {
+		printk(KERN_ERR "%s: Unable to create proc entry: pkt\n", __func__);
+		remove_proc_entry("unit", pdir);
+		remove_proc_entry("pfe", NULL);
+		return;
+	}
+	pkt->proc_fops = &pfe_pkt_fops;
+
+	dump = create_proc_entry("dump", S_IFREG, pdir);
+	if (dump == NULL) {
+		printk(KERN_ERR "%s: Unable to create proc entry: pkt\n", __func__);
+		remove_proc_entry("unit", pdir);
+		remove_proc_entry("pkt", pdir);
+		remove_proc_entry("pfe", NULL);
+		return;
+	}
+	dump->proc_fops = &pfe_dump_fops;
+
+
+	
+}
+
+void pfe_proc_exit(void)
+{
+	if (unit)
+		remove_proc_entry("unit", pdir);
+	if (pkt)
+		remove_proc_entry("pkt", pdir);
+	if (dump)
+		remove_proc_entry("dump", pdir);
+	if (pdir) 
+		remove_proc_entry("pfe", NULL);
+
+	return;
+}
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/net/c2000_eth/pfe_unit.c u-boot-2013.01.new/drivers/net/c2000_eth/pfe_unit.c
--- u-boot-2013.01/drivers/net/c2000_eth/pfe_unit.c	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/net/c2000_eth/pfe_unit.c	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,334 @@
+/*
+ *  (C) Copyright 2011
+ *  Author : Mindspeed Technologes
+ *  
+ *  See file CREDITS for list of people who contributed to this
+ *  project.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License as
+ *  published by the Free Software Foundation; either version 2 of
+ *  the License, or (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA 02111-1307 USA
+ * */
+
+
+#include <linux/delay.h>
+#include "pfe_driver.h"
+
+
+void dump_phy_reg();
+#if 0
+#define DMEM_TEST_BASE_ADDR	0x0	/* !!! For class overlaps with packets in dmem, for tmu overwrites exception vectors !!! */
+
+#define BUF_SIZE 6
+
+static u32 w[BUF_SIZE] = {0x01234567, 0x89abcdef, 0x00112233, 0x44556677, 0x8899aabb, 0xccddeeff};
+static u32 zero[BUF_SIZE] = {0, };
+static u32 r[BUF_SIZE];
+
+static void dmem_read4_write4(unsigned int id)
+{
+	pe_dmem_write(id, w[0], DMEM_TEST_BASE_ADDR, 4);
+
+	r[0] = pe_dmem_read(id, DMEM_TEST_BASE_ADDR, 4);
+
+	if (r[0] != w[0])
+		printk(KERN_ERR "PE %d: %s failed: %#x %#x\n", id, __func__, w[0], r[0]);
+	else
+		printk(KERN_INFO "PE %d: %s wr-pass: %#x %#x\n", id, __func__, w[0], r[0]);
+}
+#endif
+
+#if 0
+void pfe_unit_test(void)
+{
+	u32 i,val,j;
+
+#if 0
+	dmem_read4_write4(0);
+	dmem_read4_write4(1);
+	dmem_read4_write4(2);
+	dmem_read4_write4(3);
+
+	//dmem_read4_write4(4);
+	for(i=0; i < 4; i++) {
+		val = pe_dmem_read(0, 0x830 + (i * 4), 4);
+		printk(KERN_ERR "PE %d: loc: %d, regMask: %08x\n", 0, i, val);
+	}
+
+	val = pe_dmem_read(0, 0x840, 4);
+	printk(KERN_ERR "PE %d: %08x\n", 0, val);
+
+	val = pe_dmem_read(0, 0x844, 4);
+	printk(KERN_ERR "PE %d: %08x\n", 0, val);
+
+	val = pe_dmem_read(0, 0x840, 4);
+	printk(KERN_ERR "PE %d: %08x\n", 0, val);
+
+	val = pe_dmem_read(0, 0x844, 4);
+	printk(KERN_ERR "PE %d: %08x\n", 0, val);
+
+
+	val = pe_dmem_read(0, 0x844, 4);
+	printk(KERN_ERR "PE %d: %08x\n", 0, val);
+
+#endif
+
+	for(i=0; i < 4; i++)  {
+		//printk(KERN_ERR "%s: %#lx %#lx\n", __func__, readl(CLASS_STATE), readl(CLASS_PE0_DEBUG));	
+		
+		for(j=0; j < 10; j++)  {
+			printk(KERN_ERR "%s: %#lx\n", __func__, readl(CLASS_PE0_DEBUG));	
+		}
+		val = pe_dmem_read(i, 0x840, 4);
+		printk(KERN_ERR "PE %d: %08x\n", i, val);
+		val = pe_dmem_read(i, 0x844, 4);
+		printk(KERN_ERR "PE %d: %08x\n", i, val);
+	}
+
+}
+#endif
+static char stat_strings[][50] = {
+	"tx- octets  (Lower 32-bits)",
+	"tx- octets  (Upper 16-bits)",
+	"tx- packets",
+	"tx- broadcast",
+	"tx- multicast",
+	"tx- pause",
+	"tx- 64 bytes packets",
+	"tx- 64 - 127 bytes packets",
+	"tx- 128 - 255 bytes packets",
+	"tx- 256 - 511 bytes packets",
+	"tx- 512 - 1023 bytes packets",
+	"tx- 1024 - 1518 bytes packets",
+	"tx- > 1518 bytes packets",
+	"tx- underruns  - errors",
+	"tx- single collision",
+	"tx- multi collision",
+	"tx- exces. collision  - errors",
+	"tx- late collision  - errors",
+	"tx- deferred",
+	"tx- carrier sense - errors",
+	"rx- octets (Lower 32-bits)",
+	"rx- octets (Upper 16-bits)",
+	"rx- packets",
+	"rx- broadcast",
+	"rx- multicast",
+	"rx- pause",
+	"rx- 64 bytes packets",
+	"rx- 64 - 127 bytes packets",
+	"rx- 128 - 255 bytes packets",
+	"rx- 256 - 511 bytes packets",
+	"rx- 512 - 1023 bytes packets",
+	"rx- 1024 - 1518 bytes packets",
+	"rx- > 1518 bytes packets",
+	"rx- undersize -errors",
+	"rx- oversize  - errors ",
+	"rx- jabbers - errors",
+	"rx- fcs - errors",
+	"rx- length - errors",
+	"rx- symbol - errors",
+	"rx- align - errors",
+	"rx- ressource - errors",
+	"rx- overrun - errors",
+	"rx- IP cksum - errors",
+	"rx- TCP cksum - errors",
+	"rx- UDP cksum - errors" 
+};
+static void gem_print_stats(void *base)
+{
+	u32 *pstat = (u32*)gemac_get_stats(base);
+	int i;
+
+	for (i=0; i<(sizeof(GEM_STATS)/4); i++)
+		printk("%s : %d\n", stat_strings[i], *pstat++);
+}
+
+
+void pfe_class_read (int id)
+{
+	u32 val,j;
+
+	for(j=0; j < 20; j++)  {
+		printk(KERN_ERR "%s: %#lx\n", __func__, readl(CLASS_PE0_DEBUG));	
+	}
+
+	val = pe_dmem_read(id, 0x840, 4);
+	printk(KERN_ERR "PE %d: %08x\n", id, val);
+	val = pe_dmem_read(id, 0x844, 4);
+	printk(KERN_ERR "PE %d: %08x\n", id, val);
+
+	return;
+
+}
+
+void pfe_send_pkt(int len)
+{
+	unsigned char *pbuf;
+	int i;
+	int rcount = 0;
+	int rc,phyport=0;
+
+	printk(KERN_INFO "%s:\n", __func__);
+
+	pbuf = (unsigned char *)kmalloc(1024*2, GFP_ATOMIC | GFP_DMA);
+
+	if ((len >= 0) || (len < 1000))  {
+
+		for(i=0; i < len; i++)
+			pbuf[i] = i;
+#if 0
+		if(len == 100) phyport=0;
+		if(len == 200) phyport=1;
+		if(len == 300) phyport=2;
+		if(len == 400) phyport=3;
+#endif
+
+		rc = pfe_send(phyport, (void *)(pbuf), len);
+
+		if (rc < 0)
+			goto done;
+			
+		/* wait for tx done/completion indication */
+		rcount = 0;
+		while (1) {
+			rc = pfe_tx_done(); 
+			if (rc == 0)
+				break;
+			mdelay(100);
+			if (rcount == 20) {
+				printk(KERN_ERR "Tx send fail\n");
+				break;
+			}
+			rcount++;
+		}
+	}
+
+done:
+	kfree(pbuf);
+}
+
+void pfe_print_tx_status(void)
+{
+	u32 val;
+
+	gem_print_stats(EMAC1_BASE_ADDR);
+	//gem_print_stats(EMAC2_BASE_ADDR);
+
+	val = readl(HIF_TX_CTRL);
+	printk(KERN_INFO "TX_CTRL: %08x\n", val);
+
+	val = readl(HIF_TX_CURR_BD_ADDR);
+	printk(KERN_INFO "TX_CURR_BD_ADDR: %08x\n", val);
+
+	val = readl(HIF_TX_BDP_ADDR);
+	printk(KERN_INFO "TX_BDP_ADDR: %08x\n", val);
+
+	val = readl(HIF_TX_STATUS);
+	printk(KERN_INFO "TX_STATUS: %08x\n", val);
+
+	val = readl(HIF_TX_DMA_STATUS);
+	printk(KERN_INFO "TX_DMA_STATUS: %08x\n", val);
+
+	val = readl(BMU2_BASE_ADDR+BMU_REM_BUF_CNT);
+	printk(KERN_INFO "BMU2_REM_BUF_CNT: %08x\n", val);
+
+	val = readl(BMU1_BASE_ADDR+BMU_REM_BUF_CNT);
+	printk(KERN_INFO "BMU1_REM_BUF_CNT: %08x\n", val);
+
+}
+
+void class_dmem_readn(int id, u32 addr, u32 len)
+{
+	u32 val, i;
+
+
+	for(i=0; i < len; i += 4)  {
+		val = pe_dmem_read(id, addr+i, 4);
+		printk(KERN_INFO "%08x: %08x\n",addr+i, val);
+	}
+}
+
+void class_pmem_readn(int id, u32 addr, u32 len)
+{
+	u32 val, i;
+
+	printk(KERN_INFO "Class pe: %d PMEM\n", id);
+	for(i=0; i < len; i += 4)  {
+		val = pe_pmem_read(id, addr+i, 4);
+		printk(KERN_INFO "%08x: %08x\n",addr+i, val);
+		mdelay(40);
+	}
+}
+
+void class_pe_dump(void)
+{
+	u32 val,j,id;
+
+#if 0
+	printk(KERN_INFO "Class-PE 0: ===========>\n");
+	for(j=0; j < 20; j++)  {
+		printk(KERN_ERR "%s: PC: %#lx\n", __func__, readl(CLASS_PE0_DEBUG)&0xffff);	
+		mdelay(40);
+	}
+	printk(KERN_INFO "Class-PE 0: DMEM /n");
+	class_dmem_readn(0,0x814,20);
+	//class_pmem_readn(0,0x10000, 256);
+#endif
+	printk(KERN_INFO "Class-PE 1: ===========>\n");
+	for(j=0; j < 10; j++)  {
+		printk(KERN_ERR "%s: PC: %#lx\n", __func__, readl(CLASS_PE1_DEBUG)&0xffff);	
+		mdelay(40);
+	}
+	class_dmem_readn(1,0x858,4);
+	//printk(KERN_INFO "Class-PE 1: DMEM /n");
+	//class_dmem_readn(1,0x814,20);
+	//class_pmem_readn(1,0x10000, 256);
+
+#if 0
+	printk(KERN_INFO "Class-PE 2: ===========>\n");
+	for(j=0; j < 20; j++)  {
+		printk(KERN_ERR "%s: PC: %#lx\n", __func__, readl(CLASS_PE2_DEBUG)&0xffff);	
+		mdelay(40);
+	}
+	printk(KERN_INFO "Class-PE 2: DMEM /n");
+	class_dmem_readn(2,0x814,20);
+	//class_pmem_readn(2,0x10000, 256);
+
+
+	printk(KERN_INFO "Class-PE 3: ===========>\n");
+	for(j=0; j < 20; j++)  {
+		printk(KERN_ERR "%s: PC: %#lx\n", __func__, readl(CLASS_PE3_DEBUG)&0xffff);	
+		mdelay(40);
+	}
+	printk(KERN_INFO "Class-PE 3: DMEM /n");
+	class_dmem_readn(3,0x814,20);
+	//class_pmem_readn(3,0x10000, 256);
+#endif
+	
+}
+
+void class_dmem_dump(int id)
+{
+	u32 val, i;
+
+	if (id > 3)
+		id = 0;
+
+	printk(KERN_ERR "PE %d:\n", id);
+
+	for(i=0; i < 256; i += 4)  {
+		val = pe_dmem_read(id, i, 4);
+		printk("%08x: %08x\n",i, val);
+	}
+}
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/net/c2000_eth/tmu_sbl_c2000_elf.fw u-boot-2013.01.new/drivers/net/c2000_eth/tmu_sbl_c2000_elf.fw
--- u-boot-2013.01/drivers/net/c2000_eth/tmu_sbl_c2000_elf.fw	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/net/c2000_eth/tmu_sbl_c2000_elf.fw	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1 @@
+0x7f,0x45,0x4c,0x46,0x01,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x6f,0x00,0x00,0x00,0x01,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x34,0x00,0x00,0x25,0x54,0x00,0x04,0x00,0x05,0x00,0x34,0x00,0x20,0x00,0x04,0x00,0x28,0x00,0x0a,0x00,0x09,0x00,0x00,0x00,0x01,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x28,0x00,0x00,0x00,0x28,0x00,0x00,0x00,0x04,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x10,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x68,0x00,0x00,0x02,0x08,0x00,0x00,0x00,0x06,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x12,0x88,0x00,0x00,0x02,0x88,0x00,0x00,0x02,0x88,0x00,0x00,0x01,0x80,0x00,0x00,0x01,0x80,0x00,0x00,0x00,0x06,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x20,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x04,0xe6,0x00,0x00,0x04,0xe6,0x00,0x00,0x00,0x05,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x40,0x00,0x01,0x00,0x40,0x00,0x01,0x00,0x40,0x00,0x01,0x00,0x40,0x00,0x01,0x00,0x40,0x00,0x01,0x00,0x40,0x00,0x01,0x00,0x40,0x00,0x01,0x00,0x40,0x00,0x01,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x2a,0x2a,0x2a,0x2a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x44,0x45,0x41,0x44,0x53,0x54,0x4f,0x50,0x0c,0x08,0x04,0x00,0xc1,0x1c,0x00,0x0c,0x0d,0x09,0x05,0x01,0x0e,0x0a,0x06,0x02,0x0f,0x0b,0x07,0x03,0x3f,0xff,0xff,0xff,0xc1,0x26,0x00,0x48,0xc1,0x26,0x00,0x4c,0xc1,0x26,0x00,0x50,0xc1,0x26,0x00,0x60,0x69,0x6e,0x69,0x74,0x72,0x75,0x6e,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x10,0x80,0x11,0x00,0x11,0x80,0x12,0x00,0x12,0x80,0x13,0x00,0x13,0x80,0x14,0x00,0x14,0x80,0x15,0x00,0x15,0x80,0x16,0x00,0x16,0x80,0x17,0x00,0x17,0x80,0xea,0x00,0xc8,0x00,0xe0,0x08,0xc8,0x04,0xea,0x00,0xcb,0x80,0xe0,0x01,0xcb,0xa0,0xe0,0x60,0x3c,0x00,0xcc,0x02,0xe0,0x60,0x3c,0x10,0xe0,0x00,0xd2,0x45,0x3a,0x80,0xea,0x00,0xcb,0x80,0xe0,0x00,0xcb,0xa8,0xb8,0x47,0xb8,0xd7,0xb9,0x67,0xb9,0xf7,0xe0,0x01,0xba,0x07,0xe0,0x01,0xba,0x97,0xe0,0x01,0xbb,0x27,0xe0,0x01,0xbb,0xb7,0xe0,0x01,0xbc,0x47,0xe0,0x01,0xbc,0xd7,0xe0,0x01,0xbd,0x67,0xe0,0x01,0xbd,0xf7,0xe0,0x02,0xbe,0x07,0xe0,0x02,0xbe,0x97,0xe0,0x02,0xbf,0x27,0xe0,0x02,0xbf,0xb7,0xe0,0x60,0x3e,0x09,0xe0,0x60,0x3e,0x8a,0xe0,0x60,0x3f,0x0b,0xe0,0x60,0x3f,0x8c,0xbe,0x07,0xbe,0x97,0xbf,0x27,0xbf,0xb7,0xe0,0x00,0x00,0x82,0xe0,0x00,0x1c,0x03,0xe0,0x00,0x1c,0x84,0xbc,0x88,0xe0,0x00,0x1c,0x85,0xbc,0x88,0x3a,0x80,0x00,0xff,0xea,0x00,0x7c,0x48,0xe8,0x00,0xc4,0x00,0xeb,0x82,0xcc,0x82,0xbc,0x88,0xeb,0x82,0xcc,0x83,0xbc,0xa8,0xeb,0x82,0xcc,0x84,0xbc,0xc8,0xeb,0x82,0xcc,0x85,0xbc,0xe8,0xeb,0x82,0xcc,0x86,0xe0,0x01,0xbc,0x88,0xeb,0x82,0xcc,0x87,0xe0,0x01,0xbc,0xa8,0xeb,0x82,0xcc,0x88,0xe0,0x01,0xbc,0xc8,0xeb,0x82,0xcc,0x89,0xe0,0x01,0xbc,0xe8,0xeb,0x82,0xcc,0x8a,0xe0,0x02,0xbc,0x88,0xeb,0x82,0xcc,0x8b,0xe0,0x02,0xbc,0xa8,0xea,0x01,0x7c,0x98,0xe8,0x00,0xc4,0x80,0xeb,0x82,0xcd,0x1c,0xbd,0x09,0xeb,0x82,0xcd,0x1d,0xbd,0x79,0xeb,0x82,0xcd,0x1e,0xe0,0x01,0xbd,0x69,0xeb,0x82,0xcd,0x1f,0xe0,0x02,0xbd,0x59,0xeb,0x82,0xcd,0x20,0xe0,0x03,0xbd,0x49,0xeb,0x82,0xcd,0x21,0xe0,0x04,0xbd,0x39,0xeb,0x82,0xcd,0x22,0xe0,0x05,0xbd,0x29,0xeb,0x82,0xcd,0x23,0xe0,0x06,0xbd,0x19,0x14,0x8f,0xbc,0xb8,0xe0,0x01,0x14,0xf0,0xbc,0xd8,0xe0,0x1e,0x14,0x80,0xbc,0xf8,0xe1,0xe0,0x14,0x80,0xe0,0x01,0xbc,0x98,0x15,0x00,0x14,0x80,0xea,0x02,0x7f,0x78,0x16,0x82,0xe0,0x0b,0x34,0xc2,0x3c,0x6a,0xc5,0x81,0xe0,0xae,0xad,0xf8,0x3d,0xe9,0xe2,0x00,0xc5,0x83,0xc4,0x81,0xe3,0xff,0xc4,0xff,0xad,0x98,0xe2,0x00,0xcc,0x90,0xae,0xa8,0x16,0x02,0xc5,0x03,0x01,0xee,0xea,0x01,0x7c,0x18,0xe8,0x00,0xc4,0x00,0x15,0x01,0xbd,0x38,0x15,0x20,0xbc,0xc8,0xe0,0x02,0x14,0x80,0xe0,0x01,0xbd,0x38,0xe0,0x04,0x15,0x00,0xbc,0xd8,0xe0,0x22,0x14,0x91,0xe0,0x01,0xbd,0x48,0xe0,0x40,0x15,0x00,0xbc,0x98,0x14,0x82,0xe0,0x01,0xbd,0x58,0xe0,0x44,0x15,0x22,0xe0,0x01,0xbc,0xa8,0xe0,0x20,0x15,0x80,0xe0,0x01,0xbd,0x08,0x15,0x04,0xe0,0x08,0xac,0x88,0xe0,0x0b,0xac,0xc8,0x14,0x88,0xe0,0x02,0xbd,0x18,0xe0,0x00,0x15,0x40,0xe0,0x03,0xbc,0x88,0xe0,0x01,0x14,0x80,0xe0,0x02,0xbd,0x28,0xe0,0x08,0x15,0x00,0xe0,0x03,0xbc,0x98,0xe0,0x10,0x14,0x80,0xe0,0x02,0xbd,0x38,0xe0,0x80,0x15,0x00,0xe0,0x03,0xbc,0xa8,0xe1,0x00,0x14,0x80,0xe0,0x02,0xbd,0x48,0xe0,0x88,0x15,0x44,0xe0,0x03,0xbc,0xb8,0xe1,0x11,0x14,0x88,0xe0,0x01,0xbd,0x78,0xe0,0x02,0xbc,0xe8,0xe0,0x00,0x1d,0x06,0xe0,0x00,0x1c,0x87,0xe0,0x01,0xae,0x08,0xbd,0xe8,0xe0,0x04,0xae,0x48,0xbd,0x09,0x00,0x00,0x14,0x80,0xa5,0x08,0xbc,0xca,0x00,0x00,0xe0,0x00,0x1e,0x08,0xa5,0x78,0xbe,0x3a,0x00,0x00,0xa5,0x78,0xbc,0xca,0x00,0x00,0xe0,0x00,0x1e,0x09,0xe0,0x01,0xa5,0x68,0xbe,0x3a,0x00,0x00,0xe0,0x01,0xa5,0x68,0xbc,0xca,0x00,0x00,0xe0,0x00,0x1e,0x0a,0xe0,0x02,0xa5,0x58,0xbe,0x3a,0x00,0x00,0xe0,0x02,0xa5,0x58,0xbc,0xca,0x00,0x00,0x3f,0x68,0xe0,0x00,0xc7,0x70,0x16,0x92,0xe0,0x0a,0x14,0x80,0xe0,0x04,0x16,0x50,0xe0,0x0e,0x15,0x50,0xa7,0x88,0xbe,0x8f,0x00,0x00,0xa7,0x88,0xbc,0x9f,0x00,0x00,0xa7,0x88,0xe0,0x01,0xbe,0x0f,0x00,0x00,0xa7,0x88,0xe0,0x01,0xbc,0x9f,0x00,0x00,0xa7,0x88,0xe0,0x01,0xbd,0xaf,0x00,0x00,0xa7,0x88,0xe0,0x01,0xbd,0x3f,0x00,0x00,0xa7,0x88,0xe0,0x01,0xbd,0xcf,0x00,0x00,0xa7,0x88,0xe0,0x01,0xbe,0x5f,0x00,0x00,0xa7,0x88,0xe0,0x01,0xbd,0x6f,0x00,0x00,0xe1,0x80,0xa7,0xf8,0xe0,0x01,0xbc,0xff,0x00,0x00,0x3c,0x7e,0x01,0xd8,0xea,0x00,0x7c,0x48,0xe8,0x00,0xc4,0x00,0x3d,0xe8,0xe0,0x00,0x1c,0x8b,0xc5,0xa8,0x15,0x01,0xa6,0x08,0xbd,0x0c,0x00,0x00,0xe1,0x80,0xa6,0x28,0xbc,0x9c,0x00,0x00,0x3c,0x7b,0x01,0xf8,0xea,0x03,0x7c,0x28,0xe0,0x0a,0x16,0x01,0xe0,0x12,0x15,0x82,0xe0,0x22,0x15,0x04,0xe0,0x42,0x14,0x88,0xbe,0x08,0xbd,0x98,0xbd,0x28,0xbc,0xb8,0xbe,0x48,0xbd,0xd8,0xbd,0x68,0xbc,0xf8,0xe0,0x01,0xbe,0x08,0xe0,0x01,0xbd,0x98,0xe0,0x01,0xbd,0x28,0xe0,0x01,0xbc,0xb8,0xe0,0x01,0xbe,0x48,0xe0,0x01,0xbd,0xd8,0xe0,0x01,0xbd,0x68,0xe0,0x01,0xbc,0xf8,0x38,0x82,0xeb,0x82,0xcc,0x26,0xa4,0x88,0x3c,0x69,0xe2,0x00,0xc4,0x07,0xe0,0x01,0x2c,0x37,0xe4,0x08,0x34,0xc3,0x3e,0xe8,0xe2,0x00,0xc4,0x01,0xe2,0x07,0xc6,0xff,0xe0,0x01,0x24,0x2e,0x34,0xc3,0xea,0x00,0x7c,0x54,0xe3,0xff,0xc4,0xff,0xe8,0x00,0xc4,0x00,0x15,0x80,0x15,0x01,0xe0,0x0c,0x36,0xda,0xe2,0x00,0xc6,0x01,0x26,0x03,0xa6,0x08,0x3d,0xcc,0xc5,0x01,0xe2,0x00,0xcd,0x05,0xc4,0x08,0x01,0xf5,0x3c,0xdb,0xe0,0x01,0x24,0x96,0xe0,0x00,0x1d,0x03,0xa4,0x2a,0xc4,0x01,0xbc,0x2a,0xea,0x01,0x7c,0x18,0xe8,0x00,0xc4,0x00,0xe0,0x02,0xa5,0x68,0xe0,0x0a,0x3c,0xda,0x2d,0x0e,0xe0,0x01,0xa5,0x78,0xe0,0x0a,0x3c,0xda,0x2d,0x0b,0xe0,0x01,0xa5,0x08,0x14,0x00,0xe0,0x0a,0x3c,0xda,0x25,0x06,0x14,0x01,0x00,0x84,0x14,0x03,0x00,0x82,0x14,0x02,0xe0,0x0a,0x34,0x22,0xe0,0x0c,0x34,0x25,0x3e,0x2a,0xea,0x01,0x7d,0x18,0xe8,0x00,0xc5,0x00,0xe0,0x0b,0x3e,0x1a,0xe0,0x01,0x8e,0x8b,0x2e,0x9e,0xa4,0x9b,0xe1,0xff,0x15,0x7f,0x3c,0xfa,0x14,0x00,0x05,0x84,0xe4,0x09,0x34,0xc0,0x14,0x10,0xe2,0x01,0xcc,0xff,0x05,0x83,0x34,0xc8,0xc4,0x08,0xe2,0x00,0xcc,0x8f,0x05,0x83,0x34,0xc4,0xc4,0x04,0xe2,0x00,0xcc,0x83,0x05,0x83,0x34,0xc2,0xc4,0x02,0x15,0x02,0xe1,0x29,0x3c,0xaa,0x3c,0x19,0x00,0xaa,0xa5,0x9b,0xc6,0x08,0x3c,0xdb,0x3e,0x1a,0x15,0x80,0x15,0x00,0x16,0x81,0xe0,0x80,0xa7,0x1c,0xe0,0x0e,0x3c,0xde,0x27,0x05,0xe0,0x0e,0x36,0xba,0x37,0x28,0x3d,0xce,0xc5,0x01,0xe2,0x00,0xcd,0x04,0x01,0xf4,0xe0,0x0a,0x34,0x22,0xea,0x01,0x7c,0x98,0x34,0x25,0x3c,0x2a,0xe8,0x00,0xc4,0x80,0x3c,0x98,0xa4,0x09,0xbd,0x88,0x00,0x00,0xa4,0x89,0xc4,0x88,0xa4,0x09,0x3d,0x68,0xe3,0x00,0xc5,0x00,0x25,0x7c,0xe4,0x08,0x34,0x48,0x3c,0xe8,0xe2,0x00,0xcc,0x07,0xe0,0x01,0xcc,0x80,0x02,0x04,0xe0,0x00,0x1d,0x0c,0x00,0x8b,0x3d,0x68,0xc5,0x78,0xe2,0x00,0xcd,0x03,0x02,0x84,0xe0,0x00,0x1d,0x0d,0x00,0x83,0xe0,0x00,0x1d,0x0e,0xbc,0x8a,0x00,0x00,0xe0,0x00,0x1d,0x03,0xa4,0xba,0xc4,0x81,0xbc,0xba,0xea,0x03,0x7c,0xa8,0xe0,0x28,0xa4,0xf9,0xe0,0x00,0x1c,0x0f,0xbc,0x88,0x00,0x00,0x38,0x82,0xc0,0x78,0x78,0x82,0x7a,0x01,0xe0,0x00,0x1c,0x10,0xe0,0x00,0x1a,0x03,0xbc,0x04,0xdd,0xee,0xe0,0x00,0x1c,0x11,0xbc,0x04,0xa4,0x14,0xc4,0x01,0xbc,0x14,0xdf,0x33,0x00,0xfc,0x47,0x43,0x43,0x3a,0x20,0x28,0x47,0x4e,0x55,0x29,0x20,0x34,0x2e,0x36,0x2e,0x31,0x00,0x00,0x2e,0x73,0x68,0x73,0x74,0x72,0x74,0x61,0x62,0x00,0x2e,0x70,0x6d,0x65,0x6d,0x00,0x2e,0x76,0x65,0x63,0x74,0x6f,0x72,0x00,0x2e,0x64,0x6d,0x65,0x6d,0x5f,0x70,0x65,0x73,0x74,0x61,0x74,0x75,0x73,0x00,0x2e,0x64,0x6d,0x65,0x6d,0x5f,0x67,0x6f,0x74,0x00,0x2e,0x64,0x6d,0x65,0x6d,0x5f,0x6c,0x69,0x74,0x34,0x00,0x2e,0x64,0x6d,0x65,0x6d,0x5f,0x62,0x73,0x73,0x00,0x2e,0x64,0x6d,0x65,0x6d,0x5f,0x73,0x74,0x61,0x63,0x6b,0x00,0x2e,0x63,0x6f,0x6d,0x6d,0x65,0x6e,0x74,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0b,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x06,0x00,0x01,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x04,0xe6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x11,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x19,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x80,0x00,0x00,0x10,0x80,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x28,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0xa0,0x00,0x00,0x10,0xa0,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x32,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x12,0x00,0x00,0x00,0xb0,0x00,0x00,0x10,0xb0,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x3d,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0xe8,0x00,0x00,0x10,0xe8,0x00,0x00,0x01,0xa0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x47,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x03,0x00,0x00,0x02,0x88,0x00,0x00,0x12,0x88,0x00,0x00,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x53,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x24,0xe6,0x00,0x00,0x00,0x11,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x24,0xf7,0x00,0x00,0x00,0x5c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,
\ No newline at end of file
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/net/c2000_eth/util_c2000_elf.fw u-boot-2013.01.new/drivers/net/c2000_eth/util_c2000_elf.fw
--- u-boot-2013.01/drivers/net/c2000_eth/util_c2000_elf.fw	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/net/c2000_eth/util_c2000_elf.fw	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1 @@
+0x7f,0x45,0x4c,0x46,0x01,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x6f,0x00,0x00,0x00,0x01,0x03,0xf8,0x00,0x00,0x00,0x00,0x00,0x34,0x00,0x00,0x4d,0x64,0x00,0x04,0x00,0x05,0x00,0x34,0x00,0x20,0x00,0x04,0x00,0x28,0x00,0x0e,0x00,0x0d,0x00,0x00,0x00,0x01,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x00,0x00,0x0a,0xcc,0x00,0x00,0x00,0x06,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x1a,0xe0,0x00,0x00,0x0a,0xe0,0x00,0x00,0x0a,0xe0,0x00,0x00,0x06,0xa0,0x00,0x00,0x06,0xa0,0x00,0x00,0x00,0x06,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x2f,0x80,0x00,0x00,0x1f,0x80,0x00,0x00,0x1f,0x80,0x00,0x00,0x00,0x28,0x00,0x00,0x00,0x28,0x00,0x00,0x00,0x04,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x30,0x00,0x03,0xf8,0x00,0x00,0x03,0xf8,0x00,0x00,0x00,0x00,0x1c,0xc8,0x00,0x00,0x38,0xc8,0x00,0x00,0x00,0x07,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x2a,0x2a,0x2a,0x2a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x00,0x00,0x00,0xb0,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x4c,0x00,0x00,0x02,0x48,0x00,0x00,0x0a,0xe8,0x00,0x00,0x02,0x6c,0x00,0x00,0x03,0x34,0x00,0x00,0x02,0xc0,0x00,0x00,0x02,0xd0,0x00,0x00,0x03,0x40,0x00,0x00,0x01,0x38,0x00,0x00,0x00,0xf8,0x00,0x00,0x0d,0xf8,0x00,0x00,0x03,0x98,0x00,0x00,0x03,0x90,0x00,0x00,0x03,0xc0,0x00,0x00,0x0a,0x21,0x00,0x00,0x0a,0x20,0x00,0x00,0x08,0xd4,0x03,0xf8,0x1c,0xaa,0x03,0xf8,0x10,0x6e,0x00,0x00,0x0a,0xf8,0x00,0x00,0x0a,0x24,0x00,0x00,0x0e,0xf8,0x00,0x00,0x0c,0xf8,0x00,0x00,0x0a,0xa8,0x00,0x00,0x0a,0xe0,0x00,0x00,0x0a,0xac,0x00,0x00,0x0a,0xc8,0x00,0x00,0x0a,0xa8,0x00,0x00,0x0f,0xf8,0x03,0xf8,0x0f,0x2c,0x00,0x00,0x00,0x01,0xc1,0x04,0x00,0x00,0xc1,0x05,0x00,0x00,0xc1,0x06,0x00,0x00,0x49,0x4e,0x49,0x54,0x52,0x55,0x4e,0x20,0xc0,0x2f,0xff,0xff,0xc0,0x25,0x00,0x34,0x44,0x45,0x41,0x44,0xc0,0x24,0x00,0x30,0xc0,0x32,0x00,0x10,0xc1,0x03,0x00,0x0c,0xc1,0x03,0x00,0x08,0xc0,0x25,0x00,0x34,0x0e,0x08,0x00,0x84,0x0e,0x08,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xf8,0x00,0x00,0x03,0xf8,0x00,0x40,0x03,0xf8,0x00,0x40,0x03,0xf8,0x00,0x40,0x03,0xf8,0x00,0x40,0x03,0xf8,0x00,0x40,0x03,0xf8,0x00,0x40,0x03,0xf8,0x00,0x40,0x03,0xf8,0x00,0x40,0x03,0xf8,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x10,0x80,0x11,0x00,0x11,0x80,0x12,0x00,0x12,0x80,0x13,0x00,0x13,0x80,0x14,0x00,0x14,0x80,0x15,0x00,0x15,0x80,0x16,0x00,0x16,0x80,0x17,0x00,0x17,0x80,0xea,0x00,0xc8,0x00,0xe0,0x22,0xc8,0x7c,0xea,0x00,0xcb,0x80,0xe0,0x00,0xcb,0xa0,0xe0,0x60,0x3c,0x00,0xcc,0x02,0xe0,0x60,0x3c,0x10,0xe0,0x00,0xd0,0x63,0x3a,0x80,0xea,0x00,0xcb,0x80,0xe0,0x3f,0xcb,0xa8,0xb8,0x47,0xb8,0xd7,0xb9,0x67,0xb9,0xf7,0xe0,0x01,0xba,0x07,0xe0,0x01,0xba,0x97,0xe0,0x01,0xbb,0x27,0xe0,0x01,0xbb,0xb7,0xe0,0x01,0xbc,0x47,0xe0,0x01,0xbc,0xd7,0xe0,0x01,0xbd,0x67,0xe0,0x01,0xbd,0xf7,0xe0,0x02,0xbe,0x07,0xe0,0x02,0xbe,0x97,0xe0,0x02,0xbf,0x27,0xe0,0x02,0xbf,0xb7,0xe0,0x60,0x3e,0x09,0xe0,0x60,0x3e,0x8a,0xe0,0x60,0x3f,0x0b,0xe0,0x60,0x3f,0x8c,0xbe,0x07,0xbe,0x97,0xbf,0x27,0xbf,0xb7,0xe0,0x07,0x00,0x97,0x38,0x82,0x14,0x08,0x38,0x82,0xe0,0x00,0x1d,0x13,0x14,0x80,0x14,0x00,0x3d,0xea,0xe0,0x0c,0x34,0x23,0xe1,0x81,0xbc,0xaa,0xe0,0x09,0x34,0x25,0xc4,0x01,0xe0,0x09,0x3e,0x19,0xe2,0x00,0xcc,0x20,0x3c,0x9b,0x01,0xf4,0xe0,0x00,0x1c,0x1d,0xe0,0x00,0x1d,0x21,0xbc,0x88,0xea,0x00,0x7c,0xfc,0xea,0x00,0x7c,0x7e,0xe0,0x00,0x1d,0x87,0xe0,0x00,0x1e,0x20,0xe8,0x07,0xc4,0xf8,0xe8,0x07,0xc4,0x78,0xe0,0x80,0xbc,0x9a,0xe0,0x80,0xbc,0x1b,0x3d,0x7c,0x01,0xfb,0xe0,0x00,0x1c,0x97,0xe0,0x00,0x1c,0x1f,0xbc,0xa8,0x38,0x82,0xc0,0x64,0x78,0x86,0x79,0x05,0x79,0x84,0x7a,0x03,0x7a,0x82,0x7b,0x01,0xe0,0x00,0x1c,0x05,0xe0,0x00,0x1c,0xa8,0xe1,0xfe,0xc0,0x78,0xbc,0x88,0x39,0xe0,0xe0,0x00,0x1c,0xa9,0xc1,0x8b,0xbc,0x88,0x31,0xc3,0x31,0xa3,0xdf,0xbc,0xeb,0x0c,0xcb,0x00,0xe3,0xff,0x11,0x7f,0xe0,0x00,0x1c,0x85,0xa4,0x19,0xc4,0x01,0xbc,0x19,0xe0,0x00,0x1c,0x08,0xa4,0xb8,0xe2,0x00,0xc4,0x81,0xe0,0x00,0x24,0xd3,0xa4,0x98,0xa2,0x08,0x3d,0xe9,0x3d,0x64,0xe2,0x00,0xc5,0x87,0xe2,0x00,0xc5,0x07,0xa2,0xa8,0x3d,0xfa,0x14,0x01,0xe0,0x00,0x01,0xc1,0xe0,0x0a,0x3a,0x99,0xe2,0x40,0xcd,0x00,0x02,0x89,0x3a,0x72,0x14,0x02,0x05,0xb8,0xe0,0x0a,0x3a,0x94,0x3d,0x76,0x02,0xb4,0x00,0x8b,0x3c,0xf2,0x14,0x03,0x05,0xb0,0x3d,0x76,0x02,0x91,0xe0,0x0a,0x3a,0x94,0xe2,0x40,0xcd,0x00,0x02,0x83,0x3c,0x64,0x00,0xa3,0xe0,0x00,0x1e,0x2a,0x14,0x02,0x3a,0x7c,0x05,0xa2,0xeb,0x80,0xce,0x31,0x3d,0x7c,0x00,0x8f,0xe0,0x00,0x1e,0x2a,0x3c,0xfc,0x05,0x9a,0xeb,0x80,0xce,0x31,0x3d,0x7c,0x02,0x96,0x3a,0x72,0x14,0x02,0x05,0x93,0xe0,0x0a,0x3a,0x94,0x3d,0x76,0x02,0x8f,0xe0,0x0b,0x39,0x9b,0x3c,0x6b,0x3d,0x65,0x7d,0xa9,0xe0,0x00,0xd3,0x2e,0x65,0xa9,0x3c,0x64,0x3c,0xeb,0x3d,0x65,0xe0,0x00,0xd3,0x28,0x14,0x00,0xe0,0x00,0x1c,0x88,0xe4,0x08,0x34,0x20,0xbc,0x39,0xe0,0x00,0x1c,0x22,0xa4,0x88,0x24,0x85,0x14,0x81,0xbc,0x98,0xe7,0xff,0x00,0x9d,0xbc,0x98,0xe0,0x00,0x1a,0x0f,0xe0,0x00,0xd5,0x87,0xe0,0x00,0x1a,0x9f,0xe0,0x00,0x1c,0x0e,0xa4,0x84,0x24,0x85,0xa4,0x85,0x7c,0x29,0x3c,0x81,0x64,0x29,0xc2,0x08,0x3a,0x78,0xc2,0x84,0x01,0xf7,0xe0,0x00,0xd5,0xce,0xe7,0xff,0x00,0x86,0x3c,0xe8,0xe0,0x81,0xa5,0x39,0x14,0x00,0xe3,0xff,0xcd,0x7f,0xe0,0x68,0x39,0xa9,0x38,0x82,0x3c,0xe8,0xe0,0x82,0xa5,0x19,0x14,0x00,0xe3,0xff,0xcd,0x7f,0xe0,0x68,0x39,0xa9,0x38,0x82,0xc0,0x60,0x78,0x86,0x79,0x05,0x79,0x84,0x7a,0x03,0x7a,0x82,0x7b,0x01,0x39,0x6b,0x3a,0xe9,0x3b,0x68,0xe4,0x09,0x35,0x49,0xe3,0xff,0xc1,0x7f,0xe0,0x08,0x35,0x27,0x3c,0x49,0xe0,0x09,0x31,0x2b,0xe3,0xff,0xc6,0x7f,0xe0,0x08,0x3c,0x98,0xe4,0x09,0x34,0x40,0x3c,0x1c,0x3c,0x19,0xe0,0x09,0x34,0x48,0xe2,0x08,0x3c,0xc8,0xe0,0x00,0x1c,0x9c,0xe2,0x00,0xc4,0x3f,0xe0,0x28,0xa4,0xf9,0x7e,0x07,0x3a,0x6a,0xe3,0xff,0xc2,0xff,0x14,0x00,0x24,0x89,0xe0,0x00,0x1c,0x06,0xe0,0x01,0x15,0x48,0xe0,0x00,0xd2,0xc0,0xe0,0x00,0x1c,0x06,0x11,0x80,0x24,0x3b,0xe0,0x01,0xa4,0xa8,0x3c,0xf4,0x01,0x97,0xe0,0x01,0x9c,0xe8,0x3c,0xf2,0x01,0x93,0xe0,0x03,0x8c,0xe8,0x65,0x07,0x3c,0xfa,0x01,0x8e,0xe0,0x03,0x8c,0xf8,0x24,0x8a,0xe0,0x01,0xa4,0x98,0x3c,0xf6,0x01,0x87,0xe0,0x01,0x9c,0xd8,0x3c,0xf5,0x01,0x83,0x00,0x8f,0x39,0xe8,0xa4,0xa8,0x24,0x8a,0xe0,0x00,0x1c,0x06,0xe0,0x01,0x15,0x48,0xe0,0x00,0xd2,0x9a,0xe0,0x00,0x1c,0x06,0x00,0xdc,0x29,0x91,0x00,0x94,0x39,0xe8,0x00,0x8e,0xa4,0x13,0x7c,0x08,0x64,0x08,0xa4,0x08,0xe2,0x00,0xc4,0x04,0x2c,0x7c,0x64,0x88,0x3c,0x63,0xe0,0x01,0x15,0x48,0xe0,0x00,0xd2,0x72,0xa4,0x03,0xe2,0x00,0xc4,0x04,0x2c,0x70,0x3c,0x63,0x60,0x86,0x61,0x05,0x61,0x84,0x62,0x03,0x62,0x82,0x63,0x01,0xc0,0x20,0x38,0x82,0xc0,0x5c,0x78,0x86,0x79,0x05,0x79,0x84,0x7a,0x03,0x7a,0x82,0x7b,0x01,0xe3,0xff,0xc4,0xff,0x3a,0xe8,0x9c,0x6a,0x7c,0x88,0xe4,0x08,0x34,0x20,0x9c,0xfa,0x3b,0x6b,0x3c,0x49,0xe4,0x09,0x34,0x49,0xe3,0xff,0xc3,0x7f,0x34,0x27,0x3c,0x49,0xe0,0x09,0x33,0x2b,0xe3,0xff,0xc6,0x7f,0x3c,0x19,0xe4,0x09,0x34,0x40,0x3c,0x1c,0x3c,0x19,0xe0,0x09,0x34,0x48,0xe2,0x08,0x3c,0xc8,0xe0,0x00,0x1c,0x90,0xe2,0x00,0xc4,0x3f,0x7e,0x07,0x3a,0x6a,0xe0,0x28,0xa4,0xf9,0x11,0x80,0xe0,0x01,0x24,0xbf,0xe0,0x00,0x1c,0x06,0xe0,0x01,0x15,0x60,0xe0,0x00,0xd2,0x44,0xe0,0x00,0x19,0x06,0xe0,0x03,0x9c,0xa2,0xe0,0x03,0x9c,0x32,0xe4,0x09,0x34,0xa0,0x3c,0xc8,0x9c,0x04,0x9d,0x14,0xe4,0x08,0x34,0x20,0x3c,0x4a,0x3c,0xf8,0xe0,0x01,0x01,0x88,0xe0,0x03,0x9c,0xc2,0xe0,0x03,0x9c,0x52,0xe4,0x09,0x34,0xa0,0x3c,0xc8,0x9c,0x24,0x9d,0x34,0xe4,0x08,0x34,0x20,0x3c,0x4a,0x3c,0xf8,0xe0,0x00,0x01,0xf9,0xe0,0x03,0x9c,0xe2,0xe0,0x03,0x9c,0x72,0xe4,0x09,0x34,0xa0,0x3c,0xc8,0x9c,0x44,0x9d,0x54,0xe4,0x08,0x34,0x20,0x3c,0x4a,0x3c,0xf8,0xe0,0x00,0x01,0xea,0xe0,0x04,0x9c,0x82,0xe0,0x04,0x9c,0x12,0xe4,0x09,0x34,0xa0,0x3c,0xc8,0x9c,0x64,0x9d,0x74,0xe4,0x08,0x34,0x20,0x3c,0x4a,0x3c,0xf8,0xe0,0x00,0x01,0xdb,0xe0,0x03,0x8c,0x42,0xe0,0x03,0x8c,0xd2,0x34,0x28,0xe0,0x08,0x3c,0xc8,0x3c,0x76,0xe0,0x00,0x01,0xd1,0xe0,0x03,0x8c,0x62,0x64,0x87,0x3c,0x79,0xe0,0x00,0x01,0xcb,0xe0,0x03,0x8c,0x72,0xe0,0x00,0x24,0x45,0xe0,0x02,0x9c,0xa2,0xe0,0x02,0x9c,0x32,0xe4,0x09,0x34,0xa0,0x3c,0xc8,0x9c,0x05,0x9d,0x15,0xe4,0x08,0x34,0x20,0x3c,0x4a,0x3c,0xf8,0x01,0xb8,0xe0,0x02,0x9c,0xc2,0xe0,0x02,0x9c,0x52,0xe4,0x09,0x34,0xa0,0x3c,0xc8,0x9c,0x25,0x9d,0x35,0xe4,0x08,0x34,0x20,0x3c,0x4a,0x3c,0xf8,0x01,0xaa,0xe0,0x02,0x9c,0xe2,0xe0,0x02,0x9c,0x72,0xe4,0x09,0x34,0xa0,0x3c,0xc8,0x9c,0x45,0x9d,0x55,0xe4,0x08,0x34,0x20,0x3c,0x4a,0x3c,0xf8,0x01,0x9c,0xe0,0x03,0x9c,0x82,0xe0,0x03,0x9c,0x12,0xe4,0x09,0x34,0xa0,0x3c,0xc8,0x9c,0x65,0x9d,0x75,0xe4,0x08,0x34,0x20,0x3c,0x4a,0x3c,0xf8,0x01,0x8e,0xe0,0x03,0x8c,0x22,0xe0,0x03,0x8c,0xb2,0x34,0x28,0x65,0x08,0xe0,0x08,0x3c,0xc8,0x3c,0x7a,0x01,0x84,0x00,0x8f,0xe0,0x00,0x19,0x86,0xa4,0xa2,0x24,0x89,0xe0,0x00,0x1c,0x06,0xe0,0x01,0x15,0x60,0xe0,0x00,0xd1,0xa5,0xe7,0xfe,0x00,0xe3,0x29,0x92,0x00,0x95,0xe0,0x00,0x19,0x86,0x00,0x8e,0xa4,0x13,0x7c,0x09,0x64,0x09,0xa4,0x08,0xe2,0x00,0xc4,0x04,0x2c,0x7c,0x64,0x89,0x3c,0x63,0xe0,0x01,0x15,0x60,0xe0,0x00,0xd1,0x7d,0xa4,0x03,0xe2,0x00,0xc4,0x04,0x2c,0x70,0x3c,0x63,0x60,0x86,0x61,0x05,0x61,0x84,0x62,0x03,0x62,0x82,0x63,0x01,0xc0,0x24,0x38,0x82,0xc0,0x70,0x78,0x83,0x7a,0x02,0x7a,0x81,0x3a,0xe8,0xe3,0xff,0xc2,0xff,0x3c,0xe5,0xe0,0x00,0x1c,0x1b,0xe2,0x00,0xc4,0xbf,0xe0,0x29,0xa4,0xf8,0x12,0x00,0x24,0xa4,0xe0,0x00,0x1c,0x06,0xe0,0x01,0x15,0x48,0xe0,0x00,0x1a,0x06,0xe0,0x00,0xd1,0x6c,0xe0,0x01,0x9c,0x04,0x3c,0x75,0x01,0x12,0xa4,0xb4,0x24,0x95,0x00,0xf2,0xa4,0x14,0x7c,0x04,0x64,0x04,0xa4,0x08,0xe2,0x00,0xc4,0x04,0x2c,0x7c,0x64,0x84,0xe0,0x00,0x1c,0x06,0xe0,0x01,0x15,0x48,0xe0,0x00,0xd1,0x43,0xa4,0x04,0xe2,0x00,0xc4,0x04,0x2c,0x6f,0x00,0x82,0x12,0x00,0x3c,0x64,0x60,0x83,0x62,0x02,0x62,0x81,0xc0,0x10,0x38,0x82,0xc0,0x78,0x78,0x82,0x7a,0x01,0xa6,0x18,0x16,0xfc,0xc6,0x03,0x3e,0x5d,0x16,0x82,0xae,0x8c,0x3a,0x68,0xad,0x4c,0xbd,0xac,0xe0,0x01,0x9c,0x89,0xb4,0xbc,0xe0,0x00,0xd3,0x43,0x3c,0x64,0xe0,0x00,0xd3,0x51,0x60,0x82,0x62,0x01,0xc0,0x08,0x38,0x82,0xc0,0x7c,0x78,0x81,0xa6,0x18,0x16,0xfc,0xc6,0x03,0x3e,0x5d,0x16,0x82,0xae,0x8c,0xad,0x4c,0xbd,0xac,0xe0,0x01,0x9c,0x89,0xb4,0xbc,0xe0,0x00,0xd3,0x3e,0x60,0x81,0xc0,0x04,0x38,0x82,0xa4,0xa8,0x24,0x8a,0xe7,0xf0,0x15,0x00,0x3c,0xda,0xe0,0x00,0x1d,0x2b,0xbc,0x8a,0x00,0x00,0x14,0x80,0xbc,0xa8,0xe0,0x00,0x1c,0x9d,0xa5,0x09,0xbd,0x08,0xbc,0x09,0x38,0x82,0xe0,0x08,0x8e,0x08,0xe0,0x00,0x2e,0x44,0xe0,0x01,0xa6,0xd8,0x3c,0xfd,0x01,0xbf,0xe0,0x03,0x9c,0xc8,0x16,0x06,0xe0,0x0d,0x3d,0x29,0xe3,0xff,0xc6,0xff,0xe0,0x00,0x26,0xe4,0xe2,0x17,0xce,0xb7,0x02,0x99,0x16,0x01,0xe0,0x00,0x2d,0xde,0xe0,0x02,0x9d,0xb8,0x2d,0x85,0x3d,0x79,0xe0,0x00,0x03,0xd8,0x00,0x87,0x3c,0xfb,0xe0,0x00,0x03,0xd4,0x3d,0x7b,0xe0,0x00,0x04,0xd1,0xe0,0x02,0xa4,0x98,0xe8,0x00,0xc4,0x81,0xe0,0x02,0xbc,0x98,0xe0,0x00,0x00,0xc9,0xe1,0xfe,0x15,0x80,0x3e,0xfb,0x05,0x8d,0xe0,0x04,0x84,0x78,0x16,0x02,0x3d,0x28,0xe0,0x43,0x3d,0x0a,0xe2,0x00,0xcd,0x00,0x02,0x3b,0x16,0x05,0x14,0x06,0x00,0xb6,0x16,0x03,0x24,0xb6,0xc4,0x81,0x3d,0x79,0x16,0x04,0x01,0x32,0xe0,0x02,0xb5,0x38,0x16,0x03,0x00,0xae,0xe0,0x02,0x8d,0x98,0xe2,0x00,0xcd,0x81,0x01,0x8e,0x15,0x80,0xe0,0x02,0xb5,0x38,0x16,0x00,0xe0,0x08,0xad,0x88,0xe0,0x01,0xbc,0xd8,0xe0,0x03,0xb5,0x48,0xe0,0x02,0xad,0x98,0x00,0x9c,0xe0,0x03,0x9d,0xc8,0xc5,0x81,0x3d,0x7b,0xe0,0x01,0xa5,0x58,0x01,0x90,0x3d,0x79,0x01,0x8e,0x26,0x04,0xc6,0x7f,0xe0,0x08,0xae,0x08,0xe0,0x08,0x8c,0x08,0x16,0x04,0xe2,0x00,0xcc,0x00,0x14,0x08,0xe0,0x6c,0x39,0xa8,0x00,0x86,0x16,0x07,0x3d,0x79,0x14,0x03,0xe0,0x6c,0x39,0x28,0x3c,0x6c,0x38,0x82,0xc0,0x7c,0x78,0x81,0xe0,0x00,0xd3,0x02,0x60,0x81,0xc0,0x04,0x38,0x82,0xc0,0x78,0x78,0x82,0x7a,0x01,0x3a,0x68,0xe3,0xff,0xc2,0x7f,0xe0,0x08,0x32,0x48,0xe2,0x08,0x3a,0x48,0xe0,0x00,0x1c,0x99,0xe2,0x00,0xc4,0x7f,0xe0,0x28,0xa4,0xf9,0x14,0x00,0x24,0x90,0xe0,0x00,0x1c,0x09,0xe0,0x00,0x15,0x50,0xe0,0x00,0xd0,0x7c,0xe0,0x00,0x1c,0x09,0x22,0x04,0x9c,0xe8,0x3c,0xf4,0x01,0x04,0xa4,0x98,0x2c,0xf3,0x14,0x00,0x60,0x82,0x62,0x01,0xc0,0x08,0x38,0x82,0xe2,0x01,0xc4,0xff,0xe2,0x00,0xcc,0x81,0x01,0x8a,0x15,0x00,0xbd,0x08,0xbd,0x18,0xe0,0x01,0xb5,0x38,0xe0,0x01,0xb5,0x28,0xbd,0x68,0xbd,0x48,0x3d,0x69,0xc5,0x7f,0xe2,0x01,0xc5,0x7f,0xe2,0x00,0xcd,0x01,0x02,0x86,0x15,0x00,0xbd,0x28,0xe0,0x01,0xbd,0x48,0x00,0x84,0xe2,0x00,0xcd,0x02,0x01,0x9a,0x15,0x00,0x15,0xff,0xe0,0x01,0xbd,0x78,0xe0,0x01,0xbd,0x68,0xe0,0x01,0xbd,0xd8,0xe0,0x02,0xbd,0x48,0xe0,0x02,0xbd,0x38,0xe0,0x02,0xbd,0x28,0xe0,0x02,0xbd,0x98,0xbd,0x38,0xe0,0x01,0xbd,0x28,0xe0,0x02,0xbd,0x68,0xe0,0x02,0xbd,0x58,0xe0,0x03,0xbd,0x08,0xe0,0x07,0xb4,0x88,0x38,0x82,0xe0,0x00,0x1c,0xac,0xe0,0x00,0x1c,0x05,0xbc,0x88,0x3a,0x80,0x00,0xff,0x14,0x00,0x38,0x82,0x14,0x00,0x38,0x82,0x14,0x00,0x38,0x82,0x14,0x00,0x38,0x82,0x14,0x00,0x38,0x82,0x38,0x82,0x38,0x82,0x38,0x82,0x38,0x82,0xc0,0x7c,0x7c,0x01,0x64,0x01,0x3c,0xe8,0xc4,0xff,0x7c,0x81,0x2c,0x7c,0xc0,0x04,0x38,0x82,0x38,0x82,0x38,0x82,0xc0,0x7c,0x78,0x81,0xe2,0x3f,0xcc,0xff,0x3e,0x68,0x3e,0xe9,0x3d,0xea,0x14,0x00,0x02,0x85,0x3c,0xec,0x3d,0x6d,0x16,0x01,0x00,0x83,0x3d,0x6c,0x16,0x00,0xe0,0x00,0xd1,0xe5,0x60,0x81,0xc0,0x04,0x38,0x82,0xc0,0x6c,0x78,0x85,0x79,0x04,0x7a,0x03,0x7a,0x82,0x7b,0x01,0x3b,0x68,0x3c,0x69,0xe2,0x00,0xc4,0x01,0x3a,0xe9,0x3a,0x6a,0x24,0x07,0x25,0x06,0xe1,0x80,0x8c,0x15,0xc2,0x7f,0xe1,0x80,0xac,0x16,0xe0,0x08,0x32,0xc1,0xe2,0x00,0xc4,0x01,0x24,0x0a,0x14,0x01,0xe1,0x28,0x3a,0x18,0x24,0x06,0xe1,0x80,0x9c,0x15,0xc2,0x7e,0xe1,0x80,0xb4,0x16,0xe0,0x08,0x32,0xc2,0xe2,0x00,0xc4,0x01,0x24,0x0a,0x14,0x03,0xe1,0x28,0x3a,0x18,0x24,0x06,0xe1,0x80,0xa4,0x15,0xc2,0x7c,0xe1,0x80,0xbc,0x16,0x11,0x78,0xe0,0x02,0x3a,0x52,0x21,0x05,0x3c,0x66,0x3c,0xe5,0x3d,0x62,0xdf,0xb6,0x3c,0x64,0xe2,0x00,0xc4,0x07,0x24,0x18,0x3c,0x64,0xe2,0x00,0xc4,0x04,0x3a,0x92,0x3b,0x12,0x24,0x05,0xe1,0x80,0xa4,0x15,0xe1,0x80,0xbc,0x16,0x3c,0x64,0xe2,0x00,0xc4,0x02,0x24,0x05,0xe1,0x80,0x9c,0x15,0xe1,0x80,0xb4,0x16,0xe2,0x00,0xc2,0x01,0x22,0x03,0x8c,0x05,0xac,0x06,0x60,0x85,0x61,0x04,0x62,0x03,0x62,0x82,0x63,0x01,0xc0,0x14,0x38,0x82,0xe0,0x0e,0x35,0x45,0x3e,0xee,0x3e,0x69,0x3d,0xe8,0x00,0x94,0xa7,0x8c,0xc6,0xff,0xbf,0x8b,0xa7,0x9c,0xbf,0x9b,0xa7,0xac,0xbf,0xab,0xa7,0xbc,0xbf,0xbb,0xa7,0xcc,0xbf,0xcb,0xa7,0xdc,0xbf,0xdb,0xa7,0xec,0xbf,0xeb,0xa7,0xfc,0xc6,0x20,0xbf,0xfb,0xc5,0xa0,0x2e,0xed,0xe0,0x0b,0x37,0x25,0x3c,0x1b,0x3c,0x9b,0x3d,0xea,0xe2,0x00,0xc5,0x90,0x25,0x8b,0xa5,0x89,0xbd,0x88,0xa5,0x99,0xbd,0x98,0xa5,0xa9,0xbd,0xa8,0xa5,0xb9,0xc4,0x90,0xbd,0xb8,0xc4,0x10,0x3d,0xea,0xe2,0x00,0xc5,0x88,0x25,0x87,0xa5,0x89,0xbd,0x88,0xa5,0x99,0xc4,0x88,0xbd,0x98,0xc4,0x08,0x3d,0xea,0xe2,0x00,0xc5,0x84,0x25,0x85,0xe1,0x80,0xa5,0x99,0xe1,0x80,0xbd,0x98,0x3d,0xea,0xe2,0x00,0xc5,0x82,0x25,0x85,0xe1,0x80,0x9d,0x99,0xe1,0x80,0xb5,0x98,0xe2,0x00,0xc5,0x01,0x25,0x03,0x8c,0x89,0xac,0x88,0x38,0x82,0xc0,0x7c,0x78,0x81,0x3d,0xe9,0xe2,0x00,0xc5,0x81,0x25,0x86,0xe1,0x80,0x8d,0x99,0xc5,0x7f,0xe1,0x80,0xad,0x98,0x3d,0xe9,0xe2,0x00,0xc5,0x82,0x25,0x86,0xe1,0x80,0x9d,0x99,0xc5,0x7e,0xe1,0x80,0xb5,0x98,0xdf,0xa0,0x60,0x81,0xc0,0x04,0x38,0x82,0xe2,0x01,0xc4,0xff,0x00,0x84,0xe0,0x40,0xac,0x98,0xc5,0x7f,0xc4,0x01,0x2d,0x7c,0x38,0x82,0xc0,0x70,0x78,0x84,0x7a,0x03,0x7a,0x82,0x7b,0x01,0xe2,0x04,0x3c,0xc8,0xe2,0x00,0xc2,0x03,0x3e,0xe8,0x3d,0xe9,0x3e,0x6a,0x3f,0xe8,0x3f,0x69,0x2a,0x04,0xdf,0xd0,0xe0,0x01,0x00,0xcc,0xe2,0x00,0xcd,0x07,0xe0,0x01,0x05,0xc5,0x00,0x86,0xe0,0x40,0x8c,0x1e,0xc6,0x7f,0xe0,0x40,0xac,0x1f,0x3c,0x6f,0xe2,0x00,0xc4,0x03,0x3d,0xee,0x3a,0x6f,0xc7,0x01,0xc7,0x81,0x2c,0x74,0x3c,0x6b,0xe2,0x00,0xc4,0x03,0xe2,0x00,0xcc,0x01,0x3e,0xe4,0x01,0x0e,0xe2,0x00,0xcc,0x02,0x01,0x86,0xe1,0x80,0x9d,0x1b,0xc6,0x7e,0x14,0x10,0x00,0x90,0xe1,0x80,0x8d,0x1b,0xc6,0x7f,0x14,0x18,0x00,0x8b,0x3c,0xeb,0xe1,0x80,0x8d,0x19,0xc6,0x7d,0x9c,0x09,0xe4,0x0a,0x35,0x20,0x3d,0x48,0xc5,0x83,0x14,0x08,0x14,0xa0,0xe0,0x05,0x36,0x45,0x3c,0xa8,0x3f,0xe5,0x3f,0x6b,0x00,0xbc,0xa3,0x0e,0x35,0x38,0xe0,0x01,0x33,0x59,0xe0,0x0a,0x38,0xca,0xbd,0x04,0x33,0x38,0xc7,0xff,0xa5,0x1e,0xe0,0x01,0x35,0x59,0xe0,0x06,0x38,0xc6,0xbb,0x14,0x35,0x38,0xa3,0x2e,0xe0,0x01,0x33,0x59,0xe0,0x0a,0x38,0xca,0xbd,0x24,0x33,0x38,0xa5,0x3e,0xe0,0x01,0x35,0x59,0xe0,0x06,0x38,0xc6,0xbb,0x34,0x35,0x38,0xa3,0x4e,0xe0,0x01,0x33,0x59,0xe0,0x0a,0x38,0xca,0xbd,0x44,0x33,0x38,0xa5,0x5e,0xe0,0x01,0x35,0x59,0xe0,0x06,0x38,0xc6,0xbb,0x54,0x35,0x38,0xa3,0x6e,0xe0,0x01,0x33,0x59,0xe0,0x0a,0x38,0xca,0xbd,0x64,0x33,0x38,0xa5,0x7e,0xc7,0x20,0xe0,0x01,0x35,0x59,0xe0,0x06,0x38,0xc6,0xbb,0x74,0xc2,0x20,0x2f,0xc5,0xe0,0x0e,0x32,0xa5,0x3e,0x9e,0x3d,0x9e,0x3f,0x6c,0xe2,0x00,0xc7,0x10,0x27,0x1e,0xa7,0x0b,0x35,0x38,0xe0,0x0f,0x37,0x59,0x3d,0x4f,0xbd,0x0d,0x37,0x38,0xa5,0x1b,0xe0,0x0f,0x35,0x59,0xe0,0x0e,0x3f,0xce,0xbf,0x1d,0x35,0x38,0xa7,0x2b,0xe0,0x0f,0x37,0x59,0xe0,0x0a,0x3f,0xca,0xbd,0x2d,0x37,0x38,0xa5,0x3b,0xc5,0x90,0xe0,0x0f,0x35,0x59,0xe0,0x0e,0x3f,0xce,0xbf,0x3d,0xc6,0x90,0x3f,0x6c,0xe2,0x00,0xc7,0x08,0x27,0x11,0xa7,0x0b,0x35,0x38,0xe0,0x0f,0x37,0x59,0xe0,0x0a,0x3f,0xca,0xbd,0x0d,0x37,0x38,0xa5,0x1b,0xc5,0x88,0xe0,0x0f,0x35,0x59,0xe0,0x0e,0x3f,0xce,0xbf,0x1d,0xc6,0x88,0x3f,0x6c,0xe2,0x00,0xc7,0x04,0x27,0x0b,0xe0,0x0e,0x35,0x38,0xe1,0x80,0xa5,0x1b,0xe0,0x0f,0x35,0x59,0xe0,0x0e,0x3f,0xce,0xe1,0x80,0xbf,0x1d,0xe0,0x08,0x35,0x38,0x34,0xc3,0xbc,0x0d,0xe2,0x00,0xc6,0x03,0x3e,0x99,0x00,0x86,0xe0,0x40,0x8c,0x1b,0xc6,0x7f,0xe0,0x40,0xac,0x1d,0xc6,0x81,0xc5,0x81,0x2e,0x79,0x60,0x84,0x62,0x03,0x62,0x82,0x63,0x01,0xc0,0x10,0x38,0x82,0xe2,0x01,0xc6,0x7f,0xea,0x01,0x7e,0x94,0xe0,0x28,0xa6,0xfd,0xe2,0x07,0xc5,0xff,0xe4,0x0c,0x36,0x20,0x3e,0x4b,0xbe,0x1d,0x00,0x00,0xbd,0x2d,0x00,0x00,0xbc,0x8d,0x00,0x00,0x14,0x81,0xe0,0x08,0x34,0xb8,0xe8,0x00,0x64,0xc6,0xe0,0x08,0x3c,0xc8,0xe8,0x00,0x7c,0x46,0x38,0x82,0xc0,0x7c,0xea,0x01,0x7c,0x94,0xe0,0x28,0xa5,0x79,0xc5,0x0c,0xa4,0x8a,0xe2,0x00,0xc4,0x81,0x24,0x8e,0x14,0x81,0xe0,0x08,0x34,0xb8,0xe8,0x00,0x64,0xc6,0xe3,0x08,0x3c,0xd8,0xe8,0x00,0x7c,0x46,0xc0,0x04,0x38,0x82,0x64,0x81,0xc4,0x81,0x7c,0x81,0x64,0x81,0xe2,0x00,0xcc,0x84,0x02,0xeb,0x00,0xf9,0xc0,0x68,0x78,0x83,0x7a,0x02,0x7a,0x81,0xe8,0x00,0x66,0xc6,0x3a,0xec,0x16,0x01,0x36,0x38,0x3e,0x5d,0x3a,0x68,0xe2,0x01,0xc2,0xff,0x26,0x08,0x7c,0x86,0x7d,0x05,0x7d,0x84,0xdf,0xd2,0x65,0x84,0x65,0x05,0x64,0x86,0x3c,0x64,0x3e,0x65,0xdf,0xb1,0x3c,0x64,0xdf,0xca,0x60,0x83,0x62,0x02,0x62,0x81,0xc0,0x18,0x38,0x82,0xe0,0x00,0x1c,0x85,0xa4,0x39,0xc4,0x01,0xbc,0x39,0x14,0x00,0x38,0x82,0xe0,0x00,0x1c,0x0c,0x38,0x82,0xc0,0x7c,0x78,0x81,0xe0,0x01,0x9d,0x88,0x3c,0xe8,0xa4,0xb9,0xe0,0x00,0x1c,0x0c,0xe0,0x00,0x15,0x64,0xe1,0x2a,0x3d,0xda,0xef,0xff,0xde,0xb1,0x60,0x81,0xc0,0x04,0x38,0x82,0xc0,0x78,0x78,0x82,0x7a,0x01,0xe0,0x03,0x8d,0xa8,0xe0,0x00,0x1c,0x8b,0x35,0xab,0xe2,0xf0,0xc5,0x80,0xe1,0x00,0xcd,0x80,0xe0,0x0c,0x35,0xc8,0xae,0x69,0x15,0x00,0xad,0xf9,0xe0,0x01,0x95,0x88,0xc5,0x8c,0xe3,0xff,0xc5,0xff,0xe0,0x0c,0x35,0xc8,0xae,0x49,0xad,0xd9,0xa5,0xb8,0xe7,0xf0,0x14,0x00,0xe0,0x08,0x3d,0xd8,0xe4,0x0b,0x34,0x48,0xad,0x89,0xe4,0x0b,0x34,0x40,0xad,0x99,0x34,0x48,0xad,0x39,0xe0,0x01,0xad,0x09,0xe0,0x01,0xad,0x19,0xe0,0x01,0xad,0x29,0xe0,0x01,0xad,0x39,0xe0,0x01,0xad,0x49,0xe0,0x01,0xad,0x59,0xe0,0x01,0xad,0x69,0xe0,0x01,0xad,0x79,0xac,0x29,0xe0,0x00,0x1c,0x2d,0xa2,0x08,0x22,0x7f,0xe0,0x00,0x1c,0x8b,0x3c,0x64,0xe0,0x01,0x15,0x00,0xef,0xff,0xde,0x6b,0xe0,0x00,0x1c,0x2e,0xba,0x08,0x00,0x00,0xe0,0x00,0x1c,0x85,0xa4,0x39,0xc4,0x01,0xbc,0x39,0x14,0x00,0x60,0x82,0x62,0x01,0xc0,0x08,0x38,0x82,0xe0,0x00,0x1c,0x85,0xa4,0x39,0xc4,0x01,0xbc,0x39,0x14,0x00,0x38,0x82,0xc0,0x4c,0x78,0x86,0x79,0x05,0x79,0x84,0x7a,0x03,0x7a,0x82,0x7b,0x01,0x12,0x89,0xe0,0x00,0x1d,0xaf,0xe0,0x00,0x19,0x1d,0xe0,0x00,0x19,0xb0,0xe0,0x00,0x1b,0x05,0x00,0xba,0xa2,0x02,0x22,0x03,0xa4,0x04,0xbc,0x02,0x14,0x00,0xa4,0x83,0xbc,0x34,0x15,0x18,0xa4,0x26,0xbc,0xa4,0xc4,0x01,0xbc,0x26,0x3c,0x60,0xc4,0x20,0x7d,0x87,0xef,0xff,0xde,0x34,0x3c,0x64,0x3c,0xe0,0xc4,0x18,0xc4,0xa8,0x15,0x10,0xef,0xff,0xdd,0xc0,0xa4,0xa4,0x4c,0x20,0x65,0x87,0xe0,0x08,0x3c,0x98,0xbc,0x34,0x5c,0x11,0xe0,0x00,0x1c,0x8a,0xe0,0x01,0xb4,0x04,0xe2,0x00,0xcc,0x64,0x02,0x84,0xe0,0x00,0x1c,0x8c,0x3c,0x98,0xe0,0x03,0x8c,0x14,0xbc,0x94,0x34,0x23,0xe0,0x00,0x1c,0x8f,0x3c,0x19,0x14,0x80,0xbc,0x84,0xa4,0x88,0x24,0x84,0xa4,0x98,0xba,0x09,0x00,0x82,0xba,0x08,0xba,0x18,0xa4,0x0b,0x24,0x03,0xc2,0xff,0x2a,0xc4,0x14,0x00,0x60,0x86,0x61,0x05,0x61,0x84,0x62,0x03,0x62,0x82,0x63,0x01,0xc0,0x34,0x38,0x82,0xc0,0x78,0x78,0x82,0x7a,0x01,0xeb,0x82,0xca,0x02,0xa4,0x04,0xe2,0x00,0xc4,0x02,0x24,0x03,0xe0,0x00,0xd2,0x36,0xa4,0x04,0xe2,0x00,0xc4,0x01,0x24,0x03,0xe0,0x00,0xd3,0x19,0x14,0x00,0x60,0x82,0x62,0x01,0xc0,0x08,0x38,0x82,0xe4,0x0a,0x34,0x48,0xe4,0x09,0x34,0x28,0xe0,0x09,0x3d,0x49,0x3d,0x68,0xe3,0xfe,0xc5,0x00,0x35,0x28,0xea,0x01,0xc4,0x7f,0x3c,0xca,0x34,0x48,0xe0,0x08,0x3c,0xc8,0x38,0x82,0xa4,0xa8,0x24,0x8a,0xe7,0xf0,0x15,0x00,0x3c,0xda,0xe0,0x00,0x1d,0x31,0xbc,0x8a,0x00,0x00,0x14,0x80,0xbc,0xa8,0xe0,0x00,0x1c,0x9d,0xa5,0x09,0xbd,0x08,0xbc,0x09,0x38,0x82,0xe2,0x00,0xcc,0x03,0x01,0x11,0xe0,0x00,0x1c,0x8d,0xe0,0x01,0xa5,0x79,0xe0,0x01,0xa5,0xe9,0xe0,0x0c,0x3d,0xca,0x26,0x24,0xa6,0x39,0xa4,0xa9,0x3d,0xf9,0x02,0xa0,0x01,0x83,0x3d,0x7c,0x02,0x9d,0xe0,0x00,0x1c,0x0d,0xa4,0x48,0xe0,0x07,0x94,0xc8,0xe3,0xff,0xc4,0xfe,0xe0,0x07,0xb4,0xc8,0xe0,0x00,0x1c,0xb2,0xa5,0x89,0xe0,0x00,0x1d,0x32,0x25,0xfd,0xe0,0x00,0x1c,0xb3,0xbc,0x09,0xa4,0x0a,0x24,0x7f,0xe0,0x00,0x1c,0x0d,0x84,0xc8,0xe2,0x01,0xc4,0xef,0xac,0xc8,0x14,0x83,0x00,0x87,0xe2,0x00,0xcc,0x02,0xe0,0x00,0x1c,0x0d,0x01,0x84,0x14,0x84,0xac,0xd8,0x38,0x82,0x8c,0xd8,0xe2,0x00,0xcc,0x81,0x01,0xaa,0xe0,0x01,0xa4,0x98,0xe0,0x01,0xa5,0x08,0xe0,0x0b,0x3d,0x49,0x25,0x8f,0xa4,0x48,0x16,0x00,0xe0,0x03,0xa5,0xc8,0xe0,0x03,0xa4,0x78,0xc5,0x80,0x3d,0xfa,0xe0,0x28,0x3e,0x78,0x02,0x94,0x01,0x83,0x3c,0x79,0x02,0x91,0xe0,0x00,0x1c,0x0d,0xe0,0x01,0xa4,0xd8,0xe0,0x01,0xa5,0x48,0xe0,0x0b,0x3d,0x49,0x25,0x8c,0xa5,0xb8,0xa4,0x28,0x3d,0x78,0x02,0x88,0x01,0x83,0x3c,0xfb,0x02,0x85,0xe0,0x00,0x1c,0x0d,0x14,0x84,0xac,0xd8,0x38,0x82,0xe0,0x00,0x1c,0xa3,0xbc,0x88,0x14,0x00,0x38,0x82,0xe0,0x00,0x1c,0x98,0xbc,0x88,0x14,0x00,0x38,0x82,0xc0,0x7c,0x78,0x81,0x3d,0x68,0xe0,0x00,0xc5,0x60,0x3c,0x69,0x3c,0xea,0xe0,0x00,0x15,0x50,0xef,0xff,0xdc,0x73,0x14,0x00,0x60,0x81,0xc0,0x04,0x38,0x82,0xc0,0x64,0x78,0x86,0x79,0x05,0x79,0x84,0x7a,0x03,0x7a,0x82,0x7b,0x01,0x3a,0x68,0xe0,0x00,0x1c,0x1a,0xa1,0x08,0xa4,0x48,0xe2,0x00,0xcc,0x01,0x01,0x85,0xe0,0x00,0x1c,0x04,0x14,0x80,0xbc,0x88,0xe0,0x03,0x8c,0x44,0xe0,0x00,0x1c,0x8d,0xc4,0x02,0x34,0x22,0xe0,0x08,0x3a,0x18,0xa4,0x68,0xdf,0xd5,0xe0,0x00,0x1c,0x0d,0x8c,0x48,0xe2,0x00,0xc4,0x10,0x2c,0x08,0xe0,0x00,0x1c,0x83,0xa4,0x09,0xcc,0x04,0xbc,0x09,0x3c,0x64,0xdf,0x48,0xe0,0x03,0x8c,0x44,0xa3,0x34,0xe0,0x08,0x3a,0x18,0xe0,0x03,0x8c,0x58,0xe0,0x01,0x99,0x84,0x3b,0x18,0x39,0xa8,0xe0,0x08,0x3b,0x13,0xe2,0x08,0x3c,0x46,0xe4,0x08,0x34,0x40,0xe0,0x00,0x1a,0x92,0x24,0x11,0x3c,0x66,0xdf,0x21,0xbc,0x65,0xbc,0x05,0x3c,0x66,0xe1,0xff,0xcc,0x7f,0x3c,0x26,0xc4,0x01,0xdf,0x19,0xbc,0x75,0x3b,0x18,0xbc,0x15,0x39,0xa8,0xe0,0x00,0x1a,0x91,0x3c,0x66,0xdf,0x11,0xbc,0x65,0x13,0x00,0xbc,0x05,0x3c,0x63,0xdf,0x0c,0xbc,0x75,0x15,0x30,0xbc,0x15,0xe0,0x01,0xbb,0x05,0xbb,0x25,0xe0,0x01,0xbb,0x15,0xbb,0x35,0xe0,0x00,0x1a,0x9a,0xe0,0x00,0x1c,0x92,0xa1,0xf5,0x3c,0x63,0xef,0xff,0xdc,0x09,0xe0,0x02,0xa4,0x22,0xbb,0x08,0x00,0x00,0x3c,0x63,0xe0,0x02,0xa4,0x82,0x7c,0x87,0xde,0xf2,0x64,0x87,0xbc,0x09,0x00,0x00,0x3c,0x63,0xe0,0x02,0xa4,0x92,0xc4,0x18,0x7c,0x87,0xde,0xe9,0x64,0x87,0xbc,0x09,0x00,0x00,0xe0,0x00,0x1c,0x0d,0xe0,0x02,0xa1,0x42,0xa4,0x48,0xde,0xe0,0xbc,0x02,0x00,0x00,0xa4,0x45,0xa4,0xf5,0xc4,0x7f,0xa5,0xe5,0xbc,0x45,0x3c,0x69,0xa5,0x55,0x3c,0xfb,0xc4,0x30,0xe0,0x68,0x39,0x2a,0xbc,0x75,0xe0,0x00,0x1c,0x0f,0xbb,0x04,0xa4,0xe8,0x24,0x84,0xa4,0xf8,0xba,0x09,0x00,0x82,0xba,0x68,0xba,0x78,0x60,0x86,0x61,0x05,0x61,0x84,0x62,0x03,0x62,0x82,0x63,0x01,0xc0,0x1c,0x38,0x82,0xc0,0x60,0x78,0x86,0x79,0x05,0x79,0x84,0x7a,0x03,0x7a,0x82,0x7b,0x01,0x3a,0x68,0xe0,0x00,0x1c,0x1a,0xa1,0x08,0xe0,0x01,0xa4,0x08,0xe2,0x00,0xcc,0x01,0x01,0x85,0xe0,0x00,0x1c,0x04,0x14,0x80,0xbc,0x88,0xe0,0x03,0x8c,0x44,0xe0,0x00,0x1c,0x8d,0xc4,0x02,0x34,0x22,0xe0,0x08,0x3a,0x18,0xa4,0x68,0xdf,0x33,0xe0,0x00,0x1c,0x0d,0x8c,0x48,0xe2,0x00,0xc4,0x10,0x2c,0x11,0xe0,0x00,0x1c,0x83,0xa4,0x09,0xcc,0x04,0xbc,0x09,0xe0,0x03,0x8c,0x04,0xe2,0x00,0xc4,0x04,0x24,0x04,0x3c,0x64,0xde,0xa1,0x00,0x84,0x3c,0x64,0xef,0xff,0xde,0x19,0xe0,0x03,0x8c,0x44,0xa3,0x34,0xe0,0x08,0x3a,0x18,0xe0,0x03,0x8c,0x58,0xe0,0x01,0x99,0x84,0x3b,0x18,0x39,0xa8,0xe0,0x08,0x3b,0x13,0xe2,0x08,0x3c,0x46,0xe4,0x08,0x34,0x40,0xe0,0x00,0x1a,0x92,0x24,0x11,0x3c,0x66,0xde,0x76,0xbc,0x65,0xbc,0x05,0x3c,0x66,0xe1,0xff,0xcc,0x7f,0x3c,0x26,0xc4,0x01,0xde,0x6e,0xbc,0x75,0x3b,0x18,0xbc,0x15,0x39,0xa8,0xe0,0x00,0x1a,0x91,0x3c,0x66,0xde,0x66,0xbc,0x65,0x3b,0x13,0xbc,0x05,0x3c,0x63,0xde,0x61,0x3d,0x66,0x3c,0xe6,0xe0,0x00,0xc5,0x7f,0xc4,0xff,0xe2,0x09,0x3d,0x49,0xbc,0x15,0xe4,0x09,0x34,0xc0,0x24,0xa2,0x3c,0xe6,0xe1,0xff,0xcc,0xff,0x3c,0xa6,0x7c,0x88,0xc4,0x81,0x24,0x88,0xe0,0x08,0x3c,0x93,0x7c,0x87,0xde,0x4b,0xbc,0x75,0x64,0x87,0x00,0x82,0xbc,0x75,0x14,0x00,0xbc,0x25,0xbc,0x35,0xe0,0x08,0x3b,0x19,0xde,0x41,0xe0,0x01,0xbc,0x05,0xe0,0x00,0x14,0x7f,0x64,0x88,0x3c,0x29,0xde,0x3a,0xe0,0x01,0xbc,0x15,0x3c,0x65,0xc4,0x10,0x00,0x8c,0x3c,0x63,0xe0,0x01,0xc4,0x00,0x7c,0x87,0xde,0x30,0x64,0x87,0xbc,0x75,0x3c,0x65,0xbc,0xa5,0xc4,0x08,0xbc,0xb5,0xe0,0x00,0x1a,0x9a,0x13,0x00,0xbb,0x68,0x15,0x30,0xbb,0x78,0xe0,0x01,0xa1,0xb5,0xe0,0x00,0x1c,0x92,0x3c,0x63,0xef,0xff,0xdb,0x2b,0xe0,0x01,0xa4,0x22,0xbb,0x08,0x00,0x00,0x3c,0x63,0xe0,0x01,0xa4,0x82,0x7c,0x87,0xde,0x14,0x64,0x87,0xbc,0x09,0x00,0x00,0x3c,0x63,0xe0,0x01,0xa4,0x92,0xc4,0x18,0x7c,0x87,0xde,0x0b,0x64,0x87,0xbc,0x09,0x00,0x00,0xe0,0x00,0x1c,0x0d,0xe0,0x01,0xa1,0x42,0xa4,0x48,0xde,0x02,0xbc,0x02,0x00,0x00,0xe0,0x01,0xa4,0x05,0xe0,0x01,0xa4,0xb5,0xc4,0x7f,0xe0,0x01,0xa5,0xa5,0xe0,0x01,0xbc,0x05,0x3c,0x69,0xe0,0x01,0xa5,0x15,0x3c,0xfb,0xc4,0x30,0xe0,0x68,0x39,0x2a,0xe0,0x01,0xbc,0x35,0xe0,0x00,0x1c,0x0f,0xbb,0x04,0xe0,0x01,0xa4,0x88,0x24,0x85,0xe0,0x01,0xa4,0x98,0xba,0x09,0x00,0x83,0xe0,0x01,0xba,0x08,0xe0,0x01,0xba,0x18,0x60,0x86,0x61,0x05,0x61,0x84,0x62,0x03,0x62,0x82,0x63,0x01,0xc0,0x20,0x38,0x82,0xc0,0x58,0x78,0x86,0x79,0x05,0x79,0x84,0x7a,0x03,0x7a,0x82,0x7b,0x01,0xe0,0x00,0x1c,0x1a,0x11,0x08,0xa4,0x88,0xe0,0x00,0x19,0x9d,0x7c,0x88,0xeb,0x82,0xcc,0x82,0xa5,0x09,0xe0,0x01,0x00,0xc7,0x64,0x08,0xe0,0x01,0xa2,0x68,0x14,0x01,0xdd,0xc0,0xbc,0x04,0x00,0x00,0x64,0x88,0xe0,0x01,0xa4,0x79,0xa4,0x08,0xdd,0xb9,0xe0,0x00,0x1c,0x9a,0x7c,0x09,0xe0,0x01,0xa4,0x09,0xc4,0x01,0xe0,0x01,0xbc,0x09,0xe0,0x00,0x1c,0x0f,0xe0,0x01,0xa2,0x08,0x22,0x06,0xa4,0x04,0xe0,0x00,0x1c,0x8f,0xe0,0x01,0xbc,0x09,0xe0,0x03,0x8c,0x44,0xe0,0x00,0x1c,0x8d,0xc4,0x02,0x34,0x22,0xe0,0x08,0x3a,0x18,0xa4,0x68,0x7c,0x0a,0xde,0x2d,0xe0,0x00,0x1c,0x0d,0x8c,0x48,0x3c,0xe8,0xe2,0x00,0xc4,0x90,0x2c,0x85,0x3c,0x64,0xdd,0xa4,0xe0,0x01,0x00,0x8f,0xe0,0x03,0x8c,0xc4,0x63,0x09,0xe0,0x0a,0x3a,0x19,0xea,0x1e,0xc3,0x00,0xc4,0xff,0xe0,0x03,0xac,0xc4,0xe4,0x06,0x33,0x48,0x14,0x82,0xe1,0x29,0x3b,0x09,0xe0,0x03,0x8d,0xda,0x24,0x91,0x23,0x10,0xe2,0x00,0xcb,0x07,0x01,0x84,0xe2,0x00,0xc4,0x20,0x2c,0x0a,0xe0,0x00,0x1c,0x83,0xa4,0x09,0xcc,0x04,0xbc,0x09,0x3c,0x64,0xdd,0x82,0xe0,0x00,0x00,0xd5,0xe0,0x00,0x1a,0x8d,0xe0,0x01,0x9c,0x45,0xe0,0x00,0x24,0x4d,0xa4,0xa4,0x8d,0x15,0x3c,0x69,0xc5,0x18,0xc4,0x78,0x3d,0x1b,0xef,0xff,0xda,0x6f,0xa4,0x24,0xa4,0xb4,0xc4,0x78,0xbc,0x24,0x3c,0x69,0xc4,0x78,0xbc,0x34,0xe0,0x01,0x94,0x04,0xc4,0x08,0xe0,0x01,0xb4,0x04,0x8c,0x05,0xe2,0x00,0xcc,0x01,0x01,0x99,0xe0,0x01,0x95,0x45,0xe0,0x40,0x9c,0x69,0xe0,0x01,0xb5,0x49,0xc4,0x08,0xe0,0x01,0x95,0x55,0xe3,0xff,0xc4,0x7f,0xe0,0x01,0xb5,0x59,0x15,0x00,0xe0,0x01,0xb5,0x79,0x15,0x11,0xe0,0x01,0xb4,0x69,0xe0,0x41,0xad,0x29,0xe0,0x40,0xb4,0x69,0x00,0x9c,0xe0,0x01,0x94,0x45,0xb4,0x29,0xe0,0x01,0x94,0x55,0xb4,0x39,0x64,0x09,0xe3,0xff,0xc4,0x7f,0x3d,0x68,0xc5,0x74,0xb5,0x49,0x15,0x00,0xb5,0x59,0x15,0x11,0xe0,0x40,0xb4,0x79,0x3c,0x69,0xe0,0x40,0xad,0x79,0xc4,0x70,0x7c,0x87,0xef,0xff,0xda,0x1a,0x64,0x87,0xe0,0x40,0xb4,0x39,0x3c,0x64,0xde,0x5d,0xe0,0x00,0x1c,0x0d,0x14,0x84,0x8c,0x58,0xe0,0x29,0x3c,0x09,0x2c,0x85,0x14,0x81,0xe0,0x28,0x3c,0x09,0x24,0x03,0x3c,0x66,0xdd,0x31,0x64,0x0a,0xe0,0x00,0x1c,0x8d,0xe0,0x00,0xc4,0x60,0x15,0x10,0xef,0xff,0xda,0x15,0xa4,0x03,0xbc,0x04,0xba,0x03,0xeb,0x82,0xcc,0x02,0xa5,0x08,0xc1,0x7f,0xe2,0x00,0xc5,0x02,0x25,0x06,0x14,0x00,0xe1,0x28,0x39,0x08,0xe7,0xfe,0x2c,0x35,0x14,0x00,0x60,0x86,0x61,0x05,0x61,0x84,0x62,0x03,0x62,0x82,0x63,0x01,0xc0,0x28,0x38,0x82,0xc0,0x54,0x78,0x86,0x79,0x05,0x79,0x84,0x7a,0x03,0x7a,0x82,0x7b,0x01,0xe0,0x00,0x1c,0x1a,0x12,0x88,0xa4,0x88,0x7c,0x89,0xeb,0x82,0xcc,0x82,0xa5,0x09,0x7a,0x88,0xe0,0x01,0x00,0xa3,0x64,0x09,0xe0,0x02,0xa2,0x68,0x14,0x01,0xdc,0xd8,0xbc,0x04,0x00,0x00,0x64,0x89,0xe0,0x02,0xa4,0x79,0xa4,0x08,0xdc,0xd1,0xe0,0x00,0x1c,0x9a,0x3b,0x68,0xa4,0x49,0xc4,0x01,0xbc,0x49,0xe0,0x00,0x1c,0x0f,0xa2,0x68,0x22,0x05,0xa4,0x04,0xe0,0x00,0x1c,0x8f,0xbc,0x69,0xe0,0x03,0x8c,0x44,0xe0,0x00,0x1c,0x8d,0xc4,0x02,0x34,0x22,0xe0,0x08,0x3a,0x18,0xa4,0x68,0xdd,0x4a,0xe0,0x00,0x1c,0x0d,0x8c,0x48,0xe2,0x00,0xc4,0x10,0x2c,0x05,0x3c,0x64,0xdc,0xc2,0xe0,0x00,0x00,0xef,0xe0,0x03,0x8c,0x44,0xea,0x1e,0xc3,0x00,0x3c,0xe8,0xc4,0x82,0x34,0xa2,0xe0,0x09,0x3a,0x19,0xa4,0xe9,0xe4,0x06,0x33,0x48,0x7c,0x8b,0xe0,0x09,0x3a,0x18,0xc4,0x01,0xe0,0x03,0xac,0x44,0x14,0x02,0xe1,0x28,0x3b,0x08,0xe0,0x03,0x89,0xd9,0x24,0x05,0x23,0x04,0x3c,0x64,0xdc,0xa5,0x00,0xbd,0xa4,0x14,0x14,0xfc,0xc4,0x03,0xe0,0x09,0x3c,0x59,0xe0,0x00,0x1a,0x8d,0x7c,0x8a,0xef,0xff,0xdb,0xb1,0x8c,0x85,0xe0,0x00,0x11,0x68,0xe2,0x00,0xcc,0x81,0xe0,0x00,0x14,0xc0,0xe0,0x62,0x39,0xa9,0xa4,0xb4,0x3d,0x62,0x7c,0x07,0xef,0xff,0xd9,0x89,0x8c,0x25,0x65,0x87,0xe2,0x00,0xcc,0x01,0x01,0x8e,0x8d,0x15,0xe0,0x0c,0x39,0x23,0xe0,0x09,0x39,0x9a,0xe0,0x08,0x3d,0x93,0xe0,0x09,0x3d,0x99,0xe0,0x0a,0x3e,0x2a,0xef,0xff,0xda,0x51,0xe0,0x00,0x1a,0x8d,0x64,0x8a,0x8c,0x15,0x39,0x28,0xac,0x49,0x3c,0x64,0xa9,0x59,0xef,0xff,0xdb,0x9b,0xa4,0x25,0xa5,0x35,0xc4,0x00,0x14,0x81,0xe0,0x29,0x3d,0x79,0xbc,0xb5,0xbc,0x25,0xe0,0x00,0x1c,0x0d,0x14,0x84,0x8c,0x58,0xe0,0x29,0x3c,0x09,0x2c,0x85,0x14,0x81,0xe0,0x28,0x3c,0x09,0x24,0x03,0x3c,0x66,0xdc,0x6c,0x64,0x0b,0xe0,0x00,0x1c,0x8d,0xe0,0x00,0xc4,0x60,0x15,0x10,0xef,0xff,0xd9,0x50,0x64,0x08,0xeb,0x82,0xcc,0x82,0xc4,0x7f,0xa5,0x09,0x7c,0x08,0xe2,0x00,0xc5,0x01,0x25,0x04,0x64,0x88,0xe7,0xfe,0x2c,0xdb,0x14,0x00,0x60,0x86,0x61,0x05,0x61,0x84,0x62,0x03,0x62,0x82,0x63,0x01,0xc0,0x2c,0x38,0x82,0xe0,0x01,0x9e,0x98,0xa6,0x38,0x3d,0xed,0xc5,0x8e,0xe3,0xff,0xc5,0xff,0x3d,0x6b,0xc5,0x7e,0xe0,0x0a,0x3e,0x1a,0x97,0x0a,0xe3,0xff,0xc4,0xff,0xe3,0x02,0xcf,0x00,0x01,0x89,0x3d,0xed,0xc5,0x92,0xe3,0xff,0xc5,0xff,0x3d,0x6b,0xc5,0x7e,0xe0,0x0a,0x3e,0x1a,0x96,0x8a,0xe3,0x10,0xce,0xe4,0x01,0x9c,0xc5,0x88,0xe3,0xff,0xc5,0xff,0x3d,0x6b,0xc5,0x7e,0xe0,0x0a,0x3e,0x1a,0x2c,0x83,0x14,0xa1,0x00,0x86,0xe2,0x00,0xcc,0x81,0x01,0x84,0xe0,0x00,0x14,0xd7,0xb4,0x8a,0xe0,0x01,0x94,0x88,0xe0,0x01,0x94,0x18,0xe0,0x08,0x3c,0x98,0xc4,0x02,0x3c,0x2b,0xe0,0x40,0xb4,0x1a,0x00,0x8a,0xe0,0x10,0x14,0x00,0x24,0x86,0xe2,0x00,0xcc,0x81,0x01,0x84,0xe7,0x0d,0x14,0x5d,0xb4,0x0a,0x14,0x00,0x38,0x82,0xe0,0x01,0x9e,0x18,0xa5,0xb8,0x3c,0xec,0xc4,0x8e,0xe3,0xff,0xc4,0xff,0x3d,0x69,0xc5,0x7e,0xe0,0x0a,0x3d,0x9a,0x96,0x8a,0xe3,0x02,0xce,0x80,0x01,0x89,0x3c,0xec,0xc4,0x92,0xe3,0xff,0xc4,0xff,0x3d,0x69,0xc5,0x7e,0xe0,0x0a,0x3d,0x9a,0x96,0x8a,0xe3,0x10,0xce,0xe4,0x01,0x8f,0xe0,0x01,0x96,0x88,0xc4,0x88,0xe3,0xff,0xc4,0xff,0x3d,0x69,0x3e,0x1d,0xc5,0x7e,0xc6,0x02,0xe0,0x0a,0x3d,0x9a,0x3e,0x29,0xe0,0x40,0xb6,0x1a,0x9d,0x0a,0xe0,0x00,0x16,0x57,0xe0,0x2c,0x3d,0x0c,0x2e,0x06,0xe1,0x0d,0x16,0x5d,0xe0,0x2a,0x3d,0x0c,0x25,0x10,0x3d,0x99,0x8d,0x6b,0xe2,0x00,0xcd,0x04,0x01,0x8b,0xe0,0x01,0x95,0x08,0xe0,0x01,0x94,0x18,0xe0,0x08,0x3d,0x18,0xc4,0x58,0xe0,0x09,0x3c,0x29,0xb4,0xab,0x14,0x00,0x38,0x82,0x38,0x82,0xc0,0x50,0x78,0x86,0x79,0x05,0x79,0x84,0x7a,0x03,0x7a,0x82,0x7b,0x01,0x39,0x68,0xef,0xff,0xda,0xc2,0xa4,0xb2,0xe0,0x01,0x9d,0x02,0x39,0xe8,0xef,0xff,0xd8,0xb6,0xe0,0x01,0x9a,0xe2,0xe0,0x02,0x9a,0x12,0x3c,0x65,0xef,0xff,0xd8,0x1d,0x3b,0x68,0xe0,0x04,0x24,0x30,0x3c,0x65,0xef,0xff,0xd7,0x27,0x3a,0xe8,0xe0,0x04,0x24,0x2a,0xa4,0xa6,0x24,0x87,0xe0,0x00,0x1c,0x16,0xe0,0x02,0x15,0x50,0xef,0xff,0xd8,0x9e,0xe0,0x00,0x1c,0x15,0xe0,0x04,0x39,0x94,0x8c,0x08,0x2c,0x08,0xe0,0x00,0x1c,0x14,0x8c,0x08,0xe2,0x00,0xcc,0x03,0xe0,0x00,0x01,0xcf,0xe0,0x03,0x8c,0x22,0xe0,0x00,0x2c,0x4b,0xe0,0x01,0x9c,0x22,0xe2,0x00,0xc4,0x10,0xe0,0x00,0x2c,0x45,0xe0,0x01,0x8d,0x04,0xe0,0x01,0x8c,0x94,0xe0,0x01,0x8c,0x24,0xe4,0x0a,0x35,0x28,0xe4,0x09,0x34,0xa0,0x3c,0xca,0x34,0x28,0x3c,0x49,0xe0,0x01,0x8c,0xb4,0xe0,0x08,0x3c,0xc8,0xe0,0x01,0xa4,0xd6,0x3c,0xf8,0x01,0xaf,0x8c,0x24,0x8d,0x34,0x34,0x28,0xe0,0x03,0x9c,0xc6,0xe0,0x08,0x3d,0x48,0x3c,0xf8,0x01,0xa6,0x8d,0x44,0x8c,0xd4,0x8c,0x64,0xe4,0x0a,0x35,0x28,0xe4,0x09,0x34,0xa0,0x3c,0xca,0x34,0x28,0x3c,0x49,0x8c,0xf4,0xe0,0x08,0x3c,0xc8,0xe0,0x01,0xa4,0xc6,0x3c,0xf8,0x01,0x95,0xe0,0x01,0x8c,0x44,0xe2,0x00,0xcc,0x56,0x01,0x90,0xe0,0x01,0x8c,0x54,0xe2,0x00,0xcc,0x50,0x01,0x8b,0xe0,0x01,0x8c,0x64,0xe2,0x00,0xcc,0x4e,0x01,0x86,0x3c,0x62,0xef,0xff,0xd7,0xad,0xe0,0x04,0x00,0xfa,0x16,0x00,0xe0,0x03,0x22,0x15,0x84,0x04,0xe2,0x00,0xc4,0x03,0xe2,0x00,0xcc,0x02,0x01,0x08,0xe0,0x05,0xa4,0x05,0xc4,0x01,0xe0,0x05,0xbc,0x05,0xe0,0x03,0x00,0x88,0xe0,0x00,0x1c,0x9e,0x8c,0x14,0x8d,0x09,0x15,0x81,0x34,0x41,0x7d,0x8a,0x3c,0x7a,0x04,0x05,0x8c,0x99,0xe0,0x29,0x3c,0x19,0x7c,0x8a,0xe0,0x02,0xa4,0x35,0xe0,0x02,0xbc,0x25,0xe0,0x0b,0x9c,0x45,0xe2,0x00,0xcc,0x01,0x01,0xa5,0x8d,0x24,0x8c,0x34,0x35,0x28,0xe0,0x0a,0x3c,0x4a,0xe0,0x02,0xb5,0x36,0x14,0x00,0xe0,0x05,0xb5,0x75,0xe0,0x02,0xbc,0x16,0xe0,0x05,0xbc,0x15,0xe0,0x0b,0xb4,0x45,0xe0,0x01,0x8d,0x84,0xe0,0x01,0x8c,0x14,0xe0,0x01,0x8c,0xa4,0xe4,0x0b,0x35,0xa8,0xe4,0x08,0x34,0x20,0x3c,0x4b,0x34,0xa8,0xe0,0x01,0x8d,0xb4,0x3c,0xc8,0xe0,0x09,0x3d,0xc9,0x3c,0x66,0x15,0x81,0x00,0x99,0xe0,0x01,0x8d,0x04,0xe0,0x01,0x8c,0x14,0xe4,0x0a,0x35,0x28,0xe4,0x08,0x34,0x20,0xe0,0x01,0x8c,0xa4,0x3c,0x4a,0x8d,0x24,0x8d,0xb4,0x34,0xa8,0xe0,0x01,0x8e,0x34,0x3c,0xc8,0x35,0x28,0xe0,0x0a,0x3d,0xca,0x3c,0x66,0xe0,0x09,0x3e,0x49,0x15,0x80,0xef,0xff,0xd6,0xd2,0x39,0xe8,0x2c,0x17,0x3c,0x65,0xe0,0x00,0xc4,0x48,0x14,0x83,0xef,0xff,0xd7,0x6b,0x8c,0x24,0x8c,0xb4,0x34,0x28,0xe0,0x08,0x3c,0xc8,0xe0,0x05,0xb4,0x75,0x3c,0x66,0xc4,0x28,0xef,0xff,0xd7,0xb7,0x15,0x80,0x16,0x00,0x7d,0x89,0xe0,0x01,0x00,0x96,0x8c,0x24,0x8c,0xb4,0x34,0x28,0xe0,0x08,0x3c,0xc8,0xe0,0x03,0x94,0xc6,0xe2,0x00,0xc9,0x86,0x3c,0x29,0xe0,0x43,0x3c,0x18,0x7c,0x09,0x8c,0xc4,0x8c,0x54,0x8d,0xe4,0xe4,0x09,0x34,0xa8,0xe4,0x08,0x34,0x20,0x3c,0x49,0x35,0xa8,0x3d,0xc8,0x8c,0x74,0xe0,0x0b,0x3c,0x4b,0xe0,0x01,0xa4,0x46,0x3d,0xa8,0x3e,0x6b,0x01,0x86,0xe0,0x03,0xa4,0x45,0xc4,0x01,0xe0,0x03,0xbc,0x45,0x14,0x02,0xe0,0x28,0x39,0x88,0x2c,0x05,0x14,0x05,0xe0,0x28,0x39,0x88,0x24,0x06,0xe0,0x05,0xa4,0x25,0xc4,0x01,0xe0,0x05,0xbc,0x25,0xe2,0x00,0x7c,0x2c,0x7d,0x88,0x7e,0x07,0xef,0xff,0xd7,0x7b,0x14,0x00,0xe0,0x02,0xbc,0x35,0x3c,0x66,0xc4,0x28,0xe2,0x00,0x7c,0xac,0x15,0x08,0xef,0xff,0xd8,0x4d,0x14,0x04,0xe0,0x28,0x39,0x88,0x65,0x88,0x66,0x07,0x2c,0x08,0x14,0x01,0xe0,0x28,0x39,0x88,0x2c,0x04,0xe2,0x00,0xc9,0x83,0x01,0xae,0x64,0x0a,0xe2,0x00,0xcc,0x01,0x01,0xaa,0x35,0xc3,0xe0,0x09,0x35,0xa7,0xe0,0x08,0x35,0xa2,0xe0,0x08,0x3c,0xa8,0xe0,0x0b,0x3c,0x1b,0xe0,0x02,0xa4,0x35,0x35,0xa3,0xe0,0x0a,0x3d,0xa8,0x3c,0x7b,0xe0,0x09,0x3c,0x2b,0xe0,0x69,0x3d,0xaa,0xe0,0x04,0xa5,0x15,0x3c,0x6a,0xc4,0x08,0x34,0x44,0xe0,0x08,0x3d,0x28,0x3c,0x19,0xe0,0x03,0xa4,0xf5,0xe0,0x04,0xbc,0x15,0x3c,0x79,0x03,0x83,0xe0,0x03,0xbc,0x75,0xe0,0x04,0xa4,0x85,0x3c,0x79,0x05,0x83,0xe0,0x04,0xbc,0x05,0xe0,0x02,0xa4,0x35,0xe0,0x04,0xa4,0xb5,0x3c,0x79,0x03,0x83,0xe0,0x04,0xbc,0x35,0xe0,0x04,0xa4,0xc5,0x3c,0x79,0x05,0x83,0xe0,0x04,0xbc,0x45,0xe0,0x04,0xa4,0xd5,0xe0,0x04,0xa5,0x65,0xc4,0x80,0xe0,0x28,0x3c,0x7a,0xe0,0x04,0xbc,0x65,0xe0,0x04,0xbc,0xd5,0x15,0x87,0xe0,0x2b,0x39,0x8b,0x2d,0x84,0xe0,0x28,0x39,0x8b,0x24,0x0c,0x3c,0x65,0xe0,0x00,0xc4,0x64,0x3c,0xe4,0x15,0x0c,0x7d,0x88,0x7e,0x07,0xef,0xff,0xd7,0xea,0x66,0x07,0x65,0x88,0x14,0x03,0xe0,0x28,0x39,0x88,0x2c,0x02,0x25,0x8f,0x8c,0x24,0x8c,0xb4,0x34,0x28,0xe0,0x08,0x3c,0xc8,0xe0,0x05,0xb4,0x75,0x14,0x00,0xe0,0x02,0xbc,0x65,0xe0,0x02,0xbc,0x16,0xe0,0x05,0xbc,0x15,0x3c,0x63,0xc4,0x7b,0xe3,0xff,0xc4,0x7f,0x14,0x81,0xe1,0x28,0x3c,0x19,0x24,0x2c,0x14,0x02,0xe1,0x23,0x39,0x88,0x21,0xa8,0x8c,0x24,0x8c,0xb4,0x34,0x28,0xe0,0x08,0x3c,0xc8,0xe0,0x02,0xa4,0xe5,0xe0,0x03,0xb4,0x46,0xc4,0x81,0xe0,0x02,0xbc,0xe5,0xe0,0x05,0xb4,0x65,0xe0,0x05,0x9c,0xf5,0x24,0x8b,0x3c,0x79,0x04,0x83,0x3c,0x29,0x00,0x87,0xe2,0x00,0x15,0x00,0xe0,0x09,0x3d,0x29,0xe0,0x08,0x3c,0x98,0xc4,0x01,0xe0,0x04,0xbc,0x75,0xe0,0x02,0xa4,0x16,0xe0,0x09,0x9c,0xf5,0xe0,0x05,0xbc,0x15,0x3c,0x98,0xe0,0x04,0xbc,0xf5,0x8d,0x44,0x8c,0xd4,0x8c,0x64,0xe4,0x0a,0x35,0x28,0xe4,0x09,0x34,0xa0,0x3c,0xca,0x34,0x28,0x3c,0x49,0x8c,0xf4,0xe0,0x08,0x3c,0xc8,0xe0,0x01,0xbc,0x46,0xe0,0x01,0x8d,0x84,0xe0,0x01,0x8d,0x14,0xe0,0x01,0x8c,0xa4,0xe4,0x0b,0x35,0xa8,0xe4,0x0a,0x35,0x20,0x3d,0x4b,0x34,0xa8,0x3c,0xca,0xe0,0x01,0x8d,0x34,0xe0,0x09,0x3d,0x49,0xe0,0x01,0xbc,0xd6,0xe0,0x03,0xbc,0x05,0xe0,0x02,0xa4,0x55,0xc4,0x01,0xe0,0x02,0xbc,0x55,0xe0,0x03,0xa4,0x55,0xc4,0x01,0xe0,0x03,0xbc,0x55,0x9c,0x76,0x7e,0x07,0xef,0xff,0xd5,0x28,0x39,0xe8,0x66,0x07,0x24,0x2a,0xe0,0x08,0x8c,0x48,0xe2,0x00,0xcc,0x01,0x01,0x99,0xe0,0x02,0x8c,0x26,0x24,0x1f,0x14,0x00,0xe0,0x02,0xac,0x26,0xa4,0x56,0xeb,0xff,0xc4,0x7f,0x24,0x18,0xe0,0x01,0xa6,0x06,0x26,0x18,0x15,0x81,0xe0,0x02,0x8c,0x66,0x7d,0x89,0x24,0x10,0x3c,0x60,0xc4,0x2c,0xef,0xff,0xd6,0x76,0x16,0x00,0x00,0x8a,0x14,0x00,0xe0,0x02,0xac,0x26,0x15,0x80,0x14,0x01,0xe0,0x08,0xac,0x43,0x16,0x00,0x7d,0x89,0xe0,0x02,0x8c,0x06,0x2c,0x06,0x3c,0x62,0xef,0xff,0xd5,0x5c,0xe0,0x01,0x00,0xaf,0xe0,0x02,0x8c,0x36,0x16,0x80,0x24,0x34,0xe0,0x01,0x8c,0x84,0xe0,0x01,0x8c,0x14,0xe0,0x01,0x8d,0x24,0xe4,0x09,0x34,0xa8,0xe4,0x08,0x34,0x20,0x3c,0x49,0x35,0x28,0x3d,0x48,0xe0,0x01,0x8c,0x34,0xe0,0x0a,0x3c,0x4a,0xa4,0x66,0x3d,0x78,0x01,0x20,0xe4,0x09,0x35,0x40,0xe3,0xff,0xc5,0x7f,0xe0,0x0a,0x3c,0x9a,0xe4,0x0e,0x34,0x40,0xe0,0x41,0x3c,0x88,0xe3,0xff,0xc4,0xff,0x3d,0xee,0xe0,0x09,0x3d,0x19,0xe5,0xff,0xcd,0xff,0xe0,0x0d,0x3c,0x9b,0xe4,0x09,0x34,0x48,0xe0,0x01,0xac,0x84,0xe0,0x09,0x34,0x48,0xe0,0x01,0xaf,0x14,0xe0,0x01,0xac,0xa4,0xe0,0x01,0xac,0x34,0xe0,0x02,0x8c,0x46,0x15,0x00,0x24,0x1b,0x8c,0xa4,0x8c,0x34,0x34,0xa8,0xe0,0x09,0x3c,0x49,0x65,0x89,0xe0,0x02,0x94,0x26,0xe0,0x08,0x3d,0x98,0xe3,0xff,0xc4,0x7f,0xe0,0x02,0xb4,0x26,0x3c,0xf8,0x01,0x0b,0xe0,0x41,0x3d,0x08,0xe3,0xff,0xc5,0x7f,0xe0,0x0a,0x3c,0x9a,0xe0,0x09,0x34,0x48,0xac,0xa4,0xac,0x34,0xe0,0x02,0x8c,0xd6,0x14,0x00,0x24,0xb1,0x8f,0x44,0x8d,0xd4,0x8c,0xe4,0xe4,0x0e,0x37,0x28,0xe4,0x0b,0x35,0xa0,0x3d,0xce,0x34,0xa8,0x3c,0xcb,0x8d,0xf4,0xe0,0x09,0x3d,0xc9,0xa5,0xf6,0x3e,0x1b,0xbe,0x76,0x3c,0xfc,0x01,0x1b,0xe4,0x08,0x34,0xc0,0xe3,0xff,0xc4,0xff,0xe0,0x09,0x3c,0x19,0xe0,0x41,0x3c,0x0c,0xe3,0xff,0xc4,0x7f,0xe0,0x08,0x3c,0x98,0xe4,0x09,0x36,0x48,0xe4,0x0e,0x36,0x40,0xac,0xc4,0xe0,0x09,0x36,0x48,0x3f,0xee,0xaf,0x54,0xe5,0xff,0xcf,0xff,0xac,0xe4,0x3c,0x1f,0xae,0x74,0xe0,0x03,0xbe,0x03,0xe0,0x03,0xbe,0x05,0xe0,0x0b,0x3d,0x1d,0x3d,0x98,0xe0,0x02,0x8c,0x23,0xe0,0x01,0x9a,0x02,0xe2,0x00,0xcc,0x01,0x3c,0xe3,0x3c,0x62,0x15,0x01,0x01,0x84,0xef,0xff,0xd4,0xb0,0x00,0x83,0xef,0xff,0xd4,0x95,0x2c,0x12,0x3c,0x63,0xe0,0x01,0xc4,0x30,0xef,0xff,0xd5,0xc2,0xe0,0x02,0xa4,0x43,0xc2,0x74,0xc4,0x01,0xe0,0x02,0xbc,0x43,0xe0,0x03,0xa4,0x63,0xe0,0x04,0x3c,0x14,0xe0,0x03,0xba,0x63,0x60,0x86,0x61,0x05,0x61,0x84,0x62,0x03,0x62,0x82,0x63,0x01,0xc0,0x30,0x38,0x82,0xc0,0x78,0x78,0x82,0x7a,0x01,0xe0,0x00,0x1a,0x0f,0xa4,0x44,0x24,0x05,0xa4,0x88,0xbc,0xc4,0xdc,0xf5,0x00,0xfb,0x60,0x82,0x62,0x01,0xc0,0x08,0x38,0x82,0x47,0x43,0x43,0x3a,0x20,0x28,0x47,0x4e,0x55,0x29,0x20,0x34,0x2e,0x36,0x2e,0x31,0x00,0x00,0x2e,0x73,0x68,0x73,0x74,0x72,0x74,0x61,0x62,0x00,0x2e,0x64,0x64,0x72,0x5f,0x74,0x65,0x78,0x74,0x00,0x66,0x61,0x73,0x74,0x5f,0x70,0x61,0x74,0x68,0x00,0x2e,0x64,0x64,0x72,0x5f,0x62,0x73,0x73,0x00,0x2e,0x64,0x6d,0x65,0x6d,0x5f,0x70,0x65,0x73,0x74,0x61,0x74,0x75,0x73,0x00,0x2e,0x64,0x6d,0x65,0x6d,0x5f,0x67,0x6f,0x74,0x00,0x2e,0x64,0x6d,0x65,0x6d,0x5f,0x73,0x64,0x61,0x74,0x61,0x00,0x2e,0x64,0x6d,0x65,0x6d,0x5f,0x6c,0x69,0x74,0x34,0x00,0x2e,0x64,0x6d,0x65,0x6d,0x5f,0x62,0x73,0x73,0x00,0x2e,0x64,0x6d,0x65,0x6d,0x5f,0x73,0x68,0x00,0x2e,0x64,0x6d,0x65,0x6d,0x5f,0x73,0x74,0x61,0x63,0x6b,0x00,0x2e,0x76,0x65,0x63,0x74,0x6f,0x72,0x00,0x2e,0x63,0x6f,0x6d,0x6d,0x65,0x6e,0x74,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0b,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x06,0x03,0xf8,0x00,0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x16,0xa6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x15,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x06,0x03,0xf8,0x16,0xa6,0x00,0x00,0x46,0xa6,0x00,0x00,0x06,0x22,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1f,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x03,0x03,0xf8,0x1c,0xc8,0x00,0x00,0x4c,0xc8,0x00,0x00,0x1c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x28,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x37,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x20,0x00,0x00,0x10,0x20,0x00,0x00,0x00,0x90,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x41,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0xb0,0x00,0x00,0x10,0xb0,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x4d,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x12,0x00,0x00,0x00,0xc0,0x00,0x00,0x10,0xc0,0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x58,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0xf0,0x00,0x00,0x10,0xf0,0x00,0x00,0x09,0xdc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x62,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x03,0x00,0x00,0x0a,0xe0,0x00,0x00,0x1a,0xe0,0x00,0x00,0x05,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x6b,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x03,0x00,0x00,0x10,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x77,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x02,0x00,0x00,0x1f,0x80,0x00,0x00,0x2f,0x80,0x00,0x00,0x00,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7f,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x4c,0xc8,0x00,0x00,0x00,0x11,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x4c,0xd9,0x00,0x00,0x00,0x88,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,
\ No newline at end of file
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/otp/c2k_otp.c u-boot-2013.01.new/drivers/otp/c2k_otp.c
--- u-boot-2013.01/drivers/otp/c2k_otp.c	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/otp/c2k_otp.c	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,226 @@
+#include <common.h>
+#include <linux/list.h>
+#include <linux/types.h>
+#include <linux/compat.h>
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <asm/arch/otp.h>
+#include <asm/arch/comcerto-2000.h>
+#include <asm/arch/comcerto-common.h>
+#include <asm/arch/clkcore.h>
+#include <errno.h>
+
+#define NP1	4		/* Number of initial programming pulses */
+#define NP2	12		/* Maximum number of additional programming pulses */
+
+void write_protect_unlock(void)
+{
+	writel(0xEBCF0000, OTP_CONFIG_LOCK_0);  /* config lock0 */
+	writel(0xEBCF1111, OTP_CONFIG_LOCK_1); /* config lock1 */
+	writel(0x0, OTP_CEB_INPUT);
+}
+
+ 
+int otp_smart_write_sequence(u32 offset, u8 prog_data)
+{
+	int i;
+
+	/* Drive the address now */
+	writel(offset, OTP_ADDR_INPUT);
+	/* Write data to the DATA_IN register */
+	writel(prog_data, OTP_DATA_INPUT);
+
+	/* DLE drive  "1" */
+	writel(0x1, OTP_DLE_INPUT);
+	/* Wait for at least 20nsec */
+	ndelay(20);
+
+	/* WEB drive  "0" */
+	writel(0x0, OTP_WEB_INPUT);
+	/* Wait for at least 20nsec */
+	ndelay(20);
+
+	/* WEB drive  "1" */
+	writel(0x1, OTP_WEB_INPUT);
+	/* Wait for at least 20nsec */
+	ndelay(20);
+
+	/* DLE drive  "0" */
+	writel(0x0, OTP_DLE_INPUT);
+
+	/* Write '1' to PGMEN to trigger the whole write and verify operation until PGMEN will be deasserted by HW */
+	writel(0x1, OTP_PGMEN_INPUT);
+
+	/* Wait for PGMEN to go low for 11.2 u sec */
+	for (i = 0 ; i < 12 ; i++) {
+		if(!readl(OTP_PGMEN_INPUT))
+			break;
+
+		printf("Timeout waiting for PGMEN "
+				"to be deasserted\n");
+		udelay(1);
+	}
+}
+
+
+
+/*
+ ****************************************
+ *   otp_write()
+ *
+ * PARAMETERS:
+ *	s_addr -- Starting Address
+ *	prog_data -- Source Data Buffer
+ ****************************************
+ */
+int otp_write(u32 offset, u8 *prog_data, int size)
+{
+	int i, k;
+	u32 pgm2cpump_counter, cpump2web_counter, web_counter, web2cpump_counter, cpump2pgm_counter, dataout_counter;
+	u32 read_data;
+	u32 axi_clk = HAL_get_axi_clk();
+
+	if (NULL == prog_data)
+		return RETCODE_ERROR;
+
+	if (size <= 0)
+		return RETCODE_ERROR;
+
+	/* Setting up counters to program */
+	pgm2cpump_counter = axi_clk & 0x7FF ; 				/* 1 uSec */
+	cpump2web_counter = (axi_clk*3) & 0x7FF ;			/* 3 uSec */
+	web_counter = (axi_clk*5) & 0x7FF ;					/* 5 uSec */
+	web2cpump_counter = (axi_clk*2) & 0x7FF ;			/* 2 uSec */
+	cpump2pgm_counter = axi_clk & 0x7FF ;				/* 1 uSec */
+	dataout_counter = ((axi_clk * 7 + 99) / 100) & 0x1FF ;	/* 70 nSec */
+	
+	/* program the counters */
+	writel(pgm2cpump_counter, OTP_PGM2CPUMP_COUNTER);
+	writel(cpump2web_counter, OTP_CPUMP2WEB_COUNTER);
+	writel(web_counter, OTP_WEB_COUNTER);
+	writel(web2cpump_counter, OTP_WEB2CPUMP_COUNTER);
+	writel(cpump2pgm_counter, OTP_CPUMP2PGM_COUNTER);
+	writel(dataout_counter, OTP_DATA_OUT_COUNTER);
+
+	write_protect_unlock();
+
+	udelay(1);
+		
+	/* rstb drive 0 */
+	writel(0x0, OTP_RSTB_INPUT);
+	/* Wait for at least 20nsec */
+	ndelay(20);
+
+	/* rstb drive 1 to have pulse  */
+	writel(0x1, OTP_RSTB_INPUT);
+	/* Wait for at least 1usec */
+	udelay(1);
+
+	for(i = 0 ; i < size ; i++) {
+
+		/* Skip bits that are 0 because 0 is the default value */
+		if (!prog_data[i])
+			continue;
+
+		for(k = 0 ; k < NP1-1 ; k++) 
+			otp_smart_write_sequence(offset + i, prog_data[i]);
+
+		for(k = 0 ; k < NP2+1 ; k++) {
+			ndelay(100);
+			otp_smart_write_sequence(offset + i, prog_data[i]);		
+
+			/* Verify Data */
+			read_data = readl(OTP_DATA_OUTPUT);
+
+			/* Adjust bit offset */
+			read_data = ((read_data >> ((offset+i) & 0x7)) & 0x1);
+
+			if(read_data)
+				break;
+		}
+		if(!read_data) {
+			printf(" Warning : OTP Write/read mismatch, OTP write FAIL !");
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+
+
+/*
+ ****************************************
+ *   otp_read ()
+ *
+ * PARAMETERS:
+ *	s_addr --Starting Address
+ *	read_data --Destination Buffer
+ *	size -- No of Bytes to read
+ ****************************************
+ */
+int otp_read(u32 offset, u8 *read_data, int size)
+{
+	int i;
+	u32 read_tmp = 0, dataout_counter;
+	u32 axi_clk = HAL_get_axi_clk();
+
+	if (NULL == read_data)
+		return RETCODE_ERROR;
+
+	if (size <= 0)
+		return RETCODE_ERROR;
+
+	dataout_counter = ((axi_clk * 7 + 99) / 100) & 0x1FF ;	/* 70 nSec */
+	
+	/* configure the OTP_DATA_OUT_COUNTER for read operation.
+	    70 nsec is needed except for blank check test, in which 1.5 usec is needed.*/
+	writel(dataout_counter, OTP_DATA_OUT_COUNTER);
+
+	write_protect_unlock();
+	udelay(1);
+
+	/* rstb drive 0 */
+	writel(0x0, OTP_RSTB_INPUT);
+	/* Wait for at least 20nsec */
+	ndelay(20);
+	/* rstb drive 1 to have pulse  */
+	writel(0x1, OTP_RSTB_INPUT);
+	/* Wait for at least 1usec */
+	udelay(1);
+
+	/* Write the desired address to the ADDR register */
+	writel(offset, OTP_ADDR_INPUT);
+	/* read_enable drive */
+	writel(0x1, OTP_READEN_INPUT);
+	/* Wait for at least 70nsec/1.5usec depends on operation type */
+	ndelay(70);
+
+	/* Read First Byte */
+	read_tmp = readl(OTP_DATA_OUTPUT);
+	*read_data = read_tmp & 0xFF;
+
+	/* For consecutive read */
+	for(i = 1 ; i < size ; i++)
+	{
+		offset = offset + 8;
+
+		/* start reading from data out register */
+		writel(offset, OTP_ADDR_INPUT);
+		/* Wait for at least 70nsec/1.5usec depends on operation type */
+		ndelay(70);
+
+		read_tmp = readl(OTP_DATA_OUTPUT);
+		*(read_data + i) = read_tmp & 0xFF;
+	}
+
+	/* reading is done make the read_enable low */
+	writel(0x0, OTP_READEN_INPUT);
+
+	/* lock CEB register, return to standby mode */
+	writel(0x1, OTP_CEB_INPUT);
+
+	return RETCODE_OK;
+}
+EXPORT_SYMBOL(otp_read);
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/otp/Makefile u-boot-2013.01.new/drivers/otp/Makefile
--- u-boot-2013.01/drivers/otp/Makefile	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/otp/Makefile	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,24 @@
+include $(TOPDIR)/config.mk
+
+LIB	:= $(obj)libotp.o
+
+COBJS-$(CONFIG_DRIVER_OTP) += c2k_otp.o
+
+
+COBJS	:= $(COBJS-y)
+SRCS	:= $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+
+all:	$(LIB)
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/serial/Makefile u-boot-2013.01.new/drivers/serial/Makefile
--- u-boot-2013.01/drivers/serial/Makefile	2013-01-16 03:17:42.000000000 +0530
+++ u-boot-2013.01.new/drivers/serial/Makefile	2016-03-23 16:10:34.000000000 +0530
@@ -54,6 +54,7 @@
 COBJS-$(CONFIG_SANDBOX_SERIAL) += sandbox.o
 COBJS-$(CONFIG_SCIF_CONSOLE) += serial_sh.o
 COBJS-$(CONFIG_ZYNQ_SERIAL) += serial_zynq.o
+COBJS-$(CONFIG_COMCERTO_SERIAL) += serial_comcerto.o
 
 ifndef CONFIG_SPL_BUILD
 COBJS-$(CONFIG_USB_TTY) += usbtty.o
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/serial/serial_comcerto.c u-boot-2013.01.new/drivers/serial/serial_comcerto.c
--- u-boot-2013.01/drivers/serial/serial_comcerto.c	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/serial/serial_comcerto.c	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,215 @@
+/*
+ * (C) Copyright 2006
+ * Mindspeed Technologies
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+/* TODO  Important. Serial driver needs rework.*/
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/hardware.h>
+#include <asm/byteorder.h>
+#include <serial.h>
+#include <linux/compiler.h>
+
+#define COMCERTO_UART0_BASE             0x96400000
+
+#if !defined(CONFIG_UART0) && !defined(CONFIG_UART1)
+#error must define one of CONFIG_UART0 or CONFIG_UART1
+#endif
+
+
+typedef struct tagUART16550REGS {
+	volatile u32 data;	// Receive/Transmit data register
+	volatile u32 ier;	// Interrupt Enable register
+	volatile u32 iir_fcr;// Interrupt Identity register / FIFO Control register
+	volatile u32 lcr;	// Line Control register
+	volatile u32 mcr;	// Modem Control register
+	volatile u32 lsr;	// Line Status register
+	volatile u32 msr;	// Modem Status register
+	volatile u32 sr;		// Scratch register
+} UART16550REGS, *PUART16550REGS;
+
+typedef struct tagUART16550DLREGS {
+	volatile u32 dll;	// Divisor Latch (Low)
+	volatile u32 dlh;	// Divisor Latch (High)
+} UART16550DLREGS, *PUART16550DLREGS;
+
+#define LCR_CHAR_LEN_5		0x00	  /* default */
+#define LCR_CHAR_LEN_6		0x01
+#define LCR_CHAR_LEN_7		0x02
+#define LCR_CHAR_LEN_8		0x03
+#define LCR_ONE_STOP		0x00	  /* One stop bit! - default */
+#define LCR_TWO_STOP		0x04	  /* Two stop bit! */
+#define LCR_PEN				0x08	  /* Parity Enable */
+#define LCR_PARITY_NONE		0x00
+#define LCR_EPS				0x10	  /* Even Parity Select */
+#define LCR_PS				0x20	  /* Enable Parity  Stuff */
+#define LCR_SBRK				0x40  /* Start Break */
+#define LCR_PSB				0x80	  /* Parity Stuff Bit */
+#define LCR_DLAB				0x80  /* UART 16550 Divisor Latch Assess */
+
+#define LSR_FIFOE		(1 << 7)	/* FIFO Error Status */
+#define LSR_TEMT			(1 << 6)	/* Transmitter Empty */
+#define LSR_TDRQ			(1 << 5)	/* Transmit Data Request */
+#define LSR_BI			(1 << 4)	/* Break Interrupt */
+#define LSR_FE			(1 << 3)	/* Framing Error */
+#define LSR_PE			(1 << 2)	/* Parity Error */
+#define LSR_OE			(1 << 1)	/* Overrun Error */
+#define LSR_DR			(1 << 0)	/* Data Ready */
+
+
+#define IER_DMAE			(1 << 7)	/* DMA Requests Enable */
+#define IER_UUE			(1 << 6)	/* UART Unit Enable */
+#define IER_NRZE			(1 << 5)	/* NRZ coding Enable */
+#define IER_RTIOE			(1 << 4)	/* Receiver Time Out Interrupt Enable */
+#define IER_MIE			(1 << 3)	/* Modem Interrupt Enable */
+#define IER_RLSE			(1 << 2)	/* Receiver Line Status Interrupt Enable */
+#define IER_TIE			(1 << 1)	/* Transmit Data request Interrupt Enable */
+#define IER_RAVIE			(1 << 0)	/* Receiver Data Available Interrupt Enable */
+
+#define IIR_FIFOES1		(1 << 7)	/* FIFO Mode Enable Status */
+#define IIR_FIFOES0		(1 << 6)	/* FIFO Mode Enable Status */
+#define IIR_TOD			(1 << 3)	/* Time Out Detected */
+#define IIR_IID2			(1 << 2)	/* Interrupt Source Encoded */
+#define IIR_IID1			(1 << 1)	/* Interrupt Source Encoded */
+#define IIR_IP				(1 << 0)	/* Interrupt Pending (active low) */
+
+/* UART 16550 FIFO Control Register */
+#define FCR_FIFOEN			0x01
+#define FCR_RCVRRES			0x02
+#define FCR_XMITRES			0x04
+
+/* Interrupt Enable Register */
+// UART 16550
+#define IER_RXTH			0x01	// Enable Received Data Available Interrupt
+#define IER_TXTH			0x02	// Enable Transmitter Empty Interrupt
+
+void comcerto_serial_setbrg (void)
+{
+#if 0
+	int baudrate = 115200;
+	unsigned int div;
+	unsigned int clk = 200000000;
+#ifdef CONFIG_UART0
+	PUART16550REGS uart = (PUART16550REGS) COMCERTO_UART0_BASE;
+	PUART16550DLREGS uart_dl = (PUART16550DLREGS) COMCERTO_UART0_BASE;
+#else
+	PUART16550REGS uart = (PUART16550REGS) UART1_BASEADDR;
+	PUART16550DLREGS uart_dl = (PUART16550DLREGS) UART1_BASEADDR;
+#endif
+
+	div = (clk + 8 * baudrate) / (16 * baudrate);
+	uart->lcr |= __cpu_to_le32(LCR_DLAB); // Enable Divisor Latch access
+	uart_dl->dll = __cpu_to_le32(div & 0xFF); // Set Divisor Latch Low
+//	uart_dl->dll = __cpu_to_le32(0x0 & 0xFF); // Set Divisor Latch Low
+	uart_dl->dlh = __cpu_to_le32((div >> 8) & 0xFF); // Set Divisor Latch high
+//	uart_dl->dlh = __cpu_to_le32((0x0 >> 8) & 0xFF); // Set Divisor Latch high
+	uart->lcr &= __cpu_to_le32(~LCR_DLAB); // Disable Divisor Latch access
+
+#endif
+}
+
+int comcerto_serial_init (void)
+{
+#if 0
+#ifdef CONFIG_UART0
+	PUART16550REGS uart = (PUART16550REGS) COMCERTO_UART0_BASE;
+#else
+	PUART16550REGS uart = (PUART16550REGS) UART1_BASEADDR;
+#endif
+
+#ifdef CONFIG_UART1
+	EnableUART1();
+#endif
+
+	serial_setbrg ();
+
+	uart->lcr = __cpu_to_le32(LCR_ONE_STOP | LCR_CHAR_LEN_8);
+	uart->iir_fcr = __cpu_to_le32(FCR_XMITRES | FCR_RCVRRES | FCR_FIFOEN); // Reset, FIFO
+	uart->ier = __cpu_to_le32(IER_UUE);		/* Enable FFUART */
+#endif
+	return (0);
+}
+
+void comcerto_serial_putc (const char c)
+{
+#ifdef CONFIG_UART0
+	PUART16550REGS uart = (PUART16550REGS) COMCERTO_UART0_BASE;
+#else
+	PUART16550REGS uart = (PUART16550REGS) UART1_BASEADDR;
+#endif
+
+	/* wait for room in the tx FIFO on FFUART */
+	while ((uart->lsr & __cpu_to_le32(LSR_TDRQ))==0) ;
+	uart->data = __cpu_to_le32(c);
+	if (c == '\n')
+		serial_putc ('\r');
+}
+
+void comcerto_serial_puts (const char *s)
+{
+	while (*s) {
+		serial_putc (*s++);
+	}
+}
+
+int comcerto_serial_getc (void)
+{
+#ifdef CONFIG_UART0
+	PUART16550REGS uart = (PUART16550REGS) COMCERTO_UART0_BASE;
+#else
+	PUART16550REGS uart = (PUART16550REGS) UART1_BASEADDR;
+#endif
+
+	while ((uart->lsr & __cpu_to_le32(LSR_DR)) == 0);
+	return (char)__le32_to_cpu(uart->data & __cpu_to_le32(0xff));
+}
+
+int comcerto_serial_tstc (void)
+{
+#ifdef CONFIG_UART0
+	PUART16550REGS uart = (PUART16550REGS) COMCERTO_UART0_BASE;
+#else
+	PUART16550REGS uart = (PUART16550REGS) UART1_BASEADDR;
+#endif
+
+	return __le32_to_cpu(uart->lsr & __cpu_to_le32(LSR_DR));
+}
+
+static struct serial_device comcerto_serial_drv = {
+	.name	= "comcerto_serial",
+	.start	= comcerto_serial_init,
+	.stop	= NULL,
+	.setbrg	= comcerto_serial_setbrg,
+	.putc	= comcerto_serial_putc,
+	.puts	= comcerto_serial_puts,
+	.getc	= comcerto_serial_getc,
+	.tstc	= comcerto_serial_tstc,
+};
+
+void comcerto_serial_initialize(void)
+{
+	serial_register(&comcerto_serial_drv);
+}
+
+__weak struct serial_device *default_serial_console(void)
+{
+	return &comcerto_serial_drv;
+}
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/spacc/c2k_spacc.c u-boot-2013.01.new/drivers/spacc/c2k_spacc.c
--- u-boot-2013.01/drivers/spacc/c2k_spacc.c	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/spacc/c2k_spacc.c	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,276 @@
+/*
+;=======================================================================
+;   Copyright (C) 2007 Mindspeed Technologies, Inc.
+;
+;        Author   : Ananda Rao Gurram
+;        Filename : spacc.c
+;        Purpose  : SPAcc driver for Cipher Operations.
+;======================================================================
+*/
+
+#include <common.h>
+#include <linux/list.h>
+#include <linux/types.h>
+#include <linux/compat.h>
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <asm/arch/spacc.h>
+#include <asm/arch/ibr_wrapper.h>
+#include <asm/arch/comcerto-2000.h>
+#include <asm/arch/comcerto-common.h>
+#include <errno.h>
+
+// ddt_entry ddt, sddt Must be 8byte aligned.
+ddt_entry __aligned(8) ddt[MAX_DDT_ENTRIES];
+ddt_entry __aligned(8) sddt[MAX_DDT_ENTRIES];
+
+/*
+static void print_aes_key(u8 *buf, u32 length)
+{
+	int ii;
+	for(ii=0; ii < length; ii++) {
+		if (!(ii % 16))
+			printf("\n");
+		printf(" 0x%02x", buf[ii]);
+	}
+}*/
+
+void memcpy32(volatile u32 *dst, volatile u32 *src, int len)
+{
+	int i;
+
+	for (i = len - 1; i >= 0; i--) {
+		dst[i] = src[i];
+	}
+}
+
+int spacc_decrypt(u8 *buffer, u32 buffer_len, u32 ciph_algo, u32 ciph_mode, u8 *ciph_key, u32 key_len, u8 *iv, u8 *dst_buffer, u8 is_first_pkt)
+{
+	u32 idx =0, len = buffer_len, dst_len = buffer_len;
+	u32 ctrl = 0;
+	u8 *boundary, *ptr = buffer, *dptr = dst_buffer;
+	u32 newlen;
+	u32 fifo_stat, status;
+	u32 ksz;
+	u32 __aligned(8) key[12];
+
+	/*First check for any pending status*/
+	fifo_stat = INP32(SPACC_REG_FIFO_STAT);
+	while (SPACC_GET_FIFO_STAT_EMPTY(fifo_stat) != 1) {
+		printf("Clearing pending status.\n");
+		OUT32(SPACC_REG_STAT_POP, 0x1);
+		fifo_stat = INP32(SPACC_REG_FIFO_STAT);
+		if(idx++ > TIME_OUT_LOOPS) return -6;
+	}
+
+	idx = 0;
+
+	/* Check for supporting cipher algorithms */
+	if( ciph_algo !=  C_AES )
+		return -1;
+
+	ctrl = CTRL_SET_CIPH_MODE(ciph_mode) | CTRL_SET_CIPH_ALG(ciph_algo) | (1UL<<_SPACC_CTRL_MSG_BEGIN)|(1UL<<_SPACC_CTRL_MSG_END) | CTRL_SET_CTX_IDX(0);
+
+	if(is_first_pkt)
+		ctrl |= CTRL_SET_KEY_EXP;
+
+	do{
+		/* split buffer, if the data straddle a 2**16 memory boundaries. */
+                boundary = (u8 *)(((u32)ptr+SPACC_MAX_PARTICLE_SIZE) & ~(u32)(SPACC_MAX_PARTICLE_SIZE - 1));
+                if ((ptr+len) > boundary) {
+			newlen = len - (u32)(boundary - ptr);
+			len = (u32)(boundary - ptr);
+                } else {
+                        newlen = 0;
+                }
+
+                if (idx >= (MAX_DDT_ENTRIES - 2)) {
+                        /*DDT size over flow */
+                        return -2;
+                }
+
+                sddt[idx].ptr = (u32 )ptr;
+                sddt[idx].len = (u32)len;
+		//printf("sddt %x %x\n", sddt[idx].ptr, sddt[idx].len);
+                idx++;
+
+                ptr += len;
+                len = newlen;
+
+	}while(newlen);
+	sddt[idx].ptr = (u32)0;
+	sddt[idx].len = 0;
+
+	newlen=0;
+	idx=0;
+
+	do{
+		/* split buffer, if the data straddle a 2**16 memory boundaries. */
+                boundary = (u8 *)(((u32)dptr+SPACC_MAX_PARTICLE_SIZE) & ~(u32)(SPACC_MAX_PARTICLE_SIZE - 1));
+                if ((dptr+dst_len) > boundary) {
+			newlen = dst_len - (u32)(boundary - dptr);
+			dst_len = (u32)(boundary - dptr);
+                } else {
+                        newlen = 0;
+                }
+
+                if (idx >= (MAX_DDT_ENTRIES - 2)) {
+                        /*DDT size over flow */
+                        return -2;
+                }
+
+                ddt[idx].ptr = (u32)dptr;
+                ddt[idx].len = (u32)dst_len;
+		//printf("ddt %x %x\n", ddt[idx].ptr, ddt[idx].len);
+                idx++;
+
+                dptr += dst_len;
+                dst_len = newlen;
+
+	}while(newlen);
+	ddt[idx].ptr = (u32)0;
+	ddt[idx].len = 0;
+
+	memset(key,0,48);
+	ksz = SPACC_SET_CIPHER_KEY_SZ (key_len >> 3, 0);
+	if(is_first_pkt) {
+		memcpy32((u32 *)(key),(u32 *)(ciph_key),(signed short) (key_len >> 5));
+		memcpy32((u32 *)(&key[8]),(u32 *)(iv), (signed short)4);
+
+		memcpy32((u32 *)SPACC_ADDR_CIPH_KEY ,(u32 *)(key), (signed short)16);
+	}
+
+	//printf("\nkey value in register is  ");
+	//print_aes_key((u8 *)SPACC_ADDR_CIPH_KEY, 48);
+	//printf ("\n\n");
+
+	/*Configure hardware registers */
+	OUT32(SPACC_REG_SRC_PTR, sddt);
+	OUT32(SPACC_REG_DST_PTR, ddt);
+	OUT32(SPACC_REG_PROC_LEN, buffer_len);
+	OUT32(SPACC_REG_ICV_LEN, 0);
+	OUT32(SPACC_REG_ICV_OFFSET, 0);
+
+	OUT32(SPACC_REG_KEY_SZ, ksz); /*key size with cipher key bit set*/
+
+	OUT32(SPACC_REG_PRE_AAD_LEN, 0);
+	OUT32(SPACC_REG_POST_AAD_LEN, 0);
+
+	OUT32(SPACC_REG_IV_OFFSET, 0);
+	OUT32(SPACC_REG_SW_CTRL, 0);
+	OUT32(SPACC_REG_AUX_INFO, 0);
+
+	OUT32(SPACC_REG_OFFSET, 0);
+
+
+	//printf("sddt %p, ddt %p\n", &sddt[0], &ddt[0]);
+	//printf("\nproc_len %x ctrl %x\n", buffer_len, ctrl);
+	//printf("src_ptr: %X\n",sddt[0].ptr);
+	//printf("dst_ptr: %X\n",ddt[0].ptr);
+
+	OUT32(SPACC_REG_CTRL, ctrl);
+
+spacc_recheck:
+	idx=0;
+	/*Dequeue the packet from hardware */
+	fifo_stat = INP32(SPACC_REG_FIFO_STAT);
+	if (SPACC_GET_FIFO_STAT_CNT(fifo_stat) > 0) {
+		if (SPACC_GET_FIFO_STAT_EMPTY(fifo_stat) == 1) {
+                        return -6; /* FIFO is empty */
+                }
+		OUT32(SPACC_REG_STAT_POP, 0x1);
+		fifo_stat = INP32(SPACC_REG_FIFO_STAT);
+		status  = INP32(SPACC_REG_STATUS);
+		switch(SPACC_GET_STATUS_RET_CODE(status)){
+                case SPACC_OK:
+			break;
+                case SPACC_ICVFAIL:
+                        printf("SPACC_ICVFAIL\n");
+			return -3;
+                case SPACC_MEMERR:
+                        printf("SPACC_MEMERR\n");
+			return -4;
+                case SPACC_BLOCKERR:
+                        printf("SPACC_BLOCKERR\n");
+			return -5;
+		default:
+			return -7;
+		}
+	}
+	else
+	{
+		if(idx++ < TIME_OUT_LOOPS)
+			goto spacc_recheck;
+		printf("Error, Time out\n");
+		return -6;
+
+	}
+
+	return 0;
+}
+
+
+/* This function calculates custom hash on the given buffer.
+ * This method has been implemented to overcome the SPAcc hardware max processing size(64K-1) limitation.
+ *
+ * Parameters:
+ * 	buffer		-Input buffer for hash calculation
+ * 	buffer_len	-Input buffer len
+ * 	hash_type	-Type of the hash
+ * 	hash		-Buffer to store calculated hash
+ * 	hash_len	-Length of the hash buffer size
+ * Return value:
+ * 	0		-Hash calculated successfully
+ *	>0		-Failed to calculate hash
+ *
+ * Hash calculation method  will be changing depends on buffer_len
+ * 	buffer_len <= SPACC_MAX_PROC_SIZE	Regular hash will be calculated on the buffer.
+ * 	buffer_len > SPACC_MAX_PROC_SIZE	Spilt total Buffer into several SPACC_MAX_PROC_SIZE chunks,
+ * 						regular hash is calculated on each individual chunk
+ * 						concatenate all hashes, and calculate hash on the hash buffer.
+ * 	buffer_len > MAX_SEC_BOOT_IMG_LEN	Hash will not be calculated, returns error.
+ *
+ *
+ */
+int calculate_hash_bigsize(u8 *buffer, u32 buffer_len, u32 hash_type, u8 *hash, u32 hash_len)
+{
+	u8 __aligned(8) tmp_hash[CRYPTO_HASH_SHA256_SIZE * ((MAX_SEC_BOOT_IMG_LEN/SPACC_MAX_PROC_SIZE)+1)];
+	u32 hash_offset=0;
+
+
+	/* Divide total buffer several SPACC_MAX_PROC_SIZE chunks, and calculate hash*/
+	while(buffer_len > SPACC_MAX_PROC_SIZE)
+	{
+		if(ibr_wrapper_calculate_hash(buffer, SPACC_MAX_PROC_SIZE, hash_type, &tmp_hash[hash_offset], hash_len))
+			return 1;
+
+		buffer_len -= SPACC_MAX_PROC_SIZE;
+		buffer += SPACC_MAX_PROC_SIZE;
+		hash_offset += hash_len;
+	}
+
+	/* Calculate hash on remaining data */
+	if(buffer_len > 0)
+	{
+		if(hash_offset)
+		{
+			if(ibr_wrapper_calculate_hash(buffer, buffer_len, hash_type, &tmp_hash[hash_offset], hash_len))
+				return 1;
+		}
+		else
+		{
+			/*Input buffer size is lessthan SPACC_MAX_PROC_SIZE
+			 *No need to calculate hash on it, return regular hash */
+			if(ibr_wrapper_calculate_hash(buffer, buffer_len, hash_type, hash, hash_len))
+				return 1;
+			return 0;
+		}
+		hash_offset += hash_len;
+	}
+	/* Calculate hash on concatenated hash buffer */
+	if(ibr_wrapper_calculate_hash(tmp_hash, hash_offset, hash_type, hash, hash_len))
+		return 1;
+
+	return 0;
+}
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/spacc/Makefile u-boot-2013.01.new/drivers/spacc/Makefile
--- u-boot-2013.01/drivers/spacc/Makefile	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/spacc/Makefile	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,24 @@
+include $(TOPDIR)/config.mk
+
+LIB	:= $(obj)libspacc.o
+
+COBJS-$(CONFIG_DRIVER_SPACC) += c2k_spacc.o
+
+
+COBJS	:= $(COBJS-y)
+SRCS	:= $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+
+all:	$(LIB)
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/spi/c2k_spi.c u-boot-2013.01.new/drivers/spi/c2k_spi.c
--- u-boot-2013.01/drivers/spi/c2k_spi.c	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/drivers/spi/c2k_spi.c	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,394 @@
+#include <asm/types.h>
+#include <asm/io.h>
+#include <linux/types.h>
+
+#include <linux/byteorder/generic.h>
+#include <linux/byteorder/little_endian.h>
+#include <asm/arch/comcerto_spi.h>
+
+#define SPI_CTRLR0_SCPOL        (1 << 7)
+#define SPI_CTRLR0_SCPH         (1 << 6)
+
+unsigned int spi_base = SPI_BASEADDR;
+
+struct spi_transfer {
+        const void      *tx_buf;
+        void            *rx_buf;
+        unsigned        len;
+        int             mode;
+};
+
+
+int do_eeprom_read(u8 fs, u8 *wbuf, u32 *wlen, u8 *rbuf, u32 *ndf)
+{
+        u32 sr, dr;
+        u32 wlen_now = 0, rlen_now = 0;
+        int rc = 0;
+
+        while (wlen_now < *wlen) {
+                sr = readl(spi_base + COMCERTO_SPI_SR);
+
+                if (sr & TFNF) {
+                        if (wlen_now < *wlen) {
+                                writew(cpu_to_le16((u16) *wbuf), spi_base + COMCERTO_SPI_DR);
+                                wbuf++;
+                                wlen_now++;
+                        }
+                }
+        }
+
+        while (rlen_now < *ndf) {
+                sr = readl(spi_base + COMCERTO_SPI_SR);
+
+                if (sr & (RFF | DCOL)) {
+                        /* read overrun, data collision */
+                        rc = -1;
+                        goto out;
+                }
+
+                if (sr & RFNE) {
+                        dr = readw(spi_base + COMCERTO_SPI_DR);
+                        if (rlen_now < *ndf) {
+                                *rbuf = (u8) (le16_to_cpu(dr) & 0xff);
+                                rbuf++;
+                                rlen_now++;
+                        } else {
+                                /* read overflow */
+                                rc = -1;
+                                goto out;
+                        }
+                }
+        }
+
+out:
+        *ndf = rlen_now;
+        *wlen = wlen_now;
+
+        return rc;
+}
+
+
+/**
+ * do_write_read_transfer -
+ *
+ *
+ */
+int do_write_read_transfer(u8 fs, u8 *wbuf, u32 *wlen, u8 *rbuf, u32 *rlen)
+{
+        u32 sr, dr;
+        u32 wlen_now = 0, rlen_now = 0;
+        int rc = 0;
+
+        while (wlen_now < *wlen) {
+                sr = readl(spi_base + COMCERTO_SPI_SR);
+
+                if (sr & TFNF) {
+                        if (wlen_now < *wlen) {
+                                writew(cpu_to_le16((u16) *wbuf), spi_base + COMCERTO_SPI_DR);
+                                wbuf++;
+                                wlen_now++;
+                        }
+                }
+        }
+
+        while (rlen_now < *rlen) {
+                sr = readl(spi_base + COMCERTO_SPI_SR);
+
+                if (sr & (RFF | DCOL)) {
+                        /* read overrun, data collision */
+                        printf ("%s: sr=0x%x: Read Overrun.\n", __func__, sr);
+                        rc = -1;
+                        goto out;
+                }
+
+                if (sr & RFNE) {
+                        dr = readw(spi_base + COMCERTO_SPI_DR);
+                        if (rlen_now < *rlen) {
+                                *rbuf = (u8) (le16_to_cpu(dr) & 0xff);
+                                rbuf++;
+                                rlen_now++;
+                        } else {
+                                printf ("%s: Read Overflow.\n", __func__);
+                                /* read overflow */
+
+                                rc = -1;
+                                goto out;
+                        }
+                }
+        }
+
+      out:
+        *rlen = rlen_now;
+        *wlen = wlen_now;
+
+        return rc;
+}
+
+
+/**
+ * do_write_only_transfer8 -
+ *
+ *
+ */
+int do_write_only_transfer8(u8 *buf, u32 *len)
+{
+        u32 len_now;
+        int rc = 0;
+        u32 tmp = *len;
+        u32 dr = spi_base + COMCERTO_SPI_DR;
+        u32 txflr = spi_base + COMCERTO_SPI_TXFLR;
+
+        while (tmp)
+        {
+                len_now = 8 - readl(txflr);
+                if (len_now > tmp)
+                        len_now = tmp;
+
+                tmp -= len_now;
+
+                /* warm-up write fifo to avoid underruns */
+                while (len_now--)
+                {
+                        writew(cpu_to_le16((u16) *buf++), dr);
+                }
+        }
+
+        *len -= tmp;
+
+        return rc;
+}
+
+/**
+ * do_write_only_transfer -
+ *
+ *
+ */
+int do_write_only_transfer16(u16 *buf, u32 *len)
+{
+        u32 len_now;
+        int rc = 0;
+        u32 tmp = *len;
+        u32 dr = spi_base + COMCERTO_SPI_DR;
+        u32 txflr = spi_base + COMCERTO_SPI_TXFLR;
+
+        while (tmp)
+        {
+                len_now = 8 - readl(txflr);
+                if (len_now > tmp)
+                        len_now = tmp;
+
+                tmp -= len_now;
+
+                /* warm-up write fifo to avoid underruns */
+                while (len_now--)
+                        writew(cpu_to_le16(*buf++), dr);
+        }
+
+        *len -= tmp;
+
+        return rc;
+}
+
+
+/**
+ * do_read_only_transfer -
+ *
+ *
+ */
+int do_read_only_transfer8(u8 *buf, u32 *len)
+{
+        u32 len_now;
+        int rc = 0;
+        u32 tmp = *len;
+        u32 dr = spi_base + COMCERTO_SPI_DR;
+        u32 rxflr = spi_base + COMCERTO_SPI_RXFLR;
+
+        /* start the serial clock */
+        writew(0, dr);
+
+        while (tmp)
+        {
+                len_now = readl(rxflr);
+                if (len_now > tmp)
+                        len_now = tmp;
+
+                tmp -= len_now;
+
+                while (len_now--) {
+                        *buf = (u8) (le16_to_cpu(readw(dr)) & 0xff);
+                        buf++;
+                }
+        }
+
+        *len -= tmp;
+
+        return rc;
+}
+
+/**
+ * do_read_only_transfer -
+ *
+ *
+ */
+int do_read_only_transfer16(u16 *buf, u32 *len)
+{
+        u32 len_now;
+        int rc = 0;
+        u32 tmp = *len;
+        u32 dr = spi_base + COMCERTO_SPI_DR;
+        u32 rxflr = spi_base + COMCERTO_SPI_RXFLR;
+
+        /* start the serial clock */
+        writew(0, dr);
+
+        while (tmp)
+        {
+                len_now = readl(rxflr);
+                if (len_now > tmp)
+                        len_now = tmp;
+
+                tmp -= len_now;
+
+                while (len_now--) {
+                        *buf = le16_to_cpu(readw(dr));
+                        buf++;
+                }
+        }
+
+        *len -= tmp;
+
+        return rc;
+}
+
+static int c2k_spi_transfer(u8 chip_select,struct spi_transfer *t)
+{
+	unsigned int  op = t->mode & 0xff; 
+        u32 ctrlr0 = 0;
+        u32 baudr  = 0;
+        u32 ser    = 0;
+	u8 bits_per_word = 8;
+	u32 max_speed_hz = 4000000;
+        u32 hz;
+	u8 *txbuf;
+	u8 *rxbuf;
+	int spi_udelay;
+
+	ctrlr0 |= SPI_CTRLR0_SCPOL;
+	ctrlr0 |= SPI_CTRLR0_SCPH;
+	ctrlr0 |= (bits_per_word - 1) & 0xf;
+
+	hz = HAL_get_axi_clk() * 1000000;
+	baudr = hz / max_speed_hz;
+	ser = (1 << chip_select) ;
+
+	spi_udelay = 1 + ((1000000 * bits_per_word) / max_speed_hz);
+
+        while(readl(spi_base + COMCERTO_SPI_SR) & BUSY);
+
+	writel(0, spi_base + COMCERTO_SPI_SSIENR);
+
+	txbuf = t->tx_buf;
+	rxbuf = t->rx_buf;
+
+	switch(op) {
+		case SPI_TRANSFER_MODE_WRITE_ONLY:
+
+			ctrlr0 |= (0x0001 << 8);
+			writel(ctrlr0, spi_base + COMCERTO_SPI_CTRLR0);
+			writel(baudr, spi_base + COMCERTO_SPI_BAUDR);
+			writel(ser, spi_base + COMCERTO_SPI_SER);
+			writel(8, spi_base + COMCERTO_SPI_RXFTLR);
+			writel(0, spi_base + COMCERTO_SPI_TXFTLR);
+			writel(0, spi_base + COMCERTO_SPI_IMR);
+			writel(1, spi_base + COMCERTO_SPI_SSIENR);
+
+			if (bits_per_word <= 8)
+				do_write_only_transfer8(txbuf, &t->len);
+			else
+				do_write_only_transfer16((u16*)txbuf, &t->len);
+
+			break;
+
+		case SPI_TRANSFER_MODE_READ_ONLY:
+
+			ctrlr0 |= (0x0002 << 8);
+			writel(ctrlr0, spi_base + COMCERTO_SPI_CTRLR0);
+			writel(baudr, spi_base + COMCERTO_SPI_BAUDR);
+			writel(ser, spi_base + COMCERTO_SPI_SER);
+			writel(8, spi_base + COMCERTO_SPI_RXFTLR);
+			writel(0, spi_base + COMCERTO_SPI_TXFTLR);
+			writel(0, spi_base + COMCERTO_SPI_IMR);
+			writel(1, spi_base + COMCERTO_SPI_SSIENR);
+
+			if (bits_per_word <= 8)
+				do_read_only_transfer8(rxbuf, &t->len);
+			else
+				do_read_only_transfer16((u16 *)rxbuf, &t->len);
+
+			break;
+
+		case SPI_TRANSFER_MODE_WRITE_READ:
+
+			ctrlr0 |= (0x0000 << 8);
+			writel(ctrlr0, spi_base + COMCERTO_SPI_CTRLR0);
+			writel(baudr, spi_base + COMCERTO_SPI_BAUDR);
+			writel(ser, spi_base + COMCERTO_SPI_SER);
+			writel(8, spi_base + COMCERTO_SPI_RXFTLR);
+			writel(0, spi_base + COMCERTO_SPI_TXFTLR);
+			writel(0, spi_base + COMCERTO_SPI_IMR);
+			writel(1, spi_base + COMCERTO_SPI_SSIENR);
+
+			do_write_read_transfer(bits_per_word, txbuf, &t->len, rxbuf, &t->len);
+
+                                break;
+
+                        default:
+                                printf ("Transfer mode not supported.\n");
+				return -1;
+                };
+
+                /* deassert the chip select at least for this long */
+                udelay (spi_udelay);
+		while(readl(spi_base + COMCERTO_SPI_SR) & BUSY)
+			;
+
+        return 0;
+
+
+}
+
+
+int c2k_spi_write(u8 cs, const void *buf, size_t len)
+{
+        struct spi_transfer     t = {
+                        .tx_buf         = buf,
+                        .len            = len,
+			.mode		= SPI_TRANSFER_MODE_WRITE_ONLY,
+                };
+
+	c2k_spi_transfer(cs, &t);
+}
+
+int c2k_spi_read(u8 cs, void *buf, size_t len)
+{
+        struct spi_transfer     t = {
+                        .rx_buf         = buf,
+                        .len            = len,
+			.mode		= SPI_TRANSFER_MODE_READ_ONLY,
+                };
+
+	c2k_spi_transfer(cs, &t);
+}
+
+int c2k_spi_write_then_read(u8 cs, const void *tx_buf, size_t tx_len, void *rx_buf, size_t rx_len)
+{
+        struct spi_transfer     t = {
+                        .tx_buf         = tx_buf,
+                        .rx_buf         = rx_buf,
+                        .len            = tx_len,
+			.mode		= SPI_TRANSFER_MODE_WRITE_READ,
+                };
+
+	c2k_spi_transfer(cs, &t);
+}
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/drivers/spi/Makefile u-boot-2013.01.new/drivers/spi/Makefile
--- u-boot-2013.01/drivers/spi/Makefile	2013-01-16 03:17:42.000000000 +0530
+++ u-boot-2013.01.new/drivers/spi/Makefile	2016-03-23 16:10:34.000000000 +0530
@@ -47,6 +47,8 @@
 COBJS-$(CONFIG_FSL_ESPI) += fsl_espi.o
 COBJS-$(CONFIG_TEGRA_SPI) += tegra_spi.o
 COBJS-$(CONFIG_XILINX_SPI) += xilinx_spi.o
+COBJS-$(CONFIG_DRIVER_SPI_C2K) += c2k_spi.o
+
 
 COBJS	:= $(COBJS-y)
 SRCS	:= $(COBJS:.o=.c)
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/include/configs/c2kasic.h u-boot-2013.01.new/include/configs/c2kasic.h
--- u-boot-2013.01/include/configs/c2kasic.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/include/configs/c2kasic.h	2016-03-23 16:10:35.000000000 +0530
@@ -0,0 +1,248 @@
+/*
+ * Copyright (C) 2013 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef __CONFIG_C2KASIC_H
+#define __CONFIG_C2KASIC_H
+
+
+#define CONFIG_ARMV7 /* This is an ARM V7 CPU core */
+
+#define CONFIG_COMCERTO_2000
+#define MACH_TYPE_COMCERTO	1094
+#define CONFIG_MACH_TYPE	MACH_TYPE_COMCERTO
+#define CONFIG_C2KASIC
+
+#include <asm/hardware.h>
+
+/* CPU clock */
+#define CONFIG_SYS_HZ		1000		/* decrementer freq: 1 ms ticks */
+
+/*
+ * RAM configuration
+ */
+#define CONFIG_NR_DRAM_BANKS		1
+#define CONFIG_SYS_TEXT_BASE		0x1000000
+#define CONFIG_SYS_SDRAM_BASE		COMCERTO_AXI_DDR_BASE
+#define CONFIG_SYS_SDRAM_SIZE		(512 * 1024 * 1024)
+#define CONFIG_SYS_MEMTEST_START	0x0300000	/* memtest works on     */
+#define CONFIG_SYS_MEMTEST_END		0x0700000	/* 3 ... 7 MB in DRAM   */
+
+#undef  CONFIG_SHOW_BOOT_PROGRESS
+
+/*
+ * UART configuration
+ */
+/* define one of these to choose the UART0 or UART1 as console */
+#define CONFIG_UART0		1	/* TODO We use UART1. Change it along with driver */
+#define CONFIG_BAUDRATE		115200
+#define CONFIG_BAUDRATE_TABLE	{115200, 19200, 38400, 57600, 9600}
+#define CONFIG_COMCERTO_SERIAL
+
+/* Expansion Bus Configuration */
+#define EXP_CS0_BASE_VAL	0x0
+#define EXP_CS0_SEG_SIZE_VAL	0x7FFF
+#define EXP_CS0_SEG_END_VAL	(EXP_CS0_BASE_VAL + EXP_CS0_SEG_SIZE_VAL)
+
+#define EXP_CS1_BASE_VAL	(EXP_CS0_SEG_END_VAL + 1)
+#define EXP_CS1_SEG_SIZE_VAL	0xFF
+#define EXP_CS1_SEG_END_VAL	(EXP_CS1_BASE_VAL + EXP_CS1_SEG_SIZE_VAL)
+
+#define EXP_CS2_BASE_VAL	(EXP_CS1_SEG_END_VAL + 1)
+#define EXP_CS2_SEG_SIZE_VAL	0xFF
+#define EXP_CS2_SEG_END_VAL	(EXP_CS2_BASE_VAL + EXP_CS2_SEG_SIZE_VAL)
+
+#define EXP_CS3_BASE_VAL	(EXP_CS2_SEG_END_VAL + 1)
+#define EXP_CS3_SEG_SIZE_VAL	0xFF
+#define EXP_CS3_SEG_END_VAL	(EXP_CS3_BASE_VAL + EXP_CS3_SEG_SIZE_VAL)
+
+#define EXP_CS4_BASE_VAL	(EXP_CS3_SEG_END_VAL + 1)
+#define EXP_CS4_SEG_SIZE_VAL	0xFF
+#define EXP_CS4_SEG_END_VAL	(EXP_CS4_BASE_VAL + EXP_CS4_SEG_SIZE_VAL)
+
+#define SHIFT_4K_MUL	12
+
+#define COMCERTO_EXP_CS4_BASE_ADDR	(COMCERTO_AXI_EXP_BASE + (EXP_CS4_BASE_VAL << SHIFT_4K_MUL))
+
+/* SPI Driver */
+#define CONFIG_DRIVER_SPI_C2K
+
+/* OTP Driver */
+#define CONFIG_DRIVER_OTP
+
+/* SPACC Driver */
+#define CONFIG_DRIVER_SPACC
+
+/* Enable Secure boot*/
+#define CONFIG_SECUREBOOT
+
+/*SPI NOR Flash CS:0*/
+#define SPI_FLASH_SIZE  (8 * 1024 * 1024) /* 8 MB */
+#define SPI_FLASH_SECTOR_64KB     (64 * 1024)
+#define SPI_FLASH_SECTOR_256KB    (256 * 1024)
+#define SPI_FLASH_NOR_PAGE_SIZE   256 /* Bytes */
+#define SPI_FLASH_SECTOR_SIZE     SPI_FLASH_SECTOR_64KB
+#define SPI_FLASH_NUM_SECTORS     (SPI_FLASH_SIZE/SPI_FLASH_SECTOR_SIZE)
+#define SPI_FLASH_NUM_PAGES_PER_SEC       (SPI_FLASH_SECTOR_SIZE/SPI_FLASH_NOR_PAGE_SIZE)
+
+/*
+ * flash configuration - using cfi driver
+ */
+#define NOR_FLASH_BASE			COMCERTO_AXI_EXP_BASE	/* Flash Bank #1 */
+#define NOR_FLASH_SECT_SIZE		(128 * 1024)		/* 128 KiB sectors */
+#define NOR_FLASH_SECT_COUNT		1024
+
+#define CONFIG_SYS_FLASH_BASE		(NOR_FLASH_BASE)	/* Physical start address of Flash memory */
+#define CONFIG_SYS_FLASH_SIZE		(128 * 1024 * 1024)	/* 128 MB */
+#define CONFIG_SYS_MAX_FLASH_SECT	NOR_FLASH_SECT_COUNT	/* max number of sectors on one chip */
+#define CONFIG_SYS_MAX_FLASH_BANKS	1
+#define CONFIG_SYS_FLASH_CFI		1
+#define CONFIG_SYS_FLASH_PROTECTION
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE 1	/* use buffered writes (20x faster)	*/
+#define CONFIG_SYS_FLASH_EMPTY_INFO		/* print 'E' for empty sector on flinfo */
+#define CONFIG_FLASH_CFI_DRIVER		1
+
+#define CONFIG_SYS_FLASH_ERASE_TOUT	(2 * CONFIG_SYS_HZ)	/* Timeout for Flash Erase (in ms)	*/
+#define CONFIG_SYS_FLASH_WRITE_TOUT	(1 * CONFIG_SYS_HZ)	/* Timeout for Flash Write (in ms)	*/
+
+#define MTDIDS_DEFAULT			"nor0=comcertoflash.0"
+#define MTDPARTS_DEFAULT		"mtdparts=comcertoflash.0:128k(uloader)ro,256k(u-boot)ro,128k(env),4M(kernel),48M(rootfs)"
+
+/*
+ *  * Gemac Settings
+ *   */
+#define EMAC0_PHY_ADDR		4
+#define EMAC1_PHY_ADDR		0
+#define EMAC0_FLAGS		0
+#define EMAC1_FLAGS		1
+#define EMAC2_FLAGS		0
+
+#define CONFIG_NET_MULTI        1
+//#define CONFIG_MII
+//#define CONFIG_PHYLIB
+
+
+/* Enviroment */
+#define CONFIG_ENV_IS_IN_FLASH		1
+#define CONFIG_ENV_ADDR			(CONFIG_SYS_FLASH_BASE + ((128 + 256) * 1024))
+#define CONFIG_ENV_SIZE			0x20000	/* Total Size of Environment 128KiB */
+
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 128 * 1024)
+#define CONFIG_SYS_INIT_RAM_ADDR	0x01000000 /* DDR address */
+#define CONFIG_SYS_INIT_RAM_SIZE	0x00080000 /* 512K */
+#define CONFIG_SYS_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
+#define CONFIG_SYS_GBL_DATA_OFFSET	((CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_RAM_SIZE) - CONFIG_SYS_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR		CONFIG_SYS_GBL_DATA_OFFSET
+
+#define CONFIG_SYS_PROMPT		"U-Boot> "
+#define CONFIG_SYS_CBSIZE		256 /* Console I/O Buffer Size */
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
+						sizeof(CONFIG_SYS_PROMPT) + 16)
+
+#define CONFIG_SYS_LOAD_ADDR		(CONFIG_SYS_SDRAM_BASE + 0x01000000) /* default load address */
+#define CONFIG_SYS_MAXARGS		15 /* max number of command args */
+#define CONFIG_SYS_LONGHELP
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_CMDLINE_EDITING
+
+/* Commands */ /* TODO */
+#include <config_cmd_default.h>
+
+#undef CONFIG_CMD_BDI
+#undef CONFIG_CMD_FPGA
+#undef CONFIG_CMD_IMI
+#undef CONFIG_CMD_IMLS
+#undef CONFIG_CMD_LOADS
+#undef CONFIG_CMD_SOURCE
+
+#define CONFIG_CMD_FLASH	/* flinfo, erase, protect	*/
+#define CONFIG_CMD_SAVEENV
+
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_PFE_COMMANDS
+#define CONFIG_CMD_PFE_STATS
+
+#define CONFIG_CMD_SOCINFO
+#define CONFIG_CMD_UPDATE_SPI
+
+/*
+ * Environment Configuration
+ */
+#ifndef CONFIG_SECUREBOOT
+#define CONFIG_BOOTCOMMAND	"bootm 0xc0080000"
+#else
+#define CONFIG_BOOTCOMMAND	"run boot_flash_sec"
+#endif
+#define CONFIG_BOOTARGS		"console=ttyS0,115200 "			\
+				"root=/dev/mtdblock4 "			\
+				"mtdparts=comcertoflash.0:128k(uloader)ro,256k(u-boot)ro,128k(env),4M(kernel),48M(rootfs)"	\
+				"rw rootfstype=jffs2"
+
+
+#define	CONFIG_EXTRA_ENV_SETTINGS											\
+	"hostname=comcerto2000\0"											\
+	"netdev=eth0\0"													\
+	"nfsargs=setenv bootargs init=${init_process} root=/dev/nfs rw "						\
+		"nfsroot=${serverip}:${rootpath}\0"									\
+	"flashargs=setenv bootargs init=${init_process} root=/dev/mtdblock4 rootfstype=${rootfstype} rw\0"		\
+	"rootfstype=jffs2\0"												\
+	"init_process=/etc/preinit\0"											\
+	"addip=setenv bootargs ${bootargs} "										\
+		"ip=${ipaddr}:${serverip}:${gatewayip}:${netmask}"							\
+		":${hostname}:${netdev}:off\0"										\
+	"addeth=setenv bootargs ${bootargs} "										\
+	"hwaddress=${netdev},${ethaddr}\0"										\
+	"addtty=setenv bootargs ${bootargs} console=ttyS0,115200n8\0"							\
+	"addmtd=setenv bootargs ${bootargs} ${mtdparts}\0"								\
+	"flash_self=run flashargs addip addtty;"									\
+		"bootm ${kernel_addr}\0"										\
+	"boot_nfs=nfs 80600000 ${rootpath}/boot/${kernelfile};run nfsargs addeth addip addtty;"				\
+	        "bootm 80600000\0"											\
+	"boot_flash=run flashargs addeth addtty addmtd; bootm 0xc0080000\0"						\
+	"boot_flash_sec=run flashargs addeth addtty addmtd; cp.b 0xc0080000 0x00900000 0x400000; bootm 0x00900000\0"	\
+	"boot_flashold=run flashargs addeth addtty addmtd; fsload /boot/uImage; bootm\0"				\
+	"loadaddr=0x3000000\0"												\
+	"rootpath=/devel/fs-c2kasic\0"											\
+	"kernelfile=uImage\0"												\
+	"bootfile=u-boot.bin\0"												\
+	"mtdids=" MTDIDS_DEFAULT "\0"											\
+	"mtdparts=" MTDPARTS_DEFAULT "\0"										\
+	"mtddevnum=2\0"													\
+	"mtddevname=fs\0"												\
+	"fsfile=root.jffs2-128k\0"											\
+	"updatefs=tftp 3000000 ${fsfile};protect off 1:36-420\;erase 1:36-420;cp.b 3000000 c0480000 ${filesize}\0"	\
+	"updatekernel=tftp 3000000 ${kernelfile};protect off 1:4-35\;erase 1:4-35;cp.b 3000000 c0080000 ${filesize}\0"	\
+	"updateboot=tftp 3000000 ${bootfile};protect off 1:1-3\;erase 1:1-3;cp.b 3000000 c0020000 ${filesize}\0"	\
+	"updateuloader=tftp 3000000 uloader.bin;protect off 1:0-1\;erase 1:0-1;cp.b 3000000 c0000000 ${filesize}\0"	\
+	""
+
+#define CONFIG_ETHADDR		00:aa:bb:cc:dd:ee
+#define CONFIG_IPADDR		192.168.0.2
+#define CONFIG_SERVERIP		192.168.0.1
+#define CONFIG_BOOTDELAY	3
+
+/*
+ * Misc configuration options
+ */
+#define CONFIG_CMDLINE_TAG		1	/* enable passing of ATAGs	*/
+#define CONFIG_SETUP_MEMORY_TAGS	1
+//#define CONFIG_INITRD_TAG		1
+
+#endif /* __CONFIG_C2KASIC_H */
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/include/configs/c2kasic-nand.h u-boot-2013.01.new/include/configs/c2kasic-nand.h
--- u-boot-2013.01/include/configs/c2kasic-nand.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/include/configs/c2kasic-nand.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,293 @@
+/*
+ * Copyright (C) 2013 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef __CONFIG_C2KASIC_H
+#define __CONFIG_C2KASIC_H
+
+
+#define CONFIG_ARMV7 /* This is an ARM V7 CPU core */
+
+#define CONFIG_COMCERTO_2000
+#define MACH_TYPE_COMCERTO	1094
+#define CONFIG_MACH_TYPE	MACH_TYPE_COMCERTO
+#define CONFIG_C2KASIC
+
+#include <asm/hardware.h>
+
+/* CPU clock */
+#define CONFIG_SYS_HZ		1000		/* decrementer freq: 1 ms ticks */
+
+/*
+ * RAM configuration
+ */
+#define CONFIG_NR_DRAM_BANKS		1
+#define CONFIG_SYS_TEXT_BASE		0x1000000
+#define CONFIG_SYS_SDRAM_BASE		COMCERTO_AXI_DDR_BASE
+#define CONFIG_SYS_SDRAM_SIZE		(512 * 1024 * 1024)
+#define CONFIG_SYS_MEMTEST_START	0x0300000	/* memtest works on     */
+#define CONFIG_SYS_MEMTEST_END		0x0700000	/* 3 ... 7 MB in DRAM   */
+
+#undef  CONFIG_SHOW_BOOT_PROGRESS
+
+/*
+ * UART configuration
+ */
+/* define one of these to choose the UART0 or UART1 as console */
+#define CONFIG_UART0		1	/* TODO We use UART1. Change it along with driver */
+#define CONFIG_BAUDRATE		115200
+#define CONFIG_BAUDRATE_TABLE	{115200, 19200, 38400, 57600, 9600}
+#define CONFIG_COMCERTO_SERIAL
+
+#define CONFIG_NAND_COMCERTO
+
+/* Expansion Bus Configuration */
+#define EXP_CS0_BASE_VAL	0x0
+#define EXP_CS0_SEG_SIZE_VAL	0x7FFF
+#define EXP_CS0_SEG_END_VAL	(EXP_CS0_BASE_VAL + EXP_CS0_SEG_SIZE_VAL)
+
+#define EXP_CS1_BASE_VAL	(EXP_CS0_SEG_END_VAL + 1)
+#define EXP_CS1_SEG_SIZE_VAL	0xFF
+#define EXP_CS1_SEG_END_VAL	(EXP_CS1_BASE_VAL + EXP_CS1_SEG_SIZE_VAL)
+
+#define EXP_CS2_BASE_VAL	(EXP_CS1_SEG_END_VAL + 1)
+#define EXP_CS2_SEG_SIZE_VAL	0xFF
+#define EXP_CS2_SEG_END_VAL	(EXP_CS2_BASE_VAL + EXP_CS2_SEG_SIZE_VAL)
+
+#define EXP_CS3_BASE_VAL	(EXP_CS2_SEG_END_VAL + 1)
+#define EXP_CS3_SEG_SIZE_VAL	0xFF
+#define EXP_CS3_SEG_END_VAL	(EXP_CS3_BASE_VAL + EXP_CS3_SEG_SIZE_VAL)
+
+#define EXP_CS4_BASE_VAL	(EXP_CS3_SEG_END_VAL + 1)
+#define EXP_CS4_SEG_SIZE_VAL	0xFF
+#define EXP_CS4_SEG_END_VAL	(EXP_CS4_BASE_VAL + EXP_CS4_SEG_SIZE_VAL)
+
+#define SHIFT_4K_MUL	12
+
+#define COMCERTO_EXP_CS4_BASE_ADDR	(COMCERTO_AXI_EXP_BASE + (EXP_CS4_BASE_VAL << SHIFT_4K_MUL))
+
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_SYS_NAND_MAX_CHIPS	1
+#define CONFIG_SYS_NAND_BASE		COMCERTO_EXP_CS4_BASE_ADDR
+#define CONFIG_SYS_NAND_SELF_INIT
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+#define CONFIG_NAND_COMCERTO_ECC_24_HW_BCH
+//#define CONFIG_NAND_COMCERTO_ECC_8_HW_BCH
+#define CONFIG_COMCERTO_NAND_ERASE_FBB
+#define CONFIG_MACH_COMCERTO_C2K_ASIC
+//#define CONFIG_NAND_TYPE_SLC
+#define CONFIG_SYS_NAND_USE_FLASH_BBT
+#define NAND_BBT_SIZE			(1024 * 1024)
+
+
+#define CONFIG_CMD_NAND_TRIMFFS
+
+/* SPI Driver */
+#define CONFIG_DRIVER_SPI_C2K
+
+/* OTP Driver */
+#define CONFIG_DRIVER_OTP
+
+/* SPACC Driver */
+#define CONFIG_DRIVER_SPACC
+
+/* Enable Secure boot*/
+#define CONFIG_SECUREBOOT
+
+/*SPI NOR Flash CS:0*/
+#define SPI_FLASH_SIZE  (8 * 1024 * 1024) /* 8 MB */
+#define SPI_FLASH_SECTOR_64KB     (64 * 1024)
+#define SPI_FLASH_SECTOR_256KB    (256 * 1024)
+#define SPI_FLASH_NOR_PAGE_SIZE   256 /* Bytes */
+#define SPI_FLASH_SECTOR_SIZE     SPI_FLASH_SECTOR_64KB
+#define SPI_FLASH_NUM_SECTORS     (SPI_FLASH_SIZE/SPI_FLASH_SECTOR_SIZE)
+#define SPI_FLASH_NUM_PAGES_PER_SEC       (SPI_FLASH_SECTOR_SIZE/SPI_FLASH_NOR_PAGE_SIZE)
+
+/*
+ * flash configuration - using cfi driver
+ */
+#define NOR_FLASH_BASE			COMCERTO_AXI_EXP_BASE	/* Flash Bank #1 */
+#define NOR_FLASH_SECT_SIZE		(128 * 1024)		/* 128 KiB sectors */
+#define NOR_FLASH_SECT_COUNT		512
+
+#define CONFIG_SYS_FLASH_BASE		(NOR_FLASH_BASE)	/* Physical start address of Flash memory */
+#define CONFIG_SYS_FLASH_SIZE		(64 * 1024 * 1024)	/* 64 MB */
+#define CONFIG_SYS_MAX_FLASH_SECT	NOR_FLASH_SECT_COUNT	/* max number of sectors on one chip */
+#define CONFIG_SYS_MAX_FLASH_BANKS	1
+#define CONFIG_SYS_FLASH_CFI		1
+#define CONFIG_SYS_FLASH_PROTECTION
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE 1	/* use buffered writes (20x faster)	*/
+#define CONFIG_SYS_FLASH_EMPTY_INFO		/* print 'E' for empty sector on flinfo */
+#define CONFIG_FLASH_CFI_DRIVER		1
+
+#define CONFIG_SYS_FLASH_ERASE_TOUT	(2 * CONFIG_SYS_HZ)	/* Timeout for Flash Erase (in ms)	*/
+#define CONFIG_SYS_FLASH_WRITE_TOUT	(1 * CONFIG_SYS_HZ)	/* Timeout for Flash Write (in ms)	*/
+
+#define CONFIG_MTD_DEVICE
+#define MTDIDS_DEFAULT			"nand0=comcertonand"
+
+/*
+ *  * Gemac Settings
+ *   */
+#define EMAC0_PHY_ADDR		4
+#define EMAC1_PHY_ADDR		0
+#define EMAC0_FLAGS		0
+#define EMAC1_FLAGS		1
+#define EMAC2_FLAGS		0
+
+#define CONFIG_NET_MULTI        1
+//#define CONFIG_MII
+//#define CONFIG_PHYLIB
+
+
+/* Enviroment */
+//#define CONFIG_ENV_IS_IN_FLASH		1
+#define CONFIG_ENV_IS_IN_C2K_SPI_FLASH	1
+
+#if defined (CONFIG_ENV_IS_IN_FLASH)
+#define CONFIG_ENV_ADDR			(CONFIG_SYS_FLASH_BASE + ((128 + 256) * 1024))
+#define CONFIG_ENV_SIZE			0x20000	/* Total Size of Environment 128KiB */
+#elif defined CONFIG_ENV_IS_IN_C2K_SPI_FLASH
+#define CONFIG_ENV_OFFSET		0
+#define CONFIG_ENV_SPI_SECTOR		10
+#define CONFIG_ENV_SIZE			0x20000	/* Total Size of Environment 128KiB */
+#define CONFIG_ENV_SECT_SIZE		0x20000
+#endif
+
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 128 * 1024) + (NAND_BBT_SIZE)
+#define CONFIG_SYS_INIT_RAM_ADDR	0x01000000 /* DDR address */
+#define CONFIG_SYS_INIT_RAM_SIZE	0x00080000 /* 512K */
+#define CONFIG_SYS_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
+#define CONFIG_SYS_GBL_DATA_OFFSET	((CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_RAM_SIZE) - CONFIG_SYS_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR		CONFIG_SYS_GBL_DATA_OFFSET
+
+#define CONFIG_SYS_PROMPT		"U-Boot> "
+#define CONFIG_SYS_CBSIZE		256 /* Console I/O Buffer Size */
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
+						sizeof(CONFIG_SYS_PROMPT) + 16)
+
+#define CONFIG_SYS_LOAD_ADDR		(CONFIG_SYS_SDRAM_BASE + 0x01000000) /* default load address */
+#define CONFIG_SYS_MAXARGS		15 /* max number of command args */
+#define CONFIG_SYS_LONGHELP
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_CMDLINE_EDITING
+
+/* Commands */ /* TODO */
+#include <config_cmd_default.h>
+
+#undef CONFIG_CMD_BDI
+#undef CONFIG_CMD_FPGA
+#undef CONFIG_CMD_IMI
+#undef CONFIG_CMD_IMLS
+#undef CONFIG_CMD_LOADS
+#undef CONFIG_CMD_SOURCE
+
+#define CONFIG_CMD_FLASH	/* flinfo, erase, protect	*/
+#define CONFIG_CMD_SAVEENV
+#define CONFIG_CMD_MTDPARTS
+#define CONFIG_CMD_NAND
+
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_PFE_COMMANDS
+#define CONFIG_CMD_PFE_STATS
+#define CONFIG_CMD_DHCP
+
+#define CONFIG_CMD_SOCINFO
+#define CONFIG_CMD_UPDATE_SPI
+
+/*
+ * Environment Configuration
+ */
+#define CONFIG_BOOTCOMMAND	"nand read 0x3000000 0x200000 0x400000; bootm 0x3000000;"
+#define CONFIG_BOOTARGS         "console=ttyS0,115200 "			\
+				"init=/etc/preinit "			\
+				"root=ubi0:rootfs "			\
+				"ubi.mtd=8,4096 "			\
+				"rootfstype=ubifs rw "			\
+				"noinitrd "				\
+				"mtdparts=comcertoflash.0:"		\
+					"128k(uloader)ro,"		\
+					"512k(barebox)ro,"		\
+					"128k(env),"			\
+					"4M(kernel),"			\
+					"48M(rootfs);"			\
+					"comcertonand:"			\
+					"1M(u-boot)ro,"			\
+					"1M(env),"			\
+					"4M(kernel),"			\
+					"-(rootfs) "			\
+				"usb3_internal_clk=yes"
+
+#define CONFIG_MTDPARTS		"1M(u-boot)ro,1M(env),4M(kernel),-(rootfs)"
+#define CONFIG_MTDPARTS_NAND	"mtdparts=comcertonand:1M(u-boot)ro,1M(env),4M(kernel),-(rootfs)"
+#define MTDPARTS_DEFAULT	"mtdparts=comcertonand:"CONFIG_MTDPARTS
+
+#define	CONFIG_EXTRA_ENV_SETTINGS											\
+	"hostname=comcerto2000\0"											\
+	"netdev=eth0\0"													\
+	"nfsargs=setenv bootargs init=${init_process} root=/dev/nfs rw "						\
+		"nfsroot=${serverip}:${rootpath}\0"									\
+	"flashargs=setenv bootargs init=${init_process} root=/dev/mtdblock4 rootfstype=${rootfstype} rw\0"		\
+	"rootfstype=ubifs\0"												\
+	"init_process=/etc/preinit\0"											\
+	"addip=setenv bootargs ${bootargs} "										\
+		"ip=${ipaddr}:${serverip}:${gatewayip}:${netmask}"							\
+		":${hostname}:${netdev}:off\0"										\
+	"addeth=setenv bootargs ${bootargs} "										\
+	"hwaddress=${netdev},${ethaddr}\0"										\
+	"addtty=setenv bootargs ${bootargs} console=ttyS0,115200n8\0"							\
+	"addmtd=setenv bootargs ${bootargs} ${mtdparts}\0"								\
+	"flash_self=run flashargs addip addtty;"									\
+		"bootm ${kernel_addr}\0"										\
+	"boot_nfs=nfs 80600000 ${rootpath}/boot/${kernelfile};run nfsargs addeth addip addtty;"				\
+	        "bootm 80600000\0"											\
+	"boot_flash=run flashargs addeth addtty addmtd; bootm 0xc0080000\0"						\
+	"boot_flashold=run flashargs addeth addtty addmtd; fsload /boot/uImage; bootm\0"				\
+	"loadaddr=0x3000000\0"												\
+	"rootpath=/devel/fs-c2kasic\0"											\
+	"kernelfile=uImage\0"												\
+	"bootfile=u-boot.bin\0"												\
+	"mtdids=" MTDIDS_DEFAULT "\0"											\
+	"mtdparts=" MTDPARTS_DEFAULT "\0"										\
+	"mtddevnum=2\0"													\
+	"mtddevname=fs\0"												\
+	"fsfile=root.jffs2-128k\0"											\
+	"updatefs=tftp 3000000 ${fsfile};protect off 1:36-420\;erase 1:36-420;cp.b 3000000 c0480000 ${filesize}\0"	\
+	"updatekernel=tftp 3000000 ${kernelfile};protect off 1:4-35\;erase 1:4-35;cp.b 3000000 c0080000 ${filesize}\0"	\
+	"updateboot=tftp 3000000 ${bootfile};protect off 1:1-3\;erase 1:1-3;cp.b 3000000 c0020000 ${filesize}\0"	\
+	"updateuloader=tftp 3000000 uloader.bin;protect off 1:0-1\;erase 1:0-1;cp.b 3000000 c0000000 ${filesize}\0"	\
+	"updatefs_nand=tftp 0000000 ${fsfile}; nand erase.part rootfs; nand write.trimffs ${fileaddr} rootfs ${filesize}\0"		\
+	"updatekernel_nand=tftp 3000000 ${kernelfile}; nand erase.part kernel; nand write ${fileaddr} kernel ${filesize}\0"\
+	"updateboot_nand=tftp 3000000 ${bootfile}; nand erase.part u-boot; nand write ${fileaddr} u-boot ${filesize}\0"	\
+	""
+
+#define CONFIG_ETHADDR		00:aa:bb:cc:dd:ee
+#define CONFIG_IPADDR		192.168.0.2
+#define CONFIG_SERVERIP		192.168.0.1
+#define CONFIG_BOOTDELAY	3
+
+/*
+ * Misc configuration options
+ */
+#define CONFIG_CMDLINE_TAG		1	/* enable passing of ATAGs	*/
+#define CONFIG_SETUP_MEMORY_TAGS	1
+//#define CONFIG_INITRD_TAG		1
+
+#endif /* __CONFIG_C2KASIC_H */
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/include/configs/c2kevm.h u-boot-2013.01.new/include/configs/c2kevm.h
--- u-boot-2013.01/include/configs/c2kevm.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/include/configs/c2kevm.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,248 @@
+/*
+ * Copyright (C) 2013 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef __CONFIG_C2KEVM_H
+#define __CONFIG_C2KEVM_H
+
+
+#define CONFIG_ARMV7 /* This is an ARM V7 CPU core */
+
+#define CONFIG_COMCERTO_2000
+#define MACH_TYPE_COMCERTO	1094
+#define CONFIG_MACH_TYPE	MACH_TYPE_COMCERTO
+#define CONFIG_C2KEVM
+
+#include <asm/hardware.h>
+
+/* CPU clock */
+#define CONFIG_SYS_HZ		1000		/* decrementer freq: 1 ms ticks */
+
+/*
+ * RAM configuration
+ */
+#define CONFIG_NR_DRAM_BANKS		1
+#define CONFIG_SYS_TEXT_BASE		0x1000000
+#define CONFIG_SYS_SDRAM_BASE		COMCERTO_AXI_DDR_BASE
+#define CONFIG_SYS_SDRAM_SIZE		(512 * 1024 * 1024)
+#define CONFIG_SYS_MEMTEST_START	0x0300000	/* memtest works on     */
+#define CONFIG_SYS_MEMTEST_END		0x0700000	/* 3 ... 7 MB in DRAM   */
+
+#undef  CONFIG_SHOW_BOOT_PROGRESS
+
+/*
+ * UART configuration
+ */
+/* define one of these to choose the UART0 or UART1 as console */
+#define CONFIG_UART0		1	/* TODO We use UART1. Change it along with driver */
+#define CONFIG_BAUDRATE		115200
+#define CONFIG_BAUDRATE_TABLE	{115200, 19200, 38400, 57600, 9600}
+#define CONFIG_COMCERTO_SERIAL
+
+/* Expansion Bus Configuration */
+#define EXP_CS0_BASE_VAL	0x0
+#define EXP_CS0_SEG_SIZE_VAL	0x7FFF
+#define EXP_CS0_SEG_END_VAL	(EXP_CS0_BASE_VAL + EXP_CS0_SEG_SIZE_VAL)
+
+#define EXP_CS1_BASE_VAL	(EXP_CS0_SEG_END_VAL + 1)
+#define EXP_CS1_SEG_SIZE_VAL	0xFF
+#define EXP_CS1_SEG_END_VAL	(EXP_CS1_BASE_VAL + EXP_CS1_SEG_SIZE_VAL)
+
+#define EXP_CS2_BASE_VAL	(EXP_CS1_SEG_END_VAL + 1)
+#define EXP_CS2_SEG_SIZE_VAL	0xFF
+#define EXP_CS2_SEG_END_VAL	(EXP_CS2_BASE_VAL + EXP_CS2_SEG_SIZE_VAL)
+
+#define EXP_CS3_BASE_VAL	(EXP_CS2_SEG_END_VAL + 1)
+#define EXP_CS3_SEG_SIZE_VAL	0xFF
+#define EXP_CS3_SEG_END_VAL	(EXP_CS3_BASE_VAL + EXP_CS3_SEG_SIZE_VAL)
+
+#define EXP_CS4_BASE_VAL	(EXP_CS3_SEG_END_VAL + 1)
+#define EXP_CS4_SEG_SIZE_VAL	0xFF
+#define EXP_CS4_SEG_END_VAL	(EXP_CS4_BASE_VAL + EXP_CS4_SEG_SIZE_VAL)
+
+#define SHIFT_4K_MUL	12
+
+#define COMCERTO_EXP_CS4_BASE_ADDR	(COMCERTO_AXI_EXP_BASE + (EXP_CS4_BASE_VAL << SHIFT_4K_MUL))
+
+/* SPI Driver */
+#define CONFIG_DRIVER_SPI_C2K
+
+/* OTP Driver */
+#define CONFIG_DRIVER_OTP
+
+/* SPACC Driver */
+#define CONFIG_DRIVER_SPACC
+
+/* Enable Secure boot*/
+#define CONFIG_SECUREBOOT
+
+/*SPI NOR Flash CS:0*/
+#define SPI_FLASH_SIZE  (16 * 1024 * 1024) /* 16 MB */
+#define SPI_FLASH_SECTOR_64KB     (64 * 1024)
+#define SPI_FLASH_SECTOR_256KB    (256 * 1024)
+#define SPI_FLASH_NOR_PAGE_SIZE   256 /* Bytes */
+#define SPI_FLASH_SECTOR_SIZE     SPI_FLASH_SECTOR_64KB
+#define SPI_FLASH_NUM_SECTORS     (SPI_FLASH_SIZE/SPI_FLASH_SECTOR_SIZE)
+#define SPI_FLASH_NUM_PAGES_PER_SEC       (SPI_FLASH_SECTOR_SIZE/SPI_FLASH_NOR_PAGE_SIZE)
+
+/*
+ * flash configuration - using cfi driver
+ */
+#define NOR_FLASH_BASE			COMCERTO_AXI_EXP_BASE	/* Flash Bank #1 */
+#define NOR_FLASH_SECT_SIZE		(128 * 1024)		/* 128 KiB sectors */
+#define NOR_FLASH_SECT_COUNT		512
+
+#define CONFIG_SYS_FLASH_BASE		(NOR_FLASH_BASE)	/* Physical start address of Flash memory */
+#define CONFIG_SYS_FLASH_SIZE		(64 * 1024 * 1024)	/* 64 MB */
+#define CONFIG_SYS_MAX_FLASH_SECT	NOR_FLASH_SECT_COUNT	/* max number of sectors on one chip */
+#define CONFIG_SYS_MAX_FLASH_BANKS	1
+#define CONFIG_SYS_FLASH_CFI		1
+#define CONFIG_SYS_FLASH_PROTECTION
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE 1	/* use buffered writes (20x faster)	*/
+#define CONFIG_SYS_FLASH_EMPTY_INFO		/* print 'E' for empty sector on flinfo */
+#define CONFIG_FLASH_CFI_DRIVER		1
+
+#define CONFIG_SYS_FLASH_ERASE_TOUT	(2 * CONFIG_SYS_HZ)	/* Timeout for Flash Erase (in ms)	*/
+#define CONFIG_SYS_FLASH_WRITE_TOUT	(1 * CONFIG_SYS_HZ)	/* Timeout for Flash Write (in ms)	*/
+
+#define MTDIDS_DEFAULT			"nor0=comcertoflash.0"
+#define MTDPARTS_DEFAULT		"mtdparts=comcertoflash.0:128k(uloader)ro,256k(u-boot)ro,128k(env),4M(kernel),48M(rootfs)"
+
+/*
+ *  * Gemac Settings
+ *   */
+#define EMAC0_PHY_ADDR		4
+#define EMAC1_PHY_ADDR		0
+#define EMAC0_FLAGS		0
+#define EMAC1_FLAGS		1
+#define EMAC2_FLAGS		0
+
+#define CONFIG_NET_MULTI        1
+//#define CONFIG_MII
+//#define CONFIG_PHYLIB
+
+
+/* Enviroment */
+#define CONFIG_ENV_IS_IN_FLASH		1
+#define CONFIG_ENV_ADDR			(CONFIG_SYS_FLASH_BASE + ((128 + 256) * 1024))
+#define CONFIG_ENV_SIZE			0x20000	/* Total Size of Environment 128KiB */
+
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 128 * 1024)
+#define CONFIG_SYS_INIT_RAM_ADDR	0x01000000 /* DDR address */
+#define CONFIG_SYS_INIT_RAM_SIZE	0x00080000 /* 512K */
+#define CONFIG_SYS_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
+#define CONFIG_SYS_GBL_DATA_OFFSET	((CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_RAM_SIZE) - CONFIG_SYS_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR		CONFIG_SYS_GBL_DATA_OFFSET
+
+#define CONFIG_SYS_PROMPT		"U-Boot> "
+#define CONFIG_SYS_CBSIZE		256 /* Console I/O Buffer Size */
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
+						sizeof(CONFIG_SYS_PROMPT) + 16)
+
+#define CONFIG_SYS_LOAD_ADDR		(CONFIG_SYS_SDRAM_BASE + 0x01000000) /* default load address */
+#define CONFIG_SYS_MAXARGS		15 /* max number of command args */
+#define CONFIG_SYS_LONGHELP
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_CMDLINE_EDITING
+
+/* Commands */ /* TODO */
+#include <config_cmd_default.h>
+
+#undef CONFIG_CMD_BDI
+#undef CONFIG_CMD_FPGA
+#undef CONFIG_CMD_IMI
+#undef CONFIG_CMD_IMLS
+#undef CONFIG_CMD_LOADS
+#undef CONFIG_CMD_SOURCE
+
+#define CONFIG_CMD_FLASH	/* flinfo, erase, protect	*/
+#define CONFIG_CMD_SAVEENV
+
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_PFE_COMMANDS
+#define CONFIG_CMD_PFE_STATS
+
+#define CONFIG_CMD_SOCINFO
+#define CONFIG_CMD_UPDATE_SPI
+
+/*
+ * Environment Configuration
+ */
+#ifndef CONFIG_SECUREBOOT
+#define CONFIG_BOOTCOMMAND	"bootm 0xc0080000"
+#else
+#define CONFIG_BOOTCOMMAND	"run boot_flash_sec"
+#endif
+#define CONFIG_BOOTARGS		"console=ttyS0,115200 "			\
+				"root=/dev/mtdblock4 "			\
+				"mtdparts=comcertoflash.0:128k(uloader)ro,256k(u-boot)ro,128k(env),4M(kernel),48M(rootfs)"	\
+				"rw rootfstype=jffs2"
+
+
+#define	CONFIG_EXTRA_ENV_SETTINGS											\
+	"hostname=comcerto2000\0"											\
+	"netdev=eth0\0"													\
+	"nfsargs=setenv bootargs init=${init_process} root=/dev/nfs rw "						\
+		"nfsroot=${serverip}:${rootpath}\0"									\
+	"flashargs=setenv bootargs init=${init_process} root=/dev/mtdblock4 rootfstype=${rootfstype} rw\0"		\
+	"rootfstype=jffs2\0"												\
+	"init_process=/etc/preinit\0"											\
+	"addip=setenv bootargs ${bootargs} "										\
+		"ip=${ipaddr}:${serverip}:${gatewayip}:${netmask}"							\
+		":${hostname}:${netdev}:off\0"										\
+	"addeth=setenv bootargs ${bootargs} "										\
+	"hwaddress=${netdev},${ethaddr}\0"										\
+	"addtty=setenv bootargs ${bootargs} console=ttyS0,115200n8\0"							\
+	"addmtd=setenv bootargs ${bootargs} ${mtdparts}\0"								\
+	"flash_self=run flashargs addip addtty;"									\
+		"bootm ${kernel_addr}\0"										\
+	"boot_nfs=nfs 80600000 ${rootpath}/boot/${kernelfile};run nfsargs addeth addip addtty;"				\
+	        "bootm 80600000\0"											\
+	"boot_flash=run flashargs addeth addtty addmtd; bootm 0xc0080000\0"						\
+	"boot_flash_sec=run flashargs addeth addtty addmtd; cp.b 0xc0080000 0x00900000 0x400000; bootm 0x00900000\0"	\
+	"boot_flashold=run flashargs addeth addtty addmtd; fsload /boot/uImage; bootm\0"				\
+	"loadaddr=0x3000000\0"												\
+	"rootpath=/devel/fs-c2kasic\0"											\
+	"kernelfile=uImage\0"												\
+	"bootfile=u-boot.bin\0"												\
+	"mtdids=" MTDIDS_DEFAULT "\0"											\
+	"mtdparts=" MTDPARTS_DEFAULT "\0"										\
+	"mtddevnum=2\0"													\
+	"mtddevname=fs\0"												\
+	"fsfile=root.jffs2-128k\0"											\
+	"updatefs=tftp 3000000 ${fsfile};protect off 1:36-420\;erase 1:36-420;cp.b 3000000 c0480000 ${filesize}\0"	\
+	"updatekernel=tftp 3000000 ${kernelfile};protect off 1:4-35\;erase 1:4-35;cp.b 3000000 c0080000 ${filesize}\0"	\
+	"updateboot=tftp 3000000 ${bootfile};protect off 1:1-3\;erase 1:1-3;cp.b 3000000 c0020000 ${filesize}\0"	\
+	"updateuloader=tftp 3000000 uloader.bin;protect off 1:0-1\;erase 1:0-1;cp.b 3000000 c0000000 ${filesize}\0"	\
+	""
+
+#define CONFIG_ETHADDR		00:aa:bb:cc:dd:ee
+#define CONFIG_IPADDR		192.168.0.2
+#define CONFIG_SERVERIP		192.168.0.1
+#define CONFIG_BOOTDELAY	3
+
+/*
+ * Misc configuration options
+ */
+#define CONFIG_CMDLINE_TAG		1	/* enable passing of ATAGs	*/
+#define CONFIG_SETUP_MEMORY_TAGS	1
+//#define CONFIG_INITRD_TAG		1
+
+#endif /* __CONFIG_C2KEVM_H */
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/include/configs/c2kevm-nand.h u-boot-2013.01.new/include/configs/c2kevm-nand.h
--- u-boot-2013.01/include/configs/c2kevm-nand.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/include/configs/c2kevm-nand.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,293 @@
+/*
+ * Copyright (C) 2013 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef __CONFIG_C2KEVM_NAND_H
+#define __CONFIG_C2KEVM_NAND_H
+
+
+#define CONFIG_ARMV7 /* This is an ARM V7 CPU core */
+
+#define CONFIG_COMCERTO_2000
+#define MACH_TYPE_COMCERTO	1094
+#define CONFIG_MACH_TYPE	MACH_TYPE_COMCERTO
+#define CONFIG_C2KEVM
+
+#include <asm/hardware.h>
+
+/* CPU clock */
+#define CONFIG_SYS_HZ		1000		/* decrementer freq: 1 ms ticks */
+
+/*
+ * RAM configuration
+ */
+#define CONFIG_NR_DRAM_BANKS		1
+#define CONFIG_SYS_TEXT_BASE		0x1000000
+#define CONFIG_SYS_SDRAM_BASE		COMCERTO_AXI_DDR_BASE
+#define CONFIG_SYS_SDRAM_SIZE		(512 * 1024 * 1024)
+#define CONFIG_SYS_MEMTEST_START	0x0300000	/* memtest works on     */
+#define CONFIG_SYS_MEMTEST_END		0x0700000	/* 3 ... 7 MB in DRAM   */
+
+#undef  CONFIG_SHOW_BOOT_PROGRESS
+
+/*
+ * UART configuration
+ */
+/* define one of these to choose the UART0 or UART1 as console */
+#define CONFIG_UART0		1	/* TODO We use UART1. Change it along with driver */
+#define CONFIG_BAUDRATE		115200
+#define CONFIG_BAUDRATE_TABLE	{115200, 19200, 38400, 57600, 9600}
+#define CONFIG_COMCERTO_SERIAL
+
+#define CONFIG_NAND_COMCERTO
+
+/* Expansion Bus Configuration */
+#define EXP_CS0_BASE_VAL	0x0
+#define EXP_CS0_SEG_SIZE_VAL	0x7FFF
+#define EXP_CS0_SEG_END_VAL	(EXP_CS0_BASE_VAL + EXP_CS0_SEG_SIZE_VAL)
+
+#define EXP_CS1_BASE_VAL	(EXP_CS0_SEG_END_VAL + 1)
+#define EXP_CS1_SEG_SIZE_VAL	0xFF
+#define EXP_CS1_SEG_END_VAL	(EXP_CS1_BASE_VAL + EXP_CS1_SEG_SIZE_VAL)
+
+#define EXP_CS2_BASE_VAL	(EXP_CS1_SEG_END_VAL + 1)
+#define EXP_CS2_SEG_SIZE_VAL	0xFF
+#define EXP_CS2_SEG_END_VAL	(EXP_CS2_BASE_VAL + EXP_CS2_SEG_SIZE_VAL)
+
+#define EXP_CS3_BASE_VAL	(EXP_CS2_SEG_END_VAL + 1)
+#define EXP_CS3_SEG_SIZE_VAL	0xFF
+#define EXP_CS3_SEG_END_VAL	(EXP_CS3_BASE_VAL + EXP_CS3_SEG_SIZE_VAL)
+
+#define EXP_CS4_BASE_VAL	(EXP_CS3_SEG_END_VAL + 1)
+#define EXP_CS4_SEG_SIZE_VAL	0xFF
+#define EXP_CS4_SEG_END_VAL	(EXP_CS4_BASE_VAL + EXP_CS4_SEG_SIZE_VAL)
+
+#define SHIFT_4K_MUL	12
+
+#define COMCERTO_EXP_CS4_BASE_ADDR	(COMCERTO_AXI_EXP_BASE + (EXP_CS4_BASE_VAL << SHIFT_4K_MUL))
+
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_SYS_NAND_MAX_CHIPS	1
+#define CONFIG_SYS_NAND_BASE		COMCERTO_EXP_CS4_BASE_ADDR
+#define CONFIG_SYS_NAND_SELF_INIT
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+#define CONFIG_NAND_COMCERTO_ECC_24_HW_BCH
+//#define CONFIG_NAND_COMCERTO_ECC_8_HW_BCH
+#define CONFIG_COMCERTO_NAND_ERASE_FBB
+#define CONFIG_MACH_COMCERTO_C2K_EVM
+//#define CONFIG_NAND_TYPE_SLC
+#define CONFIG_SYS_NAND_USE_FLASH_BBT
+#define NAND_BBT_SIZE			(1024 * 1024)
+
+
+#define CONFIG_CMD_NAND_TRIMFFS
+
+/* SPI Driver */
+#define CONFIG_DRIVER_SPI_C2K
+
+/* OTP Driver */
+#define CONFIG_DRIVER_OTP
+
+/* SPACC Driver */
+#define CONFIG_DRIVER_SPACC
+
+/* Enable Secure boot*/
+#define CONFIG_SECUREBOOT
+
+/*SPI NOR Flash CS:0*/
+#define SPI_FLASH_SIZE  (16 * 1024 * 1024) /* 16 MB */
+#define SPI_FLASH_SECTOR_64KB     (64 * 1024)
+#define SPI_FLASH_SECTOR_256KB    (256 * 1024)
+#define SPI_FLASH_NOR_PAGE_SIZE   256 /* Bytes */
+#define SPI_FLASH_SECTOR_SIZE     SPI_FLASH_SECTOR_64KB
+#define SPI_FLASH_NUM_SECTORS     (SPI_FLASH_SIZE/SPI_FLASH_SECTOR_SIZE)
+#define SPI_FLASH_NUM_PAGES_PER_SEC       (SPI_FLASH_SECTOR_SIZE/SPI_FLASH_NOR_PAGE_SIZE)
+
+/*
+ * flash configuration - using cfi driver
+ */
+#define NOR_FLASH_BASE			COMCERTO_AXI_EXP_BASE	/* Flash Bank #1 */
+#define NOR_FLASH_SECT_SIZE		(128 * 1024)		/* 128 KiB sectors */
+#define NOR_FLASH_SECT_COUNT		512
+
+#define CONFIG_SYS_FLASH_BASE		(NOR_FLASH_BASE)	/* Physical start address of Flash memory */
+#define CONFIG_SYS_FLASH_SIZE		(64 * 1024 * 1024)	/* 64 MB */
+#define CONFIG_SYS_MAX_FLASH_SECT	NOR_FLASH_SECT_COUNT	/* max number of sectors on one chip */
+#define CONFIG_SYS_MAX_FLASH_BANKS	1
+#define CONFIG_SYS_FLASH_CFI		1
+#define CONFIG_SYS_FLASH_PROTECTION
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE 1	/* use buffered writes (20x faster)	*/
+#define CONFIG_SYS_FLASH_EMPTY_INFO		/* print 'E' for empty sector on flinfo */
+#define CONFIG_FLASH_CFI_DRIVER		1
+
+#define CONFIG_SYS_FLASH_ERASE_TOUT	(2 * CONFIG_SYS_HZ)	/* Timeout for Flash Erase (in ms)	*/
+#define CONFIG_SYS_FLASH_WRITE_TOUT	(1 * CONFIG_SYS_HZ)	/* Timeout for Flash Write (in ms)	*/
+
+#define CONFIG_MTD_DEVICE
+#define MTDIDS_DEFAULT			"nand0=comcertonand"
+
+/*
+ *  * Gemac Settings
+ *   */
+#define EMAC0_PHY_ADDR		4
+#define EMAC1_PHY_ADDR		0
+#define EMAC0_FLAGS		0
+#define EMAC1_FLAGS		1
+#define EMAC2_FLAGS		0
+
+#define CONFIG_NET_MULTI        1
+//#define CONFIG_MII
+//#define CONFIG_PHYLIB
+
+
+/* Enviroment */
+//#define CONFIG_ENV_IS_IN_FLASH		1
+#define CONFIG_ENV_IS_IN_C2K_SPI_FLASH	1
+
+#if defined (CONFIG_ENV_IS_IN_FLASH)
+#define CONFIG_ENV_ADDR			(CONFIG_SYS_FLASH_BASE + ((128 + 256) * 1024))
+#define CONFIG_ENV_SIZE			0x20000	/* Total Size of Environment 128KiB */
+#elif defined CONFIG_ENV_IS_IN_C2K_SPI_FLASH
+#define CONFIG_ENV_OFFSET		0
+#define CONFIG_ENV_SPI_SECTOR		10
+#define CONFIG_ENV_SIZE			0x20000	/* Total Size of Environment 128KiB */
+#define CONFIG_ENV_SECT_SIZE		0x20000
+#endif
+
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 128 * 1024) + (NAND_BBT_SIZE)
+#define CONFIG_SYS_INIT_RAM_ADDR	0x01000000 /* DDR address */
+#define CONFIG_SYS_INIT_RAM_SIZE	0x00080000 /* 512K */
+#define CONFIG_SYS_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
+#define CONFIG_SYS_GBL_DATA_OFFSET	((CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_RAM_SIZE) - CONFIG_SYS_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR		CONFIG_SYS_GBL_DATA_OFFSET
+
+#define CONFIG_SYS_PROMPT		"U-Boot> "
+#define CONFIG_SYS_CBSIZE		256 /* Console I/O Buffer Size */
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
+						sizeof(CONFIG_SYS_PROMPT) + 16)
+
+#define CONFIG_SYS_LOAD_ADDR		(CONFIG_SYS_SDRAM_BASE + 0x01000000) /* default load address */
+#define CONFIG_SYS_MAXARGS		15 /* max number of command args */
+#define CONFIG_SYS_LONGHELP
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_CMDLINE_EDITING
+
+/* Commands */ /* TODO */
+#include <config_cmd_default.h>
+
+#undef CONFIG_CMD_BDI
+#undef CONFIG_CMD_FPGA
+#undef CONFIG_CMD_IMI
+#undef CONFIG_CMD_IMLS
+#undef CONFIG_CMD_LOADS
+#undef CONFIG_CMD_SOURCE
+
+#define CONFIG_CMD_FLASH	/* flinfo, erase, protect	*/
+#define CONFIG_CMD_SAVEENV
+#define CONFIG_CMD_MTDPARTS
+#define CONFIG_CMD_NAND
+
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_PFE_COMMANDS
+#define CONFIG_CMD_PFE_STATS
+#define CONFIG_CMD_DHCP
+
+#define CONFIG_CMD_SOCINFO
+#define CONFIG_CMD_UPDATE_SPI
+
+/*
+ * Environment Configuration
+ */
+#define CONFIG_BOOTCOMMAND	"nand read 0x3000000 0x200000 0x400000; bootm 0x3000000;"
+#define CONFIG_BOOTARGS         "console=ttyS0,115200 "			\
+				"init=/etc/preinit "			\
+				"root=ubi0:rootfs "			\
+				"ubi.mtd=8,4096 "			\
+				"rootfstype=ubifs rw "			\
+				"noinitrd "				\
+				"mtdparts=comcertoflash.0:"		\
+					"128k(uloader)ro,"		\
+					"512k(barebox)ro,"		\
+					"128k(env),"			\
+					"4M(kernel),"			\
+					"48M(rootfs);"			\
+					"comcertonand:"			\
+					"1M(u-boot)ro,"			\
+					"1M(env),"			\
+					"4M(kernel),"			\
+					"-(rootfs) "			\
+				"usb3_internal_clk=yes"
+
+#define CONFIG_MTDPARTS		"1M(u-boot)ro,1M(env),4M(kernel),-(rootfs)"
+#define CONFIG_MTDPARTS_NAND	"mtdparts=comcertonand:1M(u-boot)ro,1M(env),4M(kernel),-(rootfs)"
+#define MTDPARTS_DEFAULT	"mtdparts=comcertonand:"CONFIG_MTDPARTS
+
+#define	CONFIG_EXTRA_ENV_SETTINGS											\
+	"hostname=comcerto2000\0"											\
+	"netdev=eth0\0"													\
+	"nfsargs=setenv bootargs init=${init_process} root=/dev/nfs rw "						\
+		"nfsroot=${serverip}:${rootpath}\0"									\
+	"flashargs=setenv bootargs init=${init_process} root=/dev/mtdblock4 rootfstype=${rootfstype} rw\0"		\
+	"rootfstype=ubifs\0"												\
+	"init_process=/etc/preinit\0"											\
+	"addip=setenv bootargs ${bootargs} "										\
+		"ip=${ipaddr}:${serverip}:${gatewayip}:${netmask}"							\
+		":${hostname}:${netdev}:off\0"										\
+	"addeth=setenv bootargs ${bootargs} "										\
+	"hwaddress=${netdev},${ethaddr}\0"										\
+	"addtty=setenv bootargs ${bootargs} console=ttyS0,115200n8\0"							\
+	"addmtd=setenv bootargs ${bootargs} ${mtdparts}\0"								\
+	"flash_self=run flashargs addip addtty;"									\
+		"bootm ${kernel_addr}\0"										\
+	"boot_nfs=nfs 80600000 ${rootpath}/boot/${kernelfile};run nfsargs addeth addip addtty;"				\
+	        "bootm 80600000\0"											\
+	"boot_flash=run flashargs addeth addtty addmtd; bootm 0xc0080000\0"						\
+	"boot_flashold=run flashargs addeth addtty addmtd; fsload /boot/uImage; bootm\0"				\
+	"loadaddr=0x3000000\0"												\
+	"rootpath=/devel/fs-c2kasic\0"											\
+	"kernelfile=uImage\0"												\
+	"bootfile=u-boot.bin\0"												\
+	"mtdids=" MTDIDS_DEFAULT "\0"											\
+	"mtdparts=" MTDPARTS_DEFAULT "\0"										\
+	"mtddevnum=2\0"													\
+	"mtddevname=fs\0"												\
+	"fsfile=root.jffs2-128k\0"											\
+	"updatefs=tftp 3000000 ${fsfile};protect off 1:36-420\;erase 1:36-420;cp.b 3000000 c0480000 ${filesize}\0"	\
+	"updatekernel=tftp 3000000 ${kernelfile};protect off 1:4-35\;erase 1:4-35;cp.b 3000000 c0080000 ${filesize}\0"	\
+	"updateboot=tftp 3000000 ${bootfile};protect off 1:1-3\;erase 1:1-3;cp.b 3000000 c0020000 ${filesize}\0"	\
+	"updateuloader=tftp 3000000 uloader.bin;protect off 1:0-1\;erase 1:0-1;cp.b 3000000 c0000000 ${filesize}\0"	\
+	"updatefs_nand=tftp 0000000 ${fsfile}; nand erase.part rootfs; nand write.trimffs ${fileaddr} rootfs ${filesize}\0"		\
+	"updatekernel_nand=tftp 3000000 ${kernelfile}; nand erase.part kernel; nand write ${fileaddr} kernel ${filesize}\0"\
+	"updateboot_nand=tftp 3000000 ${bootfile}; nand erase.part u-boot; nand write ${fileaddr} u-boot ${filesize}\0"	\
+	""
+
+#define CONFIG_ETHADDR		00:aa:bb:cc:dd:ee
+#define CONFIG_IPADDR		192.168.0.2
+#define CONFIG_SERVERIP		192.168.0.1
+#define CONFIG_BOOTDELAY	3
+
+/*
+ * Misc configuration options
+ */
+#define CONFIG_CMDLINE_TAG		1	/* enable passing of ATAGs	*/
+#define CONFIG_SETUP_MEMORY_TAGS	1
+//#define CONFIG_INITRD_TAG		1
+
+#endif /* __CONFIG_C2KEVM_NAND_H */
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/include/configs/c2kmfcnevm.h u-boot-2013.01.new/include/configs/c2kmfcnevm.h
--- u-boot-2013.01/include/configs/c2kmfcnevm.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/include/configs/c2kmfcnevm.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,248 @@
+/*
+ * Copyright (C) 2013 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef __CONFIG_C2KEVM_H
+#define __CONFIG_C2KEVM_H
+
+
+#define CONFIG_ARMV7 /* This is an ARM V7 CPU core */
+
+#define CONFIG_COMCERTO_2000
+#define MACH_TYPE_COMCERTO	1094
+#define CONFIG_MACH_TYPE	MACH_TYPE_COMCERTO
+#define CONFIG_C2KEVM
+
+#include <asm/hardware.h>
+
+/* CPU clock */
+#define CONFIG_SYS_HZ		1000		/* decrementer freq: 1 ms ticks */
+
+/*
+ * RAM configuration
+ */
+#define CONFIG_NR_DRAM_BANKS		1
+#define CONFIG_SYS_TEXT_BASE		0x1000000
+#define CONFIG_SYS_SDRAM_BASE		COMCERTO_AXI_DDR_BASE
+#define CONFIG_SYS_SDRAM_SIZE		(512 * 1024 * 1024)
+#define CONFIG_SYS_MEMTEST_START	0x0300000	/* memtest works on     */
+#define CONFIG_SYS_MEMTEST_END		0x0700000	/* 3 ... 7 MB in DRAM   */
+
+#undef  CONFIG_SHOW_BOOT_PROGRESS
+
+/*
+ * UART configuration
+ */
+/* define one of these to choose the UART0 or UART1 as console */
+#define CONFIG_UART0		1	/* TODO We use UART1. Change it along with driver */
+#define CONFIG_BAUDRATE		115200
+#define CONFIG_BAUDRATE_TABLE	{115200, 19200, 38400, 57600, 9600}
+#define CONFIG_COMCERTO_SERIAL
+
+/* Expansion Bus Configuration */
+#define EXP_CS0_BASE_VAL	0x0
+#define EXP_CS0_SEG_SIZE_VAL	0x7FFF
+#define EXP_CS0_SEG_END_VAL	(EXP_CS0_BASE_VAL + EXP_CS0_SEG_SIZE_VAL)
+
+#define EXP_CS1_BASE_VAL	(EXP_CS0_SEG_END_VAL + 1)
+#define EXP_CS1_SEG_SIZE_VAL	0xFF
+#define EXP_CS1_SEG_END_VAL	(EXP_CS1_BASE_VAL + EXP_CS1_SEG_SIZE_VAL)
+
+#define EXP_CS2_BASE_VAL	(EXP_CS1_SEG_END_VAL + 1)
+#define EXP_CS2_SEG_SIZE_VAL	0xFF
+#define EXP_CS2_SEG_END_VAL	(EXP_CS2_BASE_VAL + EXP_CS2_SEG_SIZE_VAL)
+
+#define EXP_CS3_BASE_VAL	(EXP_CS2_SEG_END_VAL + 1)
+#define EXP_CS3_SEG_SIZE_VAL	0xFF
+#define EXP_CS3_SEG_END_VAL	(EXP_CS3_BASE_VAL + EXP_CS3_SEG_SIZE_VAL)
+
+#define EXP_CS4_BASE_VAL	(EXP_CS3_SEG_END_VAL + 1)
+#define EXP_CS4_SEG_SIZE_VAL	0xFF
+#define EXP_CS4_SEG_END_VAL	(EXP_CS4_BASE_VAL + EXP_CS4_SEG_SIZE_VAL)
+
+#define SHIFT_4K_MUL	12
+
+#define COMCERTO_EXP_CS4_BASE_ADDR	(COMCERTO_AXI_EXP_BASE + (EXP_CS4_BASE_VAL << SHIFT_4K_MUL))
+
+/* SPI Driver */
+#define CONFIG_DRIVER_SPI_C2K
+
+/* OTP Driver */
+#define CONFIG_DRIVER_OTP
+
+/* SPACC Driver */
+#define CONFIG_DRIVER_SPACC
+
+/* Enable Secure boot*/
+#define CONFIG_SECUREBOOT
+
+/*SPI NOR Flash CS:0*/
+#define SPI_FLASH_SIZE  (16 * 1024 * 1024) /* 16 MB */
+#define SPI_FLASH_SECTOR_64KB     (64 * 1024)
+#define SPI_FLASH_SECTOR_256KB    (256 * 1024)
+#define SPI_FLASH_NOR_PAGE_SIZE   256 /* Bytes */
+#define SPI_FLASH_SECTOR_SIZE     SPI_FLASH_SECTOR_64KB
+#define SPI_FLASH_NUM_SECTORS     (SPI_FLASH_SIZE/SPI_FLASH_SECTOR_SIZE)
+#define SPI_FLASH_NUM_PAGES_PER_SEC       (SPI_FLASH_SECTOR_SIZE/SPI_FLASH_NOR_PAGE_SIZE)
+
+/*
+ * flash configuration - using cfi driver
+ */
+#define NOR_FLASH_BASE			COMCERTO_AXI_EXP_BASE	/* Flash Bank #1 */
+#define NOR_FLASH_SECT_SIZE		(128 * 1024)		/* 128 KiB sectors */
+#define NOR_FLASH_SECT_COUNT		512
+
+#define CONFIG_SYS_FLASH_BASE		(NOR_FLASH_BASE)	/* Physical start address of Flash memory */
+#define CONFIG_SYS_FLASH_SIZE		(64 * 1024 * 1024)	/* 64 MB */
+#define CONFIG_SYS_MAX_FLASH_SECT	NOR_FLASH_SECT_COUNT	/* max number of sectors on one chip */
+#define CONFIG_SYS_MAX_FLASH_BANKS	1
+#define CONFIG_SYS_FLASH_CFI		1
+#define CONFIG_SYS_FLASH_PROTECTION
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE 1	/* use buffered writes (20x faster)	*/
+#define CONFIG_SYS_FLASH_EMPTY_INFO		/* print 'E' for empty sector on flinfo */
+#define CONFIG_FLASH_CFI_DRIVER		1
+
+#define CONFIG_SYS_FLASH_ERASE_TOUT	(2 * CONFIG_SYS_HZ)	/* Timeout for Flash Erase (in ms)	*/
+#define CONFIG_SYS_FLASH_WRITE_TOUT	(1 * CONFIG_SYS_HZ)	/* Timeout for Flash Write (in ms)	*/
+
+#define MTDIDS_DEFAULT			"nor0=comcertoflash.0"
+#define MTDPARTS_DEFAULT		"mtdparts=comcertoflash.0:128k(uloader)ro,256k(u-boot)ro,128k(env),4M(kernel),48M(rootfs)"
+
+/*
+ *  * Gemac Settings
+ *   */
+#define EMAC0_PHY_ADDR		4
+#define EMAC1_PHY_ADDR		0
+#define EMAC0_FLAGS		0
+#define EMAC1_FLAGS		1
+#define EMAC2_FLAGS		0
+
+#define CONFIG_NET_MULTI        1
+//#define CONFIG_MII
+//#define CONFIG_PHYLIB
+
+
+/* Enviroment */
+#define CONFIG_ENV_IS_IN_FLASH		1
+#define CONFIG_ENV_ADDR			(CONFIG_SYS_FLASH_BASE + ((128 + 256) * 1024))
+#define CONFIG_ENV_SIZE			0x20000	/* Total Size of Environment 128KiB */
+
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 128 * 1024)
+#define CONFIG_SYS_INIT_RAM_ADDR	0x01000000 /* DDR address */
+#define CONFIG_SYS_INIT_RAM_SIZE	0x00080000 /* 512K */
+#define CONFIG_SYS_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
+#define CONFIG_SYS_GBL_DATA_OFFSET	((CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_RAM_SIZE) - CONFIG_SYS_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR		CONFIG_SYS_GBL_DATA_OFFSET
+
+#define CONFIG_SYS_PROMPT		"U-Boot> "
+#define CONFIG_SYS_CBSIZE		256 /* Console I/O Buffer Size */
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
+						sizeof(CONFIG_SYS_PROMPT) + 16)
+
+#define CONFIG_SYS_LOAD_ADDR		(CONFIG_SYS_SDRAM_BASE + 0x01000000) /* default load address */
+#define CONFIG_SYS_MAXARGS		15 /* max number of command args */
+#define CONFIG_SYS_LONGHELP
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_CMDLINE_EDITING
+
+/* Commands */ /* TODO */
+#include <config_cmd_default.h>
+
+#undef CONFIG_CMD_BDI
+#undef CONFIG_CMD_FPGA
+#undef CONFIG_CMD_IMI
+#undef CONFIG_CMD_IMLS
+#undef CONFIG_CMD_LOADS
+#undef CONFIG_CMD_SOURCE
+
+#define CONFIG_CMD_FLASH	/* flinfo, erase, protect	*/
+#define CONFIG_CMD_SAVEENV
+
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_PFE_COMMANDS
+#define CONFIG_CMD_PFE_STATS
+
+#define CONFIG_CMD_SOCINFO
+#define CONFIG_CMD_UPDATE_SPI
+
+/*
+ * Environment Configuration
+ */
+#ifndef CONFIG_SECUREBOOT
+#define CONFIG_BOOTCOMMAND	"bootm 0xc0080000"
+#else
+#define CONFIG_BOOTCOMMAND	"run boot_flash_sec"
+#endif
+#define CONFIG_BOOTARGS		"console=ttyS0,115200 "			\
+				"root=/dev/mtdblock4 "			\
+				"mtdparts=comcertoflash.0:128k(uloader)ro,256k(u-boot)ro,128k(env),4M(kernel),48M(rootfs)"	\
+				"rw rootfstype=jffs2"
+
+
+#define	CONFIG_EXTRA_ENV_SETTINGS											\
+	"hostname=comcerto2000\0"											\
+	"netdev=eth0\0"													\
+	"nfsargs=setenv bootargs init=${init_process} root=/dev/nfs rw "						\
+		"nfsroot=${serverip}:${rootpath}\0"									\
+	"flashargs=setenv bootargs init=${init_process} root=/dev/mtdblock4 rootfstype=${rootfstype} rw\0"		\
+	"rootfstype=jffs2\0"												\
+	"init_process=/etc/preinit\0"											\
+	"addip=setenv bootargs ${bootargs} "										\
+		"ip=${ipaddr}:${serverip}:${gatewayip}:${netmask}"							\
+		":${hostname}:${netdev}:off\0"										\
+	"addeth=setenv bootargs ${bootargs} "										\
+	"hwaddress=${netdev},${ethaddr}\0"										\
+	"addtty=setenv bootargs ${bootargs} console=ttyS0,115200n8\0"							\
+	"addmtd=setenv bootargs ${bootargs} ${mtdparts}\0"								\
+	"flash_self=run flashargs addip addtty;"									\
+		"bootm ${kernel_addr}\0"										\
+	"boot_nfs=nfs 80600000 ${rootpath}/boot/${kernelfile};run nfsargs addeth addip addtty;"				\
+	        "bootm 80600000\0"											\
+	"boot_flash=run flashargs addeth addtty addmtd; bootm 0xc0080000\0"						\
+	"boot_flash_sec=run flashargs addeth addtty addmtd; cp.b 0xc0080000 0x00900000 0x400000; bootm 0x00900000\0"	\
+	"boot_flashold=run flashargs addeth addtty addmtd; fsload /boot/uImage; bootm\0"				\
+	"loadaddr=0x3000000\0"												\
+	"rootpath=/devel/fs-c2kasic\0"											\
+	"kernelfile=uImage\0"												\
+	"bootfile=u-boot.bin\0"												\
+	"mtdids=" MTDIDS_DEFAULT "\0"											\
+	"mtdparts=" MTDPARTS_DEFAULT "\0"										\
+	"mtddevnum=2\0"													\
+	"mtddevname=fs\0"												\
+	"fsfile=root.jffs2-128k\0"											\
+	"updatefs=tftp 3000000 ${fsfile};protect off 1:36-420\;erase 1:36-420;cp.b 3000000 c0480000 ${filesize}\0"	\
+	"updatekernel=tftp 3000000 ${kernelfile};protect off 1:4-35\;erase 1:4-35;cp.b 3000000 c0080000 ${filesize}\0"	\
+	"updateboot=tftp 3000000 ${bootfile};protect off 1:1-3\;erase 1:1-3;cp.b 3000000 c0020000 ${filesize}\0"	\
+	"updateuloader=tftp 3000000 uloader.bin;protect off 1:0-1\;erase 1:0-1;cp.b 3000000 c0000000 ${filesize}\0"	\
+	""
+
+#define CONFIG_ETHADDR		00:aa:bb:cc:dd:ee
+#define CONFIG_IPADDR		192.168.0.2
+#define CONFIG_SERVERIP		192.168.0.1
+#define CONFIG_BOOTDELAY	3
+
+/*
+ * Misc configuration options
+ */
+#define CONFIG_CMDLINE_TAG		1	/* enable passing of ATAGs	*/
+#define CONFIG_SETUP_MEMORY_TAGS	1
+//#define CONFIG_INITRD_TAG		1
+
+#endif /* __CONFIG_C2KEVM_H */
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/include/configs/c2kmfcnevm-nand.h u-boot-2013.01.new/include/configs/c2kmfcnevm-nand.h
--- u-boot-2013.01/include/configs/c2kmfcnevm-nand.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/include/configs/c2kmfcnevm-nand.h	2016-03-23 16:10:35.000000000 +0530
@@ -0,0 +1,293 @@
+/*
+ * Copyright (C) 2013 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef __CONFIG_C2KMFCN_NAND_H
+#define __CONFIG_C2KMFCN_NAND_H
+
+
+#define CONFIG_ARMV7 /* This is an ARM V7 CPU core */
+
+#define CONFIG_COMCERTO_2000
+#define MACH_TYPE_COMCERTO	1094
+#define CONFIG_MACH_TYPE	MACH_TYPE_COMCERTO
+#define CONFIG_C2KEVM
+
+#include <asm/hardware.h>
+
+/* CPU clock */
+#define CONFIG_SYS_HZ		1000		/* decrementer freq: 1 ms ticks */
+
+/*
+ * RAM configuration
+ */
+#define CONFIG_NR_DRAM_BANKS		1
+#define CONFIG_SYS_TEXT_BASE		0x1000000
+#define CONFIG_SYS_SDRAM_BASE		COMCERTO_AXI_DDR_BASE
+#define CONFIG_SYS_SDRAM_SIZE		(512 * 1024 * 1024)
+#define CONFIG_SYS_MEMTEST_START	0x0300000	/* memtest works on     */
+#define CONFIG_SYS_MEMTEST_END		0x0700000	/* 3 ... 7 MB in DRAM   */
+
+#undef  CONFIG_SHOW_BOOT_PROGRESS
+
+/*
+ * UART configuration
+ */
+/* define one of these to choose the UART0 or UART1 as console */
+#define CONFIG_UART0		1	/* TODO We use UART1. Change it along with driver */
+#define CONFIG_BAUDRATE		115200
+#define CONFIG_BAUDRATE_TABLE	{115200, 19200, 38400, 57600, 9600}
+#define CONFIG_COMCERTO_SERIAL
+
+#define CONFIG_NAND_COMCERTO
+
+/* Expansion Bus Configuration */
+#define EXP_CS0_BASE_VAL	0x0
+#define EXP_CS0_SEG_SIZE_VAL	0x7FFF
+#define EXP_CS0_SEG_END_VAL	(EXP_CS0_BASE_VAL + EXP_CS0_SEG_SIZE_VAL)
+
+#define EXP_CS1_BASE_VAL	(EXP_CS0_SEG_END_VAL + 1)
+#define EXP_CS1_SEG_SIZE_VAL	0xFF
+#define EXP_CS1_SEG_END_VAL	(EXP_CS1_BASE_VAL + EXP_CS1_SEG_SIZE_VAL)
+
+#define EXP_CS2_BASE_VAL	(EXP_CS1_SEG_END_VAL + 1)
+#define EXP_CS2_SEG_SIZE_VAL	0xFF
+#define EXP_CS2_SEG_END_VAL	(EXP_CS2_BASE_VAL + EXP_CS2_SEG_SIZE_VAL)
+
+#define EXP_CS3_BASE_VAL	(EXP_CS2_SEG_END_VAL + 1)
+#define EXP_CS3_SEG_SIZE_VAL	0xFF
+#define EXP_CS3_SEG_END_VAL	(EXP_CS3_BASE_VAL + EXP_CS3_SEG_SIZE_VAL)
+
+#define EXP_CS4_BASE_VAL	(EXP_CS3_SEG_END_VAL + 1)
+#define EXP_CS4_SEG_SIZE_VAL	0xFF
+#define EXP_CS4_SEG_END_VAL	(EXP_CS4_BASE_VAL + EXP_CS4_SEG_SIZE_VAL)
+
+#define SHIFT_4K_MUL	12
+
+#define COMCERTO_EXP_CS4_BASE_ADDR	(COMCERTO_AXI_EXP_BASE + (EXP_CS4_BASE_VAL << SHIFT_4K_MUL))
+
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_SYS_NAND_MAX_CHIPS	1
+#define CONFIG_SYS_NAND_BASE		COMCERTO_EXP_CS4_BASE_ADDR
+#define CONFIG_SYS_NAND_SELF_INIT
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+#define CONFIG_NAND_COMCERTO_ECC_24_HW_BCH
+//#define CONFIG_NAND_COMCERTO_ECC_8_HW_BCH
+#define CONFIG_COMCERTO_NAND_ERASE_FBB
+#define CONFIG_MACH_COMCERTO_C2K_EVM
+//#define CONFIG_NAND_TYPE_SLC
+#define CONFIG_SYS_NAND_USE_FLASH_BBT
+#define NAND_BBT_SIZE			(1024 * 1024)
+
+
+#define CONFIG_CMD_NAND_TRIMFFS
+
+/* SPI Driver */
+#define CONFIG_DRIVER_SPI_C2K
+
+/* OTP Driver */
+#define CONFIG_DRIVER_OTP
+
+/* SPACC Driver */
+#define CONFIG_DRIVER_SPACC
+
+/* Enable Secure boot*/
+#define CONFIG_SECUREBOOT
+
+/*SPI NOR Flash CS:0*/
+#define SPI_FLASH_SIZE  (16 * 1024 * 1024) /* 16 MB */
+#define SPI_FLASH_SECTOR_64KB     (64 * 1024)
+#define SPI_FLASH_SECTOR_256KB    (256 * 1024)
+#define SPI_FLASH_NOR_PAGE_SIZE   256 /* Bytes */
+#define SPI_FLASH_SECTOR_SIZE     SPI_FLASH_SECTOR_64KB
+#define SPI_FLASH_NUM_SECTORS     (SPI_FLASH_SIZE/SPI_FLASH_SECTOR_SIZE)
+#define SPI_FLASH_NUM_PAGES_PER_SEC       (SPI_FLASH_SECTOR_SIZE/SPI_FLASH_NOR_PAGE_SIZE)
+
+/*
+ * flash configuration - using cfi driver
+ */
+#define NOR_FLASH_BASE			COMCERTO_AXI_EXP_BASE	/* Flash Bank #1 */
+#define NOR_FLASH_SECT_SIZE		(128 * 1024)		/* 128 KiB sectors */
+#define NOR_FLASH_SECT_COUNT		512
+
+#define CONFIG_SYS_FLASH_BASE		(NOR_FLASH_BASE)	/* Physical start address of Flash memory */
+#define CONFIG_SYS_FLASH_SIZE		(64 * 1024 * 1024)	/* 64 MB */
+#define CONFIG_SYS_MAX_FLASH_SECT	NOR_FLASH_SECT_COUNT	/* max number of sectors on one chip */
+#define CONFIG_SYS_MAX_FLASH_BANKS	1
+#define CONFIG_SYS_FLASH_CFI		1
+#define CONFIG_SYS_FLASH_PROTECTION
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE 1	/* use buffered writes (20x faster)	*/
+#define CONFIG_SYS_FLASH_EMPTY_INFO		/* print 'E' for empty sector on flinfo */
+#define CONFIG_FLASH_CFI_DRIVER		1
+
+#define CONFIG_SYS_FLASH_ERASE_TOUT	(2 * CONFIG_SYS_HZ)	/* Timeout for Flash Erase (in ms)	*/
+#define CONFIG_SYS_FLASH_WRITE_TOUT	(1 * CONFIG_SYS_HZ)	/* Timeout for Flash Write (in ms)	*/
+
+#define CONFIG_MTD_DEVICE
+#define MTDIDS_DEFAULT			"nand0=comcertonand"
+
+/*
+ *  * Gemac Settings
+ *   */
+#define EMAC0_PHY_ADDR		4
+#define EMAC1_PHY_ADDR		0
+#define EMAC0_FLAGS		0
+#define EMAC1_FLAGS		1
+#define EMAC2_FLAGS		0
+
+#define CONFIG_NET_MULTI        1
+//#define CONFIG_MII
+//#define CONFIG_PHYLIB
+
+
+/* Enviroment */
+//#define CONFIG_ENV_IS_IN_FLASH		1
+#define CONFIG_ENV_IS_IN_C2K_SPI_FLASH	1
+
+#if defined (CONFIG_ENV_IS_IN_FLASH)
+#define CONFIG_ENV_ADDR			(CONFIG_SYS_FLASH_BASE + ((128 + 256) * 1024))
+#define CONFIG_ENV_SIZE			0x20000	/* Total Size of Environment 128KiB */
+#elif defined CONFIG_ENV_IS_IN_C2K_SPI_FLASH
+#define CONFIG_ENV_OFFSET		0
+#define CONFIG_ENV_SPI_SECTOR		10
+#define CONFIG_ENV_SIZE			0x20000	/* Total Size of Environment 128KiB */
+#define CONFIG_ENV_SECT_SIZE		0x20000
+#endif
+
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 128 * 1024) + (NAND_BBT_SIZE)
+#define CONFIG_SYS_INIT_RAM_ADDR	0x01000000 /* DDR address */
+#define CONFIG_SYS_INIT_RAM_SIZE	0x00080000 /* 512K */
+#define CONFIG_SYS_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
+#define CONFIG_SYS_GBL_DATA_OFFSET	((CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_RAM_SIZE) - CONFIG_SYS_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR		CONFIG_SYS_GBL_DATA_OFFSET
+
+#define CONFIG_SYS_PROMPT		"U-Boot> "
+#define CONFIG_SYS_CBSIZE		256 /* Console I/O Buffer Size */
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
+						sizeof(CONFIG_SYS_PROMPT) + 16)
+
+#define CONFIG_SYS_LOAD_ADDR		(CONFIG_SYS_SDRAM_BASE + 0x01000000) /* default load address */
+#define CONFIG_SYS_MAXARGS		15 /* max number of command args */
+#define CONFIG_SYS_LONGHELP
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_CMDLINE_EDITING
+
+/* Commands */ /* TODO */
+#include <config_cmd_default.h>
+
+#undef CONFIG_CMD_BDI
+#undef CONFIG_CMD_FPGA
+#undef CONFIG_CMD_IMI
+#undef CONFIG_CMD_IMLS
+#undef CONFIG_CMD_LOADS
+#undef CONFIG_CMD_SOURCE
+
+#define CONFIG_CMD_FLASH	/* flinfo, erase, protect	*/
+#define CONFIG_CMD_SAVEENV
+#define CONFIG_CMD_MTDPARTS
+#define CONFIG_CMD_NAND
+
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_PFE_COMMANDS
+#define CONFIG_CMD_PFE_STATS
+#define CONFIG_CMD_DHCP
+
+#define CONFIG_CMD_SOCINFO
+#define CONFIG_CMD_UPDATE_SPI
+
+/*
+ * Environment Configuration
+ */
+#define CONFIG_BOOTCOMMAND	"nand read 0x3000000 0x200000 0x400000; bootm 0x3000000;"
+#define CONFIG_BOOTARGS         "console=ttyS0,115200 "			\
+				"init=/etc/preinit "			\
+				"root=ubi0:rootfs "			\
+				"ubi.mtd=8,4096 "			\
+				"rootfstype=ubifs rw "			\
+				"noinitrd "				\
+				"mtdparts=comcertoflash.0:"		\
+					"128k(uloader)ro,"		\
+					"512k(barebox)ro,"		\
+					"128k(env),"			\
+					"4M(kernel),"			\
+					"48M(rootfs);"			\
+					"comcertonand:"			\
+					"1M(u-boot)ro,"			\
+					"1M(env),"			\
+					"4M(kernel),"			\
+					"-(rootfs) "			\
+				"usb3_internal_clk=yes"
+
+#define CONFIG_MTDPARTS		"1M(u-boot)ro,1M(env),4M(kernel),-(rootfs)"
+#define CONFIG_MTDPARTS_NAND	"mtdparts=comcertonand:1M(u-boot)ro,1M(env),4M(kernel),-(rootfs)"
+#define MTDPARTS_DEFAULT	"mtdparts=comcertonand:"CONFIG_MTDPARTS
+
+#define	CONFIG_EXTRA_ENV_SETTINGS											\
+	"hostname=comcerto2000\0"											\
+	"netdev=eth0\0"													\
+	"nfsargs=setenv bootargs init=${init_process} root=/dev/nfs rw "						\
+		"nfsroot=${serverip}:${rootpath}\0"									\
+	"flashargs=setenv bootargs init=${init_process} root=/dev/mtdblock4 rootfstype=${rootfstype} rw\0"		\
+	"rootfstype=ubifs\0"												\
+	"init_process=/etc/preinit\0"											\
+	"addip=setenv bootargs ${bootargs} "										\
+		"ip=${ipaddr}:${serverip}:${gatewayip}:${netmask}"							\
+		":${hostname}:${netdev}:off\0"										\
+	"addeth=setenv bootargs ${bootargs} "										\
+	"hwaddress=${netdev},${ethaddr}\0"										\
+	"addtty=setenv bootargs ${bootargs} console=ttyS0,115200n8\0"							\
+	"addmtd=setenv bootargs ${bootargs} ${mtdparts}\0"								\
+	"flash_self=run flashargs addip addtty;"									\
+		"bootm ${kernel_addr}\0"										\
+	"boot_nfs=nfs 80600000 ${rootpath}/boot/${kernelfile};run nfsargs addeth addip addtty;"				\
+	        "bootm 80600000\0"											\
+	"boot_flash=run flashargs addeth addtty addmtd; bootm 0xc0080000\0"						\
+	"boot_flashold=run flashargs addeth addtty addmtd; fsload /boot/uImage; bootm\0"				\
+	"loadaddr=0x3000000\0"												\
+	"rootpath=/devel/fs-c2kasic\0"											\
+	"kernelfile=uImage\0"												\
+	"bootfile=u-boot.bin\0"												\
+	"mtdids=" MTDIDS_DEFAULT "\0"											\
+	"mtdparts=" MTDPARTS_DEFAULT "\0"										\
+	"mtddevnum=2\0"													\
+	"mtddevname=fs\0"												\
+	"fsfile=root.jffs2-128k\0"											\
+	"updatefs=tftp 3000000 ${fsfile};protect off 1:36-420\;erase 1:36-420;cp.b 3000000 c0480000 ${filesize}\0"	\
+	"updatekernel=tftp 3000000 ${kernelfile};protect off 1:4-35\;erase 1:4-35;cp.b 3000000 c0080000 ${filesize}\0"	\
+	"updateboot=tftp 3000000 ${bootfile};protect off 1:1-3\;erase 1:1-3;cp.b 3000000 c0020000 ${filesize}\0"	\
+	"updateuloader=tftp 3000000 uloader.bin;protect off 1:0-1\;erase 1:0-1;cp.b 3000000 c0000000 ${filesize}\0"	\
+	"updatefs_nand=tftp 0000000 ${fsfile}; nand erase.part rootfs; nand write.trimffs ${fileaddr} rootfs ${filesize}\0"		\
+	"updatekernel_nand=tftp 3000000 ${kernelfile}; nand erase.part kernel; nand write ${fileaddr} kernel ${filesize}\0"\
+	"updateboot_nand=tftp 3000000 ${bootfile}; nand erase.part u-boot; nand write ${fileaddr} u-boot ${filesize}\0"	\
+	""
+
+#define CONFIG_ETHADDR		00:aa:bb:cc:dd:ee
+#define CONFIG_IPADDR		192.168.0.2
+#define CONFIG_SERVERIP		192.168.0.1
+#define CONFIG_BOOTDELAY	3
+
+/*
+ * Misc configuration options
+ */
+#define CONFIG_CMDLINE_TAG		1	/* enable passing of ATAGs	*/
+#define CONFIG_SETUP_MEMORY_TAGS	1
+//#define CONFIG_INITRD_TAG		1
+
+#endif /* __CONFIG_C2KEVM_NAND_H */
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/include/miiphy.h u-boot-2013.01.new/include/miiphy.h
--- u-boot-2013.01/include/miiphy.h	2013-01-16 03:17:42.000000000 +0530
+++ u-boot-2013.01.new/include/miiphy.h	2016-03-23 16:10:34.000000000 +0530
@@ -61,6 +61,11 @@
 int miiphy_link(const char *devname, unsigned char addr);
 #endif
 
+/****** MSPD Change *******/
+void miiphy_enable_rgmii_rx_delay(char *devname, unsigned char addr);
+void miiphy_enable_rgmii_tx_delay(char *devname, unsigned char addr);
+/*************************/
+
 void miiphy_init(void);
 
 void miiphy_register(const char *devname,
@@ -117,6 +122,13 @@
 #define HALF			22
 #define FULL			44
 
+/**** MSPD Change *****/
+#define PHY_DEBUG_PORT_ADDRESS          29
+#define PHY_DEBUG_PORT_DATA             30
+/**** MSPD Change completed *****/
+
+
+
 /* phy register offsets */
 #define MII_MIPSCR		0x11
 
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/include/netdev.h u-boot-2013.01.new/include/netdev.h
--- u-boot-2013.01/include/netdev.h	2013-01-16 03:17:42.000000000 +0530
+++ u-boot-2013.01.new/include/netdev.h	2016-03-23 16:10:35.000000000 +0530
@@ -105,6 +105,10 @@
 int xilinx_ll_temac_eth_init(bd_t *bis, unsigned long base_addr, int flags,
 						unsigned long ctrl_addr);
 int zynq_gem_initialize(bd_t *bis, int base_addr);
+
+int c2000_gemac_initialize(bd_t *bis, int index, char *devname);
+
+
 /*
  * As long as the Xilinx xps_ll_temac ethernet driver has not its own interface
  * exported by a public hader file, we need a global definition at this point.
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/Makefile u-boot-2013.01.new/Makefile
--- u-boot-2013.01/Makefile	2013-01-16 03:17:42.000000000 +0530
+++ u-boot-2013.01.new/Makefile	2016-03-23 16:10:34.000000000 +0530
@@ -291,6 +291,9 @@
 LIBS-y += drivers/mtd/spi/libspi_flash.o
 LIBS-y += drivers/net/libnet.o
 LIBS-y += drivers/net/phy/libphy.o
+ifeq ($(SOC),comcerto)
+LIBS-y += drivers/net/c2000_eth/libcomcerto_pfe.o
+endif
 LIBS-y += drivers/pci/libpci.o
 LIBS-y += drivers/pcmcia/libpcmcia.o
 LIBS-y += drivers/power/libpower.o \
@@ -298,6 +301,8 @@
 	drivers/power/pmic/libpmic.o \
 	drivers/power/battery/libbattery.o
 LIBS-y += drivers/spi/libspi.o
+LIBS-y += drivers/otp/libotp.o
+LIBS-y += drivers/spacc/libspacc.o
 LIBS-y += drivers/dfu/libdfu.o
 ifeq ($(CPU),mpc83xx)
 LIBS-y += drivers/qe/libqe.o
@@ -404,7 +409,7 @@
 endif
 
 # Always append ALL so that arch config.mk's can add custom ones
-ALL-y += $(obj)u-boot.srec $(obj)u-boot.bin $(obj)System.map
+ALL-y += $(obj)u-boot.srec $(obj)u-boot.bin $(obj)System.map $(obj)u-boot_secureboot
 
 ALL-$(CONFIG_NAND_U_BOOT) += $(obj)u-boot-nand.bin
 ALL-$(CONFIG_ONENAND_U_BOOT) += $(obj)u-boot-onenand.bin
@@ -440,6 +445,10 @@
 		$(OBJCOPY) ${OBJCFLAGS} -O binary $< $@
 		$(BOARD_SIZE_CHECK)
 
+$(obj)u-boot_secureboot:
+		$(shell cp u-boot.bin ./tools/ImageGenarator/.; cd $(SRCTREE)/tools/ImageGenarator/; \
+		 chmod 755 *.sh; ./uboot_gen.sh 1>/dev/null;)
+
 $(obj)u-boot.ldr:	$(obj)u-boot
 		$(CREATE_LDR_ENV)
 		$(LDR) -T $(CONFIG_BFIN_CPU) -c $@ $< $(LDR_FLAGS)
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/snapshot.commit u-boot-2013.01.new/snapshot.commit
--- u-boot-2013.01/snapshot.commit	2013-01-16 03:17:42.000000000 +0530
+++ u-boot-2013.01.new/snapshot.commit	2016-03-23 16:10:34.000000000 +0530
@@ -1 +1 @@
-3a9d879f6f64585b819af728b53be0a05037fe0d  Tue, 15 Jan 2013 14:47:42 -0700
+$Format:%H  %cD$
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/tools/ImageGenarator/c2k_image_gen.c u-boot-2013.01.new/tools/ImageGenarator/c2k_image_gen.c
--- u-boot-2013.01/tools/ImageGenarator/c2k_image_gen.c	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/tools/ImageGenarator/c2k_image_gen.c	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,353 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include "header.h"
+#include <fcntl.h>
+#include <sys/types.h>
+
+#define MAX_KEY_FILE_SIZE 	(1024+1) //It can hold 4096 bit key in ascii string
+
+/*
+ * Table of CRC-32's of all single-byte values (made by make_crc_table)
+ */
+static const unsigned long crc_table[256] = {
+  0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
+  0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
+  0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
+  0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
+  0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
+  0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
+  0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
+  0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
+  0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
+  0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
+  0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
+  0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
+  0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
+  0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
+  0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
+  0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
+  0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
+  0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
+  0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
+  0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
+  0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
+  0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
+  0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
+  0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
+  0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
+  0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
+  0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
+  0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
+  0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
+  0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
+  0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
+  0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
+  0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
+  0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
+  0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
+  0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
+  0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
+  0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
+  0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
+  0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
+  0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
+  0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
+  0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
+  0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
+  0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
+  0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
+  0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
+  0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
+  0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
+  0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
+  0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
+  0x2d02ef8dL
+};
+
+
+/* CRC calculation related defines */
+#define DO1(buf) crc = crc_table[((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8);
+#define DO2(buf)  DO1(buf); DO1(buf);
+#define DO4(buf)  DO2(buf); DO2(buf);
+#define DO8(buf)  DO4(buf); DO4(buf);
+
+/*
+ *****************************************
+ *   calculate_crc_32 ()
+ *
+ *   Calculate 32 bit CRC
+ *****************************************
+ */
+unsigned long calculate_crc_32(unsigned long crc, const unsigned char *buf, unsigned int len)
+{
+    crc = crc ^ 0xffffffffL;
+    while (len >= 8)
+    {
+      DO8(buf);
+      len -= 8;
+    }
+    if (len) do {
+      DO1(buf);
+    } while (--len);
+    return crc ^ 0xffffffffL;
+}
+
+int bn_atoi(char *keyfile, unsigned char *key, int maxkeylen)
+{
+	int infd=0,outfd=0;
+	int ret=0;
+	int i,boffset=0;
+	unsigned char k,c;
+	char astr[MAX_KEY_FILE_SIZE];
+	struct stat st;
+
+	infd = open(keyfile, O_RDONLY);
+	if(infd < 0) {
+		printf("Failed to open file\n");
+		goto bad_exit;
+	}
+	stat(keyfile, &st);
+	if(st.st_size > MAX_KEY_FILE_SIZE) {
+		printf("Too big infile %d\n", (int)st.st_size);
+		goto bad_exit;
+	}
+
+	if(read(infd, astr, st.st_size) != st.st_size) {
+		printf("Failed to read from %s\n", keyfile);
+		goto bad_exit;
+	}
+	for(i = 0; ((i<st.st_size) && (isxdigit((unsigned char)astr[i]))); i++)
+	{
+		c=astr[i];
+		if((c >= '0') && (c <='9')) k=c-'0';
+		else if ((c >= 'a') && (c <= 'f')) k=c-'a'+10;
+		else if ((c >= 'A') && (c <= 'F')) k=c-'A'+10;
+		else k = 0;
+
+		boffset=i/2;
+		if( boffset > maxkeylen)
+			goto bad_exit;
+		if(i%2)
+			key[boffset] = key[boffset]|k;
+		else
+			key[boffset] = k<<4;
+
+	}
+	if(!boffset)
+	 	goto bad_exit;
+
+	boffset++; //To get length
+
+	ret = boffset;
+bad_exit:
+	if(infd) close(infd);
+	return ret;
+}
+
+int main(int argc, char *argv[])
+{
+	int fdo, fdi, fd1, fd2, timestamp, keylen = 0, keypkg = 0 , aes_iv_len = 0;
+	unsigned int crc = CRC_INIT, hdr_len, hashtype, bytes, hash_len;
+	unsigned char hdr_buf[MAX_HEADER_LENGTH];
+	ssboot_img_hdr *h1 = (ssboot_img_hdr *)hdr_buf;
+	unsigned char pub_key_buf[C2K_KEY_LENGTH_4K];
+	unsigned char aes_iv_buf[C2K_AES_IV_LENGTH];
+	unsigned char *hash_val_buf = (unsigned char *)(h1 + 1), *img_buf;
+	struct stat st;
+	char *timestmp, *image, *hash, *signature, *pblcky, *keymode, *aes_iv=NULL;
+	int ii;
+
+	if ( argc < 4 )
+	{
+		printf( "Usage: %s", argv[0] );
+		goto out;
+	}
+	else
+	{
+		hdr_len = SSBOOT_HEADER_LEN;
+
+		timestmp = argv[1];
+		image	= argv[2];
+		hash	= argv[3];
+		signature = argv[4];
+		pblcky = argv[5];
+		keymode = argv[6];
+
+		timestamp = atoi(timestmp);
+		printf("timestamp = %d\n", timestamp);
+
+		stat(image, &st);
+		printf("image length = %d\n", (int)st.st_size);
+
+		if (strcmp(hash, "null") == 0)
+			hashtype = 0;
+		else if (strcmp(hash, "sha256") == 0)
+			hashtype = 1;
+		else if(strcmp(hash, "rsa") == 0)
+		{
+			if(argc < 6)
+			{
+				printf("Invalid number of arguments to %s\n", argv[0]);
+				goto out;
+			}
+			else
+			{
+				if(pblcky != NULL)
+				{
+					keylen = bn_atoi(pblcky, &pub_key_buf[0], C2K_KEY_LENGTH_4K);
+					if ((keylen * 8) != 1024 && (keylen * 8) != 2048)
+					{
+						printf("Key size %d bit not supported\n", keylen * 8);
+						goto out;
+					}
+					printf("Copied Public key of length %d.\n", keylen);
+				}
+
+				if (strcmp(keymode, "insertkey") == 0)
+					keypkg = 1;
+
+				hashtype = 2;
+			}
+		}
+		else if (strcmp(hash, "aes_rsa") == 0)
+		{
+			if(argc < 7)
+			{
+				printf("Invalid number of arguments to %s\n", argv[0]);
+				goto out;
+			}
+			else
+			{
+				if(pblcky != NULL)
+				{
+					keylen = bn_atoi(pblcky, &pub_key_buf[0], C2K_KEY_LENGTH_4K);
+					if ((keylen * 8) != 1024 && (keylen * 8) != 2048)
+					{
+						printf("Key size %d bit not supported\n", keylen * 8);
+						goto out;
+					}
+					printf("Copied Public key of length %d.\n", keylen);
+				}
+
+				if (strcmp(keymode, "insertkey") == 0)
+					keypkg = 1;
+
+				hashtype = 3;
+				aes_iv = argv[7];
+				if(aes_iv != NULL)
+				{
+					aes_iv_len = bn_atoi(aes_iv, &aes_iv_buf[0], C2K_AES_IV_LENGTH);
+					if (((aes_iv_len * 8) != 128) && ((aes_iv_len * 8) != 256))
+					{
+						printf("AES key IV size %d bit not supported\n", aes_iv_len * 8);
+						goto out;
+					}
+					printf("Copied AES IV of length %d.\n", aes_iv_len);
+				}
+			}
+		}
+
+		h1->magic 		= C2K_MAGIC;
+		h1->timestamp 		= timestamp;
+		h1->ssboot_header_crc 	= 0x0;
+
+		if(keypkg)
+			h1->key_length	= keylen;
+		else
+			h1->key_length	= 0;
+
+		h1->hash_type 		= hashtype;
+		h1->image_len 		= (unsigned int)st.st_size;
+
+                if ( ( h1->hash_type == 2) || ( h1->hash_type == 3) )
+                        hash_len = keylen;
+                else
+                        hash_len = SSBOOT_HASH_LENGTH;
+
+
+		/* Copy Hash Value If available */
+		if ( h1->hash_type )
+		{
+			printf("Copying Hash Value...\n");
+			if((fd2 = open(signature, O_RDONLY, S_IREAD)) == -1)
+			{
+				printf("ERROR: Cannot open the file %s\n", signature);
+				goto out;
+			}
+			bytes = read(fd2, hash_val_buf, hash_len);
+			if (bytes != hash_len)
+				goto out;
+		}
+		else
+		{
+			printf("Copying null Hash...\n");
+			memset(hash_val_buf, 0, hash_len);
+		}
+		hdr_len += hash_len;
+
+		if((pblcky != NULL) && keypkg)
+		{
+			memcpy((unsigned char *)&hdr_buf[hdr_len],(unsigned char *)&pub_key_buf[0], keylen);
+			hdr_len += keylen;
+		}
+
+		if ( aes_iv != NULL)
+		{
+			memcpy((unsigned char *)&hdr_buf[hdr_len],(unsigned char *)&aes_iv_buf[0], aes_iv_len);
+			hdr_len += aes_iv_len;
+		}
+
+		crc = calculate_crc_32(crc, (unsigned char *)&hdr_buf[0], hdr_len);
+		h1->ssboot_header_crc = crc;
+	}
+
+	/*printf("hdr_len = %d hash_len = %d keylen %d aes_iv_len %d \n",hdr_len,hash_len,keylen,aes_iv_len);
+
+        for(ii=0; ii < hdr_len; ii++) {
+                if (!(ii % 16))
+                        printf("\n");
+                printf(" 0x%02x", hdr_buf[ii]);
+        }
+        printf("\n");*/
+
+	printf("Preparing the image with header...\n");
+	if((fdi = open(image, O_RDONLY, S_IREAD)) == -1)
+	{
+		printf("ERROR: Cannot open the file %s\n", image);
+		goto out;
+	}
+	if((fdo = open(strcat(image, ".c2kimg"), O_RDWR | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) == -1)
+	{
+		printf("ERROR: Cannot create a file %s\n", strcat(image, ".c2kimg"));
+		goto out;
+	}
+	if(hdr_len != write(fdo, &hdr_buf[0], hdr_len))
+	{
+		printf("ERROR: Write to the file %s has failed\n", strcat(image, ".c2kimg"));
+		goto out;
+	}
+	img_buf = malloc(st.st_size);
+	if (img_buf == NULL)
+	{
+		printf("ERROR: Out of memory\n");
+		goto out;
+	}
+	bytes = read(fdi, img_buf, st.st_size);
+	if(bytes != write(fdo, img_buf, bytes))
+	{
+		printf("ERROR: Write to the file %s has failed\n", image);
+		goto out;
+	}
+	free(img_buf);
+
+out:
+	if(fd1) close(fd1);
+	if(fd2) close(fd2);
+	if(fdi) close(fdi);
+	if(fdo) close(fdo);
+	return 0;
+}
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/tools/ImageGenarator/hdr_gen_cfg u-boot-2013.01.new/tools/ImageGenarator/hdr_gen_cfg
--- u-boot-2013.01/tools/ImageGenarator/hdr_gen_cfg	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/tools/ImageGenarator/hdr_gen_cfg	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,64 @@
+# Header Generator Configuration File
+#
+#		Header Format
+#	|-----------------------|
+#	|	Magic Number	|
+#	|-----------------------|
+#	|	Timestamp	|
+#	|-----------------------|
+#	|	CRC		|
+#	|-----------------------|
+#	|	Key Length	|
+#	|-----------------------|
+#	|	Image Hash Type	|
+#	|-----------------------|
+#	|	Image Length	|
+#	|-----------------------|
+#	|	Hash Value	|
+#	|-----------------------|
+#	|	Public Key	|
+#	|-----------------------|
+#	|	IV		|
+#	|-----------------------|
+#
+#	 1. Magic Number : Fix string  MSPD - 0x4D535044 
+#	 2. Timestamp: Image creation timestamp.
+#	 3. CRC: 32 Bit CRC on full header.	At the time of CRC calculation this field should be 0. 
+#	 4. Image Hash Type: Hash Type 0/Sha-256/Rsa-Sha-256. 
+#	 I. Zero --  Initialized with all zero [size 32 bytes].
+#	 II. SHA-256 -- SHA-256 hash on the image [size 32 bytes].
+#	 III. RSA-SHA-256 -- RSA encrypted sha-256 hash on the image [size key size].
+#	 IV. AES-RSA-SHA-256 -- AES Decryption and RSA encrypted sha-256 hash on the Image.
+#	 5. Key Length: Length of Public Key 0/1K,2K. Zero means no key.
+#	 6. Image Length: Length of Current Image (excluding header).
+#	 7. Hash value: Hash result 256/1K/2K bits.
+#	 8. Public key (optional): Public key used for firmware authentication (Size 1K/2K/4K)
+#	 9. AES IV value (optional).
+#
+#	Sample configurations
+#
+#	  To generate uboot image with NULL hash
+#		null:::uboot.bin::
+#
+#	  To generate firmware image with SHA256
+#		mk_c2kimage.sh sha256 uboot.bin
+#		sha256:::uboot.bin::
+#
+#	  To generate firmware image with RSA signature and key inbuilt to the header
+#		rsa:private.pem:insertkey:uboot.bin::
+#
+#	  To generate firmware image with RSA signature and no key inserted in the header
+#		rsa:private.pem:nokey:uboot.bin::
+#
+#	  To generate uboot image with AES-128 encryption and RSA signature and key inbuilt to the header
+#		aes-rsa:private.pem:insertkey:uboot.bin:128:
+#
+#	  To generate uboot image with AES-128 encryption and RSA signature and no key inserted in the header
+#		aes-rsa:private.pem:nokey:uboot.bin:128:
+#
+#	  To generate uboot image with AES-256 encryption and RSA signature and key inbuilt to the header
+#		aes-rsa:private.pem:insertkey:uboot.bin:256:
+#
+#	  To generate uboot image with AES-256 encryption and RSA signature and no key inserted in the header
+#		aes-rsa:private.pem:nokey:uboot.bin:256:
+null:::u-boot.bin::
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/tools/ImageGenarator/header.h u-boot-2013.01.new/tools/ImageGenarator/header.h
--- u-boot-2013.01/tools/ImageGenarator/header.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/tools/ImageGenarator/header.h	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,28 @@
+
+typedef struct _ssboot_img_hdr
+{
+	unsigned int magic;		/* Magic No to identify Header == 0x4D535044 */
+	unsigned int timestamp;		/* image creation timestamp in second starting from 01/01/76 */
+	unsigned int ssboot_header_crc;	/* 32 bit CRC of header */
+	unsigned int key_length;	/* Length of Public Key 0/1K,2K/4K. */
+	unsigned int hash_type;		/* Hash Type 0/Sha-256/Rsa-Sha-256/AES/Aes-sha-256/Aes-Rsa-sha-256.
+					   Zero - Initialized with all zero [size 32 bytes],
+					   SHA-256 - SHA-256 hash on the image [size 32 bytes], 
+					   RSA-SHA-256 - RSA encrypted sha-256 hash on the
+					   image [size key size].
+					   AES-RSA-SHA-256 - AES Decryption and RSA encrypted sha-256 hash on the Image */
+	unsigned int image_len;		/* Length of Current Image (excluding header). */
+} ssboot_img_hdr;
+
+#define SSBOOT_HEADER_LEN       sizeof(ssboot_img_hdr)
+
+#define CRC_INIT		0x0
+#define SSBOOT_HASH_LENGTH	32
+#define C2K_KEY_LENGTH_4K	512
+#define C2K_AES_128_KEY_LENGTH	16
+#define C2K_AES_256_KEY_LENGTH	32
+#define C2K_AES_IV_LENGTH	16
+#define MAX_HEADER_LENGTH	(SSBOOT_HEADER_LEN + 2 * C2K_KEY_LENGTH_4K + C2K_AES_IV_LENGTH)
+
+#define	C2K_MAGIC		0x4D535044
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/tools/ImageGenarator/Makefile u-boot-2013.01.new/tools/ImageGenarator/Makefile
--- u-boot-2013.01/tools/ImageGenarator/Makefile	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/tools/ImageGenarator/Makefile	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,12 @@
+all: clean header
+
+header:
+	$(CC) c2k_image_gen.c -o c2k_image_gen
+
+install:
+	cp mk_c2k_image.sh /usr/local/bin/
+	cp c2k_image_gen /usr/local/bin/
+
+clean:
+	rm -f c2k_image_gen *.c2kimg
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/tools/ImageGenarator/mk_c2kimage.sh u-boot-2013.01.new/tools/ImageGenarator/mk_c2kimage.sh
--- u-boot-2013.01/tools/ImageGenarator/mk_c2kimage.sh	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/tools/ImageGenarator/mk_c2kimage.sh	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,229 @@
+#!/bin/sh
+################################################################################
+# This script generates c2k images(that includes image header) from the standard
+# binary file. It can generates header with NULL, SHA256, RSA signatures, and
+# key inbuilt to the header. This script internally invoke header generation
+# application with corresponding parameters.
+#
+# Example Usage:
+# To generate firmware image with NULL hash
+# 	mk_c2kimage.sh null firmware.bin
+#
+# To generate firmware image with SHA256
+#	mk_c2kimage.sh sha256 firmware.bin
+#
+# To generate firmware image with RSA signature and key inbuilt to the header
+#	mk_c2kimage.sh rsa private.pem insertkey firmware.bin
+#
+# To generate firmware image with RSA signature and no key inserted in the header
+#	mk_c2kimage.sh rsa private.pem nokey firmware.bin
+#
+# To generate firmware image with RSA signature and key inbuilt to the header and encrypt the image
+#	mk_c2kimage.sh aes_rsa private.pem insertkey firmware.bin
+#
+# To generate firmware image with RSA signature and no key inserted in the header and encrypt the image
+#	mk_c2kimage.sh aes_rsa private.pem nokey firmware.bin
+#
+# OpenSSL command to generate new private key
+#	openssl genrsa -out private.pem 2048
+#
+# Note: RSA key size is determined from the given private key.
+################################################################################
+
+usage()
+{
+	echo "Usage..."
+	echo "$0 <options> <fw_file>"
+	echo " <fw_file>    - Firmware image"
+	echo " options -"
+	echo " <null>       - Place NULL hash in the header"
+	echo " <sha256>     - Place SHA256 hash in the header"
+	echo " <rsa> <private_key> <insertkey|nokey>"
+	echo "              - Place RSA signature in the header using private_key"
+	echo "                insertkey|nokey to inbuilt or exclude the key from header"
+	echo " <aes_rsa> <private_key> <insertkey|nokey>"
+	echo "              - Encrypt the image and place RSA signature in the header using private_key"
+	echo "                insertkey|nokey to inbuilt or exclude the key from header"
+}
+
+clean_exit()
+{
+	if [ -e "$public_modulus" ]
+	then
+		rm $public_modulus
+	fi
+	if [ -e "$sig_file" ]
+	then
+		rm $sig_file
+	fi
+	if [ -e "$hash_file" ]
+	then
+		rm $hash_file
+	fi
+	exit $1
+}
+
+check_image()
+{
+	if [ "$1" = "" ]; then
+		usage
+		clean_exit 1
+	fi
+
+	if [ ! -e $1 ]; then
+		echo "Firmware file not found "$1
+		clean_exit 1
+	fi
+}
+
+
+#This function calculates C2K custom hash on given input file
+# $1 input file name
+# $2 file name to store hash
+calculate_c2k_hash()
+{
+	img_size=$(stat -c%s $1)
+	part_size=$(((252*1024)))
+	tmp_hash_file=`mktemp` || exit 1
+
+	#create  one temp filename to use as prefix
+	prefix=`mktemp` && rm $prefix
+
+	echo "Calculating custom SHA256 hash on $1 size $img_size"
+	split -b $part_size $1 $prefix
+
+	for part_file in `ls $prefix*`
+	do
+		echo "$(stat -c%s $part_file)"
+		openssl dgst -binary -sha256 < $part_file >> $tmp_hash_file
+		rm $part_file
+	done
+
+	if [ $img_size -gt $part_size ]; then
+		openssl dgst -binary -sha256 < $tmp_hash_file > $2
+	else
+		cat $tmp_hash_file > $2
+	fi
+	rm $tmp_hash_file
+}
+
+case "$1" in
+null)
+	echo "Generating C2K image with NULL hash"
+	timestamp=`date +%s` || exit 1
+	image=$2
+
+	check_image $image
+
+	#Call header generation utility
+	./c2k_image_gen $timestamp $image $1
+	echo "c2k_image_gen $timestamp $image $1"
+	;;
+
+sha256)
+	echo "Generating C2K image with SHA256.."
+	hash_file=`mktemp` || exit 1
+	timestamp=`date +%s` || exit 1
+	image=$2
+
+	check_image $image
+
+	#Calculate SHA256 hash on fw file.
+	calculate_c2k_hash $image $hash_file
+	if [ $? != 0 ]; then
+		echo "Error while calculating hash on $image"
+		clean_exit 1
+	fi
+
+	#Call header generation utility
+	./c2k_image_gen $timestamp $image $1 $hash_file
+	echo "c2k_image_gen $timestamp $image $1 $hash_file"
+	;;
+
+rsa*)
+	echo "Generating C2K image with RSA signature .."
+	public_modulus=`mktemp` || clean_exit 1
+	sig_file=`mktemp` || clean_exit 1
+	hash_file=`mktemp` || clean_exit 1
+	private_key=$2
+	keymode=$3
+	timestamp=`date +%s` || exit 1
+	image=$4
+
+	check_image $image
+
+	if [ ! -e $private_key ]; then
+		echo "Private key file not found '$private_key'"
+		clean_exit 1
+	fi
+
+	#Calculate SHA256 hash on fw file.
+	calculate_c2k_hash $image $hash_file
+	#RSA Sign the hash using private key
+	openssl rsautl -sign -inkey $private_key -keyform PEM -pkcs -in $hash_file -out $sig_file
+
+	#extract the public modulus(N) from the private key.
+	openssl rsa -in $private_key -modulus | awk -F"=" '{if ($1 == "Modulus"){print $2}}' > $public_modulus
+
+	./c2k_image_gen $timestamp $image $1 $sig_file $public_modulus $keymode
+	echo "c2k_image_gen $timestamp $image $1 $sig_file $public_modulus $keymode"
+	;;
+
+aes_rsa*)
+	echo "Generating C2K image with RSA signature and encrypted with AES"
+	public_modulus=`mktemp` || clean_exit 1
+	sig_file=`mktemp` || clean_exit 1
+	hash_file=`mktemp` || clean_exit 1
+	aes_iv_file=`mktemp` || clean_exit 1
+	private_key=$2
+	keymode=$3
+	timestamp=`date +%s` || exit 1
+	image=$4
+	aes_key_size=$5
+	enc_image=$image.enc
+
+	check_image $image
+
+	if [ $aes_key_size = 128 ]; then
+		aes_key=`cat aes_128_plain.key` || exit 1
+		aes_iv=`openssl rand -hex 16` || exit 1
+		openssl enc -aes-128-cbc -p -nosalt -K $aes_key -iv $aes_iv -in $image -out $enc_image
+	fi
+	if [ $aes_key_size = 256 ]; then
+		aes_key=`cat aes_256_plain.key` || exit 1
+		aes_iv=`openssl rand -hex 16` || exit 1
+		openssl enc -aes-256-cbc -p -nosalt -K $aes_key -iv $aes_iv -in $image -out $enc_image
+	fi
+
+	echo $aes_iv > $aes_iv_file
+
+	echo "************VERY IMPORTANT*************"
+	echo "Program this AES key $aes_key into OTP area stored in aes.key file"
+
+	#Calculate SHA256 hash on fw file.
+	if [ ! -e $private_key ]; then
+		echo "Private key file not found '$private_key'"
+		clean_exit 1
+	fi
+
+	#Calculate SHA256 hash on fw file.
+	calculate_c2k_hash $enc_image $hash_file
+
+	#RSA Sign the hash using private key
+	openssl rsautl -sign -inkey $private_key -keyform PEM -pkcs -in $hash_file -out $sig_file
+
+	#extract the public modulus(N) from the private key.
+	openssl rsa -in $private_key -modulus | awk -F"=" '{if ($1 == "Modulus"){print $2}}' > $public_modulus
+
+	./c2k_image_gen $timestamp $enc_image $1 $sig_file $public_modulus $keymode $aes_iv_file
+	echo "c2k_image_gen $timestamp $enc_image $1 $sig_file $public_modulus $keymode $aes_iv_file"
+	;;
+
+*)
+	usage
+	exit 1
+	;;
+
+esac
+clean_exit 0
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' u-boot-2013.01/tools/ImageGenarator/uboot_gen.sh u-boot-2013.01.new/tools/ImageGenarator/uboot_gen.sh
--- u-boot-2013.01/tools/ImageGenarator/uboot_gen.sh	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2013.01.new/tools/ImageGenarator/uboot_gen.sh	2016-03-23 16:10:34.000000000 +0530
@@ -0,0 +1,29 @@
+#!/bin/sh
+
+while IFS=: read f1 f2 f3 f4 f5
+do
+field1=$f1
+field2=$f2
+field3=$f3
+field4=$f4
+field5=$f5
+done < hdr_gen_cfg
+
+make clean;make header
+
+echo "Generating uboot Image" 
+sh mk_c2kimage.sh $field1 $field2 $field3 $field4 $field5
+if [ "$field1" = "aes_rsa" ]; then
+  mv -v $field4.enc.c2kimg ../../u-boot.bin
+else
+  mv -v $field4.c2kimg ../../u-boot.bin
+fi
+echo "Done.\n\n"
+
+echo "Removing uboot original Image" 
+if [ "$field1" = "aes_rsa" ]; then
+rm u-boot.bin u-boot.bin.enc *.key *.rawkey *.pem publickeyhash-*
+else
+rm u-boot.bin *.key *.rawkey *.pem publickeyhash-*
+fi
+echo "Done.\n\n"

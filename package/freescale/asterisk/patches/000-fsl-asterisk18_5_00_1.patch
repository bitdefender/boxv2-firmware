diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/addons/.format_mp3.moduleinfo asterisk-1.8.2.3.new/addons/.format_mp3.moduleinfo
--- asterisk-1.8.2.3/addons/.format_mp3.moduleinfo	2011-01-27 02:48:29.000000000 +0530
+++ asterisk-1.8.2.3.new/addons/.format_mp3.moduleinfo	2011-04-28 18:54:54.000000000 +0530
@@ -1,3 +1,3 @@
 <member name="format_mp3" displayname="MP3 format [Any rate but 8000hz mono is optimal]" remove_on_change="addons/format_mp3.o addons/format_mp3.so">
-	<defaultenabled>no</defaultenabled>
+	<defaultenabled>yes</defaultenabled>
 </member>
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/addons/mp3/common.c asterisk-1.8.2.3.new/addons/mp3/common.c
--- asterisk-1.8.2.3/addons/mp3/common.c	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/addons/mp3/common.c	2011-04-27 16:10:37.000000000 +0530
@@ -0,0 +1,267 @@
+#include "asterisk.h"
+#include "asterisk/logger.h"
+
+#include <ctype.h>
+#include <stdlib.h>
+#include <signal.h>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+#include "mpg123.h"
+#include "mpglib.h"
+
+struct parameter param = { 1 , 1 , 0 , 0 };
+
+int tabsel_123[2][3][16] = {
+   { {0,32,64,96,128,160,192,224,256,288,320,352,384,416,448,},
+     {0,32,48,56, 64, 80, 96,112,128,160,192,224,256,320,384,},
+     {0,32,40,48, 56, 64, 80, 96,112,128,160,192,224,256,320,} },
+
+   { {0,32,48,56,64,80,96,112,128,144,160,176,192,224,256,},
+     {0,8,16,24,32,40,48,56,64,80,96,112,128,144,160,},
+     {0,8,16,24,32,40,48,56,64,80,96,112,128,144,160,} }
+};
+
+long freqs[9] = { 44100, 48000, 32000,
+                  22050, 24000, 16000 ,
+                  11025 , 12000 , 8000 };
+
+
+#if 0
+static void get_II_stuff(struct frame *fr)
+{
+  static int translate[3][2][16] = 
+   { { { 0,2,2,2,2,2,2,0,0,0,1,1,1,1,1,0 } ,
+       { 0,2,2,0,0,0,1,1,1,1,1,1,1,1,1,0 } } ,
+     { { 0,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0 } ,
+       { 0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0 } } ,
+     { { 0,3,3,3,3,3,3,0,0,0,1,1,1,1,1,0 } ,
+       { 0,3,3,0,0,0,1,1,1,1,1,1,1,1,1,0 } } };
+
+  int table,sblim;
+  static struct al_table *tables[5] = 
+       { alloc_0, alloc_1, alloc_2, alloc_3 , alloc_4 };
+  static int sblims[5] = { 27 , 30 , 8, 12 , 30 };
+
+  if(fr->lsf)
+    table = 4;
+  else
+    table = translate[fr->sampling_frequency][2-fr->stereo][fr->bitrate_index];
+  sblim = sblims[table];
+
+  fr->alloc = tables[table];
+  fr->II_sblimit = sblim;
+}
+#endif
+
+#define HDRCMPMASK 0xfffffd00
+
+#if 0
+int head_check(unsigned long head)
+{
+    if( (head & 0xffe00000) != 0xffe00000)
+	return FALSE;
+    if(!((head>>17)&3))
+	return FALSE;
+    if( ((head>>12)&0xf) == 0xf)
+	return FALSE;
+    if( ((head>>10)&0x3) == 0x3 )
+	return FALSE;
+    return TRUE;
+}
+#endif
+
+
+/*
+ * the code a header and write the information
+ * into the frame structure
+ */
+int decode_header(struct frame *fr,unsigned long newhead)
+{
+    if( newhead & (1<<20) ) {
+      fr->lsf = (newhead & (1<<19)) ? 0x0 : 0x1;
+      fr->mpeg25 = 0;
+    }
+    else {
+      fr->lsf = 1;
+      fr->mpeg25 = 1;
+    }
+    
+    fr->lay = 4-((newhead>>17)&3);
+    if( ((newhead>>10)&0x3) == 0x3) {
+      ast_log(LOG_WARNING,"Stream error\n");
+      return (0);
+    }
+    if(fr->mpeg25) {
+      fr->sampling_frequency = 6 + ((newhead>>10)&0x3);
+    }
+    else
+      fr->sampling_frequency = ((newhead>>10)&0x3) + (fr->lsf*3);
+    fr->error_protection = ((newhead>>16)&0x1)^0x1;
+
+    if(fr->mpeg25) /* allow Bitrate change for 2.5 ... */
+      fr->bitrate_index = ((newhead>>12)&0xf);
+
+    fr->bitrate_index = ((newhead>>12)&0xf);
+    fr->padding   = ((newhead>>9)&0x1);
+    fr->extension = ((newhead>>8)&0x1);
+    fr->mode      = ((newhead>>6)&0x3);
+    fr->mode_ext  = ((newhead>>4)&0x3);
+    fr->copyright = ((newhead>>3)&0x1);
+    fr->original  = ((newhead>>2)&0x1);
+    fr->emphasis  = newhead & 0x3;
+
+    fr->stereo    = (fr->mode == MPG_MD_MONO) ? 1 : 2;
+
+    if(!fr->bitrate_index)
+    {
+      ast_log(LOG_WARNING,"Free format not supported.\n");
+      return (0);
+    }
+
+    switch(fr->lay)
+    {
+      case 1:
+#if 0
+		fr->do_layer = do_layer1;
+        fr->jsbound = (fr->mode == MPG_MD_JOINT_STEREO) ? 
+                         (fr->mode_ext<<2)+4 : 32;
+        fr->framesize  = (long) tabsel_123[fr->lsf][0][fr->bitrate_index] * 12000;
+        fr->framesize /= freqs[fr->sampling_frequency];
+        fr->framesize  = ((fr->framesize+fr->padding)<<2)-4;
+#else
+        ast_log(LOG_WARNING,"Layer 1 not supported!\n");
+#endif
+        break;
+      case 2:
+#if 0
+		fr->do_layer = do_layer2;
+        get_II_stuff(fr);
+        fr->jsbound = (fr->mode == MPG_MD_JOINT_STEREO) ?
+                         (fr->mode_ext<<2)+4 : fr->II_sblimit;
+        fr->framesize = (long) tabsel_123[fr->lsf][1][fr->bitrate_index] * 144000;
+        fr->framesize /= freqs[fr->sampling_frequency];
+        fr->framesize += fr->padding - 4;
+#else
+        ast_log(LOG_WARNING,"Layer 2 not supported!\n");
+#endif
+        break;
+      case 3:
+#if 0
+        fr->do_layer = do_layer3;
+        if(fr->lsf)
+          ssize = (fr->stereo == 1) ? 9 : 17;
+        else
+          ssize = (fr->stereo == 1) ? 17 : 32;
+#endif
+
+#if 0
+        if(fr->error_protection)
+          ssize += 2;
+#endif
+          fr->framesize  = (long) tabsel_123[fr->lsf][2][fr->bitrate_index] * 144000;
+          fr->framesize /= freqs[fr->sampling_frequency]<<(fr->lsf);
+          fr->framesize = fr->framesize + fr->padding - 4;
+        break; 
+      default:
+        ast_log(LOG_WARNING,"Sorry, unknown layer type.\n"); 
+        return (0);
+    }
+    return 1;
+}
+
+#if 0
+void print_header(struct frame *fr)
+{
+	static char *modes[4] = { "Stereo", "Joint-Stereo", "Dual-Channel", "Single-Channel" };
+	static char *layers[4] = { "Unknown" , "I", "II", "III" };
+
+	ast_log(LOG_WARNING,"MPEG %s, Layer: %s, Freq: %ld, mode: %s, modext: %d, BPF : %d\n", 
+		fr->mpeg25 ? "2.5" : (fr->lsf ? "2.0" : "1.0"),
+		layers[fr->lay],freqs[fr->sampling_frequency],
+		modes[fr->mode],fr->mode_ext,fr->framesize+4);
+	ast_log(LOG_WARNING,"Channels: %d, copyright: %s, original: %s, CRC: %s, emphasis: %d.\n",
+		fr->stereo,fr->copyright?"Yes":"No",
+		fr->original?"Yes":"No",fr->error_protection?"Yes":"No",
+		fr->emphasis);
+	ast_log(LOG_WARNING,"Bitrate: %d Kbits/s, Extension value: %d\n",
+		tabsel_123[fr->lsf][fr->lay-1][fr->bitrate_index],fr->extension);
+}
+
+void print_header_compact(struct frame *fr)
+{
+	static char *modes[4] = { "stereo", "joint-stereo", "dual-channel", "mono" };
+	static char *layers[4] = { "Unknown" , "I", "II", "III" };
+ 
+	ast_log(LOG_WARNING,"MPEG %s layer %s, %d kbit/s, %ld Hz %s\n",
+		fr->mpeg25 ? "2.5" : (fr->lsf ? "2.0" : "1.0"),
+		layers[fr->lay],
+		tabsel_123[fr->lsf][fr->lay-1][fr->bitrate_index],
+		freqs[fr->sampling_frequency], modes[fr->mode]);
+}
+
+#endif
+
+unsigned int getbits(struct mpstr *mp, int number_of_bits)
+{
+  unsigned long rval;
+
+  if(!number_of_bits)
+    return 0;
+
+  {
+    rval = (mp->worksample).wordpointer[0];
+    rval <<= 8;
+    rval |= (mp->worksample).wordpointer[1];
+    rval <<= 8;
+    rval |= (mp->worksample).wordpointer[2];
+    rval <<= (mp->worksample).bitindex;
+    rval &= 0xffffff;
+
+    (mp->worksample).bitindex += number_of_bits;
+
+    rval >>= (24-number_of_bits);
+
+    (mp->worksample).wordpointer += ((mp->worksample).bitindex>>3);
+    (mp->worksample).bitindex &= 7;
+  }
+  return rval;
+}
+
+unsigned int getbits_fast(struct mpstr *mp, int number_of_bits)
+{
+  unsigned long rval;
+
+  {
+    rval = (mp->worksample).wordpointer[0];
+    rval <<= 8;	
+    rval |= (mp->worksample).wordpointer[1];
+    rval <<= (mp->worksample).bitindex;
+    rval &= 0xffff;
+    (mp->worksample).bitindex += number_of_bits;
+
+    rval >>= (16-number_of_bits);
+
+    (mp->worksample).wordpointer += ((mp->worksample).bitindex>>3);
+    (mp->worksample).bitindex &= 7;
+  }
+  return rval;
+}
+
+unsigned int get1bit(struct mpstr *mp)
+{
+  unsigned char rval;
+
+  rval = *((mp->worksample).wordpointer) << (mp->worksample).bitindex;
+
+  (mp->worksample).bitindex++;
+  (mp->worksample).wordpointer += ((mp->worksample).bitindex>>3);
+  (mp->worksample).bitindex &= 7;
+
+  return rval>>7;
+}
+
+
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/addons/mp3/dct64_i386.c asterisk-1.8.2.3.new/addons/mp3/dct64_i386.c
--- asterisk-1.8.2.3/addons/mp3/dct64_i386.c	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/addons/mp3/dct64_i386.c	2011-04-27 16:10:37.000000000 +0530
@@ -0,0 +1,335 @@
+
+/*
+ * Discrete Cosine Tansform (DCT) for subband synthesis
+ * optimized for machines with no auto-increment. 
+ * The performance is highly compiler dependend. Maybe
+ * the dct64.c version for 'normal' processor may be faster
+ * even for Intel processors.
+ */
+
+#include "mpg123.h"
+
+/*
+ * the call via dct64 is a trick to force GCC to use
+ * (new) registers for the b1,b2 pointer to the bufs[xx] field
+ */
+void dct64(real *a,real *b,real *c);
+
+static void dct64_1(real *out0,real *out1,real *b1,real *b2,real *samples)
+{
+ {
+  register real *costab = pnts[0];
+
+  b1[0x00] = samples[0x00] + samples[0x1F];
+  b1[0x01] = samples[0x01] + samples[0x1E];
+  b1[0x1F] = (samples[0x00] - samples[0x1F]) * costab[0x0];
+  b1[0x1E] = (samples[0x01] - samples[0x1E]) * costab[0x1];
+
+  b1[0x02] = samples[0x02] + samples[0x1D];
+  b1[0x03] = samples[0x03] + samples[0x1C];
+  b1[0x1D] = (samples[0x02] - samples[0x1D]) * costab[0x2];
+  b1[0x1C] = (samples[0x03] - samples[0x1C]) * costab[0x3];
+
+  b1[0x04] = samples[0x04] + samples[0x1B];
+  b1[0x05] = samples[0x05] + samples[0x1A];
+  b1[0x1B] = (samples[0x04] - samples[0x1B]) * costab[0x4];
+  b1[0x1A] = (samples[0x05] - samples[0x1A]) * costab[0x5];
+
+  b1[0x06] = samples[0x06] + samples[0x19];
+  b1[0x07] = samples[0x07] + samples[0x18];
+  b1[0x19] = (samples[0x06] - samples[0x19]) * costab[0x6];
+  b1[0x18] = (samples[0x07] - samples[0x18]) * costab[0x7];
+
+  b1[0x08] = samples[0x08] + samples[0x17];
+  b1[0x09] = samples[0x09] + samples[0x16];
+  b1[0x17] = (samples[0x08] - samples[0x17]) * costab[0x8];
+  b1[0x16] = (samples[0x09] - samples[0x16]) * costab[0x9];
+
+  b1[0x0A] = samples[0x0A] + samples[0x15];
+  b1[0x0B] = samples[0x0B] + samples[0x14];
+  b1[0x15] = (samples[0x0A] - samples[0x15]) * costab[0xA];
+  b1[0x14] = (samples[0x0B] - samples[0x14]) * costab[0xB];
+
+  b1[0x0C] = samples[0x0C] + samples[0x13];
+  b1[0x0D] = samples[0x0D] + samples[0x12];
+  b1[0x13] = (samples[0x0C] - samples[0x13]) * costab[0xC];
+  b1[0x12] = (samples[0x0D] - samples[0x12]) * costab[0xD];
+
+  b1[0x0E] = samples[0x0E] + samples[0x11];
+  b1[0x0F] = samples[0x0F] + samples[0x10];
+  b1[0x11] = (samples[0x0E] - samples[0x11]) * costab[0xE];
+  b1[0x10] = (samples[0x0F] - samples[0x10]) * costab[0xF];
+
+ }
+
+
+ {
+  register real *costab = pnts[1];
+
+  b2[0x00] = b1[0x00] + b1[0x0F]; 
+  b2[0x01] = b1[0x01] + b1[0x0E]; 
+  b2[0x0F] = (b1[0x00] - b1[0x0F]) * costab[0];
+  b2[0x0E] = (b1[0x01] - b1[0x0E]) * costab[1];
+
+  b2[0x02] = b1[0x02] + b1[0x0D]; 
+  b2[0x03] = b1[0x03] + b1[0x0C]; 
+  b2[0x0D] = (b1[0x02] - b1[0x0D]) * costab[2];
+  b2[0x0C] = (b1[0x03] - b1[0x0C]) * costab[3];
+
+  b2[0x04] = b1[0x04] + b1[0x0B]; 
+  b2[0x05] = b1[0x05] + b1[0x0A]; 
+  b2[0x0B] = (b1[0x04] - b1[0x0B]) * costab[4];
+  b2[0x0A] = (b1[0x05] - b1[0x0A]) * costab[5];
+
+  b2[0x06] = b1[0x06] + b1[0x09]; 
+  b2[0x07] = b1[0x07] + b1[0x08]; 
+  b2[0x09] = (b1[0x06] - b1[0x09]) * costab[6];
+  b2[0x08] = (b1[0x07] - b1[0x08]) * costab[7];
+
+  /* */
+
+  b2[0x10] = b1[0x10] + b1[0x1F];
+  b2[0x11] = b1[0x11] + b1[0x1E];
+  b2[0x1F] = (b1[0x1F] - b1[0x10]) * costab[0];
+  b2[0x1E] = (b1[0x1E] - b1[0x11]) * costab[1];
+
+  b2[0x12] = b1[0x12] + b1[0x1D];
+  b2[0x13] = b1[0x13] + b1[0x1C];
+  b2[0x1D] = (b1[0x1D] - b1[0x12]) * costab[2];
+  b2[0x1C] = (b1[0x1C] - b1[0x13]) * costab[3];
+
+  b2[0x14] = b1[0x14] + b1[0x1B];
+  b2[0x15] = b1[0x15] + b1[0x1A];
+  b2[0x1B] = (b1[0x1B] - b1[0x14]) * costab[4];
+  b2[0x1A] = (b1[0x1A] - b1[0x15]) * costab[5];
+
+  b2[0x16] = b1[0x16] + b1[0x19];
+  b2[0x17] = b1[0x17] + b1[0x18];
+  b2[0x19] = (b1[0x19] - b1[0x16]) * costab[6];
+  b2[0x18] = (b1[0x18] - b1[0x17]) * costab[7];
+ }
+
+ {
+  register real *costab = pnts[2];
+
+  b1[0x00] = b2[0x00] + b2[0x07];
+  b1[0x07] = (b2[0x00] - b2[0x07]) * costab[0];
+  b1[0x01] = b2[0x01] + b2[0x06];
+  b1[0x06] = (b2[0x01] - b2[0x06]) * costab[1];
+  b1[0x02] = b2[0x02] + b2[0x05];
+  b1[0x05] = (b2[0x02] - b2[0x05]) * costab[2];
+  b1[0x03] = b2[0x03] + b2[0x04];
+  b1[0x04] = (b2[0x03] - b2[0x04]) * costab[3];
+
+  b1[0x08] = b2[0x08] + b2[0x0F];
+  b1[0x0F] = (b2[0x0F] - b2[0x08]) * costab[0];
+  b1[0x09] = b2[0x09] + b2[0x0E];
+  b1[0x0E] = (b2[0x0E] - b2[0x09]) * costab[1];
+  b1[0x0A] = b2[0x0A] + b2[0x0D];
+  b1[0x0D] = (b2[0x0D] - b2[0x0A]) * costab[2];
+  b1[0x0B] = b2[0x0B] + b2[0x0C];
+  b1[0x0C] = (b2[0x0C] - b2[0x0B]) * costab[3];
+
+  b1[0x10] = b2[0x10] + b2[0x17];
+  b1[0x17] = (b2[0x10] - b2[0x17]) * costab[0];
+  b1[0x11] = b2[0x11] + b2[0x16];
+  b1[0x16] = (b2[0x11] - b2[0x16]) * costab[1];
+  b1[0x12] = b2[0x12] + b2[0x15];
+  b1[0x15] = (b2[0x12] - b2[0x15]) * costab[2];
+  b1[0x13] = b2[0x13] + b2[0x14];
+  b1[0x14] = (b2[0x13] - b2[0x14]) * costab[3];
+
+  b1[0x18] = b2[0x18] + b2[0x1F];
+  b1[0x1F] = (b2[0x1F] - b2[0x18]) * costab[0];
+  b1[0x19] = b2[0x19] + b2[0x1E];
+  b1[0x1E] = (b2[0x1E] - b2[0x19]) * costab[1];
+  b1[0x1A] = b2[0x1A] + b2[0x1D];
+  b1[0x1D] = (b2[0x1D] - b2[0x1A]) * costab[2];
+  b1[0x1B] = b2[0x1B] + b2[0x1C];
+  b1[0x1C] = (b2[0x1C] - b2[0x1B]) * costab[3];
+ }
+
+ {
+  register real const cos0 = pnts[3][0];
+  register real const cos1 = pnts[3][1];
+
+  b2[0x00] = b1[0x00] + b1[0x03];
+  b2[0x03] = (b1[0x00] - b1[0x03]) * cos0;
+  b2[0x01] = b1[0x01] + b1[0x02];
+  b2[0x02] = (b1[0x01] - b1[0x02]) * cos1;
+
+  b2[0x04] = b1[0x04] + b1[0x07];
+  b2[0x07] = (b1[0x07] - b1[0x04]) * cos0;
+  b2[0x05] = b1[0x05] + b1[0x06];
+  b2[0x06] = (b1[0x06] - b1[0x05]) * cos1;
+
+  b2[0x08] = b1[0x08] + b1[0x0B];
+  b2[0x0B] = (b1[0x08] - b1[0x0B]) * cos0;
+  b2[0x09] = b1[0x09] + b1[0x0A];
+  b2[0x0A] = (b1[0x09] - b1[0x0A]) * cos1;
+  
+  b2[0x0C] = b1[0x0C] + b1[0x0F];
+  b2[0x0F] = (b1[0x0F] - b1[0x0C]) * cos0;
+  b2[0x0D] = b1[0x0D] + b1[0x0E];
+  b2[0x0E] = (b1[0x0E] - b1[0x0D]) * cos1;
+
+  b2[0x10] = b1[0x10] + b1[0x13];
+  b2[0x13] = (b1[0x10] - b1[0x13]) * cos0;
+  b2[0x11] = b1[0x11] + b1[0x12];
+  b2[0x12] = (b1[0x11] - b1[0x12]) * cos1;
+
+  b2[0x14] = b1[0x14] + b1[0x17];
+  b2[0x17] = (b1[0x17] - b1[0x14]) * cos0;
+  b2[0x15] = b1[0x15] + b1[0x16];
+  b2[0x16] = (b1[0x16] - b1[0x15]) * cos1;
+
+  b2[0x18] = b1[0x18] + b1[0x1B];
+  b2[0x1B] = (b1[0x18] - b1[0x1B]) * cos0;
+  b2[0x19] = b1[0x19] + b1[0x1A];
+  b2[0x1A] = (b1[0x19] - b1[0x1A]) * cos1;
+
+  b2[0x1C] = b1[0x1C] + b1[0x1F];
+  b2[0x1F] = (b1[0x1F] - b1[0x1C]) * cos0;
+  b2[0x1D] = b1[0x1D] + b1[0x1E];
+  b2[0x1E] = (b1[0x1E] - b1[0x1D]) * cos1;
+ }
+
+ {
+  register real const cos0 = pnts[4][0];
+
+  b1[0x00] = b2[0x00] + b2[0x01];
+  b1[0x01] = (b2[0x00] - b2[0x01]) * cos0;
+  b1[0x02] = b2[0x02] + b2[0x03];
+  b1[0x03] = (b2[0x03] - b2[0x02]) * cos0;
+  b1[0x02] += b1[0x03];
+
+  b1[0x04] = b2[0x04] + b2[0x05];
+  b1[0x05] = (b2[0x04] - b2[0x05]) * cos0;
+  b1[0x06] = b2[0x06] + b2[0x07];
+  b1[0x07] = (b2[0x07] - b2[0x06]) * cos0;
+  b1[0x06] += b1[0x07];
+  b1[0x04] += b1[0x06];
+  b1[0x06] += b1[0x05];
+  b1[0x05] += b1[0x07];
+
+  b1[0x08] = b2[0x08] + b2[0x09];
+  b1[0x09] = (b2[0x08] - b2[0x09]) * cos0;
+  b1[0x0A] = b2[0x0A] + b2[0x0B];
+  b1[0x0B] = (b2[0x0B] - b2[0x0A]) * cos0;
+  b1[0x0A] += b1[0x0B];
+
+  b1[0x0C] = b2[0x0C] + b2[0x0D];
+  b1[0x0D] = (b2[0x0C] - b2[0x0D]) * cos0;
+  b1[0x0E] = b2[0x0E] + b2[0x0F];
+  b1[0x0F] = (b2[0x0F] - b2[0x0E]) * cos0;
+  b1[0x0E] += b1[0x0F];
+  b1[0x0C] += b1[0x0E];
+  b1[0x0E] += b1[0x0D];
+  b1[0x0D] += b1[0x0F];
+
+  b1[0x10] = b2[0x10] + b2[0x11];
+  b1[0x11] = (b2[0x10] - b2[0x11]) * cos0;
+  b1[0x12] = b2[0x12] + b2[0x13];
+  b1[0x13] = (b2[0x13] - b2[0x12]) * cos0;
+  b1[0x12] += b1[0x13];
+
+  b1[0x14] = b2[0x14] + b2[0x15];
+  b1[0x15] = (b2[0x14] - b2[0x15]) * cos0;
+  b1[0x16] = b2[0x16] + b2[0x17];
+  b1[0x17] = (b2[0x17] - b2[0x16]) * cos0;
+  b1[0x16] += b1[0x17];
+  b1[0x14] += b1[0x16];
+  b1[0x16] += b1[0x15];
+  b1[0x15] += b1[0x17];
+
+  b1[0x18] = b2[0x18] + b2[0x19];
+  b1[0x19] = (b2[0x18] - b2[0x19]) * cos0;
+  b1[0x1A] = b2[0x1A] + b2[0x1B];
+  b1[0x1B] = (b2[0x1B] - b2[0x1A]) * cos0;
+  b1[0x1A] += b1[0x1B];
+
+  b1[0x1C] = b2[0x1C] + b2[0x1D];
+  b1[0x1D] = (b2[0x1C] - b2[0x1D]) * cos0;
+  b1[0x1E] = b2[0x1E] + b2[0x1F];
+  b1[0x1F] = (b2[0x1F] - b2[0x1E]) * cos0;
+  b1[0x1E] += b1[0x1F];
+  b1[0x1C] += b1[0x1E];
+  b1[0x1E] += b1[0x1D];
+  b1[0x1D] += b1[0x1F];
+ }
+
+ out0[0x10*16] = b1[0x00];
+ out0[0x10*12] = b1[0x04];
+ out0[0x10* 8] = b1[0x02];
+ out0[0x10* 4] = b1[0x06];
+ out0[0x10* 0] = b1[0x01];
+ out1[0x10* 0] = b1[0x01];
+ out1[0x10* 4] = b1[0x05];
+ out1[0x10* 8] = b1[0x03];
+ out1[0x10*12] = b1[0x07];
+
+#if 1
+ out0[0x10*14] = b1[0x08] + b1[0x0C];
+ out0[0x10*10] = b1[0x0C] + b1[0x0a];
+ out0[0x10* 6] = b1[0x0A] + b1[0x0E];
+ out0[0x10* 2] = b1[0x0E] + b1[0x09];
+ out1[0x10* 2] = b1[0x09] + b1[0x0D];
+ out1[0x10* 6] = b1[0x0D] + b1[0x0B];
+ out1[0x10*10] = b1[0x0B] + b1[0x0F];
+ out1[0x10*14] = b1[0x0F];
+#else
+ b1[0x08] += b1[0x0C];
+ out0[0x10*14] = b1[0x08];
+ b1[0x0C] += b1[0x0a];
+ out0[0x10*10] = b1[0x0C];
+ b1[0x0A] += b1[0x0E];
+ out0[0x10* 6] = b1[0x0A];
+ b1[0x0E] += b1[0x09];
+ out0[0x10* 2] = b1[0x0E];
+ b1[0x09] += b1[0x0D];
+ out1[0x10* 2] = b1[0x09];
+ b1[0x0D] += b1[0x0B];
+ out1[0x10* 6] = b1[0x0D];
+ b1[0x0B] += b1[0x0F];
+ out1[0x10*10] = b1[0x0B];
+ out1[0x10*14] = b1[0x0F];
+#endif
+
+ { 
+ real tmp;
+ tmp = b1[0x18] + b1[0x1C];
+ out0[0x10*15] = tmp + b1[0x10];
+ out0[0x10*13] = tmp + b1[0x14];
+ tmp = b1[0x1C] + b1[0x1A];
+ out0[0x10*11] = tmp + b1[0x14];
+ out0[0x10* 9] = tmp + b1[0x12];
+ tmp = b1[0x1A] + b1[0x1E];
+ out0[0x10* 7] = tmp + b1[0x12];
+ out0[0x10* 5] = tmp + b1[0x16];
+ tmp = b1[0x1E] + b1[0x19];
+ out0[0x10* 3] = tmp + b1[0x16];
+ out0[0x10* 1] = tmp + b1[0x11];
+ tmp = b1[0x19] + b1[0x1D];
+ out1[0x10* 1] = tmp + b1[0x11];
+ out1[0x10* 3] = tmp + b1[0x15]; 
+ tmp = b1[0x1D] + b1[0x1B];
+ out1[0x10* 5] = tmp + b1[0x15];
+ out1[0x10* 7] = tmp + b1[0x13];
+ tmp = b1[0x1B] + b1[0x1F];
+ out1[0x10* 9] = tmp + b1[0x13];
+ out1[0x10*11] = tmp + b1[0x17];
+ out1[0x10*13] = b1[0x17] + b1[0x1F];
+ out1[0x10*15] = b1[0x1F];
+ }
+}
+
+/*
+ * the call via dct64 is a trick to force GCC to use
+ * (new) registers for the b1,b2 pointer to the bufs[xx] field
+ */
+void dct64(real *a,real *b,real *c)
+{
+  real bufs[0x40];
+  dct64_1(a,b,bufs,bufs+0x20,c);
+}
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/addons/mp3/decode_i386.c asterisk-1.8.2.3.new/addons/mp3/decode_i386.c
--- asterisk-1.8.2.3/addons/mp3/decode_i386.c	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/addons/mp3/decode_i386.c	2011-04-27 16:10:37.000000000 +0530
@@ -0,0 +1,153 @@
+/* 
+ * Mpeg Layer-1,2,3 audio decoder 
+ * ------------------------------
+ * copyright (c) 1995,1996,1997 by Michael Hipp, All rights reserved.
+ * See also 'README'
+ *
+ * slighlty optimized for machines without autoincrement/decrement.
+ * The performance is highly compiler dependend. Maybe
+ * the decode.c version for 'normal' processor may be faster
+ * even for Intel processors.
+ */
+
+#include <stdlib.h>
+#include <math.h>
+#include <string.h>
+
+
+#include "mpglib.h"
+
+
+
+ /* old WRITE_SAMPLE */
+#define WRITE_SAMPLE(samples,sum,clip) \
+  if( (sum) > 32767.0) { *(samples) = 0x7fff; (clip)++; } \
+  else if( (sum) < -32768.0) { *(samples) = -0x8000; (clip)++; } \
+  else { *(samples) = sum; }
+
+int synth_1to1_mono(struct mpstr *mp,real *bandPtr,unsigned char *samples,int *pnt)
+{
+  short samples_tmp[64];
+  short *tmp1 = samples_tmp;
+  int i,ret;
+  int pnt1 = 0;
+
+  ret = synth_1to1(mp,bandPtr,0,(unsigned char *) samples_tmp,&pnt1);
+  samples += *pnt;
+
+  for(i=0;i<32;i++) {
+    *( (short *) samples) = *tmp1;
+    samples += 2;
+    tmp1 += 2;
+  }
+  *pnt += 64;
+
+  return ret;
+}
+
+
+int synth_1to1(struct mpstr *mp, real *bandPtr,int channel,unsigned char *out,int *pnt)
+{
+  static const int step = 2;
+  int bo;
+  short *samples = (short *) (out + *pnt);
+
+  real *b0,(*buf)[0x110];
+  int clip = 0; 
+  int bo1;
+
+  bo = mp->synth_bo;
+
+  if(!channel) {
+    bo--;
+    bo &= 0xf;
+    buf = mp->synth_buffs[0];
+  }
+  else {
+    samples++;
+    buf = mp->synth_buffs[1];
+  }
+
+  if(bo & 0x1) {
+    b0 = buf[0];
+    bo1 = bo;
+    dct64(buf[1]+((bo+1)&0xf),buf[0]+bo,bandPtr);
+  }
+  else {
+    b0 = buf[1];
+    bo1 = bo+1;
+    dct64(buf[0]+bo,buf[1]+bo+1,bandPtr);
+  }
+
+  mp->synth_bo = bo;
+  
+  {
+    register int j;
+    real *window = decwin + 16 - bo1;
+
+    for (j=16;j;j--,b0+=0x10,window+=0x20,samples+=step)
+    {
+      real sum;
+      sum  = window[0x0] * b0[0x0];
+      sum -= window[0x1] * b0[0x1];
+      sum += window[0x2] * b0[0x2];
+      sum -= window[0x3] * b0[0x3];
+      sum += window[0x4] * b0[0x4];
+      sum -= window[0x5] * b0[0x5];
+      sum += window[0x6] * b0[0x6];
+      sum -= window[0x7] * b0[0x7];
+      sum += window[0x8] * b0[0x8];
+      sum -= window[0x9] * b0[0x9];
+      sum += window[0xA] * b0[0xA];
+      sum -= window[0xB] * b0[0xB];
+      sum += window[0xC] * b0[0xC];
+      sum -= window[0xD] * b0[0xD];
+      sum += window[0xE] * b0[0xE];
+      sum -= window[0xF] * b0[0xF];
+
+      WRITE_SAMPLE(samples,sum,clip);
+    }
+
+    {
+      real sum;
+      sum  = window[0x0] * b0[0x0];
+      sum += window[0x2] * b0[0x2];
+      sum += window[0x4] * b0[0x4];
+      sum += window[0x6] * b0[0x6];
+      sum += window[0x8] * b0[0x8];
+      sum += window[0xA] * b0[0xA];
+      sum += window[0xC] * b0[0xC];
+      sum += window[0xE] * b0[0xE];
+      WRITE_SAMPLE(samples,sum,clip);
+      b0-=0x10,window-=0x20,samples+=step;
+    }
+    window += bo1<<1;
+
+    for (j=15;j;j--,b0-=0x10,window-=0x20,samples+=step)
+    {
+      real sum;
+      sum = -window[-0x1] * b0[0x0];
+      sum -= window[-0x2] * b0[0x1];
+      sum -= window[-0x3] * b0[0x2];
+      sum -= window[-0x4] * b0[0x3];
+      sum -= window[-0x5] * b0[0x4];
+      sum -= window[-0x6] * b0[0x5];
+      sum -= window[-0x7] * b0[0x6];
+      sum -= window[-0x8] * b0[0x7];
+      sum -= window[-0x9] * b0[0x8];
+      sum -= window[-0xA] * b0[0x9];
+      sum -= window[-0xB] * b0[0xA];
+      sum -= window[-0xC] * b0[0xB];
+      sum -= window[-0xD] * b0[0xC];
+      sum -= window[-0xE] * b0[0xD];
+      sum -= window[-0xF] * b0[0xE];
+      sum -= window[-0x0] * b0[0xF];
+
+      WRITE_SAMPLE(samples,sum,clip);
+    }
+  }
+  *pnt += 128;
+
+  return clip;
+}
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/addons/mp3/decode_ntom.c asterisk-1.8.2.3.new/addons/mp3/decode_ntom.c
--- asterisk-1.8.2.3/addons/mp3/decode_ntom.c	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/addons/mp3/decode_ntom.c	2011-04-27 16:10:37.000000000 +0530
@@ -0,0 +1,219 @@
+/* 
+ * Mpeg Layer-1,2,3 audio decoder 
+ * ------------------------------
+ * copyright (c) 1995,1996,1997 by Michael Hipp, All rights reserved.
+ * See also 'README'
+ *
+ * N->M down/up sampling. Not optimized for speed.
+ */
+
+#include "asterisk.h"
+#include "asterisk/logger.h"
+#include <stdlib.h>
+#include <math.h>
+#include <string.h>
+
+#include "mpg123.h"
+#include "mpglib.h"
+
+#define WRITE_SAMPLE(samples,sum,clip) \
+  if( (sum) > 32767.0) { *(samples) = 0x7fff; (clip)++; } \
+  else if( (sum) < -32768.0) { *(samples) = -0x8000; (clip)++; } \
+  else { *(samples) = sum; }
+
+#define NTOM_MUL (32768)
+static unsigned long ntom_val[2] = { NTOM_MUL>>1,NTOM_MUL>>1 };
+static unsigned long ntom_step = NTOM_MUL;
+
+
+int synth_ntom_set_step(long m,long n)
+{
+	if(param.verbose > 1)
+		ast_log(LOG_WARNING,"Init rate converter: %ld->%ld\n",m,n);
+
+	if(n >= 96000 || m >= 96000 || m == 0 || n == 0) {
+		ast_log(LOG_WARNING,"NtoM converter: illegal rates\n");
+		return (1);
+	}
+
+	n *= NTOM_MUL;
+	ntom_step = n / m;
+
+	if(ntom_step > 8*NTOM_MUL) {
+		ast_log(LOG_WARNING,"max. 1:8 conversion allowed!\n");
+		return (1);
+	}
+
+	ntom_val[0] = ntom_val[1] = NTOM_MUL>>1;
+
+	return (0);
+	
+}
+
+
+int synth_ntom_mono (struct mpstr *mp, real *bandPtr,unsigned char *samples,int *pnt)
+{
+  short samples_tmp[8*64];
+  short *tmp1 = samples_tmp;
+  int i,ret;
+  int pnt1 = 0;
+
+  ret = synth_ntom(mp, bandPtr,0,(unsigned char *) samples_tmp,&pnt1);
+  samples += *pnt;
+
+  for(i=0;i<(pnt1>>2);i++) {
+    *( (short *)samples) = *tmp1;
+    samples += 2;
+    tmp1 += 2;
+  }
+  *pnt += pnt1 >> 1;
+
+  return ret;
+}
+
+
+
+int synth_ntom(struct mpstr *mp, real *bandPtr,int channel,unsigned char *out,int *pnt)
+{
+  static const int step = 2;
+  int bo;
+  short *samples = (short *) (out + *pnt);
+
+  real *b0,(*buf)[0x110];
+  int clip = 0; 
+  int bo1;
+  int ntom;
+
+  bo = mp->synth_bo;
+  
+  if(!channel) {
+    bo--;
+    bo &= 0xf;
+    buf = mp->synth_buffs[0];
+    ntom = ntom_val[1] = ntom_val[0];
+  }
+  else {
+    samples++;
+    out += 2; /* to compute the right *pnt value */
+    buf = mp->synth_buffs[1];
+    ntom = ntom_val[1];
+  }
+
+  if(bo & 0x1) {
+    b0 = buf[0];
+    bo1 = bo;
+    dct64(buf[1]+((bo+1)&0xf),buf[0]+bo,bandPtr);
+  }
+  else {
+    b0 = buf[1];
+    bo1 = bo+1;
+    dct64(buf[0]+bo,buf[1]+bo+1,bandPtr);
+  }
+
+  mp->synth_bo = bo;
+  
+  {
+    register int j;
+    real *window = (mp->decwin) + 16 - bo1;
+ 
+    for (j=16;j;j--,window+=0x10)
+    {
+      real sum;
+
+      ntom += ntom_step;
+      if(ntom < NTOM_MUL) {
+        window += 16;
+        b0 += 16;
+        continue;
+      }
+
+      sum  = *window++ * *b0++;
+      sum -= *window++ * *b0++;
+      sum += *window++ * *b0++;
+      sum -= *window++ * *b0++;
+      sum += *window++ * *b0++;
+      sum -= *window++ * *b0++;
+      sum += *window++ * *b0++;
+      sum -= *window++ * *b0++;
+      sum += *window++ * *b0++;
+      sum -= *window++ * *b0++;
+      sum += *window++ * *b0++;
+      sum -= *window++ * *b0++;
+      sum += *window++ * *b0++;
+      sum -= *window++ * *b0++;
+      sum += *window++ * *b0++;
+      sum -= *window++ * *b0++;
+
+      while(ntom >= NTOM_MUL) {
+        WRITE_SAMPLE(samples,sum,clip);
+        samples += step;
+        ntom -= NTOM_MUL;
+      }
+    }
+
+    ntom += ntom_step;
+    if(ntom >= NTOM_MUL)
+    {
+      real sum;
+      sum  = window[0x0] * b0[0x0];
+      sum += window[0x2] * b0[0x2];
+      sum += window[0x4] * b0[0x4];
+      sum += window[0x6] * b0[0x6];
+      sum += window[0x8] * b0[0x8];
+      sum += window[0xA] * b0[0xA];
+      sum += window[0xC] * b0[0xC];
+      sum += window[0xE] * b0[0xE];
+
+      while(ntom >= NTOM_MUL) {
+        WRITE_SAMPLE(samples,sum,clip);
+        samples += step;
+        ntom -= NTOM_MUL;
+      }
+    }
+
+    b0-=0x10,window-=0x20;
+    window += bo1<<1;
+
+    for (j=15;j;j--,b0-=0x20,window-=0x10)
+    {
+      real sum;
+
+      ntom += ntom_step;
+      if(ntom < NTOM_MUL) {
+        window -= 16;
+        b0 += 16;
+        continue;
+      }
+
+      sum = -*(--window) * *b0++;
+      sum -= *(--window) * *b0++;
+      sum -= *(--window) * *b0++;
+      sum -= *(--window) * *b0++;
+      sum -= *(--window) * *b0++;
+      sum -= *(--window) * *b0++;
+      sum -= *(--window) * *b0++;
+      sum -= *(--window) * *b0++;
+      sum -= *(--window) * *b0++;
+      sum -= *(--window) * *b0++;
+      sum -= *(--window) * *b0++;
+      sum -= *(--window) * *b0++;
+      sum -= *(--window) * *b0++;
+      sum -= *(--window) * *b0++;
+      sum -= *(--window) * *b0++;
+      sum -= *(--window) * *b0++;
+
+      while(ntom >= NTOM_MUL) {
+        WRITE_SAMPLE(samples,sum,clip);
+        samples += step;
+        ntom -= NTOM_MUL;
+      }
+    }
+  }
+
+  ntom_val[channel] = ntom;
+  *pnt = ((unsigned char *) samples - out);
+
+  return clip;
+}
+
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/addons/mp3/huffman.h asterisk-1.8.2.3.new/addons/mp3/huffman.h
--- asterisk-1.8.2.3/addons/mp3/huffman.h	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/addons/mp3/huffman.h	2011-04-27 16:10:37.000000000 +0530
@@ -0,0 +1,332 @@
+/*
+ * huffman tables ... recalcualted to work with my optimzed
+ * decoder scheme (MH)
+ * 
+ * probably we could save a few bytes of memory, because the 
+ * smaller tables are often the part of a bigger table
+ */
+
+struct newhuff 
+{
+  unsigned int linbits;
+  short *table;
+};
+
+static short tab0[] = 
+{ 
+   0
+};
+
+static short tab1[] =
+{
+  -5,  -3,  -1,  17,   1,  16,   0
+};
+
+static short tab2[] =
+{
+ -15, -11,  -9,  -5,  -3,  -1,  34,   2,  18,  -1,  33,  32,  17,  -1,   1,
+  16,   0
+};
+
+static short tab3[] =
+{
+ -13, -11,  -9,  -5,  -3,  -1,  34,   2,  18,  -1,  33,  32,  16,  17,  -1,
+   1,   0
+};
+
+static short tab5[] =
+{
+ -29, -25, -23, -15,  -7,  -5,  -3,  -1,  51,  35,  50,  49,  -3,  -1,  19,
+   3,  -1,  48,  34,  -3,  -1,  18,  33,  -1,   2,  32,  17,  -1,   1,  16,
+   0
+};
+
+static short tab6[] =
+{
+ -25, -19, -13,  -9,  -5,  -3,  -1,  51,   3,  35,  -1,  50,  48,  -1,  19,
+  49,  -3,  -1,  34,   2,  18,  -3,  -1,  33,  32,   1,  -1,  17,  -1,  16,
+   0
+};
+
+static short tab7[] =
+{
+ -69, -65, -57, -39, -29, -17, -11,  -7,  -3,  -1,  85,  69,  -1,  84,  83,
+  -1,  53,  68,  -3,  -1,  37,  82,  21,  -5,  -1,  81,  -1,   5,  52,  -1,
+  80,  -1,  67,  51,  -5,  -3,  -1,  36,  66,  20,  -1,  65,  64, -11,  -7,
+  -3,  -1,   4,  35,  -1,  50,   3,  -1,  19,  49,  -3,  -1,  48,  34,  18,
+  -5,  -1,  33,  -1,   2,  32,  17,  -1,   1,  16,   0
+};
+
+static short tab8[] =
+{
+ -65, -63, -59, -45, -31, -19, -13,  -7,  -5,  -3,  -1,  85,  84,  69,  83,
+  -3,  -1,  53,  68,  37,  -3,  -1,  82,   5,  21,  -5,  -1,  81,  -1,  52,
+  67,  -3,  -1,  80,  51,  36,  -5,  -3,  -1,  66,  20,  65,  -3,  -1,   4,
+  64,  -1,  35,  50,  -9,  -7,  -3,  -1,  19,  49,  -1,   3,  48,  34,  -1,
+   2,  32,  -1,  18,  33,  17,  -3,  -1,   1,  16,   0
+};
+
+static short tab9[] =
+{
+ -63, -53, -41, -29, -19, -11,  -5,  -3,  -1,  85,  69,  53,  -1,  83,  -1,
+  84,   5,  -3,  -1,  68,  37,  -1,  82,  21,  -3,  -1,  81,  52,  -1,  67,
+  -1,  80,   4,  -7,  -3,  -1,  36,  66,  -1,  51,  64,  -1,  20,  65,  -5,
+  -3,  -1,  35,  50,  19,  -1,  49,  -1,   3,  48,  -5,  -3,  -1,  34,   2,
+  18,  -1,  33,  32,  -3,  -1,  17,   1,  -1,  16,   0
+};
+
+static short tab10[] =
+{
+-125,-121,-111, -83, -55, -35, -21, -13,  -7,  -3,  -1, 119, 103,  -1, 118,
+  87,  -3,  -1, 117, 102,  71,  -3,  -1, 116,  86,  -1, 101,  55,  -9,  -3,
+  -1, 115,  70,  -3,  -1,  85,  84,  99,  -1,  39, 114, -11,  -5,  -3,  -1,
+ 100,   7, 112,  -1,  98,  -1,  69,  53,  -5,  -1,   6,  -1,  83,  68,  23,
+ -17,  -5,  -1, 113,  -1,  54,  38,  -5,  -3,  -1,  37,  82,  21,  -1,  81,
+  -1,  52,  67,  -3,  -1,  22,  97,  -1,  96,  -1,   5,  80, -19, -11,  -7,
+  -3,  -1,  36,  66,  -1,  51,   4,  -1,  20,  65,  -3,  -1,  64,  35,  -1,
+  50,   3,  -3,  -1,  19,  49,  -1,  48,  34,  -7,  -3,  -1,  18,  33,  -1,
+   2,  32,  17,  -1,   1,  16,   0
+};
+
+static short tab11[] =
+{
+-121,-113, -89, -59, -43, -27, -17,  -7,  -3,  -1, 119, 103,  -1, 118, 117,
+  -3,  -1, 102,  71,  -1, 116,  -1,  87,  85,  -5,  -3,  -1,  86, 101,  55,
+  -1, 115,  70,  -9,  -7,  -3,  -1,  69,  84,  -1,  53,  83,  39,  -1, 114,
+  -1, 100,   7,  -5,  -1, 113,  -1,  23, 112,  -3,  -1,  54,  99,  -1,  96,
+  -1,  68,  37, -13,  -7,  -5,  -3,  -1,  82,   5,  21,  98,  -3,  -1,  38,
+   6,  22,  -5,  -1,  97,  -1,  81,  52,  -5,  -1,  80,  -1,  67,  51,  -1,
+  36,  66, -15, -11,  -7,  -3,  -1,  20,  65,  -1,   4,  64,  -1,  35,  50,
+  -1,  19,  49,  -5,  -3,  -1,   3,  48,  34,  33,  -5,  -1,  18,  -1,   2,
+  32,  17,  -3,  -1,   1,  16,   0
+};
+
+static short tab12[] =
+{
+-115, -99, -73, -45, -27, -17,  -9,  -5,  -3,  -1, 119, 103, 118,  -1,  87,
+ 117,  -3,  -1, 102,  71,  -1, 116, 101,  -3,  -1,  86,  55,  -3,  -1, 115,
+  85,  39,  -7,  -3,  -1, 114,  70,  -1, 100,  23,  -5,  -1, 113,  -1,   7,
+ 112,  -1,  54,  99, -13,  -9,  -3,  -1,  69,  84,  -1,  68,  -1,   6,   5,
+  -1,  38,  98,  -5,  -1,  97,  -1,  22,  96,  -3,  -1,  53,  83,  -1,  37,
+  82, -17,  -7,  -3,  -1,  21,  81,  -1,  52,  67,  -5,  -3,  -1,  80,   4,
+  36,  -1,  66,  20,  -3,  -1,  51,  65,  -1,  35,  50, -11,  -7,  -5,  -3,
+  -1,  64,   3,  48,  19,  -1,  49,  34,  -1,  18,  33,  -7,  -5,  -3,  -1,
+   2,  32,   0,  17,  -1,   1,  16
+};
+
+static short tab13[] =
+{
+-509,-503,-475,-405,-333,-265,-205,-153,-115, -83, -53, -35, -21, -13,  -9,
+  -7,  -5,  -3,  -1, 254, 252, 253, 237, 255,  -1, 239, 223,  -3,  -1, 238,
+ 207,  -1, 222, 191,  -9,  -3,  -1, 251, 206,  -1, 220,  -1, 175, 233,  -1,
+ 236, 221,  -9,  -5,  -3,  -1, 250, 205, 190,  -1, 235, 159,  -3,  -1, 249,
+ 234,  -1, 189, 219, -17,  -9,  -3,  -1, 143, 248,  -1, 204,  -1, 174, 158,
+  -5,  -1, 142,  -1, 127, 126, 247,  -5,  -1, 218,  -1, 173, 188,  -3,  -1,
+ 203, 246, 111, -15,  -7,  -3,  -1, 232,  95,  -1, 157, 217,  -3,  -1, 245,
+ 231,  -1, 172, 187,  -9,  -3,  -1,  79, 244,  -3,  -1, 202, 230, 243,  -1,
+  63,  -1, 141, 216, -21,  -9,  -3,  -1,  47, 242,  -3,  -1, 110, 156,  15,
+  -5,  -3,  -1, 201,  94, 171,  -3,  -1, 125, 215,  78, -11,  -5,  -3,  -1,
+ 200, 214,  62,  -1, 185,  -1, 155, 170,  -1,  31, 241, -23, -13,  -5,  -1,
+ 240,  -1, 186, 229,  -3,  -1, 228, 140,  -1, 109, 227,  -5,  -1, 226,  -1,
+  46,  14,  -1,  30, 225, -15,  -7,  -3,  -1, 224,  93,  -1, 213, 124,  -3,
+  -1, 199,  77,  -1, 139, 184,  -7,  -3,  -1, 212, 154,  -1, 169, 108,  -1,
+ 198,  61, -37, -21,  -9,  -5,  -3,  -1, 211, 123,  45,  -1, 210,  29,  -5,
+  -1, 183,  -1,  92, 197,  -3,  -1, 153, 122, 195,  -7,  -5,  -3,  -1, 167,
+ 151,  75, 209,  -3,  -1,  13, 208,  -1, 138, 168, -11,  -7,  -3,  -1,  76,
+ 196,  -1, 107, 182,  -1,  60,  44,  -3,  -1, 194,  91,  -3,  -1, 181, 137,
+  28, -43, -23, -11,  -5,  -1, 193,  -1, 152,  12,  -1, 192,  -1, 180, 106,
+  -5,  -3,  -1, 166, 121,  59,  -1, 179,  -1, 136,  90, -11,  -5,  -1,  43,
+  -1, 165, 105,  -1, 164,  -1, 120, 135,  -5,  -1, 148,  -1, 119, 118, 178,
+ -11,  -3,  -1,  27, 177,  -3,  -1,  11, 176,  -1, 150,  74,  -7,  -3,  -1,
+  58, 163,  -1,  89, 149,  -1,  42, 162, -47, -23,  -9,  -3,  -1,  26, 161,
+  -3,  -1,  10, 104, 160,  -5,  -3,  -1, 134,  73, 147,  -3,  -1,  57,  88,
+  -1, 133, 103,  -9,  -3,  -1,  41, 146,  -3,  -1,  87, 117,  56,  -5,  -1,
+ 131,  -1, 102,  71,  -3,  -1, 116,  86,  -1, 101, 115, -11,  -3,  -1,  25,
+ 145,  -3,  -1,   9, 144,  -1,  72, 132,  -7,  -5,  -1, 114,  -1,  70, 100,
+  40,  -1, 130,  24, -41, -27, -11,  -5,  -3,  -1,  55,  39,  23,  -1, 113,
+  -1,  85,   7,  -7,  -3,  -1, 112,  54,  -1,  99,  69,  -3,  -1,  84,  38,
+  -1,  98,  53,  -5,  -1, 129,  -1,   8, 128,  -3,  -1,  22,  97,  -1,   6,
+  96, -13,  -9,  -5,  -3,  -1,  83,  68,  37,  -1,  82,   5,  -1,  21,  81,
+  -7,  -3,  -1,  52,  67,  -1,  80,  36,  -3,  -1,  66,  51,  20, -19, -11,
+  -5,  -1,  65,  -1,   4,  64,  -3,  -1,  35,  50,  19,  -3,  -1,  49,   3,
+  -1,  48,  34,  -3,  -1,  18,  33,  -1,   2,  32,  -3,  -1,  17,   1,  16,
+   0
+};
+
+static short tab15[] =
+{
+-495,-445,-355,-263,-183,-115, -77, -43, -27, -13,  -7,  -3,  -1, 255, 239,
+  -1, 254, 223,  -1, 238,  -1, 253, 207,  -7,  -3,  -1, 252, 222,  -1, 237,
+ 191,  -1, 251,  -1, 206, 236,  -7,  -3,  -1, 221, 175,  -1, 250, 190,  -3,
+  -1, 235, 205,  -1, 220, 159, -15,  -7,  -3,  -1, 249, 234,  -1, 189, 219,
+  -3,  -1, 143, 248,  -1, 204, 158,  -7,  -3,  -1, 233, 127,  -1, 247, 173,
+  -3,  -1, 218, 188,  -1, 111,  -1, 174,  15, -19, -11,  -3,  -1, 203, 246,
+  -3,  -1, 142, 232,  -1,  95, 157,  -3,  -1, 245, 126,  -1, 231, 172,  -9,
+  -3,  -1, 202, 187,  -3,  -1, 217, 141,  79,  -3,  -1, 244,  63,  -1, 243,
+ 216, -33, -17,  -9,  -3,  -1, 230,  47,  -1, 242,  -1, 110, 240,  -3,  -1,
+  31, 241,  -1, 156, 201,  -7,  -3,  -1,  94, 171,  -1, 186, 229,  -3,  -1,
+ 125, 215,  -1,  78, 228, -15,  -7,  -3,  -1, 140, 200,  -1,  62, 109,  -3,
+  -1, 214, 227,  -1, 155, 185,  -7,  -3,  -1,  46, 170,  -1, 226,  30,  -5,
+  -1, 225,  -1,  14, 224,  -1,  93, 213, -45, -25, -13,  -7,  -3,  -1, 124,
+ 199,  -1,  77, 139,  -1, 212,  -1, 184, 154,  -7,  -3,  -1, 169, 108,  -1,
+ 198,  61,  -1, 211, 210,  -9,  -5,  -3,  -1,  45,  13,  29,  -1, 123, 183,
+  -5,  -1, 209,  -1,  92, 208,  -1, 197, 138, -17,  -7,  -3,  -1, 168,  76,
+  -1, 196, 107,  -5,  -1, 182,  -1, 153,  12,  -1,  60, 195,  -9,  -3,  -1,
+ 122, 167,  -1, 166,  -1, 192,  11,  -1, 194,  -1,  44,  91, -55, -29, -15,
+  -7,  -3,  -1, 181,  28,  -1, 137, 152,  -3,  -1, 193,  75,  -1, 180, 106,
+  -5,  -3,  -1,  59, 121, 179,  -3,  -1, 151, 136,  -1,  43,  90, -11,  -5,
+  -1, 178,  -1, 165,  27,  -1, 177,  -1, 176, 105,  -7,  -3,  -1, 150,  74,
+  -1, 164, 120,  -3,  -1, 135,  58, 163, -17,  -7,  -3,  -1,  89, 149,  -1,
+  42, 162,  -3,  -1,  26, 161,  -3,  -1,  10, 160, 104,  -7,  -3,  -1, 134,
+  73,  -1, 148,  57,  -5,  -1, 147,  -1, 119,   9,  -1,  88, 133, -53, -29,
+ -13,  -7,  -3,  -1,  41, 103,  -1, 118, 146,  -1, 145,  -1,  25, 144,  -7,
+  -3,  -1,  72, 132,  -1,  87, 117,  -3,  -1,  56, 131,  -1, 102,  71,  -7,
+  -3,  -1,  40, 130,  -1,  24, 129,  -7,  -3,  -1, 116,   8,  -1, 128,  86,
+  -3,  -1, 101,  55,  -1, 115,  70, -17,  -7,  -3,  -1,  39, 114,  -1, 100,
+  23,  -3,  -1,  85, 113,  -3,  -1,   7, 112,  54,  -7,  -3,  -1,  99,  69,
+  -1,  84,  38,  -3,  -1,  98,  22,  -3,  -1,   6,  96,  53, -33, -19,  -9,
+  -5,  -1,  97,  -1,  83,  68,  -1,  37,  82,  -3,  -1,  21,  81,  -3,  -1,
+   5,  80,  52,  -7,  -3,  -1,  67,  36,  -1,  66,  51,  -1,  65,  -1,  20,
+   4,  -9,  -3,  -1,  35,  50,  -3,  -1,  64,   3,  19,  -3,  -1,  49,  48,
+  34,  -9,  -7,  -3,  -1,  18,  33,  -1,   2,  32,  17,  -3,  -1,   1,  16,
+   0
+};
+
+static short tab16[] =
+{
+-509,-503,-461,-323,-103, -37, -27, -15,  -7,  -3,  -1, 239, 254,  -1, 223,
+ 253,  -3,  -1, 207, 252,  -1, 191, 251,  -5,  -1, 175,  -1, 250, 159,  -3,
+  -1, 249, 248, 143,  -7,  -3,  -1, 127, 247,  -1, 111, 246, 255,  -9,  -5,
+  -3,  -1,  95, 245,  79,  -1, 244, 243, -53,  -1, 240,  -1,  63, -29, -19,
+ -13,  -7,  -5,  -1, 206,  -1, 236, 221, 222,  -1, 233,  -1, 234, 217,  -1,
+ 238,  -1, 237, 235,  -3,  -1, 190, 205,  -3,  -1, 220, 219, 174, -11,  -5,
+  -1, 204,  -1, 173, 218,  -3,  -1, 126, 172, 202,  -5,  -3,  -1, 201, 125,
+  94, 189, 242, -93,  -5,  -3,  -1,  47,  15,  31,  -1, 241, -49, -25, -13,
+  -5,  -1, 158,  -1, 188, 203,  -3,  -1, 142, 232,  -1, 157, 231,  -7,  -3,
+  -1, 187, 141,  -1, 216, 110,  -1, 230, 156, -13,  -7,  -3,  -1, 171, 186,
+  -1, 229, 215,  -1,  78,  -1, 228, 140,  -3,  -1, 200,  62,  -1, 109,  -1,
+ 214, 155, -19, -11,  -5,  -3,  -1, 185, 170, 225,  -1, 212,  -1, 184, 169,
+  -5,  -1, 123,  -1, 183, 208, 227,  -7,  -3,  -1,  14, 224,  -1,  93, 213,
+  -3,  -1, 124, 199,  -1,  77, 139, -75, -45, -27, -13,  -7,  -3,  -1, 154,
+ 108,  -1, 198,  61,  -3,  -1,  92, 197,  13,  -7,  -3,  -1, 138, 168,  -1,
+ 153,  76,  -3,  -1, 182, 122,  60, -11,  -5,  -3,  -1,  91, 137,  28,  -1,
+ 192,  -1, 152, 121,  -1, 226,  -1,  46,  30, -15,  -7,  -3,  -1, 211,  45,
+  -1, 210, 209,  -5,  -1,  59,  -1, 151, 136,  29,  -7,  -3,  -1, 196, 107,
+  -1, 195, 167,  -1,  44,  -1, 194, 181, -23, -13,  -7,  -3,  -1, 193,  12,
+  -1,  75, 180,  -3,  -1, 106, 166, 179,  -5,  -3,  -1,  90, 165,  43,  -1,
+ 178,  27, -13,  -5,  -1, 177,  -1,  11, 176,  -3,  -1, 105, 150,  -1,  74,
+ 164,  -5,  -3,  -1, 120, 135, 163,  -3,  -1,  58,  89,  42, -97, -57, -33,
+ -19, -11,  -5,  -3,  -1, 149, 104, 161,  -3,  -1, 134, 119, 148,  -5,  -3,
+  -1,  73,  87, 103, 162,  -5,  -1,  26,  -1,  10, 160,  -3,  -1,  57, 147,
+  -1,  88, 133,  -9,  -3,  -1,  41, 146,  -3,  -1, 118,   9,  25,  -5,  -1,
+ 145,  -1, 144,  72,  -3,  -1, 132, 117,  -1,  56, 131, -21, -11,  -5,  -3,
+  -1, 102,  40, 130,  -3,  -1,  71, 116,  24,  -3,  -1, 129, 128,  -3,  -1,
+   8,  86,  55,  -9,  -5,  -1, 115,  -1, 101,  70,  -1,  39, 114,  -5,  -3,
+  -1, 100,  85,   7,  23, -23, -13,  -5,  -1, 113,  -1, 112,  54,  -3,  -1,
+  99,  69,  -1,  84,  38,  -3,  -1,  98,  22,  -1,  97,  -1,   6,  96,  -9,
+  -5,  -1,  83,  -1,  53,  68,  -1,  37,  82,  -1,  81,  -1,  21,   5, -33,
+ -23, -13,  -7,  -3,  -1,  52,  67,  -1,  80,  36,  -3,  -1,  66,  51,  20,
+  -5,  -1,  65,  -1,   4,  64,  -1,  35,  50,  -3,  -1,  19,  49,  -3,  -1,
+   3,  48,  34,  -3,  -1,  18,  33,  -1,   2,  32,  -3,  -1,  17,   1,  16,
+   0
+};
+
+static short tab24[] =
+{
+-451,-117, -43, -25, -15,  -7,  -3,  -1, 239, 254,  -1, 223, 253,  -3,  -1,
+ 207, 252,  -1, 191, 251,  -5,  -1, 250,  -1, 175, 159,  -1, 249, 248,  -9,
+  -5,  -3,  -1, 143, 127, 247,  -1, 111, 246,  -3,  -1,  95, 245,  -1,  79,
+ 244, -71,  -7,  -3,  -1,  63, 243,  -1,  47, 242,  -5,  -1, 241,  -1,  31,
+ 240, -25,  -9,  -1,  15,  -3,  -1, 238, 222,  -1, 237, 206,  -7,  -3,  -1,
+ 236, 221,  -1, 190, 235,  -3,  -1, 205, 220,  -1, 174, 234, -15,  -7,  -3,
+  -1, 189, 219,  -1, 204, 158,  -3,  -1, 233, 173,  -1, 218, 188,  -7,  -3,
+  -1, 203, 142,  -1, 232, 157,  -3,  -1, 217, 126,  -1, 231, 172, 255,-235,
+-143, -77, -45, -25, -15,  -7,  -3,  -1, 202, 187,  -1, 141, 216,  -5,  -3,
+  -1,  14, 224,  13, 230,  -5,  -3,  -1, 110, 156, 201,  -1,  94, 186,  -9,
+  -5,  -1, 229,  -1, 171, 125,  -1, 215, 228,  -3,  -1, 140, 200,  -3,  -1,
+  78,  46,  62, -15,  -7,  -3,  -1, 109, 214,  -1, 227, 155,  -3,  -1, 185,
+ 170,  -1, 226,  30,  -7,  -3,  -1, 225,  93,  -1, 213, 124,  -3,  -1, 199,
+  77,  -1, 139, 184, -31, -15,  -7,  -3,  -1, 212, 154,  -1, 169, 108,  -3,
+  -1, 198,  61,  -1, 211,  45,  -7,  -3,  -1, 210,  29,  -1, 123, 183,  -3,
+  -1, 209,  92,  -1, 197, 138, -17,  -7,  -3,  -1, 168, 153,  -1,  76, 196,
+  -3,  -1, 107, 182,  -3,  -1, 208,  12,  60,  -7,  -3,  -1, 195, 122,  -1,
+ 167,  44,  -3,  -1, 194,  91,  -1, 181,  28, -57, -35, -19,  -7,  -3,  -1,
+ 137, 152,  -1, 193,  75,  -5,  -3,  -1, 192,  11,  59,  -3,  -1, 176,  10,
+  26,  -5,  -1, 180,  -1, 106, 166,  -3,  -1, 121, 151,  -3,  -1, 160,   9,
+ 144,  -9,  -3,  -1, 179, 136,  -3,  -1,  43,  90, 178,  -7,  -3,  -1, 165,
+  27,  -1, 177, 105,  -1, 150, 164, -17,  -9,  -5,  -3,  -1,  74, 120, 135,
+  -1,  58, 163,  -3,  -1,  89, 149,  -1,  42, 162,  -7,  -3,  -1, 161, 104,
+  -1, 134, 119,  -3,  -1,  73, 148,  -1,  57, 147, -63, -31, -15,  -7,  -3,
+  -1,  88, 133,  -1,  41, 103,  -3,  -1, 118, 146,  -1,  25, 145,  -7,  -3,
+  -1,  72, 132,  -1,  87, 117,  -3,  -1,  56, 131,  -1, 102,  40, -17,  -7,
+  -3,  -1, 130,  24,  -1,  71, 116,  -5,  -1, 129,  -1,   8, 128,  -1,  86,
+ 101,  -7,  -5,  -1,  23,  -1,   7, 112, 115,  -3,  -1,  55,  39, 114, -15,
+  -7,  -3,  -1,  70, 100,  -1,  85, 113,  -3,  -1,  54,  99,  -1,  69,  84,
+  -7,  -3,  -1,  38,  98,  -1,  22,  97,  -5,  -3,  -1,   6,  96,  53,  -1,
+  83,  68, -51, -37, -23, -15,  -9,  -3,  -1,  37,  82,  -1,  21,  -1,   5,
+  80,  -1,  81,  -1,  52,  67,  -3,  -1,  36,  66,  -1,  51,  20,  -9,  -5,
+  -1,  65,  -1,   4,  64,  -1,  35,  50,  -1,  19,  49,  -7,  -5,  -3,  -1,
+   3,  48,  34,  18,  -1,  33,  -1,   2,  32,  -3,  -1,  17,   1,  -1,  16,
+   0
+};
+
+static short tab_c0[] =
+{
+ -29, -21, -13,  -7,  -3,  -1,  11,  15,  -1,  13,  14,  -3,  -1,   7,   5,
+   9,  -3,  -1,   6,   3,  -1,  10,  12,  -3,  -1,   2,   1,  -1,   4,   8,
+   0
+};
+
+static short tab_c1[] =
+{
+ -15,  -7,  -3,  -1,  15,  14,  -1,  13,  12,  -3,  -1,  11,  10,  -1,   9,
+   8,  -7,  -3,  -1,   7,   6,  -1,   5,   4,  -3,  -1,   3,   2,  -1,   1,
+   0
+};
+
+
+
+static struct newhuff ht[] = 
+{
+ { /* 0 */ 0 , tab0  } ,
+ { /* 2 */ 0 , tab1  } ,
+ { /* 3 */ 0 , tab2  } ,
+ { /* 3 */ 0 , tab3  } ,
+ { /* 0 */ 0 , tab0  } ,
+ { /* 4 */ 0 , tab5  } ,
+ { /* 4 */ 0 , tab6  } ,
+ { /* 6 */ 0 , tab7  } ,
+ { /* 6 */ 0 , tab8  } ,
+ { /* 6 */ 0 , tab9  } ,
+ { /* 8 */ 0 , tab10 } ,
+ { /* 8 */ 0 , tab11 } ,
+ { /* 8 */ 0 , tab12 } ,
+ { /* 16 */ 0 , tab13 } ,
+ { /* 0  */ 0 , tab0  } ,
+ { /* 16 */ 0 , tab15 } ,
+
+ { /* 16 */ 1 , tab16 } ,
+ { /* 16 */ 2 , tab16 } ,
+ { /* 16 */ 3 , tab16 } ,
+ { /* 16 */ 4 , tab16 } ,
+ { /* 16 */ 6 , tab16 } ,
+ { /* 16 */ 8 , tab16 } ,
+ { /* 16 */ 10, tab16 } ,
+ { /* 16 */ 13, tab16 } ,
+ { /* 16 */ 4 , tab24 } ,
+ { /* 16 */ 5 , tab24 } ,
+ { /* 16 */ 6 , tab24 } ,
+ { /* 16 */ 7 , tab24 } ,
+ { /* 16 */ 8 , tab24 } ,
+ { /* 16 */ 9 , tab24 } ,
+ { /* 16 */ 11, tab24 } ,
+ { /* 16 */ 13, tab24 }
+};
+
+static struct newhuff htc[] = 
+{
+ { /* 1 , 1 , */ 0 , tab_c0 } ,
+ { /* 1 , 1 , */ 0 , tab_c1 }
+};
+
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/addons/mp3/interface.c asterisk-1.8.2.3.new/addons/mp3/interface.c
--- asterisk-1.8.2.3/addons/mp3/interface.c	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/addons/mp3/interface.c	2011-04-27 16:10:37.000000000 +0530
@@ -0,0 +1,323 @@
+#include "asterisk.h"
+#include "asterisk/logger.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+
+#include "mpg123.h"
+#include "mpglib.h"
+
+
+void InitMP3Constants(void)
+{
+	init_layer3_const();
+	make_decode_tables_const();
+	
+}
+
+
+BOOL InitMP3(struct mpstr *mp, long outscale) 
+{
+	/* quiet 4096 med 8192 */
+
+	memset(mp,0,sizeof(struct mpstr));
+
+	mp->framesize = 0;
+	mp->fsizeold = -1;
+	mp->bsize = 0;
+	mp->head = mp->tail = NULL;
+	mp->fr.single = 3; /* force mono */
+	mp->bsnum = 0;
+	mp->synth_bo = 1;
+	mp->outsamplerate = 8000;
+
+	make_decode_tables_scale(mp, outscale);
+
+	init_layer3_sample_limits(mp, SBLIMIT);
+
+	return !0;
+}
+
+void ExitMP3(struct mpstr *mp)
+{
+	struct buf *b,*bn;
+	
+	b = mp->tail;
+	while(b) {
+		free(b->pnt);
+		bn = b->next;
+		free(b);
+		b = bn;
+	}
+}
+
+static struct buf *addbuf(struct mpstr *mp,char *buf,int size)
+{
+	struct buf *nbuf;
+
+	nbuf = malloc( sizeof(struct buf) );
+	if(!nbuf) {
+		ast_log(LOG_WARNING,"Out of memory!\n");
+		return NULL;
+	}
+	nbuf->pnt = malloc(size);
+	if(!nbuf->pnt) {
+		free(nbuf);
+		return NULL;
+	}
+	nbuf->size = size;
+	memcpy(nbuf->pnt,buf,size);
+	nbuf->next = NULL;
+	nbuf->prev = mp->head;
+	nbuf->pos = 0;
+
+	if(!mp->tail) {
+		mp->tail = nbuf;
+	}
+	else {
+	  mp->head->next = nbuf;
+	}
+
+	mp->head = nbuf;
+	mp->bsize += size;
+
+	return nbuf;
+}
+
+static void remove_buf(struct mpstr *mp)
+{
+  struct buf *buf = mp->tail;
+  
+  mp->tail = buf->next;
+  if(mp->tail)
+    mp->tail->prev = NULL;
+  else {
+    mp->tail = mp->head = NULL;
+  }
+  
+  free(buf->pnt);
+  free(buf);
+
+}
+
+static int read_buf_byte(int *error, struct mpstr *mp)
+{
+	unsigned int b;int pos;
+
+	pos = mp->tail->pos;
+	while(pos >= mp->tail->size) {
+		remove_buf(mp);
+		pos = mp->tail->pos;
+		if(!mp->tail) {
+			/* We may pick up this error a few times*/
+			/* But things have gone pear shaped */
+			ast_log(LOG_WARNING,"Fatal Buffer error!\n");
+			*error = 1;
+			return (0);		
+		}
+	}
+
+	b = mp->tail->pnt[pos];
+	mp->bsize--;
+	mp->tail->pos++;
+	
+
+	return b;
+}
+
+static int  read_head(struct mpstr *mp)
+{
+	unsigned long head;
+	int error=0;
+	
+
+	head = read_buf_byte(&error, mp);
+	head <<= 8;
+	head |= read_buf_byte(&error, mp);
+	head <<= 8;
+	head |= read_buf_byte(&error, mp);
+	head <<= 8;
+	head |= read_buf_byte(&error, mp);
+
+	mp->header = head;
+
+	if(error){
+		return (1);
+	}else
+		return (0);
+		
+}
+
+static int head_check(unsigned long head)
+{
+    if( (head & 0xffe00000) != 0xffe00000)
+	return FALSE;
+    if(!((head>>17)&3))
+	return FALSE;
+    if( ((head>>12)&0xf) == 0xf || ((head>>12)&0xf) == 0)
+	return FALSE;
+    if( ((head>>10)&0x3) == 0x3 )
+	return FALSE;
+    if ((head & 0xffff0000) == 0xfffe0000)
+      return FALSE;
+
+    return TRUE;
+}
+
+static int head_shift(struct mpstr *mp)
+{
+	unsigned long head;
+	int error = 0;
+	
+	head = mp->header;
+	
+	head <<= 8;
+	head |= read_buf_byte(&error, mp);
+	
+	mp->header = head;
+
+	if (error){
+		return (1);
+	}else
+		return (0);
+	
+}
+
+
+int decodeMP3(struct mpstr *mp,char *in,int isize,char *out,
+		int osize,int *done)
+{
+	int len;
+	long n,m;
+	int down_sample_sblimit;
+
+	if(osize < 4608) {
+		ast_log(LOG_WARNING,"To less out space\n");
+		return MP3_ERR;
+	}
+
+	if(in) {
+		if(addbuf(mp,in,isize) == NULL) {
+			return MP3_ERR;
+		}
+	}
+
+	/* First decode header */
+	if(mp->framesize == 0) {
+		if(mp->bsize < 4) {
+			return MP3_NEED_MORE;
+		}
+		if (read_head(mp))
+			return MP3_ERR;
+		
+		if(!head_check(mp->header) ) {
+			int i;
+
+			ast_log(LOG_WARNING,"Junk at the beginning of frame %08lx\n",mp->header);
+			
+			/* step in byte steps through next 64K */
+			for(i=0;i<65536;i++) {
+				if(!mp->bsize)
+					return MP3_NEED_MORE;
+				
+				if(head_shift(mp))
+					return MP3_ERR;
+				
+				if(head_check(mp->header))
+					break;
+			}
+			if(i == 65536) {
+				ast_log(LOG_WARNING,"Giving up searching valid MPEG header\n");
+				return MP3_ERR;
+			}
+		}
+
+		decode_header(&mp->fr,mp->header);
+		mp->framesize = mp->fr.framesize;
+
+		if (!mp->initmp3){
+			mp->initmp3 = 1;
+			
+			n = freqs[mp->fr.sampling_frequency];
+			if (mp->outsamplerate) {
+				m = mp->outsamplerate;
+			}
+			else {
+				m =n;
+			}
+		
+			if (synth_ntom_set_step(n,m))
+				return MP3_ERR;
+			
+			
+			if(n>m) {
+				down_sample_sblimit = SBLIMIT * m;
+				down_sample_sblimit /= n;
+			}
+			else {
+				down_sample_sblimit = SBLIMIT;
+			}
+			
+			init_layer3_sample_limits(mp, down_sample_sblimit);
+	
+		}
+	}
+	
+
+	if(mp->fr.framesize > mp->bsize)
+		return MP3_NEED_MORE;
+
+	(mp->worksample).wordpointer = mp->bsspace[mp->bsnum] + 512;
+	mp->bsnum = (mp->bsnum + 1) & 0x1;
+	(mp->worksample).bitindex = 0;
+
+	len = 0;
+	while(len < mp->framesize) {
+		int nlen;
+		int blen = mp->tail->size - mp->tail->pos;
+		if( (mp->framesize - len) <= blen) {
+                  nlen = mp->framesize-len;
+		}
+		else {
+                  nlen = blen;
+                }
+		memcpy((mp->worksample).wordpointer+len,mp->tail->pnt+mp->tail->pos,nlen);
+                len += nlen;
+                mp->tail->pos += nlen;
+		mp->bsize -= nlen;
+                if(mp->tail->pos == mp->tail->size) {
+                   remove_buf(mp);
+                }
+	}
+
+	*done = 0;
+	if(mp->fr.error_protection)
+           getbits(mp, 16);
+	
+	if (do_layer3(mp,(unsigned char *) out,done))
+		return MP3_ERR;
+
+	mp->fsizeold = mp->framesize;
+	mp->framesize = 0;
+
+	return MP3_OK;
+}
+
+int set_pointer(struct mpstr *mp, long backstep)
+{
+  unsigned char *bsbufold;
+  if(mp->fsizeold < 0 && backstep > 0) {
+    ast_log(LOG_WARNING,"Can't step back %ld!\n",backstep);
+    return MP3_ERR;
+  }
+  bsbufold = mp->bsspace[mp->bsnum] + 512;
+  (mp->worksample).wordpointer -= backstep;
+  if (backstep)
+    memcpy((mp->worksample).wordpointer,bsbufold+mp->fsizeold-backstep,backstep);
+  (mp->worksample).bitindex = 0;
+  return MP3_OK;
+}
+
+
+
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/addons/mp3/layer3.c asterisk-1.8.2.3.new/addons/mp3/layer3.c
--- asterisk-1.8.2.3/addons/mp3/layer3.c	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/addons/mp3/layer3.c	2011-04-27 16:10:38.000000000 +0530
@@ -0,0 +1,2029 @@
+/* 
+ * Mpeg Layer-3 audio decoder 
+ * --------------------------
+ * copyright (c) 1995,1996,1997 by Michael Hipp.
+ * All rights reserved. See also 'README'
+ */ 
+
+#include "asterisk.h"
+#include "asterisk/logger.h"
+#include <stdlib.h>
+#include "mpg123.h"
+#include "mpglib.h"
+#include "huffman.h"
+
+#define MPEG1
+
+/* These should all be constants setup once using init_layer3_const */
+static real ispow[8207];
+static real aa_ca[8],aa_cs[8];
+static real COS1[12][6];
+static real win[4][36];
+static real win1[4][36];
+static real gainpow2[256+118+4];
+static real COS9[9];
+static real COS6_1,COS6_2;
+static real tfcos36[9];
+static real tfcos12[3];
+
+struct bandInfoStruct {
+  short longIdx[23];
+  short longDiff[22];
+  short shortIdx[14];
+  short shortDiff[13];
+};
+
+
+struct bandInfoStruct bandInfo[9] = { 
+
+/* MPEG 1.0 */
+ { {0,4,8,12,16,20,24,30,36,44,52,62,74, 90,110,134,162,196,238,288,342,418,576},
+   {4,4,4,4,4,4,6,6,8, 8,10,12,16,20,24,28,34,42,50,54, 76,158},
+   {0,4*3,8*3,12*3,16*3,22*3,30*3,40*3,52*3,66*3, 84*3,106*3,136*3,192*3},
+   {4,4,4,4,6,8,10,12,14,18,22,30,56} } ,
+
+ { {0,4,8,12,16,20,24,30,36,42,50,60,72, 88,106,128,156,190,230,276,330,384,576},
+   {4,4,4,4,4,4,6,6,6, 8,10,12,16,18,22,28,34,40,46,54, 54,192},
+   {0,4*3,8*3,12*3,16*3,22*3,28*3,38*3,50*3,64*3, 80*3,100*3,126*3,192*3},
+   {4,4,4,4,6,6,10,12,14,16,20,26,66} } ,
+
+ { {0,4,8,12,16,20,24,30,36,44,54,66,82,102,126,156,194,240,296,364,448,550,576} ,
+   {4,4,4,4,4,4,6,6,8,10,12,16,20,24,30,38,46,56,68,84,102, 26} ,
+   {0,4*3,8*3,12*3,16*3,22*3,30*3,42*3,58*3,78*3,104*3,138*3,180*3,192*3} ,
+   {4,4,4,4,6,8,12,16,20,26,34,42,12} }  ,
+
+/* MPEG 2.0 */
+ { {0,6,12,18,24,30,36,44,54,66,80,96,116,140,168,200,238,284,336,396,464,522,576},
+   {6,6,6,6,6,6,8,10,12,14,16,20,24,28,32,38,46,52,60,68,58,54 } ,
+   {0,4*3,8*3,12*3,18*3,24*3,32*3,42*3,56*3,74*3,100*3,132*3,174*3,192*3} ,
+   {4,4,4,6,6,8,10,14,18,26,32,42,18 } } ,
+
+ { {0,6,12,18,24,30,36,44,54,66,80,96,114,136,162,194,232,278,330,394,464,540,576},
+   {6,6,6,6,6,6,8,10,12,14,16,18,22,26,32,38,46,52,64,70,76,36 } ,
+   {0,4*3,8*3,12*3,18*3,26*3,36*3,48*3,62*3,80*3,104*3,136*3,180*3,192*3} ,
+   {4,4,4,6,8,10,12,14,18,24,32,44,12 } } ,
+
+ { {0,6,12,18,24,30,36,44,54,66,80,96,116,140,168,200,238,284,336,396,464,522,576},
+   {6,6,6,6,6,6,8,10,12,14,16,20,24,28,32,38,46,52,60,68,58,54 },
+   {0,4*3,8*3,12*3,18*3,26*3,36*3,48*3,62*3,80*3,104*3,134*3,174*3,192*3},
+   {4,4,4,6,8,10,12,14,18,24,30,40,18 } } ,
+/* MPEG 2.5 */
+ { {0,6,12,18,24,30,36,44,54,66,80,96,116,140,168,200,238,284,336,396,464,522,576} ,
+   {6,6,6,6,6,6,8,10,12,14,16,20,24,28,32,38,46,52,60,68,58,54},
+   {0,12,24,36,54,78,108,144,186,240,312,402,522,576},
+   {4,4,4,6,8,10,12,14,18,24,30,40,18} },
+ { {0,6,12,18,24,30,36,44,54,66,80,96,116,140,168,200,238,284,336,396,464,522,576} ,
+   {6,6,6,6,6,6,8,10,12,14,16,20,24,28,32,38,46,52,60,68,58,54},
+   {0,12,24,36,54,78,108,144,186,240,312,402,522,576},
+   {4,4,4,6,8,10,12,14,18,24,30,40,18} },
+ { {0,12,24,36,48,60,72,88,108,132,160,192,232,280,336,400,476,566,568,570,572,574,576},
+   {12,12,12,12,12,12,16,20,24,28,32,40,48,56,64,76,90,2,2,2,2,2},
+   {0, 24, 48, 72,108,156,216,288,372,480,486,492,498,576},
+   {8,8,8,12,16,20,24,28,36,2,2,2,26} } ,
+};
+
+static int mapbuf0[9][152];
+static int mapbuf1[9][156];
+static int mapbuf2[9][44];
+static int *map[9][3];
+static int *mapend[9][3];
+
+static unsigned int n_slen2[512]; /* MPEG 2.0 slen for 'normal' mode */
+static unsigned int i_slen2[256]; /* MPEG 2.0 slen for intensity stereo */
+
+static real tan1_1[16],tan2_1[16],tan1_2[16],tan2_2[16];
+static real pow1_1[2][16],pow2_1[2][16],pow1_2[2][16],pow2_2[2][16];
+
+/* 
+ * init constant tables for layer-3 
+ */
+void init_layer3_const(void)
+{
+  int i,j,k,l;
+
+  for(i=-256;i<118+4;i++)
+    gainpow2[i+256] = pow((double)2.0,-0.25 * (double) (i+210) );
+
+  for(i=0;i<8207;i++)
+    ispow[i] = pow((double)i,(double)4.0/3.0);
+
+  for (i=0;i<8;i++)
+  {
+    static double Ci[8]={-0.6,-0.535,-0.33,-0.185,-0.095,-0.041,-0.0142,-0.0037};
+    double sq=sqrt(1.0+Ci[i]*Ci[i]);
+    aa_cs[i] = 1.0/sq;
+    aa_ca[i] = Ci[i]/sq;
+  }
+
+  for(i=0;i<18;i++)
+  {
+    win[0][i]    = win[1][i]    = 0.5 * sin( M_PI / 72.0 * (double) (2*(i+0) +1) ) / cos ( M_PI * (double) (2*(i+0) +19) / 72.0 );
+    win[0][i+18] = win[3][i+18] = 0.5 * sin( M_PI / 72.0 * (double) (2*(i+18)+1) ) / cos ( M_PI * (double) (2*(i+18)+19) / 72.0 );
+  }
+  for(i=0;i<6;i++)
+  {
+    win[1][i+18] = 0.5 / cos ( M_PI * (double) (2*(i+18)+19) / 72.0 );
+    win[3][i+12] = 0.5 / cos ( M_PI * (double) (2*(i+12)+19) / 72.0 );
+    win[1][i+24] = 0.5 * sin( M_PI / 24.0 * (double) (2*i+13) ) / cos ( M_PI * (double) (2*(i+24)+19) / 72.0 );
+    win[1][i+30] = win[3][i] = 0.0;
+    win[3][i+6 ] = 0.5 * sin( M_PI / 24.0 * (double) (2*i+1) )  / cos ( M_PI * (double) (2*(i+6 )+19) / 72.0 );
+  }
+
+  for(i=0;i<9;i++)
+    COS9[i] = cos( M_PI / 18.0 * (double) i);
+
+  for(i=0;i<9;i++)
+    tfcos36[i] = 0.5 / cos ( M_PI * (double) (i*2+1) / 36.0 );
+  for(i=0;i<3;i++)
+    tfcos12[i] = 0.5 / cos ( M_PI * (double) (i*2+1) / 12.0 );
+
+  COS6_1 = cos( M_PI / 6.0 * (double) 1);
+  COS6_2 = cos( M_PI / 6.0 * (double) 2);
+
+  for(i=0;i<12;i++)
+  {
+    win[2][i]  = 0.5 * sin( M_PI / 24.0 * (double) (2*i+1) ) / cos ( M_PI * (double) (2*i+7) / 24.0 );
+    for(j=0;j<6;j++)
+      COS1[i][j] = cos( M_PI / 24.0 * (double) ((2*i+7)*(2*j+1)) );
+  }
+
+  for(j=0;j<4;j++) {
+    static int len[4] = { 36,36,12,36 };
+    for(i=0;i<len[j];i+=2)
+      win1[j][i] = + win[j][i];
+    for(i=1;i<len[j];i+=2)
+      win1[j][i] = - win[j][i];
+  }
+
+  for(i=0;i<16;i++)
+  {
+    double t = tan( (double) i * M_PI / 12.0 );
+    tan1_1[i] = t / (1.0+t);
+    tan2_1[i] = 1.0 / (1.0 + t);
+    tan1_2[i] = M_SQRT2 * t / (1.0+t);
+    tan2_2[i] = M_SQRT2 / (1.0 + t);
+
+    for(j=0;j<2;j++) {
+      double base = pow(2.0,-0.25*(j+1.0));
+      double p1=1.0,p2=1.0;
+      if(i > 0) {
+        if( i & 1 )
+          p1 = pow(base,(i+1.0)*0.5);
+        else
+          p2 = pow(base,i*0.5);
+      }
+      pow1_1[j][i] = p1;
+      pow2_1[j][i] = p2;
+      pow1_2[j][i] = M_SQRT2 * p1;
+      pow2_2[j][i] = M_SQRT2 * p2;
+    }
+  }
+
+  for(j=0;j<9;j++)
+  {
+   struct bandInfoStruct *bi = &bandInfo[j];
+   int *mp;
+   int cb,lwin;
+   short *bdf;
+
+   mp = map[j][0] = mapbuf0[j];
+   bdf = bi->longDiff;
+   for(i=0,cb = 0; cb < 8 ; cb++,i+=*bdf++) {
+     *mp++ = (*bdf) >> 1;
+     *mp++ = i;
+     *mp++ = 3;
+     *mp++ = cb;
+   }
+   bdf = bi->shortDiff+3;
+   for(cb=3;cb<13;cb++) {
+     int l = (*bdf++) >> 1;
+     for(lwin=0;lwin<3;lwin++) {
+       *mp++ = l;
+       *mp++ = i + lwin;
+       *mp++ = lwin;
+       *mp++ = cb;
+     }
+     i += 6*l;
+   }
+   mapend[j][0] = mp;
+
+   mp = map[j][1] = mapbuf1[j];
+   bdf = bi->shortDiff+0;
+   for(i=0,cb=0;cb<13;cb++) {
+     int l = (*bdf++) >> 1;
+     for(lwin=0;lwin<3;lwin++) {
+       *mp++ = l;
+       *mp++ = i + lwin;
+       *mp++ = lwin;
+       *mp++ = cb;
+     }
+     i += 6*l;
+   }
+   mapend[j][1] = mp;
+
+   mp = map[j][2] = mapbuf2[j];
+   bdf = bi->longDiff;
+   for(cb = 0; cb < 22 ; cb++) {
+     *mp++ = (*bdf++) >> 1;
+     *mp++ = cb;
+   }
+   mapend[j][2] = mp;
+
+  }
+
+  for(i=0;i<5;i++) {
+    for(j=0;j<6;j++) {
+      for(k=0;k<6;k++) {
+        int n = k + j * 6 + i * 36;
+        i_slen2[n] = i|(j<<3)|(k<<6)|(3<<12);
+      }
+    }
+  }
+  for(i=0;i<4;i++) {
+    for(j=0;j<4;j++) {
+      for(k=0;k<4;k++) {
+        int n = k + j * 4 + i * 16;
+        i_slen2[n+180] = i|(j<<3)|(k<<6)|(4<<12);
+      }
+    }
+  }
+  for(i=0;i<4;i++) {
+    for(j=0;j<3;j++) {
+      int n = j + i * 3;
+      i_slen2[n+244] = i|(j<<3) | (5<<12);
+      n_slen2[n+500] = i|(j<<3) | (2<<12) | (1<<15);
+    }
+  }
+
+  for(i=0;i<5;i++) {
+    for(j=0;j<5;j++) {
+      for(k=0;k<4;k++) {
+        for(l=0;l<4;l++) {
+          int n = l + k * 4 + j * 16 + i * 80;
+          n_slen2[n] = i|(j<<3)|(k<<6)|(l<<9)|(0<<12);
+        }
+      }
+    }
+  }
+  for(i=0;i<5;i++) {
+    for(j=0;j<5;j++) {
+      for(k=0;k<4;k++) {
+        int n = k + j * 4 + i * 20;
+        n_slen2[n+400] = i|(j<<3)|(k<<6)|(1<<12);
+      }
+    }
+  }
+}
+
+/* MP3 file specific rates */
+void init_layer3_sample_limits(struct mpstr *mp, int down_sample_sblimit)
+{
+	int i,j;	
+	for(j=0;j<9;j++) {
+		for(i=0;i<23;i++) {
+			(mp->longLimit)[j][i] = (bandInfo[j].longIdx[i] - 1 + 8) / 18 + 1;
+			if((mp->longLimit)[j][i] > (down_sample_sblimit) )
+				(mp->longLimit)[j][i] = down_sample_sblimit;
+		}
+		for(i=0;i<14;i++) {
+			(mp->shortLimit)[j][i] = (bandInfo[j].shortIdx[i] - 1) / 18 + 1;
+			if((mp->shortLimit)[j][i] > (down_sample_sblimit) )
+				(mp->shortLimit)[j][i] = down_sample_sblimit;
+		}
+	}
+}
+
+
+
+/*
+ * read additional side information
+ */
+#ifdef MPEG1 
+static int III_get_side_info_1(struct mpstr *mp, struct III_sideinfo *si,int stereo,
+ int ms_stereo,long sfreq,int single)
+{
+   int ch, gr;
+   int powdiff = (single == 3) ? 4 : 0;
+
+   si->main_data_begin = getbits(mp, 9);
+   if (stereo == 1)
+     si->private_bits = getbits_fast(mp, 5);
+   else 
+     si->private_bits = getbits_fast(mp, 3);
+
+   for (ch=0; ch<stereo; ch++) {
+       si->ch[ch].gr[0].scfsi = -1;
+       si->ch[ch].gr[1].scfsi = getbits_fast(mp, 4);
+   }
+
+   for (gr=0; gr<2; gr++) 
+   {
+     for (ch=0; ch<stereo; ch++) 
+     {
+       register struct gr_info_s *gr_info = &(si->ch[ch].gr[gr]);
+
+       gr_info->part2_3_length = getbits(mp, 12);
+       gr_info->big_values = getbits_fast(mp, 9);
+       if(gr_info->big_values > 288) {
+          ast_log(LOG_WARNING,"big_values too large!\n");
+          gr_info->big_values = 288;
+       }
+       gr_info->pow2gain = gainpow2+256 - getbits_fast(mp, 8) + powdiff;
+       if(ms_stereo)
+         gr_info->pow2gain += 2;
+       gr_info->scalefac_compress = getbits_fast(mp, 4);
+/* window-switching flag == 1 for block_Type != 0 .. and block-type == 0 -> win-sw-flag = 0 */
+       if(get1bit(mp)) 
+       {
+         int i;
+         gr_info->block_type = getbits_fast(mp, 2);
+         gr_info->mixed_block_flag = get1bit(mp);
+         gr_info->table_select[0] = getbits_fast(mp, 5);
+         gr_info->table_select[1] = getbits_fast(mp, 5);
+         /*
+          * table_select[2] not needed, because there is no region2,
+          * but to satisfy some verifications tools we set it either.
+          */
+         gr_info->table_select[2] = 0;
+         for(i=0;i<3;i++)
+           gr_info->full_gain[i] = gr_info->pow2gain + (getbits_fast(mp, 3)<<3);
+
+         if(gr_info->block_type == 0) {
+           ast_log(LOG_WARNING,"Blocktype == 0 and window-switching == 1 not allowed.\n");
+           return (1);
+         }
+         /* region_count/start parameters are implicit in this case. */       
+         gr_info->region1start = 36>>1;
+         gr_info->region2start = 576>>1;
+       }
+       else 
+       {
+         int i,r0c,r1c;
+         for (i=0; i<3; i++)
+           gr_info->table_select[i] = getbits_fast(mp, 5);
+         r0c = getbits_fast(mp, 4);
+         r1c = getbits_fast(mp, 3);
+         gr_info->region1start = bandInfo[sfreq].longIdx[r0c+1] >> 1 ;
+         gr_info->region2start = bandInfo[sfreq].longIdx[r0c+1+r1c+1] >> 1;
+         gr_info->block_type = 0;
+         gr_info->mixed_block_flag = 0;
+       }
+       gr_info->preflag = get1bit(mp);
+       gr_info->scalefac_scale = get1bit(mp);
+       gr_info->count1table_select = get1bit(mp);
+     }
+   }
+   return (0);
+   
+}
+#endif
+
+/*
+ * Side Info for MPEG 2.0 / LSF
+ */
+static int III_get_side_info_2(struct mpstr *mp, struct III_sideinfo *si,int stereo,
+ int ms_stereo,long sfreq,int single)
+{
+   int ch;
+   int powdiff = (single == 3) ? 4 : 0;
+
+   si->main_data_begin = getbits(mp, 8);
+   if (stereo == 1)
+     si->private_bits = get1bit(mp);
+   else 
+     si->private_bits = getbits_fast(mp, 2);
+
+   for (ch=0; ch<stereo; ch++) 
+   {
+       register struct gr_info_s *gr_info = &(si->ch[ch].gr[0]);
+
+       gr_info->part2_3_length = getbits(mp, 12);
+       gr_info->big_values = getbits_fast(mp, 9);
+       if(gr_info->big_values > 288) {
+         ast_log(LOG_WARNING,"big_values too large!\n");
+         gr_info->big_values = 288;
+       }
+       gr_info->pow2gain = gainpow2+256 - getbits_fast(mp, 8) + powdiff;
+       if(ms_stereo)
+         gr_info->pow2gain += 2;
+       gr_info->scalefac_compress = getbits(mp, 9);
+/* window-switching flag == 1 for block_Type != 0 .. and block-type == 0 -> win-sw-flag = 0 */
+       if(get1bit(mp)) 
+       {
+         int i;
+         gr_info->block_type = getbits_fast(mp, 2);
+         gr_info->mixed_block_flag = get1bit(mp);
+         gr_info->table_select[0] = getbits_fast(mp, 5);
+         gr_info->table_select[1] = getbits_fast(mp, 5);
+         /*
+          * table_select[2] not needed, because there is no region2,
+          * but to satisfy some verifications tools we set it either.
+          */
+         gr_info->table_select[2] = 0;
+         for(i=0;i<3;i++)
+           gr_info->full_gain[i] = gr_info->pow2gain + (getbits_fast(mp, 3)<<3);
+
+         if(gr_info->block_type == 0) {
+           ast_log(LOG_WARNING,"Blocktype == 0 and window-switching == 1 not allowed.\n");
+           return (1);
+         }
+         /* region_count/start parameters are implicit in this case. */       
+/* check this again! */
+         if(gr_info->block_type == 2)
+           gr_info->region1start = 36>>1;
+         else if(sfreq == 8)
+/* check this for 2.5 and sfreq=8 */
+           gr_info->region1start = 108>>1;
+         else
+           gr_info->region1start = 54>>1;
+         gr_info->region2start = 576>>1;
+       }
+       else 
+       {
+         int i,r0c,r1c;
+         for (i=0; i<3; i++)
+           gr_info->table_select[i] = getbits_fast(mp, 5);
+         r0c = getbits_fast(mp, 4);
+         r1c = getbits_fast(mp, 3);
+         gr_info->region1start = bandInfo[sfreq].longIdx[r0c+1] >> 1 ;
+         gr_info->region2start = bandInfo[sfreq].longIdx[r0c+1+r1c+1] >> 1;
+         gr_info->block_type = 0;
+         gr_info->mixed_block_flag = 0;
+       }
+       gr_info->scalefac_scale = get1bit(mp);
+       gr_info->count1table_select = get1bit(mp);
+   }
+   return (0);
+}
+
+/*
+ * read scalefactors
+ */
+#ifdef MPEG1
+static int III_get_scale_factors_1(struct mpstr *mp, int *scf,struct gr_info_s *gr_info)
+{
+   static unsigned char slen[2][16] = {
+     {0, 0, 0, 0, 3, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4},
+     {0, 1, 2, 3, 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 2, 3}
+   };
+   int numbits;
+   int num0 = slen[0][gr_info->scalefac_compress];
+   int num1 = slen[1][gr_info->scalefac_compress];
+
+    if (gr_info->block_type == 2) 
+    {
+      int i=18;
+      numbits = (num0 + num1) * 18;
+
+      if (gr_info->mixed_block_flag) {
+         for (i=8;i;i--)
+           *scf++ = getbits_fast(mp, num0);
+         i = 9;
+         numbits -= num0; /* num0 * 17 + num1 * 18 */
+      }
+
+      for (;i;i--)
+        *scf++ = getbits_fast(mp, num0);
+      for (i = 18; i; i--)
+        *scf++ = getbits_fast(mp, num1);
+      *scf++ = 0; *scf++ = 0; *scf++ = 0; /* short[13][0..2] = 0 */
+    }
+    else 
+    {
+      int i;
+      int scfsi = gr_info->scfsi;
+
+      if(scfsi < 0) { /* scfsi < 0 => granule == 0 */
+         for(i=11;i;i--)
+           *scf++ = getbits_fast(mp, num0);
+         for(i=10;i;i--)
+           *scf++ = getbits_fast(mp, num1);
+         numbits = (num0 + num1) * 10 + num0;
+      }
+      else {
+        numbits = 0;
+        if(!(scfsi & 0x8)) {
+          for (i=6;i;i--)
+            *scf++ = getbits_fast(mp, num0);
+          numbits += num0 * 6;
+        }
+        else {
+          *scf++ = 0; *scf++ = 0; *scf++ = 0;  /* set to ZERO necessary? */
+          *scf++ = 0; *scf++ = 0; *scf++ = 0;
+        }
+
+        if(!(scfsi & 0x4)) {
+          for (i=5;i;i--)
+            *scf++ = getbits_fast(mp, num0);
+          numbits += num0 * 5;
+        }
+        else {
+          *scf++ = 0; *scf++ = 0; *scf++ = 0;  /* set to ZERO necessary? */
+          *scf++ = 0; *scf++ = 0;
+        }
+
+        if(!(scfsi & 0x2)) {
+          for(i=5;i;i--)
+            *scf++ = getbits_fast(mp, num1);
+          numbits += num1 * 5;
+        }
+        else {
+          *scf++ = 0; *scf++ = 0; *scf++ = 0;  /* set to ZERO necessary? */
+          *scf++ = 0; *scf++ = 0;
+        }
+
+        if(!(scfsi & 0x1)) {
+          for (i=5;i;i--)
+            *scf++ = getbits_fast(mp, num1);
+          numbits += num1 * 5;
+        }
+        else {
+          *scf++ = 0; *scf++ = 0; *scf++ = 0;  /* set to ZERO necessary? */
+          *scf++ = 0; *scf++ = 0;
+        }
+      }
+
+      *scf++ = 0;  /* no l[21] in original sources */
+    }
+    return numbits;
+}
+#endif
+
+static int III_get_scale_factors_2(struct mpstr *mp, int *scf,struct gr_info_s *gr_info,int i_stereo)
+{
+  unsigned char *pnt;
+  int i,j;
+  unsigned int slen;
+  int n = 0;
+  int numbits = 0;
+
+  static unsigned char stab[3][6][4] = {
+   { { 6, 5, 5,5 } , { 6, 5, 7,3 } , { 11,10,0,0} ,
+     { 7, 7, 7,0 } , { 6, 6, 6,3 } , {  8, 8,5,0} } ,
+   { { 9, 9, 9,9 } , { 9, 9,12,6 } , { 18,18,0,0} ,
+     {12,12,12,0 } , {12, 9, 9,6 } , { 15,12,9,0} } ,
+   { { 6, 9, 9,9 } , { 6, 9,12,6 } , { 15,18,0,0} ,
+     { 6,15,12,0 } , { 6,12, 9,6 } , {  6,18,9,0} } }; 
+
+  if(i_stereo) /* i_stereo AND second channel -> do_layer3() checks this */
+    slen = i_slen2[gr_info->scalefac_compress>>1];
+  else
+    slen = n_slen2[gr_info->scalefac_compress];
+
+  gr_info->preflag = (slen>>15) & 0x1;
+
+  n = 0;  
+  if( gr_info->block_type == 2 ) {
+    n++;
+    if(gr_info->mixed_block_flag)
+      n++;
+  }
+
+  pnt = stab[n][(slen>>12)&0x7];
+
+  for(i=0;i<4;i++) {
+    int num = slen & 0x7;
+    slen >>= 3;
+    if(num) {
+      for(j=0;j<(int)(pnt[i]);j++)
+        *scf++ = getbits_fast(mp, num);
+      numbits += pnt[i] * num;
+    }
+    else {
+      for(j=0;j<(int)(pnt[i]);j++)
+        *scf++ = 0;
+    }
+  }
+  
+  n = (n << 1) + 1;
+  for(i=0;i<n;i++)
+    *scf++ = 0;
+
+  return numbits;
+}
+
+static int pretab1[22] = {0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,2,2,3,3,3,2,0};
+static int pretab2[22] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+
+/*
+ * don't forget to apply the same changes to III_dequantize_sample_ms() !!! 
+ */
+static int III_dequantize_sample(struct mpstr *mp, real xr[SBLIMIT][SSLIMIT],int *scf,
+   struct gr_info_s *gr_info,int sfreq,int part2bits)
+{
+  int shift = 1 + gr_info->scalefac_scale;
+  real *xrpnt = (real *) xr;
+  int l[3],l3;
+  int part2remain = gr_info->part2_3_length - part2bits;
+  int *me;
+
+  {
+    int bv       = gr_info->big_values;
+    int region1  = gr_info->region1start;
+    int region2  = gr_info->region2start;
+
+    l3 = ((576>>1)-bv)>>1;   
+/*
+ * we may lose the 'odd' bit here !! 
+ * check this later again 
+ */
+    if(bv <= region1) {
+      l[0] = bv; l[1] = 0; l[2] = 0;
+    }
+    else {
+      l[0] = region1;
+      if(bv <= region2) {
+        l[1] = bv - l[0];  l[2] = 0;
+      }
+      else {
+        l[1] = region2 - l[0]; l[2] = bv - region2;
+      }
+    }
+  }
+ 
+  if(gr_info->block_type == 2) {
+    /*
+     * decoding with short or mixed mode BandIndex table 
+     */
+    int i,max[4];
+    int step=0,lwin=0,cb=0;
+    register real v = 0.0;
+    register int *m,mc;
+
+    if(gr_info->mixed_block_flag) {
+      max[3] = -1;
+      max[0] = max[1] = max[2] = 2;
+      m = map[sfreq][0];
+      me = mapend[sfreq][0];
+    }
+    else {
+      max[0] = max[1] = max[2] = max[3] = -1;
+      /* max[3] not really needed in this case */
+      m = map[sfreq][1];
+      me = mapend[sfreq][1];
+    }
+
+    mc = 0;
+    for(i=0;i<2;i++) {
+      int lp = l[i];
+      struct newhuff *h = ht+gr_info->table_select[i];
+      for(;lp;lp--,mc--) {
+        register int x,y;
+        if( (!mc) ) {
+          mc = *m++;
+          xrpnt = ((real *) xr) + (*m++);
+          lwin = *m++;
+          cb = *m++;
+          if(lwin == 3) {
+            v = gr_info->pow2gain[(*scf++) << shift];
+            step = 1;
+          }
+          else {
+            v = gr_info->full_gain[lwin][(*scf++) << shift];
+            step = 3;
+          }
+        }
+        {
+          register short *val = h->table;
+          while((y=*val++)<0) {
+            if (get1bit(mp))
+              val -= y;
+            part2remain--;
+          }
+          x = y >> 4;
+          y &= 0xf;
+        }
+        if(x == 15) {
+          max[lwin] = cb;
+          part2remain -= h->linbits+1;
+          x += getbits(mp, h->linbits);
+          if(get1bit(mp))
+            *xrpnt = -ispow[x] * v;
+          else
+            *xrpnt =  ispow[x] * v;
+        }
+        else if(x) {
+          max[lwin] = cb;
+          if(get1bit(mp))
+            *xrpnt = -ispow[x] * v;
+          else
+            *xrpnt =  ispow[x] * v;
+          part2remain--;
+        }
+        else
+          *xrpnt = 0.0;
+        xrpnt += step;
+        if(y == 15) {
+          max[lwin] = cb;
+          part2remain -= h->linbits+1;
+          y += getbits(mp, h->linbits);
+          if(get1bit(mp))
+            *xrpnt = -ispow[y] * v;
+          else
+            *xrpnt =  ispow[y] * v;
+        }
+        else if(y) {
+          max[lwin] = cb;
+          if(get1bit(mp))
+            *xrpnt = -ispow[y] * v;
+          else
+            *xrpnt =  ispow[y] * v;
+          part2remain--;
+        }
+        else
+          *xrpnt = 0.0;
+        xrpnt += step;
+      }
+    }
+    for(;l3 && (part2remain > 0);l3--) {
+      struct newhuff *h = htc+gr_info->count1table_select;
+      register short *val = h->table,a;
+
+      while((a=*val++)<0) {
+        part2remain--;
+        if(part2remain < 0) {
+          part2remain++;
+          a = 0;
+          break;
+        }
+        if (get1bit(mp))
+          val -= a;
+      }
+
+      for(i=0;i<4;i++) {
+        if(!(i & 1)) {
+          if(!mc) {
+            mc = *m++;
+            xrpnt = ((real *) xr) + (*m++);
+            lwin = *m++;
+            cb = *m++;
+            if(lwin == 3) {
+              v = gr_info->pow2gain[(*scf++) << shift];
+              step = 1;
+            }
+            else {
+              v = gr_info->full_gain[lwin][(*scf++) << shift];
+              step = 3;
+            }
+          }
+          mc--;
+        }
+        if( (a & (0x8>>i)) ) {
+          max[lwin] = cb;
+          part2remain--;
+          if(part2remain < 0) {
+            part2remain++;
+            break;
+          }
+          if(get1bit(mp)) 
+            *xrpnt = -v;
+          else
+            *xrpnt = v;
+        }
+        else
+          *xrpnt = 0.0;
+        xrpnt += step;
+      }
+    }
+ 
+    while( m < me ) {
+      if(!mc) {
+        mc = *m++;
+        xrpnt = ((real *) xr) + *m++;
+        if( (*m++) == 3)
+          step = 1;
+        else
+          step = 3;
+        m++; /* cb */
+      }
+      mc--;
+      *xrpnt = 0.0;
+      xrpnt += step;
+      *xrpnt = 0.0;
+      xrpnt += step;
+/* we could add a little opt. here:
+ * if we finished a band for window 3 or a long band
+ * further bands could copied in a simple loop without a
+ * special 'map' decoding
+ */
+    }
+
+    gr_info->maxband[0] = max[0]+1;
+    gr_info->maxband[1] = max[1]+1;
+    gr_info->maxband[2] = max[2]+1;
+    gr_info->maxbandl = max[3]+1;
+
+    {
+      int rmax = max[0] > max[1] ? max[0] : max[1];
+      rmax = (rmax > max[2] ? rmax : max[2]) + 1;
+      gr_info->maxb = rmax ? (mp->shortLimit)[sfreq][rmax] : (mp->longLimit)[sfreq][max[3]+1];
+    }
+
+  }
+  else {
+	/*
+     * decoding with 'long' BandIndex table (block_type != 2)
+     */
+    int *pretab = gr_info->preflag ? pretab1 : pretab2;
+    int i,max = -1;
+    int cb = 0;
+    register int *m = map[sfreq][2];
+    register real v = 0.0;
+    register int mc = 0;
+#if 0
+    me = mapend[sfreq][2];
+#endif
+
+	/*
+     * long hash table values
+     */
+    for(i=0;i<3;i++) {
+      int lp = l[i];
+      struct newhuff *h = ht+gr_info->table_select[i];
+
+      for(;lp;lp--,mc--) {
+        int x,y;
+
+        if(!mc) {
+          mc = *m++;
+          v = gr_info->pow2gain[((*scf++) + (*pretab++)) << shift];
+          cb = *m++;
+        }
+        {
+          register short *val = h->table;
+          while((y=*val++)<0) {
+            if (get1bit(mp))
+              val -= y;
+            part2remain--;
+          }
+          x = y >> 4;
+          y &= 0xf;
+        }
+        if (x == 15) {
+          max = cb;
+          part2remain -= h->linbits+1;
+          x += getbits(mp, h->linbits);
+          if(get1bit(mp))
+            *xrpnt++ = -ispow[x] * v;
+          else
+            *xrpnt++ =  ispow[x] * v;
+        }
+        else if(x) {
+          max = cb;
+          if(get1bit(mp))
+            *xrpnt++ = -ispow[x] * v;
+          else
+            *xrpnt++ =  ispow[x] * v;
+          part2remain--;
+        }
+        else
+          *xrpnt++ = 0.0;
+
+        if (y == 15) {
+          max = cb;
+          part2remain -= h->linbits+1;
+          y += getbits(mp, h->linbits);
+          if(get1bit(mp))
+            *xrpnt++ = -ispow[y] * v;
+          else
+            *xrpnt++ =  ispow[y] * v;
+        }
+        else if(y) {
+          max = cb;
+          if(get1bit(mp))
+            *xrpnt++ = -ispow[y] * v;
+          else
+            *xrpnt++ =  ispow[y] * v;
+          part2remain--;
+        }
+        else
+          *xrpnt++ = 0.0;
+      }
+    }
+
+	/*
+     * short (count1table) values
+     */
+    for(;l3 && (part2remain > 0);l3--) {
+      struct newhuff *h = htc+gr_info->count1table_select;
+      register short *val = h->table,a;
+
+      while((a=*val++)<0) {
+        part2remain--;
+        if(part2remain < 0) {
+          part2remain++;
+          a = 0;
+          break;
+        }
+        if (get1bit(mp))
+          val -= a;
+      }
+
+      for(i=0;i<4;i++) {
+        if(!(i & 1)) {
+          if(!mc) {
+            mc = *m++;
+            cb = *m++;
+            v = gr_info->pow2gain[((*scf++) + (*pretab++)) << shift];
+          }
+          mc--;
+        }
+        if ( (a & (0x8>>i)) ) {
+          max = cb;
+          part2remain--;
+          if(part2remain < 0) {
+            part2remain++;
+            break;
+          }
+          if(get1bit(mp))
+            *xrpnt++ = -v;
+          else
+            *xrpnt++ = v;
+        }
+        else
+          *xrpnt++ = 0.0;
+      }
+    }
+
+	/* 
+     * zero part
+     */
+    for(i=(&xr[SBLIMIT][0]-xrpnt)>>1;i;i--) {
+      *xrpnt++ = 0.0;
+      *xrpnt++ = 0.0;
+    }
+
+    gr_info->maxbandl = max+1;
+    gr_info->maxb = (mp->longLimit)[sfreq][gr_info->maxbandl];
+  }
+
+  while( part2remain > 16 ) {
+    getbits(mp, 16); /* Dismiss stuffing Bits */
+    part2remain -= 16;
+  }
+  if(part2remain > 0)
+    getbits(mp, part2remain);
+  else if(part2remain < 0) {
+    ast_log(LOG_WARNING,"mpg123: Can't rewind stream by %d bits!\n",-part2remain);
+    return 1; /* -> error */
+  }
+  return 0;
+}
+
+#if 0
+static int III_dequantize_sample_ms(real xr[2][SBLIMIT][SSLIMIT],int *scf,
+   struct gr_info_s *gr_info,int sfreq,int part2bits)
+{
+  int shift = 1 + gr_info->scalefac_scale;
+  real *xrpnt = (real *) xr[1];
+  real *xr0pnt = (real *) xr[0];
+  int l[3],l3;
+  int part2remain = gr_info->part2_3_length - part2bits;
+  int *me;
+
+  {
+    int bv       = gr_info->big_values;
+    int region1  = gr_info->region1start;
+    int region2  = gr_info->region2start;
+
+    l3 = ((576>>1)-bv)>>1;   
+/*
+ * we may lose the 'odd' bit here !! 
+ * check this later gain 
+ */
+    if(bv <= region1) {
+      l[0] = bv; l[1] = 0; l[2] = 0;
+    }
+    else {
+      l[0] = region1;
+      if(bv <= region2) {
+        l[1] = bv - l[0];  l[2] = 0;
+      }
+      else {
+        l[1] = region2 - l[0]; l[2] = bv - region2;
+      }
+    }
+  }
+ 
+  if(gr_info->block_type == 2) {
+    int i,max[4];
+    int step=0,lwin=0,cb=0;
+    register real v = 0.0;
+    register int *m,mc = 0;
+
+    if(gr_info->mixed_block_flag) {
+      max[3] = -1;
+      max[0] = max[1] = max[2] = 2;
+      m = map[sfreq][0];
+      me = mapend[sfreq][0];
+    }
+    else {
+      max[0] = max[1] = max[2] = max[3] = -1;
+      /* max[3] not really needed in this case */
+      m = map[sfreq][1];
+      me = mapend[sfreq][1];
+    }
+
+    for(i=0;i<2;i++) {
+      int lp = l[i];
+      struct newhuff *h = ht+gr_info->table_select[i];
+      for(;lp;lp--,mc--) {
+        int x,y;
+
+        if(!mc) {
+          mc = *m++;
+          xrpnt = ((real *) xr[1]) + *m;
+          xr0pnt = ((real *) xr[0]) + *m++;
+          lwin = *m++;
+          cb = *m++;
+          if(lwin == 3) {
+            v = gr_info->pow2gain[(*scf++) << shift];
+            step = 1;
+          }
+          else {
+            v = gr_info->full_gain[lwin][(*scf++) << shift];
+            step = 3;
+          }
+        }
+        {
+          register short *val = h->table;
+          while((y=*val++)<0) {
+            if (get1bit(mp))
+              val -= y;
+            part2remain--;
+          }
+          x = y >> 4;
+          y &= 0xf;
+        }
+        if(x == 15) {
+          max[lwin] = cb;
+          part2remain -= h->linbits+1;
+          x += getbits(mp, h->linbits);
+          if(get1bit(mp)) {
+            real a = ispow[x] * v;
+            *xrpnt = *xr0pnt + a;
+            *xr0pnt -= a;
+          }
+          else {
+            real a = ispow[x] * v;
+            *xrpnt = *xr0pnt - a;
+            *xr0pnt += a;
+          }
+        }
+        else if(x) {
+          max[lwin] = cb;
+          if(get1bit(mp)) {
+            real a = ispow[x] * v;
+            *xrpnt = *xr0pnt + a;
+            *xr0pnt -= a;
+          }
+          else {
+            real a = ispow[x] * v;
+            *xrpnt = *xr0pnt - a;
+            *xr0pnt += a;
+          }
+          part2remain--;
+        }
+        else
+          *xrpnt = *xr0pnt;
+        xrpnt += step;
+        xr0pnt += step;
+
+        if(y == 15) {
+          max[lwin] = cb;
+          part2remain -= h->linbits+1;
+          y += getbits(mp, h->linbits);
+          if(get1bit(mp)) {
+            real a = ispow[y] * v;
+            *xrpnt = *xr0pnt + a;
+            *xr0pnt -= a;
+          }
+          else {
+            real a = ispow[y] * v;
+            *xrpnt = *xr0pnt - a;
+            *xr0pnt += a;
+          }
+        }
+        else if(y) {
+          max[lwin] = cb;
+          if(get1bit(mp)) {
+            real a = ispow[y] * v;
+            *xrpnt = *xr0pnt + a;
+            *xr0pnt -= a;
+          }
+          else {
+            real a = ispow[y] * v;
+            *xrpnt = *xr0pnt - a;
+            *xr0pnt += a;
+          }
+          part2remain--;
+        }
+        else
+          *xrpnt = *xr0pnt;
+        xrpnt += step;
+        xr0pnt += step;
+      }
+    }
+
+    for(;l3 && (part2remain > 0);l3--) {
+      struct newhuff *h = htc+gr_info->count1table_select;
+      register short *val = h->table,a;
+
+      while((a=*val++)<0) {
+        part2remain--;
+        if(part2remain < 0) {
+          part2remain++;
+          a = 0;
+          break;
+        }
+        if (get1bit(mp))
+          val -= a;
+      }
+
+      for(i=0;i<4;i++) {
+        if(!(i & 1)) {
+          if(!mc) {
+            mc = *m++;
+            xrpnt = ((real *) xr[1]) + *m;
+            xr0pnt = ((real *) xr[0]) + *m++;
+            lwin = *m++;
+            cb = *m++;
+            if(lwin == 3) {
+              v = gr_info->pow2gain[(*scf++) << shift];
+              step = 1;
+            }
+            else {
+              v = gr_info->full_gain[lwin][(*scf++) << shift];
+              step = 3;
+            }
+          }
+          mc--;
+        }
+        if( (a & (0x8>>i)) ) {
+          max[lwin] = cb;
+          part2remain--;
+          if(part2remain < 0) {
+            part2remain++;
+            break;
+          }
+          if(get1bit(mp)) {
+            *xrpnt = *xr0pnt + v;
+            *xr0pnt -= v;
+          }
+          else {
+            *xrpnt = *xr0pnt - v;
+            *xr0pnt += v;
+          }
+        }
+        else
+          *xrpnt = *xr0pnt;
+        xrpnt += step;
+        xr0pnt += step;
+      }
+    }
+ 
+    while( m < me ) {
+      if(!mc) {
+        mc = *m++;
+        xrpnt = ((real *) xr[1]) + *m;
+        xr0pnt = ((real *) xr[0]) + *m++;
+        if(*m++ == 3)
+          step = 1;
+        else
+          step = 3;
+        m++; /* cb */
+      }
+      mc--;
+      *xrpnt = *xr0pnt;
+      xrpnt += step;
+      xr0pnt += step;
+      *xrpnt = *xr0pnt;
+      xrpnt += step;
+      xr0pnt += step;
+/* we could add a little opt. here:
+ * if we finished a band for window 3 or a long band
+ * further bands could copied in a simple loop without a
+ * special 'map' decoding
+ */
+    }
+
+    gr_info->maxband[0] = max[0]+1;
+    gr_info->maxband[1] = max[1]+1;
+    gr_info->maxband[2] = max[2]+1;
+    gr_info->maxbandl = max[3]+1;
+
+    {
+      int rmax = max[0] > max[1] ? max[0] : max[1];
+      rmax = (rmax > max[2] ? rmax : max[2]) + 1;
+      gr_info->maxb = rmax ? (mp->shortLimit)[sfreq][rmax] : (mp->longLimit)[sfreq][max[3]+1];
+    }
+  }
+  else {
+    int *pretab = gr_info->preflag ? pretab1 : pretab2;
+    int i,max = -1;
+    int cb = 0;
+    register int mc=0,*m = map[sfreq][2];
+    register real v = 0.0;
+#if 0
+    me = mapend[sfreq][2];
+#endif
+
+    for(i=0;i<3;i++) {
+      int lp = l[i];
+      struct newhuff *h = ht+gr_info->table_select[i];
+
+      for(;lp;lp--,mc--) {
+        int x,y;
+        if(!mc) {
+          mc = *m++;
+          cb = *m++;
+          v = gr_info->pow2gain[((*scf++) + (*pretab++)) << shift];
+        }
+        {
+          register short *val = h->table;
+          while((y=*val++)<0) {
+            if (get1bit(mp))
+              val -= y;
+            part2remain--;
+          }
+          x = y >> 4;
+          y &= 0xf;
+        }
+        if (x == 15) {
+          max = cb;
+          part2remain -= h->linbits+1;
+          x += getbits(mp, h->linbits);
+          if(get1bit(mp)) {
+            real a = ispow[x] * v;
+            *xrpnt++ = *xr0pnt + a;
+            *xr0pnt++ -= a;
+          }
+          else {
+            real a = ispow[x] * v;
+            *xrpnt++ = *xr0pnt - a;
+            *xr0pnt++ += a;
+          }
+        }
+        else if(x) {
+          max = cb;
+          if(get1bit(mp)) {
+            real a = ispow[x] * v;
+            *xrpnt++ = *xr0pnt + a;
+            *xr0pnt++ -= a;
+          }
+          else {
+            real a = ispow[x] * v;
+            *xrpnt++ = *xr0pnt - a;
+            *xr0pnt++ += a;
+          }
+          part2remain--;
+        }
+        else
+          *xrpnt++ = *xr0pnt++;
+
+        if (y == 15) {
+          max = cb;
+          part2remain -= h->linbits+1;
+          y += getbits(mp, h->linbits);
+          if(get1bit(mp)) {
+            real a = ispow[y] * v;
+            *xrpnt++ = *xr0pnt + a;
+            *xr0pnt++ -= a;
+          }
+          else {
+            real a = ispow[y] * v;
+            *xrpnt++ = *xr0pnt - a;
+            *xr0pnt++ += a;
+          }
+        }
+        else if(y) {
+          max = cb;
+          if(get1bit(mp)) {
+            real a = ispow[y] * v;
+            *xrpnt++ = *xr0pnt + a;
+            *xr0pnt++ -= a;
+          }
+          else {
+            real a = ispow[y] * v;
+            *xrpnt++ = *xr0pnt - a;
+            *xr0pnt++ += a;
+          }
+          part2remain--;
+        }
+        else
+          *xrpnt++ = *xr0pnt++;
+      }
+    }
+
+    for(;l3 && (part2remain > 0);l3--) {
+      struct newhuff *h = htc+gr_info->count1table_select;
+      register short *val = h->table,a;
+
+      while((a=*val++)<0) {
+        part2remain--;
+        if(part2remain < 0) {
+          part2remain++;
+          a = 0;
+          break;
+        }
+        if (get1bit(mp))
+          val -= a;
+      }
+
+      for(i=0;i<4;i++) {
+        if(!(i & 1)) {
+          if(!mc) {
+            mc = *m++;
+            cb = *m++;
+            v = gr_info->pow2gain[((*scf++) + (*pretab++)) << shift];
+          }
+          mc--;
+        }
+        if ( (a & (0x8>>i)) ) {
+          max = cb;
+          part2remain--;
+          if(part2remain <= 0) {
+            part2remain++;
+            break;
+          }
+          if(get1bit(mp)) {
+            *xrpnt++ = *xr0pnt + v;
+            *xr0pnt++ -= v;
+          }
+          else {
+            *xrpnt++ = *xr0pnt - v;
+            *xr0pnt++ += v;
+          }
+        }
+        else
+          *xrpnt++ = *xr0pnt++;
+      }
+    }
+    for(i=(&xr[1][SBLIMIT][0]-xrpnt)>>1;i;i--) {
+      *xrpnt++ = *xr0pnt++;
+      *xrpnt++ = *xr0pnt++;
+    }
+
+    gr_info->maxbandl = max+1;
+    gr_info->maxb = longLimit[sfreq][gr_info->maxbandl];
+  }
+
+  while ( part2remain > 16 ) {
+    getbits(mp, 16); /* Dismiss stuffing Bits */
+    part2remain -= 16;
+  }
+  if(part2remain > 0 )
+    getbits(mp, part2remain);
+  else if(part2remain < 0) {
+    ast_log(LOG_WARNING,"mpg123_ms: Can't rewind stream by %d bits!\n",-part2remain);
+    return 1; /* -> error */
+  }
+  return 0;
+}
+#endif
+
+/* 
+ * III_stereo: calculate real channel values for Joint-I-Stereo-mode
+ */
+static void III_i_stereo(real xr_buf[2][SBLIMIT][SSLIMIT],int *scalefac,
+   struct gr_info_s *gr_info,int sfreq,int ms_stereo,int lsf)
+{
+      real (*xr)[SBLIMIT*SSLIMIT] = (real (*)[SBLIMIT*SSLIMIT] ) xr_buf;
+      struct bandInfoStruct *bi = &bandInfo[sfreq];
+      real *tab1,*tab2;
+
+      if(lsf) {
+        int p = gr_info->scalefac_compress & 0x1;
+	    if(ms_stereo) {
+          tab1 = pow1_2[p]; tab2 = pow2_2[p];
+        }
+        else {
+          tab1 = pow1_1[p]; tab2 = pow2_1[p];
+        }
+      }
+      else {
+        if(ms_stereo) {
+          tab1 = tan1_2; tab2 = tan2_2;
+        }
+        else {
+          tab1 = tan1_1; tab2 = tan2_1;
+        }
+      }
+
+      if (gr_info->block_type == 2)
+      {
+         int lwin,do_l = 0;
+         if( gr_info->mixed_block_flag )
+           do_l = 1;
+
+         for (lwin=0;lwin<3;lwin++) /* process each window */
+         {
+             /* get first band with zero values */
+           int is_p,sb,idx,sfb = gr_info->maxband[lwin];  /* sfb is minimal 3 for mixed mode */
+           if(sfb > 3)
+             do_l = 0;
+
+           for(;sfb<12;sfb++)
+           {
+             is_p = scalefac[sfb*3+lwin-gr_info->mixed_block_flag]; /* scale: 0-15 */ 
+             if(is_p != 7) {
+               real t1,t2;
+               sb = bi->shortDiff[sfb];
+               idx = bi->shortIdx[sfb] + lwin;
+               t1 = tab1[is_p]; t2 = tab2[is_p];
+               for (; sb > 0; sb--,idx+=3)
+               {
+                 real v = xr[0][idx];
+                 xr[0][idx] = v * t1;
+                 xr[1][idx] = v * t2;
+               }
+             }
+           }
+
+#if 1
+/* in the original: copy 10 to 11 , here: copy 11 to 12 
+maybe still wrong??? (copy 12 to 13?) */
+           is_p = scalefac[11*3+lwin-gr_info->mixed_block_flag]; /* scale: 0-15 */
+           sb = bi->shortDiff[12];
+           idx = bi->shortIdx[12] + lwin;
+#else
+           is_p = scalefac[10*3+lwin-gr_info->mixed_block_flag]; /* scale: 0-15 */
+           sb = bi->shortDiff[11];
+           idx = bi->shortIdx[11] + lwin;
+#endif
+           if(is_p != 7)
+           {
+             real t1,t2;
+             t1 = tab1[is_p]; t2 = tab2[is_p];
+             for ( ; sb > 0; sb--,idx+=3 )
+             {  
+               real v = xr[0][idx];
+               xr[0][idx] = v * t1;
+               xr[1][idx] = v * t2;
+             }
+           }
+         } /* end for(lwin; .. ; . ) */
+
+         if (do_l)
+         {
+/* also check l-part, if ALL bands in the three windows are 'empty'
+ * and mode = mixed_mode 
+ */
+           int sfb = gr_info->maxbandl;
+           int idx = bi->longIdx[sfb];
+
+           for ( ; sfb<8; sfb++ )
+           {
+             int sb = bi->longDiff[sfb];
+             int is_p = scalefac[sfb]; /* scale: 0-15 */
+             if(is_p != 7) {
+               real t1,t2;
+               t1 = tab1[is_p]; t2 = tab2[is_p];
+               for ( ; sb > 0; sb--,idx++)
+               {
+                 real v = xr[0][idx];
+                 xr[0][idx] = v * t1;
+                 xr[1][idx] = v * t2;
+               }
+             }
+             else 
+               idx += sb;
+           }
+         }     
+      } 
+      else /* ((gr_info->block_type != 2)) */
+      {
+        int sfb = gr_info->maxbandl;
+        int is_p,idx = bi->longIdx[sfb];
+        for ( ; sfb<21; sfb++)
+        {
+          int sb = bi->longDiff[sfb];
+          is_p = scalefac[sfb]; /* scale: 0-15 */
+          if(is_p != 7) {
+            real t1,t2;
+            t1 = tab1[is_p]; t2 = tab2[is_p];
+            for ( ; sb > 0; sb--,idx++)
+            {
+               real v = xr[0][idx];
+               xr[0][idx] = v * t1;
+               xr[1][idx] = v * t2;
+            }
+          }
+          else
+            idx += sb;
+        }
+
+        is_p = scalefac[20]; /* copy l-band 20 to l-band 21 */
+        if(is_p != 7)
+        {
+          int sb;
+          real t1 = tab1[is_p],t2 = tab2[is_p]; 
+
+          for ( sb = bi->longDiff[21]; sb > 0; sb--,idx++ )
+          {
+            real v = xr[0][idx];
+            xr[0][idx] = v * t1;
+            xr[1][idx] = v * t2;
+          }
+        }
+      } /* ... */
+}
+
+static void III_antialias(real xr[SBLIMIT][SSLIMIT],struct gr_info_s *gr_info)
+{
+   int sblim;
+
+   if(gr_info->block_type == 2)
+   {
+      if(!gr_info->mixed_block_flag) 
+        return;
+      sblim = 1; 
+   }
+   else {
+     sblim = gr_info->maxb-1;
+   }
+
+   /* 31 alias-reduction operations between each pair of sub-bands */
+   /* with 8 butterflies between each pair                         */
+
+   {
+     int sb;
+     real *xr1=(real *) xr[1];
+
+     for(sb=sblim;sb;sb--,xr1+=10)
+     {
+       int ss;
+       real *cs=aa_cs,*ca=aa_ca;
+       real *xr2 = xr1;
+
+       for(ss=7;ss>=0;ss--)
+       {       /* upper and lower butterfly inputs */
+         register real bu = *--xr2,bd = *xr1;
+         *xr2   = (bu * (*cs)   ) - (bd * (*ca)   );
+         *xr1++ = (bd * (*cs++) ) + (bu * (*ca++) );
+       }
+     }
+  }
+}
+
+/*
+ DCT insipired by Jeff Tsay's DCT from the maplay package
+ this is an optimized version with manual unroll.
+
+ References:
+ [1] S. Winograd: "On Computing the Discrete Fourier Transform",
+     Mathematics of Computation, Volume 32, Number 141, January 1978,
+     Pages 175-199
+*/
+
+static void dct36(real *inbuf,real *o1,real *o2,real *wintab,real *tsbuf)
+{
+  {
+    register real *in = inbuf;
+
+    in[17]+=in[16]; in[16]+=in[15]; in[15]+=in[14];
+    in[14]+=in[13]; in[13]+=in[12]; in[12]+=in[11];
+    in[11]+=in[10]; in[10]+=in[9];  in[9] +=in[8];
+    in[8] +=in[7];  in[7] +=in[6];  in[6] +=in[5];
+    in[5] +=in[4];  in[4] +=in[3];  in[3] +=in[2];
+    in[2] +=in[1];  in[1] +=in[0];
+
+    in[17]+=in[15]; in[15]+=in[13]; in[13]+=in[11]; in[11]+=in[9];
+    in[9] +=in[7];  in[7] +=in[5];  in[5] +=in[3];  in[3] +=in[1];
+
+
+  {
+
+#define MACRO0(v) { \
+    real tmp; \
+    out2[9+(v)] = (tmp = sum0 + sum1) * w[27+(v)]; \
+    out2[8-(v)] = tmp * w[26-(v)];  } \
+    sum0 -= sum1; \
+    ts[SBLIMIT*(8-(v))] = out1[8-(v)] + sum0 * w[8-(v)]; \
+    ts[SBLIMIT*(9+(v))] = out1[9+(v)] + sum0 * w[9+(v)]; 
+#define MACRO1(v) { \
+	real sum0,sum1; \
+    sum0 = tmp1a + tmp2a; \
+	sum1 = (tmp1b + tmp2b) * tfcos36[(v)]; \
+	MACRO0(v); }
+#define MACRO2(v) { \
+    real sum0,sum1; \
+    sum0 = tmp2a - tmp1a; \
+    sum1 = (tmp2b - tmp1b) * tfcos36[(v)]; \
+	MACRO0(v); }
+
+    register const real *c = COS9;
+    register real *out2 = o2;
+	register real *w = wintab;
+	register real *out1 = o1;
+	register real *ts = tsbuf;
+
+    real ta33,ta66,tb33,tb66;
+
+    ta33 = in[2*3+0] * c[3];
+    ta66 = in[2*6+0] * c[6];
+    tb33 = in[2*3+1] * c[3];
+    tb66 = in[2*6+1] * c[6];
+
+    { 
+      real tmp1a,tmp2a,tmp1b,tmp2b;
+      tmp1a =             in[2*1+0] * c[1] + ta33 + in[2*5+0] * c[5] + in[2*7+0] * c[7];
+      tmp1b =             in[2*1+1] * c[1] + tb33 + in[2*5+1] * c[5] + in[2*7+1] * c[7];
+      tmp2a = in[2*0+0] + in[2*2+0] * c[2] + in[2*4+0] * c[4] + ta66 + in[2*8+0] * c[8];
+      tmp2b = in[2*0+1] + in[2*2+1] * c[2] + in[2*4+1] * c[4] + tb66 + in[2*8+1] * c[8];
+
+      MACRO1(0);
+      MACRO2(8);
+    }
+
+    {
+      real tmp1a,tmp2a,tmp1b,tmp2b;
+      tmp1a = ( in[2*1+0] - in[2*5+0] - in[2*7+0] ) * c[3];
+      tmp1b = ( in[2*1+1] - in[2*5+1] - in[2*7+1] ) * c[3];
+      tmp2a = ( in[2*2+0] - in[2*4+0] - in[2*8+0] ) * c[6] - in[2*6+0] + in[2*0+0];
+      tmp2b = ( in[2*2+1] - in[2*4+1] - in[2*8+1] ) * c[6] - in[2*6+1] + in[2*0+1];
+
+      MACRO1(1);
+      MACRO2(7);
+    }
+
+    {
+      real tmp1a,tmp2a,tmp1b,tmp2b;
+      tmp1a =             in[2*1+0] * c[5] - ta33 - in[2*5+0] * c[7] + in[2*7+0] * c[1];
+      tmp1b =             in[2*1+1] * c[5] - tb33 - in[2*5+1] * c[7] + in[2*7+1] * c[1];
+      tmp2a = in[2*0+0] - in[2*2+0] * c[8] - in[2*4+0] * c[2] + ta66 + in[2*8+0] * c[4];
+      tmp2b = in[2*0+1] - in[2*2+1] * c[8] - in[2*4+1] * c[2] + tb66 + in[2*8+1] * c[4];
+
+      MACRO1(2);
+      MACRO2(6);
+    }
+
+    {
+      real tmp1a,tmp2a,tmp1b,tmp2b;
+      tmp1a =             in[2*1+0] * c[7] - ta33 + in[2*5+0] * c[1] - in[2*7+0] * c[5];
+      tmp1b =             in[2*1+1] * c[7] - tb33 + in[2*5+1] * c[1] - in[2*7+1] * c[5];
+      tmp2a = in[2*0+0] - in[2*2+0] * c[4] + in[2*4+0] * c[8] + ta66 - in[2*8+0] * c[2];
+      tmp2b = in[2*0+1] - in[2*2+1] * c[4] + in[2*4+1] * c[8] + tb66 - in[2*8+1] * c[2];
+
+      MACRO1(3);
+      MACRO2(5);
+    }
+
+	{
+		real sum0,sum1;
+    	sum0 =  in[2*0+0] - in[2*2+0] + in[2*4+0] - in[2*6+0] + in[2*8+0];
+    	sum1 = (in[2*0+1] - in[2*2+1] + in[2*4+1] - in[2*6+1] + in[2*8+1] ) * tfcos36[4];
+		MACRO0(4);
+	}
+  }
+
+  }
+}
+
+/*
+ * new DCT12
+ */
+static void dct12(real *in,real *rawout1,real *rawout2,register real *wi,register real *ts)
+{
+#define DCT12_PART1 \
+             in5 = in[5*3];  \
+     in5 += (in4 = in[4*3]); \
+     in4 += (in3 = in[3*3]); \
+     in3 += (in2 = in[2*3]); \
+     in2 += (in1 = in[1*3]); \
+     in1 += (in0 = in[0*3]); \
+                             \
+     in5 += in3; in3 += in1; \
+                             \
+     in2 *= COS6_1; \
+     in3 *= COS6_1; \
+
+#define DCT12_PART2 \
+     in0 += in4 * COS6_2; \
+                          \
+     in4 = in0 + in2;     \
+     in0 -= in2;          \
+                          \
+     in1 += in5 * COS6_2; \
+                          \
+     in5 = (in1 + in3) * tfcos12[0]; \
+     in1 = (in1 - in3) * tfcos12[2]; \
+                         \
+     in3 = in4 + in5;    \
+     in4 -= in5;         \
+                         \
+     in2 = in0 + in1;    \
+     in0 -= in1;
+
+
+   {
+     real in0,in1,in2,in3,in4,in5;
+     register real *out1 = rawout1;
+     ts[SBLIMIT*0] = out1[0]; ts[SBLIMIT*1] = out1[1]; ts[SBLIMIT*2] = out1[2];
+     ts[SBLIMIT*3] = out1[3]; ts[SBLIMIT*4] = out1[4]; ts[SBLIMIT*5] = out1[5];
+ 
+     DCT12_PART1
+
+     {
+       real tmp0,tmp1 = (in0 - in4);
+       {
+         real tmp2 = (in1 - in5) * tfcos12[1];
+         tmp0 = tmp1 + tmp2;
+         tmp1 -= tmp2;
+       }
+       ts[(17-1)*SBLIMIT] = out1[17-1] + tmp0 * wi[11-1];
+       ts[(12+1)*SBLIMIT] = out1[12+1] + tmp0 * wi[6+1];
+       ts[(6 +1)*SBLIMIT] = out1[6 +1] + tmp1 * wi[1];
+       ts[(11-1)*SBLIMIT] = out1[11-1] + tmp1 * wi[5-1];
+     }
+
+     DCT12_PART2
+
+     ts[(17-0)*SBLIMIT] = out1[17-0] + in2 * wi[11-0];
+     ts[(12+0)*SBLIMIT] = out1[12+0] + in2 * wi[6+0];
+     ts[(12+2)*SBLIMIT] = out1[12+2] + in3 * wi[6+2];
+     ts[(17-2)*SBLIMIT] = out1[17-2] + in3 * wi[11-2];
+
+     ts[(6+0)*SBLIMIT]  = out1[6+0] + in0 * wi[0];
+     ts[(11-0)*SBLIMIT] = out1[11-0] + in0 * wi[5-0];
+     ts[(6+2)*SBLIMIT]  = out1[6+2] + in4 * wi[2];
+     ts[(11-2)*SBLIMIT] = out1[11-2] + in4 * wi[5-2];
+  }
+
+  in++;
+
+  {
+     real in0,in1,in2,in3,in4,in5;
+     register real *out2 = rawout2;
+ 
+     DCT12_PART1
+
+     {
+       real tmp0,tmp1 = (in0 - in4);
+       {
+         real tmp2 = (in1 - in5) * tfcos12[1];
+         tmp0 = tmp1 + tmp2;
+         tmp1 -= tmp2;
+       }
+       out2[5-1] = tmp0 * wi[11-1];
+       out2[0+1] = tmp0 * wi[6+1];
+       ts[(12+1)*SBLIMIT] += tmp1 * wi[1];
+       ts[(17-1)*SBLIMIT] += tmp1 * wi[5-1];
+     }
+
+     DCT12_PART2
+
+     out2[5-0] = in2 * wi[11-0];
+     out2[0+0] = in2 * wi[6+0];
+     out2[0+2] = in3 * wi[6+2];
+     out2[5-2] = in3 * wi[11-2];
+
+     ts[(12+0)*SBLIMIT] += in0 * wi[0];
+     ts[(17-0)*SBLIMIT] += in0 * wi[5-0];
+     ts[(12+2)*SBLIMIT] += in4 * wi[2];
+     ts[(17-2)*SBLIMIT] += in4 * wi[5-2];
+  }
+
+  in++; 
+
+  {
+     real in0,in1,in2,in3,in4,in5;
+     register real *out2 = rawout2;
+     out2[12]=out2[13]=out2[14]=out2[15]=out2[16]=out2[17]=0.0;
+
+     DCT12_PART1
+
+     {
+       real tmp0,tmp1 = (in0 - in4);
+       {
+         real tmp2 = (in1 - in5) * tfcos12[1];
+         tmp0 = tmp1 + tmp2;
+         tmp1 -= tmp2;
+       }
+       out2[11-1] = tmp0 * wi[11-1];
+       out2[6 +1] = tmp0 * wi[6+1];
+       out2[0+1] += tmp1 * wi[1];
+       out2[5-1] += tmp1 * wi[5-1];
+     }
+
+     DCT12_PART2
+
+     out2[11-0] = in2 * wi[11-0];
+     out2[6 +0] = in2 * wi[6+0];
+     out2[6 +2] = in3 * wi[6+2];
+     out2[11-2] = in3 * wi[11-2];
+
+     out2[0+0] += in0 * wi[0];
+     out2[5-0] += in0 * wi[5-0];
+     out2[0+2] += in4 * wi[2];
+     out2[5-2] += in4 * wi[5-2];
+  }
+}
+
+/*
+ * III_hybrid
+ */
+static void III_hybrid(struct mpstr *mp, real fsIn[SBLIMIT][SSLIMIT],real tsOut[SSLIMIT][SBLIMIT],
+   int ch,struct gr_info_s *gr_info)
+{
+   real *tspnt = (real *) tsOut;
+   real (*block)[2][SBLIMIT*SSLIMIT] = mp->hybrid_block;
+   int *blc = mp->hybrid_blc;
+   real *rawout1,*rawout2;
+   int bt;
+   int sb = 0;
+
+   {
+     int b = blc[ch];
+     rawout1=block[b][ch];
+     b=-b+1;
+     rawout2=block[b][ch];
+     blc[ch] = b;
+   }
+
+  
+   if(gr_info->mixed_block_flag) {
+     sb = 2;
+     dct36(fsIn[0],rawout1,rawout2,win[0],tspnt);
+     dct36(fsIn[1],rawout1+18,rawout2+18,win1[0],tspnt+1);
+     rawout1 += 36; rawout2 += 36; tspnt += 2;
+   }
+ 
+   bt = gr_info->block_type;
+   if(bt == 2) {
+     for (; sb<gr_info->maxb; sb+=2,tspnt+=2,rawout1+=36,rawout2+=36) {
+       dct12(fsIn[sb],rawout1,rawout2,win[2],tspnt);
+       dct12(fsIn[sb+1],rawout1+18,rawout2+18,win1[2],tspnt+1);
+     }
+   }
+   else {
+     for (; sb<gr_info->maxb; sb+=2,tspnt+=2,rawout1+=36,rawout2+=36) {
+       dct36(fsIn[sb],rawout1,rawout2,win[bt],tspnt);
+       dct36(fsIn[sb+1],rawout1+18,rawout2+18,win1[bt],tspnt+1);
+     }
+   }
+
+   for(;sb<SBLIMIT;sb++,tspnt++) {
+     int i;
+     for(i=0;i<SSLIMIT;i++) {
+       tspnt[i*SBLIMIT] = *rawout1++;
+       *rawout2++ = 0.0;
+     }
+   }
+}
+
+/*
+ * main layer3 handler
+ */
+int do_layer3(struct mpstr *mp,unsigned char *pcm_sample,int *pcm_point)
+{
+
+  int gr, ch, ss,clip=0;
+  int scalefacs[39]; /* max 39 for short[13][3] mode, mixed: 38, long: 22 */
+  struct III_sideinfo sideinfo;
+  struct frame *fr;
+  int stereo, single, sfreq;
+  int ms_stereo,i_stereo;
+  int stereo1,granules;
+
+  fr = &(mp->fr);
+  stereo = fr->stereo;
+  single = fr->single;
+  sfreq = fr->sampling_frequency;
+
+  
+  
+  if(stereo == 1) { /* stream is mono */
+    stereo1 = 1;
+    single = 0;
+  }
+  else if(single >= 0) /* stream is stereo, but force to mono */
+    stereo1 = 1;
+  else
+    stereo1 = 2;
+
+  if(fr->mode == MPG_MD_JOINT_STEREO) {
+    ms_stereo = fr->mode_ext & 0x2;
+    i_stereo  = fr->mode_ext & 0x1;
+  }
+  else
+    ms_stereo = i_stereo = 0;
+
+  if(fr->lsf) {
+    granules = 1;
+    if (III_get_side_info_2(mp, &sideinfo,stereo,ms_stereo,sfreq,single))
+	    return (MP3_ERR);
+  }
+  else {
+    granules = 2;
+#ifdef MPEG1
+   if ( III_get_side_info_1(mp, &sideinfo,stereo,ms_stereo,sfreq,single))
+	   return (MP3_ERR);
+   
+#else
+    ast_log(LOG_WARNING,"Not supported\n");
+#endif
+  }
+
+  if(set_pointer(mp, sideinfo.main_data_begin) == MP3_ERR)
+    return 0;
+
+  for (gr=0;gr<granules;gr++) 
+  {
+    static real hybridIn[2][SBLIMIT][SSLIMIT];
+    static real hybridOut[2][SSLIMIT][SBLIMIT];
+
+    {
+      struct gr_info_s *gr_info = &(sideinfo.ch[0].gr[gr]);
+      long part2bits;
+      if(fr->lsf)
+        part2bits = III_get_scale_factors_2(mp, scalefacs,gr_info,0);
+      else {
+#ifdef MPEG1
+        part2bits = III_get_scale_factors_1(mp, scalefacs,gr_info);
+#else
+	ast_log(LOG_WARNING,"Not supported\n");
+#endif
+      }
+      if(III_dequantize_sample(mp, hybridIn[0], scalefacs,gr_info,sfreq,part2bits))
+        return (MP3_ERR);
+    }
+    if(stereo == 2) {
+      struct gr_info_s *gr_info = &(sideinfo.ch[1].gr[gr]);
+      long part2bits;
+      if(fr->lsf) 
+        part2bits = III_get_scale_factors_2(mp, scalefacs,gr_info,i_stereo);
+      else {
+#ifdef MPEG1
+        part2bits = III_get_scale_factors_1(mp, scalefacs,gr_info);
+#else
+	ast_log(LOG_WARNING,"Not supported\n");
+#endif
+      }
+
+      if(III_dequantize_sample(mp, hybridIn[1],scalefacs,gr_info,sfreq,part2bits))
+          return (MP3_ERR);
+
+      if(ms_stereo) {
+        int i;
+        for(i=0;i<SBLIMIT*SSLIMIT;i++) {
+          real tmp0,tmp1;
+          tmp0 = ((real *) hybridIn[0])[i];
+          tmp1 = ((real *) hybridIn[1])[i];
+          ((real *) hybridIn[1])[i] = tmp0 - tmp1;  
+          ((real *) hybridIn[0])[i] = tmp0 + tmp1;
+        }
+      }
+
+      if(i_stereo)
+        III_i_stereo(hybridIn,scalefacs,gr_info,sfreq,ms_stereo,fr->lsf);
+
+      if(ms_stereo || i_stereo || (single == 3) ) {
+        if(gr_info->maxb > sideinfo.ch[0].gr[gr].maxb) 
+          sideinfo.ch[0].gr[gr].maxb = gr_info->maxb;
+        else
+          gr_info->maxb = sideinfo.ch[0].gr[gr].maxb;
+      }
+
+      switch(single) {
+        case 3:
+          {
+            register int i;
+            register real *in0 = (real *) hybridIn[0],*in1 = (real *) hybridIn[1];
+            for(i=0;i<SSLIMIT*gr_info->maxb;i++,in0++)
+              *in0 = (*in0 + *in1++); /* *0.5 done by pow-scale */ 
+          }
+          break;
+        case 1:
+          {
+            register int i;
+            register real *in0 = (real *) hybridIn[0],*in1 = (real *) hybridIn[1];
+            for(i=0;i<SSLIMIT*gr_info->maxb;i++)
+              *in0++ = *in1++;
+          }
+          break;
+      }
+    }
+
+    for(ch=0;ch<stereo1;ch++) {
+      struct gr_info_s *gr_info = &(sideinfo.ch[ch].gr[gr]);
+      III_antialias(hybridIn[ch],gr_info);
+      III_hybrid(mp, hybridIn[ch], hybridOut[ch], ch,gr_info);
+    }
+
+    for(ss=0;ss<SSLIMIT;ss++) {
+      if(single >= 0) {
+        clip += synth_ntom_mono(mp,hybridOut[0][ss],pcm_sample,pcm_point);
+      }
+      else {
+        int p1 = *pcm_point;
+        clip += synth_ntom(mp,hybridOut[0][ss],0,pcm_sample,&p1);
+        clip += synth_ntom(mp,hybridOut[1][ss],1,pcm_sample,pcm_point);
+      }
+    }
+  }
+  
+  return 0;
+}
+
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/addons/mp3/Makefile asterisk-1.8.2.3.new/addons/mp3/Makefile
--- asterisk-1.8.2.3/addons/mp3/Makefile	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/addons/mp3/Makefile	2011-04-27 16:10:37.000000000 +0530
@@ -0,0 +1,24 @@
+MP3OBJS=common.o dct64_i386.o decode_ntom.o layer3.o tabinit.o interface.o
+
+ifeq ($(OSARCH),FreeBSD)
+OSVERSION=$(shell make -V OSVERSION -f /usr/share/mk/bsd.port.subdir.mk)
+CFLAGS+=$(if $(OSVERSION)<500016,-D_THREAD_SAFE)
+LIBS+=$(if $(OSVERSION)<502102,-lc_r,-pthread)
+INCLUDE+=-I/usr/local/include
+CFLAGS+=$(shell if [ -d /usr/local/include/spandsp ]; then echo "-I/usr/local/include/spandsp"; fi)
+endif # FreeBSD
+
+ifeq ($(OSARCH),NetBSD)
+CFLAGS+=-pthread
+INCLUDE+=-I/usr/local/include
+endif
+
+ifeq ($(OSARCH),OpenBSD)
+CFLAGS+=-pthread
+endif
+
+all: $(MP3OBJS)
+
+clean:
+	rm -f *.o *.so *~
+	rm -f .*.o.d
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/addons/mp3/mpg123.h asterisk-1.8.2.3.new/addons/mp3/mpg123.h
--- asterisk-1.8.2.3/addons/mp3/mpg123.h	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/addons/mp3/mpg123.h	2011-04-27 16:10:38.000000000 +0530
@@ -0,0 +1,132 @@
+#include        <stdio.h>
+#include        <string.h>
+#include        <signal.h>
+
+#ifndef WIN32
+#include        <sys/signal.h>
+#include        <unistd.h>
+#endif
+
+#include        <math.h>
+
+#ifdef _WIN32
+# undef WIN32
+# define WIN32
+
+# define M_PI       3.14159265358979323846
+# define M_SQRT2	1.41421356237309504880
+# define REAL_IS_FLOAT
+# define NEW_DCT9
+
+# define random rand
+# define srandom srand
+
+#endif
+
+#ifdef REAL_IS_FLOAT
+#  define real float
+#elif defined(REAL_IS_LONG_DOUBLE)
+#  define real long double
+#else
+#  define real double
+#endif
+
+#ifdef __GNUC__
+#define INLINE inline
+#else
+#define INLINE
+#endif
+
+/* AUDIOBUFSIZE = n*64 with n=1,2,3 ...  */
+#define		AUDIOBUFSIZE		16384
+
+#define         FALSE                   0
+#define         TRUE                    1
+
+#define         SBLIMIT                 32
+#define         SSLIMIT                 18
+
+#define         MPG_MD_STEREO           0
+#define         MPG_MD_JOINT_STEREO     1
+#define         MPG_MD_DUAL_CHANNEL     2
+#define         MPG_MD_MONO             3
+
+#define MAXFRAMESIZE 1792
+
+
+/* Pre Shift fo 16 to 8 bit converter table */
+#define AUSHIFT (3)
+
+struct frame {
+    int stereo;
+    int jsbound;
+    int single;
+    int lsf;
+    int mpeg25;
+    int header_change;
+    int lay;
+    int error_protection;
+    int bitrate_index;
+    int sampling_frequency;
+    int padding;
+    int extension;
+    int mode;
+    int mode_ext;
+    int copyright;
+    int original;
+    int emphasis;
+    int framesize; /* computed framesize */
+};
+
+struct parameter {
+	int quiet;	/* shut up! */
+	int tryresync;  /* resync stream after error */
+	int verbose;    /* verbose level */
+	int checkrange;
+};
+
+extern int decode_header(struct frame *fr,unsigned long newhead);
+
+
+
+struct gr_info_s {
+      int scfsi;
+      unsigned part2_3_length;
+      unsigned big_values;
+      unsigned scalefac_compress;
+      unsigned block_type;
+      unsigned mixed_block_flag;
+      unsigned table_select[3];
+      unsigned subblock_gain[3];
+      unsigned maxband[3];
+      unsigned maxbandl;
+      unsigned maxb;
+      unsigned region1start;
+      unsigned region2start;
+      unsigned preflag;
+      unsigned scalefac_scale;
+      unsigned count1table_select;
+      real *full_gain[3];
+      real *pow2gain;
+};
+
+struct III_sideinfo
+{
+  unsigned main_data_begin;
+  unsigned private_bits;
+  struct {
+    struct gr_info_s gr[2];
+  } ch[2];
+};
+
+struct pcm_workingsample
+{
+	int bitindex;
+	unsigned char *wordpointer;
+};
+
+
+extern long freqs[9];
+extern struct parameter param;
+extern real *pnts[5];
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/addons/mp3/mpglib.h asterisk-1.8.2.3.new/addons/mp3/mpglib.h
--- asterisk-1.8.2.3/addons/mp3/mpglib.h	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/addons/mp3/mpglib.h	2011-04-27 16:10:38.000000000 +0530
@@ -0,0 +1,75 @@
+
+struct buf {
+        unsigned char *pnt;
+	long size;
+	long pos;
+        struct buf *next;
+        struct buf *prev;
+};
+
+struct framebuf {
+	struct buf *buf;
+	long pos;
+	struct frame *next;
+	struct frame *prev;
+};
+
+struct mpstr {
+	struct buf *head,*tail;
+	int bsize;
+	int framesize;
+        int fsizeold;
+	struct frame fr;
+        unsigned char bsspace[2][MAXFRAMESIZE+512]; /* MAXFRAMESIZE */
+	real hybrid_block[2][2][SBLIMIT*SSLIMIT];
+	int hybrid_blc[2];
+	unsigned long header;
+	int bsnum;
+	real synth_buffs[2][2][0x110];
+        int  synth_bo;
+	long outscale; /* volume control default value 32768 */
+	long outsamplerate; /* raw output rate default same as mp3 sample rate*/
+	struct pcm_workingsample worksample; /* keep the state of the working sample for threads */
+	int initmp3; /* flag for first initialisation */
+	int longLimit[9][23]; /*sample limits re setting volume */
+	int shortLimit[9][14];
+	real decwin[512+32]; /* scale table */
+	
+	};
+
+#define BOOL int
+
+#define MP3_ERR -1
+#define MP3_OK  0
+#define MP3_NEED_MORE 1
+
+
+void InitMP3Constants(void);
+BOOL InitMP3(struct mpstr *mp, long outscale);
+int decodeMP3(struct mpstr *mp,char *inmemory,int inmemsize,
+     char *outmemory,int outmemsize,int *done);
+void ExitMP3(struct mpstr *mp);
+
+extern int synth_ntom_set_step(long,long);
+extern int synth_ntom(struct mpstr *mp, real *bandPtr,int channel,unsigned char *out,int *pnt);
+extern int synth_ntom_mono (struct mpstr *mp, real *bandPtr,unsigned char *samples,int *pnt);
+extern int synth_ntom_8bit (real *,int,unsigned char *,int *);
+extern int synth_ntom_mono2stereo (real *,unsigned char *,int *);
+extern int synth_ntom_8bit_mono (real *,unsigned char *,int *);
+extern int synth_ntom_8bit_mono2stereo (real *,unsigned char *,int *);
+
+extern void init_layer3_sample_limits(struct mpstr *mp, int down_sample_sblimit);
+extern void init_layer3_const(void);
+extern int do_layer3(struct mpstr *mp,unsigned char *,int *);
+
+extern void make_decode_tables_scale(struct mpstr *mp, long scaleval);
+extern void make_decode_tables_const(void);
+extern void make_conv16to8_table(int);
+
+extern void dct64(real *,real *,real *);
+
+extern unsigned int   get1bit(struct mpstr *mp);
+extern unsigned int   getbits(struct mpstr *mp, int);
+extern unsigned int   getbits_fast(struct mpstr *mp, int);
+extern int set_pointer(struct mpstr *mp, long backstep);
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/addons/mp3/MPGLIB_README asterisk-1.8.2.3.new/addons/mp3/MPGLIB_README
--- asterisk-1.8.2.3/addons/mp3/MPGLIB_README	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/addons/mp3/MPGLIB_README	2011-04-27 16:10:37.000000000 +0530
@@ -0,0 +1,39 @@
+MP3 library
+-----------
+Version 0.2
+
+This decoder is a 'light' version (thrown out all unnecessay parts)
+from the mpg123 package. I made this for a company.
+
+Currently only Layer3 is enabled to save some space. Layer1,2 isn't
+tested at all. The interface will not change significantly. 
+A backport to the mpg123 package is planed.
+
+comiled and tested only on Solaris 2.6
+main.c contains a simple demo application for library.
+
+COPYING: you may use this source under GPL terms!
+
+PLEASE NOTE: This software may contain patented alogrithm (at least
+  patented in some countries). It may be not allowed to sell/use products
+  based on this source code in these countries. Check this out first!
+
+COPYRIGHT of MP3 music:
+  Please note, that the duplicating of copyrighted music without explicit
+  permission violates the rights of the owner.
+
+SENDING PATCHES:
+  Maybe I change the copyright policy (ie some kind of more free BSD licencse).
+  Please consider this when sending patches/changes.
+  I also want to have the freedom to sell the code to companies that
+  can not use the code under GPL. So, if you send me significant patches,
+  I need your explicit permission to do this. Of course, there will also 
+  be the GPLed open source version of the 100% same code.
+  For the case you cannot accept this: the code is GPL, it's your freedom 
+  to distribute your changes again under GPL. 
+
+FEEDBACK:
+  I'm interessted to here from you, when you use this package as part
+  of another project.
+
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/addons/mp3/MPGLIB_TODO asterisk-1.8.2.3.new/addons/mp3/MPGLIB_TODO
--- asterisk-1.8.2.3/addons/mp3/MPGLIB_TODO	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/addons/mp3/MPGLIB_TODO	2011-04-27 16:10:37.000000000 +0530
@@ -0,0 +1,2 @@
+
+apply 'VBR' bugfix
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/addons/mp3/README asterisk-1.8.2.3.new/addons/mp3/README
--- asterisk-1.8.2.3/addons/mp3/README	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/addons/mp3/README	2011-04-27 16:10:37.000000000 +0530
@@ -0,0 +1 @@
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/addons/mp3/tabinit.c asterisk-1.8.2.3.new/addons/mp3/tabinit.c
--- asterisk-1.8.2.3/addons/mp3/tabinit.c	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/addons/mp3/tabinit.c	2011-04-27 16:10:38.000000000 +0530
@@ -0,0 +1,81 @@
+
+#include <stdlib.h>
+
+#include "mpg123.h"
+#include "mpglib.h"
+
+static real cos64[16],cos32[8],cos16[4],cos8[2],cos4[1];
+real *pnts[] = { cos64,cos32,cos16,cos8,cos4 };
+
+static long intwinbase[] = {
+     0,    -1,    -1,    -1,    -1,    -1,    -1,    -2,    -2,    -2,
+    -2,    -3,    -3,    -4,    -4,    -5,    -5,    -6,    -7,    -7,
+    -8,    -9,   -10,   -11,   -13,   -14,   -16,   -17,   -19,   -21,
+   -24,   -26,   -29,   -31,   -35,   -38,   -41,   -45,   -49,   -53,
+   -58,   -63,   -68,   -73,   -79,   -85,   -91,   -97,  -104,  -111,
+  -117,  -125,  -132,  -139,  -147,  -154,  -161,  -169,  -176,  -183,
+  -190,  -196,  -202,  -208,  -213,  -218,  -222,  -225,  -227,  -228,
+  -228,  -227,  -224,  -221,  -215,  -208,  -200,  -189,  -177,  -163,
+  -146,  -127,  -106,   -83,   -57,   -29,     2,    36,    72,   111,
+   153,   197,   244,   294,   347,   401,   459,   519,   581,   645,
+   711,   779,   848,   919,   991,  1064,  1137,  1210,  1283,  1356,
+  1428,  1498,  1567,  1634,  1698,  1759,  1817,  1870,  1919,  1962,
+  2001,  2032,  2057,  2075,  2085,  2087,  2080,  2063,  2037,  2000,
+  1952,  1893,  1822,  1739,  1644,  1535,  1414,  1280,  1131,   970,
+   794,   605,   402,   185,   -45,  -288,  -545,  -814, -1095, -1388,
+ -1692, -2006, -2330, -2663, -3004, -3351, -3705, -4063, -4425, -4788,
+ -5153, -5517, -5879, -6237, -6589, -6935, -7271, -7597, -7910, -8209,
+ -8491, -8755, -8998, -9219, -9416, -9585, -9727, -9838, -9916, -9959,
+ -9966, -9935, -9863, -9750, -9592, -9389, -9139, -8840, -8492, -8092,
+ -7640, -7134, -6574, -5959, -5288, -4561, -3776, -2935, -2037, -1082,
+   -70,   998,  2122,  3300,  4533,  5818,  7154,  8540,  9975, 11455,
+ 12980, 14548, 16155, 17799, 19478, 21189, 22929, 24694, 26482, 28289,
+ 30112, 31947, 33791, 35640, 37489, 39336, 41176, 43006, 44821, 46617,
+ 48390, 50137, 51853, 53534, 55178, 56778, 58333, 59838, 61289, 62684,
+ 64019, 65290, 66494, 67629, 68692, 69679, 70590, 71420, 72169, 72835,
+ 73415, 73908, 74313, 74630, 74856, 74992, 75038 };
+
+void make_decode_tables_const(void)
+{
+	int i,k,kr,divv;
+	real *costab;
+		
+	for(i=0;i<5;i++)
+	{
+		kr=0x10>>i; divv=0x40>>i;
+		costab = pnts[i];
+		for(k=0;k<kr;k++)
+			costab[k] = 1.0 / (2.0 * cos(M_PI * ((double) k * 2.0 + 1.0) / (double) divv));
+	}
+
+}
+
+void make_decode_tables_scale(struct mpstr *mp, long scaleval)
+{
+  int i,j;
+  real *table;
+  
+  table = mp->decwin;
+  scaleval = -scaleval;
+  for(i=0,j=0;i<256;i++,j++,table+=32)
+  {
+    if(table < (mp->decwin)+512+16)
+      table[16] = table[0] = (double) intwinbase[j] / 65536.0 * (double) scaleval;
+    if(i % 32 == 31)
+      table -= 1023;
+    if(i % 64 == 63)
+      scaleval = - scaleval;
+  }
+
+  for( /* i=256 */ ;i<512;i++,j--,table+=32)
+  {
+    if(table < (mp->decwin)+512+16)
+      table[16] = table[0] = (double) intwinbase[j] / 65536.0 * (double) scaleval;
+    if(i % 32 == 31)
+      table -= 1023;
+    if(i % 64 == 63)
+      scaleval = - scaleval;
+  }
+}
+
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/apps/app_confbridge.c asterisk-1.8.2.3.new/apps/app_confbridge.c
--- asterisk-1.8.2.3/apps/app_confbridge.c	2010-07-21 01:05:02.000000000 +0530
+++ asterisk-1.8.2.3.new/apps/app_confbridge.c	2011-09-20 12:55:18.000000000 +0530
@@ -428,7 +428,8 @@
 		ast_copy_string(conference_bridge->name, name, sizeof(conference_bridge->name));
 
 		/* Create an actual bridge that will do the audio mixing */
-		if (!(conference_bridge->bridge = ast_bridge_new(AST_BRIDGE_CAPABILITY_1TO1MIX, AST_BRIDGE_FLAG_SMART))) {
+		// MSPD: Merged from trunk: Create a bridge as Multimix without smart flag
+		if (!(conference_bridge->bridge = ast_bridge_new(AST_BRIDGE_CAPABILITY_MULTIMIX, 0))) {
 			ao2_ref(conference_bridge, -1);
 			conference_bridge = NULL;
 			ao2_unlock(conference_bridges);
@@ -624,6 +625,11 @@
 		/* Just us so MOH is probably indeed going, let's stop it */
 		ast_moh_stop(bridge_channel->chan);
 	}
+#ifdef MSPD_CHANNEL_MODULE
+    if (conference_bridge->users > 1)
+        if (!strcasecmp(bridge_channel->chan->tech->type, "MSPD"))
+            ast_indicate(bridge_channel->chan, AST_CONTROL_MSPD_CHANNEL_SWITCH_MODE);
+#endif
 	ao2_unlock(conference_bridge);
 
 	/* Try to play back the user menu, if it fails pass this back up so the bridging core will act on it */
@@ -655,6 +661,10 @@
 			ao2_unlock(conference_bridge);
 			res = ast_stream_and_wait(bridge_channel->chan, "conf-errormenu", "");
 		} else {
+#ifdef MSPD_CHANNEL_MODULE
+		if (!strcasecmp(last_participant->chan->tech->type, "MSPD"))
+			ast_indicate(last_participant->chan, AST_CONTROL_MSPD_CHANNEL_SWITCH_MODE);
+#endif
 			last_participant->kicked = 1;
 			ast_bridge_remove(conference_bridge->bridge, last_participant->chan);
 			ao2_unlock(conference_bridge);
@@ -684,6 +694,11 @@
 	if (conference_bridge->users == 1 && ast_test_flag(&conference_bridge_user->flags, OPTION_MUSICONHOLD)) {
 		ast_moh_start(bridge_channel->chan, conference_bridge_user->opt_args[OPTION_MUSICONHOLD_CLASS], NULL);
 	}
+#ifdef MSPD_CHANNEL_MODULE
+    if (conference_bridge->users > 1)
+        if (!strcasecmp(bridge_channel->chan->tech->type, "MSPD"))
+            ast_indicate(bridge_channel->chan, AST_CONTROL_MSPD_CHANNEL_SWITCH_MODE);
+#endif
 	ao2_unlock(conference_bridge);
 
 	bridge_channel->state = AST_BRIDGE_CHANNEL_STATE_WAIT;
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/bridges/bridge_mspd.c asterisk-1.8.2.3.new/bridges/bridge_mspd.c
--- asterisk-1.8.2.3/bridges/bridge_mspd.c	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/bridges/bridge_mspd.c	2012-02-22 18:39:33.000000000 +0530
@@ -0,0 +1,584 @@
+/*
+ * Mindspeed Comcerto Voice mixing Bridge module.
+ *
+ *  Copyright (C) 2004 - 2011 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+/*! \file
+ *
+ * \brief Multi-party voice mixing module with MSP conference support
+ *
+ * \ingroup bridges
+ *
+ */
+
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 1.11 $")
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/time.h>
+#include <signal.h>
+#include <errno.h>
+#include <unistd.h>
+
+#include <vapi/vapi.h>
+#include <vapi/comcerto-api-defs.h>
+
+#include <asterisk/mspd/common.h>
+#include <asterisk/mspd/defaults.h>
+#include <asterisk/mspd/device.h>
+#include <asterisk/mspd/macro.h>
+#include <asterisk/mspd/rtp.h>
+#include <asterisk/mspd/conference.h>
+
+#include "asterisk/config.h"
+#include "asterisk/module.h"
+#include "asterisk/channel.h"
+#include "asterisk/bridging.h"
+#include "asterisk/bridging_technology.h"
+#include "asterisk/frame.h"
+#include "asterisk/options.h"
+#include "asterisk/logger.h"
+#include "asterisk/astobj2.h"
+#include "asterisk/timing.h"
+#include "asterisk/pbx.h"
+
+#ifdef MSPD_CHANNEL_MODULE
+#include "../channels/mspd/include/mspd_common.h"
+#endif
+
+// C100, C1000 has single MSP processor, thus we don't need to search in the list of devices
+static mspd_device_t * msp_device = NULL;
+
+// Default packet size for all MSP channels
+#define MSPD_PKTSIZE 20
+
+// The structure which represents bridge conference room
+struct mspd_bridge_conference {
+    /*! MSP conference */
+    mspd_conference_t *mspd_conf;
+    /*! File descriptors count */
+    int nfds;
+    /*! File descriptors array of the sockets assosiated with RSP participants */
+    int fds[MSPD_MAX_CHANNELS];
+};
+
+// The structure which represents bridge participant
+struct mspd_bridge_channel {
+    /*! Lock to protect this structure */
+    ast_mutex_t lock;
+    /*! Keep MSP channel to check type and send commands*/
+    mspd_channel_t* mspd_chan;
+    /*! Auxiliary RSP channel for single LSP */
+    mspd_channel_t* mspd_aux_rsp;
+    /*! RTP instance for RSP to exchange voice with Asterisk channel */
+    struct ast_rtp_instance *rtp;
+    /*! Flag to keep the state of MSP conference participant */
+    int muted;
+};
+
+//=================================================================//
+
+// Function called when the first participant is joining the bridge instance
+static int mspd_bridge_create_conference (struct ast_bridge *bridge, BandMode conf_mode)
+{
+    mspd_conference_t *mspd_conf = NULL;
+    struct mspd_bridge_conference *room = NULL;
+
+    if (!(room = ast_calloc(1, sizeof(*room)))) {
+        MSPD_ERR("Bridge conference room is not created. Out of memory\n");
+        return -1;
+    }
+    room->nfds = 0;
+    memset(room->fds, -1, sizeof(room->fds));
+
+    if (!(mspd_conf = mspd_conference_create(msp_device, conf_mode))) {
+        MSPD_ERR("Could not create a conference in %s device\n", mspd_device_get_name(msp_device));
+        return -1;
+    }
+    MSPD_LOG(1, "MSP conferece %s created\n", mspd_conference_get_name(mspd_conf));
+
+    room->mspd_conf = mspd_conf;
+    bridge->bridge_pvt = room;
+
+    return 0;
+}
+
+// Function called when a bridge instance is destroyed
+static int mspd_bridge_destroy (struct ast_bridge *bridge)
+{
+    if (!bridge->bridge_pvt) {
+        MSPD_ERR("No PVT bridge %p\n", bridge);
+        return -1;
+    }
+
+    struct mspd_bridge_conference *room = (struct mspd_bridge_conference *) bridge->bridge_pvt;
+    mspd_conference_t * mspd_conf = room->mspd_conf;
+
+    MSPD_LOG(1, "Destroying MSP conferece %s\n", mspd_conference_get_name(mspd_conf));
+    mspd_conference_destroy(mspd_conf);
+    ast_free(room);
+    bridge->bridge_pvt = NULL;
+
+    return 0;
+}
+
+// Refresh socket descriptors array of the conference room
+static void mspd_bridge_refresh_fds (struct ast_bridge *bridge)
+{
+    struct mspd_bridge_conference *room = (struct mspd_bridge_conference *) bridge->bridge_pvt;
+    struct ast_bridge_channel *bridge_channel = NULL;
+    struct mspd_bridge_channel *bc = NULL;
+
+    room->nfds = 0;
+    memset(room->fds, -1, sizeof (room->fds));
+    AST_LIST_TRAVERSE(&bridge->channels, bridge_channel, entry) {
+        // Skip service participant Bridge
+        if (strcasecmp(bridge_channel->chan->tech->type, "Bridge")) {
+            bc = bridge_channel->bridge_pvt;
+            if (bc && bc->rtp) {
+                room->fds[room->nfds] = ast_rtp_instance_fd (bc->rtp, 0);
+                room->nfds++;
+            }
+        }
+    }
+}
+
+// Function called when a channel joines the bridge instance
+static int mspd_bridge_join (struct ast_bridge *bridge, struct ast_bridge_channel *bridge_channel)
+{
+    struct ast_bridge_channel *first_bc = NULL;
+    struct mspd_bridge_channel *bc = NULL;
+    BandMode conf_mode = Narrow;
+
+    ao2_lock(bridge);
+
+    /* Creating a bridge participant and MSP conference participant */
+    if (!(bc = ast_calloc(1, sizeof(*bc)))) {
+        MSPD_ERR("Bridge channel object is not created. Out of memory\n");
+        goto bail_out;
+    }
+    ast_mutex_init(&bc->lock);
+    bridge_channel->bridge_pvt = bc;
+
+    // The first participant is joining the bridge, so we are going to create a MSP conference room
+    if (bridge->num == 1 && !bridge->bridge_pvt) {
+        const char *var;
+        ast_channel_lock(bridge_channel->chan);
+        // Read the msp conference mixer mode from the dial plan option
+        if ((var = pbx_builtin_getvar_helper(bridge_channel->chan, "MSPD_CONF_BRIDGE_MODE"))) {
+            if (!strcmp(var, "WIDE"))
+                conf_mode = Wide;
+        }
+        ast_channel_unlock(bridge_channel->chan);
+
+        // Creating a conference room in MSP, assosiated with the bridge instance
+        if (mspd_bridge_create_conference (bridge, conf_mode)) {
+            MSPD_ERR("MSP conference is not created\n");
+            goto bail_out;
+        }
+    }
+
+    // The second participant is joining the bridge, so we have to remove an auxiliary RSP part (for MSPD channels)
+    if (bridge->num == 2) {
+        if (AST_LIST_FIRST(&bridge->channels) != bridge_channel) {
+            first_bc = AST_LIST_FIRST(&bridge->channels);
+        } else {
+            first_bc = AST_LIST_LAST(&bridge->channels);
+        }
+
+        struct mspd_bridge_channel *fbc = first_bc->bridge_pvt;
+        if (!fbc) {
+            MSPD_ERR("Can't get MSPD Bridge channel from first bridge %p channel!\n", bridge);
+            goto bail_out;
+        }
+
+        // Removing an auxiliary RSP part
+        if (!strcasecmp(first_bc->chan->tech->type, "MSPD")) {
+            if (fbc->mspd_aux_rsp) {
+                MSPD_LOG(3, "Destroying auxiliary channel on the first MSPD bridge channel\n");
+                mspd_channel_disable(fbc->mspd_aux_rsp);
+                mspd_channel_destroy(fbc->mspd_aux_rsp);
+                fbc->mspd_aux_rsp = NULL;
+            }
+        }
+    }
+
+    struct mspd_bridge_conference *room = (struct mspd_bridge_conference *) bridge->bridge_pvt;
+    mspd_conference_t * mspd_conf = room->mspd_conf;
+    const char* mspd_conf_name = mspd_conference_get_name(mspd_conf);
+
+    MSPD_LOG(1, "Joining a participant of type %s to the conference %s\n",
+            bridge_channel->chan->tech->type,
+            mspd_conf_name);
+
+    // Creating LSP for Asterisk channel of type MSPD
+    if (!strcasecmp(bridge_channel->chan->tech->type, "MSPD")) {
+
+#ifdef MSPD_CHANNEL_MODULE
+        mspd_line_t *line = (mspd_line_t *)(bridge_channel->chan->tech_pvt);
+        if (!line) {
+            MSPD_ERR("Asterisk channel %s does not keep MSPD line\n", bridge_channel->chan->name);
+            goto bail_out_bc;
+        }
+        MSPD_LOCK(line->lock, goto bail_out_bc);
+        MSPD_LOG(4, "MSPD Line %s found on channel %s\n", line->name, bridge_channel->chan->name);
+
+        if (!line->phone || !line->channel) {
+            MSPD_WARN(5, "Line %s resources were freed\n", line->name);
+            MSPD_UNLOCK(line->lock);
+            goto bail_out_bc;
+        }
+
+        bc->mspd_chan = line->channel;
+        ao2_ref(line->channel, +1); // Increasing ref counter of MSPD channel to make channel's destructor be called after bridge participant leaves the bridge
+        MSPD_UNLOCK(line->lock);
+
+        MSPD_LOG(3, "Converting %s channel %s on line %s to LSP participant for %s\n",
+                mspd_channel_type2text(mspd_channel_get_type(line->channel)),
+                mspd_channel_get_name(line->channel),
+                line->name, mspd_conf_name);
+
+        if(mspd_channel_switch_to_lsp_part (line->channel, line->phone->wideband, line->timeslot,
+            mspd_conference_get_id(mspd_conf))) {
+                MSPD_ERR("Error occured while configuring channel %s on line %s\n\n",
+                            mspd_channel_get_name(line->channel), line->name);
+                goto bail_out_bc;
+        }
+
+        mspd_channel_pvt_t *pvt = mspd_channel_get_pvt(line->channel);
+        pvt->part.conference = mspd_conf;
+        mspd_conference_inc_participants(mspd_conf);
+
+        if (mspd_channel_bwe_manager(line->channel,
+                line->phone->wideband,
+                mspd_conference_get_mixer(mspd_conf),
+                &line->phone->bwe,
+                True) ||                                 // apply BWE after switching the channel
+            mspd_channel_configure_lsp_part(bc->mspd_chan, &line->phone->echocan)) {
+            MSPD_ERR("Error occured while configuring channel %s on line %s\n",
+                            mspd_channel_get_name(line->channel), line->name);
+            if(mspd_channel_switch_to_voip (line->channel, line->phone->wideband, line->timeslot))
+                MSPD_ERR("Error occured while switching back to VoIP\n");
+
+            mspd_conference_dec_participants(mspd_conf);
+            goto bail_out_bc;
+        }
+
+        // For single LSP, we need to create auxiliary RSP to provide connection with mixer from network side
+        if (bridge->num == 1) {
+            MSPD_LOG(3, "Creating auxiliary RSP channel on the first MSPD bridge channel\n");
+            format_t codec = (bridge_channel->chan->rawreadformat & MSPD_SUPPORTED_CODECS) ?
+                              bridge_channel->chan->rawreadformat : MSPD_DEFAULT_CODEC;
+            mspd_channel_t *mspd_aux_rsp =
+                mspd_conference_create_rtp_participant(mspd_conf,
+                                                        codec,
+                                                        line->intern_rtp);
+            bc->mspd_aux_rsp = mspd_aux_rsp;
+        }
+
+#else
+        // Exit immediately if MSPD channels not supported
+        goto bail_out_bc;
+#endif
+
+    }// Creating RSP for other Asterisk channel types
+    else {
+        if (!(bc->rtp = mspd_rtp_allocate_new(msp_device))) {
+            MSPD_ERR("New RTP allocation failed for RSP pariticipant for conference %s\n", mspd_conf_name);
+            goto bail_out_bc;
+        }
+
+        format_t codec = (bridge_channel->chan->rawreadformat & MSPD_SUPPORTED_CODECS) ?
+                          bridge_channel->chan->rawreadformat : MSPD_DEFAULT_CODEC;
+
+        MSPD_LOG(1, "Creating RSP participant with codec %s for conference %s\n",
+                ast_getformatname(codec), mspd_conf_name);
+
+        mspd_channel_t *mspd_part_chan =
+            mspd_conference_create_rtp_participant(mspd_conf,
+                                                    codec,
+                                                    bc->rtp);
+        if (!mspd_part_chan) {
+            MSPD_ERR("RSP creation failed for conference %s\n", mspd_conf_name);
+            goto bail_out_bc;
+        }
+        bc->mspd_chan = mspd_part_chan;
+    }
+
+    int count = mspd_conference_get_participants_count(mspd_conf);
+    MSPD_LOG(1, "%d participant%s present in the conference %s\n",
+            count, count > 1 ? "s": "", mspd_conf_name);
+
+    mspd_bridge_refresh_fds(bridge);
+
+    ao2_unlock(bridge);
+    return 0;
+
+bail_out_bc:
+    ast_mutex_destroy(&bc->lock);
+    ast_free(bc);
+    bridge_channel->bridge_pvt = NULL;
+bail_out:
+    ao2_unlock(bridge);
+    return -1;
+}
+
+// Function called when a channel leaves the bridge instance
+static int mspd_bridge_leave(struct ast_bridge *bridge, struct ast_bridge_channel *bridge_channel)
+{
+    if (!bridge->bridge_pvt) {
+        MSPD_ERR("No PVT bridge %p\n", bridge);
+        return -1;
+    }
+    ao2_lock(bridge);
+
+    struct mspd_bridge_conference *room = (struct mspd_bridge_conference *) bridge->bridge_pvt;
+    mspd_conference_t * mspd_conf = room->mspd_conf;
+    const char* mspd_conf_name = mspd_conference_get_name(mspd_conf);
+
+    struct mspd_bridge_channel *bc = bridge_channel->bridge_pvt;
+    if (!bc) {
+        MSPD_WARN(5, "Bridge channel for %s does not exist\n", bridge_channel->chan->name);
+        goto bail_out;
+    }
+
+    ast_mutex_lock(&bc->lock);
+
+    // Removing RSP participants; LSPs are destroyed by MSPD CM
+    if (mspd_channel_get_type(bc->mspd_chan) == MCT_PART_RTP) {
+        MSPD_LOG(1, "Destroying RSP participant %s for conference %s\n",
+            mspd_channel_get_name(bc->mspd_chan), mspd_conf_name);
+        MSPD_LOG(1, "Asterisk channel type %s\n", bridge_channel->chan->tech->type);
+
+        mspd_channel_disable(bc->mspd_chan);
+        mspd_channel_destroy(bc->mspd_chan);
+        bc->mspd_chan = NULL;
+    }
+
+    if (bc->rtp){
+        ast_rtp_instance_destroy(bc->rtp);
+        bc->rtp = NULL;
+    }
+
+    int count = mspd_conference_get_participants_count(mspd_conf);
+    MSPD_LOG(1, "%d participant%s left in the conference %s\n",
+            count, count > 1 ? "s": "", mspd_conf_name);
+
+    ast_mutex_unlock(&bc->lock);
+
+#ifdef MSPD_CHANNEL_MODULE
+
+    // For last participant, destroy auxiliary RSP
+    if (bridge->num == 1) {
+        if (bc->mspd_aux_rsp) {
+            MSPD_LOG(1, "Destroying auxiliary RSP participant %s for conference %s\n",
+                mspd_channel_get_name(bc->mspd_aux_rsp), mspd_conf_name);
+
+            mspd_channel_disable(bc->mspd_aux_rsp);
+            mspd_channel_destroy(bc->mspd_aux_rsp);
+            bc->mspd_aux_rsp = NULL;
+        }
+    }
+
+    struct ast_bridge_channel *first_bc = NULL;
+
+    // The single party which will remain, should be equiped with auxiliary channel if MSPD type
+    if (bridge->num == 2) {
+        if (AST_LIST_FIRST(&bridge->channels) != bridge_channel)
+            first_bc = AST_LIST_FIRST(&bridge->channels);
+        else
+            first_bc = AST_LIST_LAST(&bridge->channels);
+
+        struct mspd_bridge_channel *fbc = first_bc->bridge_pvt;
+        if (!fbc) {
+            MSPD_ERR("Can't get MSPD Bridge channel from first bridge channel!\n");
+            goto bail_out;
+        }
+
+        if (!strcasecmp(first_bc->chan->tech->type, "MSPD")){
+            if (!fbc->mspd_aux_rsp) {
+                mspd_line_t *line = (mspd_line_t *)(first_bc->chan->tech_pvt);
+                MSPD_LOG(3, "Creating auxiliary RSP channel on the first MSPD bridge channel\n");
+                if (!line) {
+                    MSPD_ERR("Asterisk channel %s does not keep MSPD line\n", bridge_channel->chan->name);
+                    goto bail_out;
+                }
+                MSPD_LOG(4, "MSPD Line %s found on channel %s\n", line->name, bridge_channel->chan->name);
+
+                format_t codec = (line->owner->rawreadformat & MSPD_SUPPORTED_CODECS) ?
+                                  line->owner->rawreadformat : MSPD_DEFAULT_CODEC;
+                mspd_channel_t *mspd_aux_rsp =
+                    mspd_conference_create_rtp_participant(mspd_conf,
+                                                            codec,
+                                                            line->intern_rtp);
+                if (!mspd_aux_rsp) {
+                    MSPD_ERR("Auxiliary RSP creation failed for conference %s\n", mspd_conference_get_name(mspd_conf));
+                    goto bail_out;
+                }
+                fbc->mspd_aux_rsp = mspd_aux_rsp;
+
+                count = mspd_conference_get_participants_count(mspd_conf);
+            }
+        }
+    }
+
+#endif
+
+    mspd_bridge_refresh_fds(bridge);
+
+    if (!strcasecmp(bridge_channel->chan->tech->type, "MSPD"))
+        ao2_ref(bc->mspd_chan,-1); // Decreasing ref counter to call channel's destructor
+
+    ast_mutex_destroy(&bc->lock);
+    ast_free(bc);
+    bridge_channel->bridge_pvt = NULL;
+
+    ao2_unlock(bridge);
+    return 0;
+
+bail_out:
+    ao2_unlock(bridge);
+    return -1;
+}
+
+
+// Function called when a channel writes a frame into the bridge
+static enum ast_bridge_write_result mspd_bridge_write(struct ast_bridge *bridge, struct ast_bridge_channel *bridge_channel, struct ast_frame *frame)
+{
+    struct mspd_bridge_channel *bc = bridge_channel->bridge_pvt;
+
+    // Only accept audio frames, all others are unsupported
+    if (frame->frametype != AST_FRAME_VOICE) {
+        return AST_BRIDGE_WRITE_UNSUPPORTED;
+    }
+
+    ast_mutex_lock(&bc->lock);
+
+    // Sending voice from Asterisk channel to MSP participant
+    if (bc->rtp)
+        if(ast_rtp_instance_write(bc->rtp, frame)) {
+            MSPD_ERR("A frame from %s was not written to MSP\n", bridge_channel->chan->name);
+            return AST_BRIDGE_WRITE_FAILED;
+        }
+
+    ast_mutex_unlock(&bc->lock);
+
+    return AST_BRIDGE_WRITE_SUCCESS;
+}
+
+// Function which interacts with RSP parts and sends frames from MSP to Asterisk channels
+static int mspd_bridge_thread(struct ast_bridge *bridge)
+{
+    struct ast_bridge_channel *bridge_channel = NULL;
+    struct mspd_bridge_channel *bc = NULL;
+    int winner = -1;
+
+    if (!bridge->bridge_pvt) {
+        MSPD_ERR("No PVT bridge %p\n", bridge);
+        return -1;
+    }
+    struct mspd_bridge_conference *room = (struct mspd_bridge_conference *) bridge->bridge_pvt;
+
+
+    // --== Working loop ==--
+    while (!bridge->stop && !bridge->refresh && bridge->array_num) {
+        int timeout_fd = MSPD_PKTSIZE;
+        // Muting/unmuting MSP participants accordingly to mute flag of a bridge participant
+        AST_LIST_TRAVERSE(&bridge->channels, bridge_channel, entry) {
+            bc = bridge_channel->bridge_pvt;
+            if (bc && bc->mspd_chan)
+                mspd_channel_lock(bc->mspd_chan); // For checking channel's type
+            else
+                continue;
+
+            if (!bc->muted && bridge_channel->features && bridge_channel->features->mute == 1) {
+                if (MSPD_IS_PART(mspd_channel_get_type(bc->mspd_chan))) {
+                    if(!mspd_channel_mute_participant(bc->mspd_chan, 1))
+                        bc->muted = 1;
+                }
+            }
+
+            if (bc->muted && mspd_channel_get_type(bc->mspd_chan) == MCT_VOIP)
+                bc->muted = 0;
+
+            if (bc->muted && bridge_channel->features && bridge_channel->features->mute == 0) {
+                if (MSPD_IS_PART(mspd_channel_get_type(bc->mspd_chan))) {
+                    if(!mspd_channel_mute_participant(bc->mspd_chan, 0))
+                        bc->muted = 0;
+                }
+            }
+
+            mspd_channel_unlock(bc->mspd_chan);
+        }
+
+        // Sleeping
+        ao2_unlock(bridge);
+        if (room->nfds > 0) { // We have several RSPs, we poll their RTP sockets
+            winner = ast_waitfor_n_fd(room->fds, room->nfds, &timeout_fd, NULL);
+        }
+        else { // We have only LSP, so we may sleep. Waiting for 100 ms
+            usleep(100000);
+        }
+        ao2_lock(bridge);
+
+        // Sending voice from MSP participant to Asterisk channel
+        AST_LIST_TRAVERSE(&bridge->channels, bridge_channel, entry) {
+            bc = bridge_channel->bridge_pvt;
+            struct ast_frame *frame = NULL;
+
+            if(winner > -1) { // Looking for RSP's socket, which has data to read
+                if (bc && bc->rtp) {
+                    if(winner == ast_rtp_instance_fd (bc->rtp, 0)){
+                        frame = ast_rtp_instance_read(bc->rtp, 0);
+                        if (frame)
+                            ast_write(bridge_channel->chan, frame);
+                    }
+                }
+            }
+        }
+    } // --== End of working loop ==--
+
+    return 0;
+}
+
+static struct ast_bridge_technology mspd_bridge = {
+    .name = "mspd_bridge",
+    .capabilities = AST_BRIDGE_CAPABILITY_MULTIMIX |
+                    AST_BRIDGE_CAPABILITY_THREAD |
+                    AST_BRIDGE_CAPABILITY_MULTITHREADED,
+    .preference = AST_BRIDGE_PREFERENCE_LOW,
+    .formats = MSPD_SUPPORTED_CODECS,
+    .destroy = mspd_bridge_destroy,
+    .join    = mspd_bridge_join,
+    .leave   = mspd_bridge_leave,
+    .write   = mspd_bridge_write,
+    .thread  = mspd_bridge_thread,
+};
+
+static int unload_module(void)
+{
+    return ast_bridge_technology_unregister(&mspd_bridge);
+}
+
+static int load_module(void)
+{
+    msp_device = mspd_device_find_by_index(0);
+    if (!msp_device) {
+        MSPD_ERR("MSPD Bridge could not find MSP device!\n");
+        return AST_MODULE_LOAD_FAILURE;
+    }
+
+    return ast_bridge_technology_register(&mspd_bridge);
+}
+
+AST_MODULE_INFO_STANDARD(ASTERISK_GPL_KEY, "MSPD multi-party voice mixer by using MSP processor");
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/channels/chan_gtalk.c asterisk-1.8.2.3.new/channels/chan_gtalk.c
--- asterisk-1.8.2.3/channels/chan_gtalk.c	2010-12-10 03:02:20.000000000 +0530
+++ asterisk-1.8.2.3.new/channels/chan_gtalk.c	2011-02-23 18:25:10.000000000 +0530
@@ -1026,7 +1026,7 @@
 	/* clear codecs */
 	bindaddr.sin_family = AF_INET;
 	ast_sockaddr_from_sin(&bindaddr_tmp, &bindaddr);
-	if (!(tmp->rtp = ast_rtp_instance_new("asterisk", sched, &bindaddr_tmp, NULL))) {
+	if (!(tmp->rtp = ast_rtp_instance_new("asterisk", sched, &bindaddr_tmp, NULL, 0))) {
 	  ast_log(LOG_ERROR, "Failed to create a new RTP instance (possibly an invalid bindaddr?)\n");
 	  ast_free(tmp);
 	  return NULL;
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/channels/chan_h323.c asterisk-1.8.2.3.new/channels/chan_h323.c
--- asterisk-1.8.2.3/channels/chan_h323.c	2010-10-14 20:45:12.000000000 +0530
+++ asterisk-1.8.2.3.new/channels/chan_h323.c	2011-06-24 16:59:31.000000000 +0530
@@ -971,7 +971,7 @@
 			return -1;
 		}
 	}
-	pvt->rtp = ast_rtp_instance_new("asterisk", sched, &our_addr, NULL);
+	pvt->rtp = ast_rtp_instance_new("asterisk", sched, &our_addr, NULL, 0);
 	if (!pvt->rtp) {
 		ast_mutex_unlock(&pvt->lock);
 		ast_log(LOG_WARNING, "Unable to create RTP session: %s\n", strerror(errno));
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/channels/chan_mgcp.c asterisk-1.8.2.3.new/channels/chan_mgcp.c
--- asterisk-1.8.2.3/channels/chan_mgcp.c	2010-09-16 00:52:15.000000000 +0530
+++ asterisk-1.8.2.3.new/channels/chan_mgcp.c	2011-06-24 16:59:31.000000000 +0530
@@ -2917,7 +2917,7 @@
 	}
 	/* Allocate the RTP now */
 	ast_sockaddr_from_sin(&bindaddr_tmp, &bindaddr);
-	sub->rtp = ast_rtp_instance_new("asterisk", sched, &bindaddr_tmp, NULL);
+	sub->rtp = ast_rtp_instance_new("asterisk", sched, &bindaddr_tmp, NULL, 0);
 	if (sub->rtp && sub->owner)
 		ast_channel_set_fd(sub->owner, 0, ast_rtp_instance_fd(sub->rtp, 0));
 	if (sub->rtp) {
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/channels/chan_mspd.c asterisk-1.8.2.3.new/channels/chan_mspd.c
--- asterisk-1.8.2.3/channels/chan_mspd.c	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/channels/chan_mspd.c	2014-05-07 14:49:34.000000000 +0530
@@ -0,0 +1,4570 @@
+/*
+ * Mindspeed Comcerto - Channel module for line handling.
+ *
+ *  Copyright (C) 2004,2005 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+// ===============================================================================================
+// Includes
+
+#include "asterisk.h"
+
+//ASTERISK_FILE_VERSION(__FILE__, "$Revision: 1.94 $")
+
+#include <stdlib.h>
+#include <stdint.h>
+#include <unistd.h>
+#include <string.h>
+#include <errno.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <time.h>
+#include <pthread.h>
+
+#include <vapi/vapi.h>
+#include <vapi/gtl.h>
+#include <vapi/comcerto-api-defs.h>
+
+#include "mspd/include/chan_mspd.h"
+#include "asterisk/mspd/defaults.h"
+#include "asterisk/mspd/macro.h"
+#include "asterisk/mspd/rtp.h"
+#include "mspd/include/mspd_rtp.h"
+#include "mspd/include/mspd_sti-lines.h"
+#include "mspd/include/mspd_dev-channels.h"
+#include "mspd/include/mspd_threeway.h"
+#include "mspd/include/t38.h"
+#include "asterisk/mspd/common.h"
+#include "asterisk/mspd/device.h"
+#include "asterisk/mspd/global.h"
+
+//#include "../conference/app_conference.h"
+//#include "conference/app_conference.h"
+//#include "app/app_conference.h"
+
+#include "asterisk/acl.h"
+#include "asterisk/lock.h"
+#include "asterisk/channel.h"
+#include "asterisk/callerid.h"
+#include "asterisk/logger.h"
+#include "asterisk/module.h"
+#include "asterisk/pbx.h"
+#include "asterisk/options.h"
+#include "asterisk/utils.h"
+#include "asterisk/cli.h"
+#include "asterisk/rtp_engine.h"
+#include "asterisk/translate.h"
+#include "asterisk/features.h"
+#include "asterisk/config.h"
+#include "asterisk/causes.h"
+#include "asterisk/sched.h"
+#include "asterisk/netsock2.h"
+#include "asterisk/frame_defs.h"
+
+// ===============================================================================================
+// Global data
+
+extern mspd_global_t    mspd_global;
+mspd_global_t           mspd_global;
+extern SCSMEUsrData     vapi_gtl_dev_config;
+SCSMEUsrData            vapi_gtl_dev_config;
+
+char const              mspd_chan_id[] = "MSPD";
+char const              mspd_supvsr_name[] = "supvsr";
+static unsigned int 	chan_idx;       	/*!< used in naming channel */
+
+struct sched_context    *sched = NULL;
+extern mspd_timer       load_module_time;
+mspd_timer              load_module_time = {0, 0};
+
+#ifndef AST_MODULE
+#define AST_MODULE mspd_chan_id
+#endif
+
+// ===============================================================================================
+// Local data
+
+static char const   chan_tdesc[]      = "Mindspeed Comcerto Channel Module";
+static char const   chan_desc[]       = "Mspd Channel Module";
+static char const   chan_type[]       = "MSPD";
+static int          use_count         = 0;
+
+static char const   chan_fxo_tdesc[]  = "Mindspeed Comcerto Channel FXO Module";
+static char const   chan_fxo_desc[]   = "Mspd Channel FXO Module";
+static char const   chan_fxo_type[]   = "MSPD_FXO";
+char const          mspd_fxo_chan_id[]= "MSPD_FXO";
+static char         fxo_ext[AST_MAX_EXTENSION];
+mspd_subline_t      *sub_line = NULL;
+
+//-------------------------------------------------------------------------------
+
+AST_MUTEX_DEFINE_STATIC (use_count_lock);
+
+/*! \brief SIP Cli commands definition */
+static struct ast_cli_entry cli_mspd[] = {
+    AST_CLI_DEFINE(mspd_cli_reload_conf,       "Reloads entire channel module configuration"),
+    AST_CLI_DEFINE(mspd_cli_reload_phone_conf, "Reload phone configuration from mspd.conf file"),
+    AST_CLI_DEFINE(mspd_cli_show_global_conf,  "Shows channel module global configuration"),
+    AST_CLI_DEFINE(mspd_cli_show_phone_conf,   "Shows phone configuration of mspd.conf file"),
+    AST_CLI_DEFINE(mspd_cli_show_ud_conf,      "Shows the unified diagnostics configuration"),
+    AST_CLI_DEFINE(mspd_cli_count_active_lines,"Counts non IDLE channel module lines")
+};
+
+#ifdef MSPD_DEBUG
+static struct ast_cli_entry cli_mspd_debug[] = {
+    AST_CLI_DEFINE(mspd_cli_reload_lines,      "Re-initializes channel module lines"),
+    AST_CLI_DEFINE(mspd_cli_show_lines_state,  "Shows current states of all channel module lines")
+};
+#endif
+
+static int mspd_setoption(struct ast_channel *chan, int option, void *data, int datalen);
+static int mspd_queryoption(struct ast_channel *chan, int option, void *data, int *datalen);
+
+static int mspd_senddigit_begin(struct ast_channel *ast, char digit);
+static int mspd_senddigit_end(struct ast_channel *ast, char digit, unsigned int duration);
+
+// ===============================================================================================
+// Channel module interface
+
+const struct ast_channel_tech mspd_tech = {
+    .type =                 chan_type,
+    .description =          chan_tdesc,
+    .capabilities =         MSPD_SUPPORTED_CODECS,
+    .requester =            mspd_request,
+    .call =                 mspd_call,
+    .hangup =               mspd_hangup,
+    .answer =               mspd_answer,
+    .read =                 mspd_read,
+    .write =                mspd_write,
+    .fixup =                mspd_fixup,
+    .indicate =             mspd_indicate,
+    .setoption =            mspd_setoption,
+    .queryoption =          mspd_queryoption,
+    .bridge =               ast_rtp_instance_bridge,
+    .send_digit_begin =     mspd_senddigit_begin,
+    .send_digit_end =       mspd_senddigit_end,
+};
+
+// -----------------------------------------------------------------------------------------------
+// FXO Channel module interface
+
+const struct ast_channel_tech mspd_fxo_tech = {
+    .type =                 chan_fxo_type,
+    .description =          chan_fxo_tdesc,
+    .capabilities =         MSPD_SUPPORTED_CODECS,
+    .requester =            mspd_fxo_request,
+    .call =                 mspd_fxo_call,
+    .hangup =               mspd_fxo_hangup,
+    .answer =               mspd_answer,
+    .read =                 mspd_read,
+    .write =                mspd_write,
+    .fixup =                mspd_fixup,
+    .indicate =             mspd_indicate,
+    .setoption =            mspd_setoption,
+    .queryoption =          mspd_queryoption,
+    .bridge =               ast_rtp_instance_bridge,
+    .send_digit_begin =     mspd_senddigit_begin,
+    .send_digit_end =       mspd_senddigit_end,
+};
+
+// =============================================================================
+// Configuration & Initialization
+// =============================================================================
+
+// -----------------------------------------------------------------------------------------------
+// Handles [global] configuration
+int
+config_global (struct ast_config *cfg, char *cat)
+{
+    struct ast_variable *v;
+    char buf[512];
+
+    MSPD_LOG(2, "Reading global configuration\n");
+
+    mspd_global_config(cfg, cat);
+
+    for (v = ast_variable_browse (cfg, cat); v; v = v->next) {
+	if (!strcasecmp (v->name, "context")) {
+            if (!ast_strlen_zero(v->value))
+                save_strdup (&(mspd_global.context), v->value);
+            else
+                MSPD_WARN(3, "config_global: \"%s\" is empty. Using defaults\n", v->name);
+        }
+        else if (!strcasecmp (v->name, "callgroups")) {
+            mspd_global.call_groups = ast_get_group (v->value);
+        }
+        else if (!strcasecmp (v->name, "pickupgroups")) {
+            mspd_global.pickup_groups = ast_get_group (v->value);
+        }
+        else if (!strcasecmp (v->name, "allow")) {
+            MSPD_LOG(5, "Enabling codecs: %s\n", v->value);
+            int error = ast_parse_allow_disallow (&mspd_global.codec_prefs,
+                                                  &mspd_global.global_phone.allowed_codecs,
+                                                  v->value,
+                                                  ALLOW);
+            if (error)
+                ast_log(LOG_WARNING, "Codec configuration errors found in line %d : %s = %s\n", v->lineno, v->name, v->value);
+        }
+        else if (!strcasecmp (v->name, "disallow")) {
+            MSPD_LOG(5, "Disabling codecs: %s\n", v->value);
+            int error = ast_parse_allow_disallow (&mspd_global.codec_prefs,
+                                                  &mspd_global.global_phone.allowed_codecs,
+                                                  v->value,
+                                                  DISALLOW);
+            if (error)
+                ast_log(LOG_WARNING, "Codec configuration errors found in line %d : %s = %s\n", v->lineno, v->name, v->value);
+        }
+        else if (!strcasecmp(v->name, "interdigit_timeout")) {
+             mspd_global.interdigit_timeout = strtoul (v->value, NULL, 0);
+        }
+        else if (!strcasecmp(v->name, "dial_timeout")) {
+            mspd_global.dial_timeout = strtoul (v->value, NULL, 0);
+        }
+        else if (!strcasecmp(v->name, "flash_mode")) {
+            mspd_global.flash_mode = (!strcmp(v->value, "threeway")) ? THREEWAYCALL : SWITCH;
+        }
+        else if (!strcasecmp(v->name, "wideband3wc")) {
+            mspd_global.threeway_band = ast_true(v->value) ? Wide : Narrow;
+        }
+        else if (!strcasecmp(v->name, "fxo_call_delay")) {
+             mspd_global.fxo_call_delay = strtoul (v->value, NULL, 0);
+        }
+        else if (!strcasecmp(v->name, "dect_pin")) {
+           tempo_dect_set_pin(v->value);
+        }
+		else if (!strcasecmp(v->name, "dect_rfpi")) {
+           tempo_dect_set_rfpi(v->value);
+        }
+        // Parameters which are already parsed in shared code by mspd_global_config()
+        else if (!strcasecmp(v->name, "ipaddr")) {
+        }
+        else if (!strcasecmp(v->name, "ec_type")) {
+        }
+        else if (!strcasecmp(v->name, "bitrate_amr")) {
+        }
+        else if (!strcasecmp(v->name, "bitrate_amr_wb")) {
+        }
+        else if (!strcasecmp(v->name, "passthru_mode")) {
+        }
+        else if (!strcasecmp(v->name, "ntt_callerid")) {
+        }
+        else if (!strcasecmp(v->name, "wideband")) {
+        }
+        else if (!strcasecmp(v->name, "rtpcutthru_mode")) {
+        }
+        else if (!strcasecmp(v->name, "rsp_bwe_master")) {
+        }
+        else if (!strcasecmp(v->name, "rsp_bwe_high_band")) {
+        }
+        else if (!strcasecmp(v->name, "rsp_bwe_low_band")) {
+        }
+        else if (!strcasecmp(v->name, "fax_mode")) {
+        }
+        else {
+            MSPD_WARN(1, "Unknown field \"%s\" in [%s]\n", v->name, cat);
+        }
+    }
+
+    if (!mspd_global_get_ipaddr()->len) {
+        MSPD_ERR("Global IP-address is missed\n");
+        return 1;
+    }
+
+    if (!mspd_global.global_phone.allowed_codecs) {
+        MSPD_ERR("Is there no codecs allowed?\n");
+        mspd_global.global_phone.allowed_codecs = MSPD_DEFAULT_CODEC;
+        MSPD_WARN(1, "Setting globally allowed codec by default (G.711 u-Law)\n");
+    }
+
+    if (!(mspd_global.global_phone.allowed_codecs & MSPD_SUPPORTED_CODECS)) {
+        MSPD_ERR("Unsupported codecs were allowed (conf=%s)", ast_getformatname_multiple (buf, sizeof (buf), mspd_global.global_phone.allowed_codecs));
+        MSPD_ERR(", supported=%s\n", ast_getformatname_multiple (buf, sizeof (buf), MSPD_SUPPORTED_CODECS));
+
+        return 1;
+    }
+
+    if (!mspd_global.interdigit_timeout ||
+         mspd_global.interdigit_timeout < MSPD_INTERDIGIT_TIMEOUT_VAL)
+         mspd_global.interdigit_timeout = MSPD_INTERDIGIT_TIMEOUT_VAL;
+
+    if (!mspd_global.dial_timeout ||
+         mspd_global.dial_timeout < MSPD_DIAL_TIMEOUT_VAL)
+         mspd_global.dial_timeout = MSPD_DIAL_TIMEOUT_VAL;
+
+    if (!mspd_global.fxo_call_delay)
+         mspd_global.fxo_call_delay = 1000;
+
+    MSPD_LOG(3, "Dial timeout       = %d ms\n", mspd_global.dial_timeout);
+    MSPD_LOG(3, "Interdigit timeout = %d ms\n", mspd_global.interdigit_timeout);
+    MSPD_LOG(3, "Allowed codecs     = %s\n", ast_getformatname_multiple (buf, sizeof (buf), mspd_global.global_phone.allowed_codecs));
+
+    return 0;
+}
+
+// -----------------------------------------------------------------------------------------------
+// Handles [tdmbus] configuration
+int
+config_tdmbus (struct ast_config *cfg, char *cat)
+{
+    struct ast_variable *v;
+    mspd_bus_t *bus = mspd_global.buses + mspd_global.n_buses;
+
+    MSPD_LOG(2, "Reading TDM bus configuration\n");
+
+    if (mspd_global.n_buses >= MSPD_MAX_BUSES) {
+        MSPD_ERR("No more room for another TDM-bus\n");
+        return 1;
+    }
+
+    bus->index = mspd_global.n_buses++;
+    save_strdup (&bus->context, mspd_global.context);
+    bus->call_groups = mspd_global.call_groups;
+    bus->pickup_groups = mspd_global.pickup_groups;
+
+    for (v = ast_variable_browse (cfg, cat); v; v = v->next) {
+        if (!strcasecmp (v->name, "name")) {
+            if (!ast_strlen_zero(v->value))
+                bus->name = ast_strdup (v->value);
+            else
+                return 1;
+        }
+        else if (!strcasecmp (v->name, "bus-id")) {
+            bus->tdm = strtoul (v->value, NULL, 0);
+        }
+        else if (!strcasecmp (v->name, "lines")) {
+            bus->n_lines = strtoul (v->value, NULL, 0);
+        }
+        else if (!strcasecmp (v->name, "istrunk")) {
+            bus->is_trunk = ast_true(v->value) ? True : False;
+        }
+        else if (!strcasecmp (v->name, "device")) {
+	    bus->dev = mspd_device_find(v->value);
+            if (!bus->dev) {
+                MSPD_ERR("Could not find device %s of TDM-bus %s\n", v->value, bus->name);
+                return 1;
+            }
+        }
+        else if (!strcasecmp (v->name, "context")) {
+            if (!bus->dev)
+                goto device_first;
+                if (!ast_strlen_zero(v->value))
+                    bus->context = ast_strdup (v->value);
+                else
+                    return 1;
+        }
+        else if (!strcasecmp (v->name, "callgroups")) {
+            if (!bus->dev)
+                goto device_first;
+            bus->call_groups = ast_get_group (v->value);
+        }
+        else if (!strcasecmp (v->name, "pickupgroups")) {
+            if (!bus->dev)
+                goto device_first;
+            bus->pickup_groups = ast_get_group (v->value);
+        }
+        else
+            MSPD_ERR("Unknown field \"%s\" in [%s]\n", v->name, cat);
+    }
+
+    if (!bus->name) {
+        MSPD_ERR("TDM-bus has no name\n");
+        return 1;
+    }
+    if (!bus->dev) {
+        MSPD_ERR("TDM-bus %s has no device\n", bus->name);
+        return 1;
+    }
+    if (bus->is_trunk) {
+        MSPD_ERR("Trunk TDM-buses are not supported\n");
+        return 1;
+    }
+    else
+        MSPD_LOG(3, "TDM params have been set from config file\n");
+
+    return sl_init_lines_of_bus (bus);
+
+device_first:
+    MSPD_ERR("(%s): 'device' of bus needs to be defined before '%s'\n",
+            bus->name, v->value);
+    return 1;
+}
+
+static int
+dfecparams_config_validate (struct ast_variable *v, mspd_echocan_t *echocan)
+{
+    U16                 dfecparam_switch_to_default = 0;
+    int                 value;
+    U16                 no_of_dfectune_params = 0;
+
+    for (; v; v = v->next)
+    {
+        if (!strcasecmp (v->name, "dfec_tx_in_scf_frc")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_TX_IN_SCF_FRC_MIN)&&(value <= EC_TX_IN_SCF_FRC_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_tx_in_scf_frc = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_tx_in_scf_int")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_TX_IN_SCF_INT_MIN)&&(value <= EC_TX_IN_SCF_INT_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_tx_in_scf_int = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_tx_flt_coef")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_TX_FLT_COEF_MIN)&&(value <= EC_TX_FLT_COEF_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_tx_flt_coef = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_tx_det_thr_le")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_TX_DET_THR_LE_MIN)&&(value <= EC_TX_DET_THR_LE_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_tx_det_thr_le = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_tx_out_scf_frc")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_TX_OUT_SCF_FRC_MIN)&&(value <= EC_TX_OUT_SCF_FRC_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_tx_out_scf_frc = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_tx_out_scf_int")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_TX_OUT_SCF_INT_MIN)&&(value <= EC_TX_OUT_SCF_INT_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_tx_out_scf_int = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_rx_in_scf_frc")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_RX_IN_SCF_FRC_MIN)&&(value <= EC_RX_IN_SCF_FRC_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_rx_in_scf_frc = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_rx_in_scf_int")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_RX_IN_SCF_INT_MIN)&&(value <= EC_RX_IN_SCF_INT_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_rx_in_scf_int = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_rx_flt_coef")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_RX_FLT_COEF_MIN)&&(value <= EC_RX_FLT_COEF_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_rx_flt_coef = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_rx_det_thr")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_RX_DET_THR_MIN)&&(value <= EC_RX_DET_THR_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_rx_det_thr = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_rx_out_scf_frc")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_RX_OUT_SCF_FRC_MIN)&&(value <= EC_RX_OUT_SCF_FRC_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_rx_out_scf_frc = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_rx_out_scf_int")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_RX_OUT_SCF_INT_MIN)&&(value <= EC_RX_OUT_SCF_INT_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_rx_out_scf_int = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_minerl")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_MINERL_MIN)&&(value <= EC_MINERL_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_minerl = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_db_hng_reset")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_DB_HNG_RESET_MIN)&&(value <= EC_DB_HNG_RESET_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_db_hng_reset = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_db_adj")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_DB_ADJ_MIN)&&(value <= EC_DB_ADJ_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_db_adj = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_nl_hng")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_NL_HNG_MIN)&&(value <= EC_NL_HNG_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_nl_hng = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_nl_hng_se")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_NL_HNG_SE_MIN)&&(value <= EC_NL_HNG_SE_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_nl_hng_se = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_nl_inc")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_NL_INC_MIN)&&(value <= EC_NL_INC_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_nl_inc = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_nl_inc_se")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_NL_INC_SE_MIN)&&(value <= EC_NL_INC_SE_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_nl_inc_se = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_flt_res_sme_nl")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_FLT_RES_SME_NL_MIN)&&(value <= EC_FLT_RES_SME_NL_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_flt_res_sme_nl = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_flt_cng_sme_nl")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_FLT_CNG_SME_NL_MIN)&&(value <= EC_FLT_CNG_SME_NL_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_flt_cng_sme_nl = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_tx_out_thr_dbt_nl")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_TX_OUT_THR_DBT_NL_MIN)&&(value <= EC_TX_OUT_THR_DBT_NL_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_tx_out_thr_dbt_nl = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_tx_out_thr_min_nl")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_TX_OUT_THR_MIN_NL_MIN)&&(value <= EC_TX_OUT_THR_MIN_NL_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_tx_out_thr_min_nl = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_tx_out_pscf_nl")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_TX_OUT_PSCF_NL_MIN)&&(value <= EC_TX_OUT_PSCF_NL_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_tx_out_pscf_nl = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_tx_c3_nl")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_TX_C3_NL_MIN)&&(value <= EC_TX_C3_NL_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_tx_c3_nl = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_tx_c4_nl")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_TX_C4_NL_MIN)&&(value <= EC_TX_C4_NL_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_tx_c4_nl = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_tx_nos_scf_nl")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_TX_NOS_SCF_NL_MIN)&&(value <= EC_TX_NOS_SCF_NL_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_tx_nos_scf_nl = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_tx_scf_max_nl")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_TX_SCF_MAX_NL_MIN)&&(value <= EC_TX_SCF_MAX_NL_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_tx_scf_max_nl = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_tx_out_pwr_adj_nl")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_TX_OUT_PWR_ADJ_NL_MIN)&&(value <= EC_TX_OUT_PWR_ADJ_NL_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_tx_out_pwr_adj_nl = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_tx_out_thr_del_nl")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_TX_OUT_THR_DEL_NL_MIN)&&(value <= EC_TX_OUT_THR_DEL_NL_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_tx_out_thr_del_nl = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_tx_nlp_off_inc")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_NLP_OFF_INC_MIN)&&(value <= EC_NLP_OFF_INC_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_nlp_off_inc = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_flt_chk_rst1")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_FLT_CHK_RST1_MIN)&&(value <= EC_FLT_CHK_RST1_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_flt_chk_rst1 = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_flt_rin_min")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_FLT_RIN_MIN_MIN)&&(value <= EC_FLT_RIN_MIN_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_flt_rin_min = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_flt_thr1")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_FLT_THR1_MIN)&&(value <= EC_FLT_THR1_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_flt_thr1 = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_flt_scf1")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_FLT_SCF1_MIN)&&(value <= EC_FLT_SCF1_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_flt_scf1 = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_flt_scf2")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_FLT_SCF2_MIN)&&(value <= EC_FLT_SCF2_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_flt_scf2 = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_flt_epc3")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_FLT_EPC3_MIN)&&(value <= EC_FLT_EPC3_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_flt_epc3 = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_flt_scf3")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_FLT_SCF3_MIN)&&(value <= EC_FLT_SCF3_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_flt_scf3 = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_flt_thr4")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_FLT_THR4_MIN)&&(value <= EC_FLT_THR4_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_flt_thr4 = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_flt_thr2")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_FLT_THR2_MIN)&&(value <= EC_FLT_THR2_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_flt_thr2 = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_flt_cnt3")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_FLT_CNT3_MIN)&&(value <= EC_FLT_CNT3_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_flt_cnt3 = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_flt_scf4")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_FLT_SCF4_MIN)&&(value <= EC_FLT_SCF4_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_flt_scf4 = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_flt_scf5")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_FLT_SCF5_MIN)&&(value <= EC_FLT_SCF5_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_flt_scf5 = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_flt_nos_scf_min")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_FLT_NOS_SCF_MIN_MIN)&&(value <= EC_FLT_NOS_SCF_MIN_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_flt_nos_scf_min = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_dat_rx_scf_min_st")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_DAT_RX_SCF_MIN_ST_MIN)&&(value <= EC_DAT_RX_SCF_MIN_ST_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_dat_rx_scf_min_st = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_dat_rese_lev")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_DAT_RESE_LEV_MIN)&&(value <= EC_DAT_RESE_LEV_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_dat_rese_lev = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_dat_rese_dt_lev")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_DAT_RESE_DT_LEV_MIN)&&(value <= EC_DAT_RESE_DT_LEV_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_dat_rese_dt_lev = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_dat_rx_lev")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_DAT_RX_LEV_MIN)&&(value <= EC_DAT_RX_LEV_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_dat_rx_lev = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_dat_tx_lev")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_DAT_TX_LEV_MIN)&&(value <= EC_DAT_TX_LEV_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_dat_tx_lev = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_tx_det_thr_se")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_TX_DET_THR_SE_MIN)&&(value <= EC_TX_DET_THR_SE_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_tx_det_thr_se = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_tx_out_thr_min_nl2")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_TX_OUT_THR_MIN_NL2_MIN)&&(value <= EC_TX_OUT_THR_MIN_NL2_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_tx_out_thr_min_nl2 = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_tx_out_min_tx_nl2")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_TX_OUT_MIN_TX_NL2_MIN)&&(value <= EC_TX_OUT_MIN_TX_NL2_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_tx_out_min_tx_nl2 = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_tx_out_inc_nl2")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_TX_OUT_INC_NL2_MIN)&&(value <= EC_TX_OUT_INC_NL2_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_tx_out_inc_nl2 = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_tx_out_cnt_rst_nl2")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_TX_OUT_CNT_RST_NL2_MIN)&&(value <= EC_TX_OUT_CNT_RST_NL2_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_tx_out_cnt_rst_nl2 = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_dat_rx_mxl")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_DAT_RX_MXL_MIN)&&(value <= EC_DAT_RX_MXL_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_dat_rx_mxl = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_flt_rxm_sme_nl")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_FLT_RXM_SME_NL_MIN)&&(value <= EC_FLT_RXM_SME_NL_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_flt_rxm_sme_nl = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_dat_rx_scf_min_dt")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_DAT_RX_SCF_MIN_DT_MIN)&&(value <= EC_DAT_RX_SCF_MIN_DT_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_dat_rx_scf_min_dt = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_tx_acom_nl")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_TX_ACOM_NL_MIN)&&(value <= EC_TX_ACOM_NL_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_tx_acom_nl = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_tx_rlim_nl")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_TX_RLIM_NL_MIN)&&(value <= EC_TX_RLIM_NL_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_tx_rlim_nl = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+        else if (!strcasecmp (v->name, "dfec_max_noise")) {
+            value = strtoul (v->value, NULL, 0);
+            if((value >= EC_MAX_NOISE_MIN)&&(value <= EC_MAX_NOISE_MAX)) {
+                no_of_dfectune_params++;
+                echocan->dfectune_params.ec_max_noise = strtoul (v->value, NULL, 0);
+            }
+            else
+                dfecparam_switch_to_default++;
+        }
+    }
+
+    MSPD_LOG(5, "Number of processed parameters:%d\n", no_of_dfectune_params);
+    if (dfecparam_switch_to_default)
+        MSPD_WARN(5, "Number of errors while configuration: %d\n", dfecparam_switch_to_default);
+
+    return dfecparam_switch_to_default;
+}
+
+// -----------------------------------------------------------------------------------------------
+// Handles [echocan_settings] configuration
+static int
+config_echocan_settings (struct ast_config *cfg, char *cat)
+{
+    struct ast_variable      *v;
+    mspd_echocan_t           *global_echocan = &mspd_global.global_echocan;
+    int                      i;
+
+    MSPD_LOG(2, "Global echocan setting\n");
+
+    for (v = ast_variable_browse (cfg, cat); v; v = v->next)
+    {
+        if (!strcasecmp (v->name, "echocan")) {
+            global_echocan->echocan_ctrl = strtoul (v->value, NULL, 0);
+        }
+        else if (!strcasecmp (v->name, "enh_echocan")) {
+            global_echocan->enh_echocan_ctrl = strtoul (v->value, NULL, 0);
+        }
+        else if (!strcasecmp (v->name, "dualfilterechocan")) {
+            global_echocan->dfec_ctrl = strtoul (v->value, NULL, 0);
+        }
+        else if (!strcasecmp(v->name, "dfec_tune_config")) {
+                if(!strcasecmp(v->value, "Config")) {
+                    global_echocan->dfectune_default = False;
+                }
+                else
+                    global_echocan->dfectune_default = True;
+
+                if (dfecparams_config_validate (v, global_echocan))
+                    global_echocan->dfectune_default = True;
+
+                break;
+        }
+        else {
+            MSPD_WARN(4, "Unknown field \"%s\" in [%s]\n", v->name, cat);
+        }
+    }
+
+    /* By default copy global configuration to all phones */
+    for (i = 0; i < MSPD_MAX_PHONES; i++)
+    {
+        mspd_phone_t *local_phone = mspd_global.phones + i;
+
+        /* Echo can settings */
+        local_phone->echocan.echocan_ctrl      = global_echocan->echocan_ctrl;
+        local_phone->echocan.enh_echocan_ctrl  = global_echocan->enh_echocan_ctrl;
+        local_phone->echocan.dfec_ctrl         = global_echocan->dfec_ctrl;
+        local_phone->echocan.dfectune_default  = global_echocan->dfectune_default;
+
+        memcpy(&local_phone->echocan.dfectune_params, &global_echocan->dfectune_params, sizeof(mspd_dfectune_t));
+    }
+    return 0;
+}
+// -----------------------------------------------------------------------------------------------
+// Handles [phone_settings] configuration
+static int
+config_phone_settings (struct ast_config *cfg, char *cat)
+{
+    struct ast_variable      *v;
+    mspd_phone_t             *phone = &mspd_global.global_phone;
+    int                      i;
+
+    MSPD_LOG(2, "Global Phone setting\n" );
+
+    for (v = ast_variable_browse (cfg, cat); v; v = v->next)
+    {
+        if (!strcasecmp (v->name, "disallow")) {
+            ast_parse_allow_disallow (&phone->codec_prefs, &phone->allowed_codecs, v->value, DISALLOW);
+        }
+        else if (!strcasecmp (v->name, "allow")) {
+            ast_parse_allow_disallow (&phone->codec_prefs, &phone->allowed_codecs, v->value, ALLOW);
+        }
+        else if (!strcasecmp (v->name, "ud_enable")) {
+            phone->ud_enable = ast_true(v->value) ? True : False;
+        }
+        else if (!strcasecmp (v->name, "dsp_acp")) {
+            phone->dsp_acp = ast_true(v->value) ? True : False;
+        }
+        else if(!strcasecmp(v->name, "vad")) {
+            phone->vad = ast_true(v->value) ? True : False;
+        }
+        else if(!strcasecmp(v->name, "bwe_master")) {
+            phone->bwe.bwe_master = ast_true(v->value) ? True : False;
+        }
+        else if (!strcasecmp (v->name, "bwe_high_band")) {
+            phone->bwe.bwe_high_band = strtoul (v->value, NULL, 0);
+        }
+        else if (!strcasecmp (v->name, "bwe_low_band")) {
+             phone->bwe.bwe_low_band = strtoul (v->value, NULL, 0);
+        }
+        else {
+            MSPD_ERR("Unknown field \"%s\" in [%s]\n", v->name, cat);
+        }
+    }
+
+    if (phone->bwe.bwe_high_band > BWE_HIGH_BAND_MAX)
+        phone->bwe.bwe_high_band = BWE_HIGH_BAND_MAX;
+    if (phone->bwe.bwe_low_band > BWE_LOW_BAND_MAX)
+        phone->bwe.bwe_low_band = BWE_LOW_BAND_MAX;
+
+    //If no codecs have been defined, we use global preferences
+    if (!phone->allowed_codecs) {
+        char buf[256];
+        memcpy(&phone->codec_prefs, &mspd_global.codec_prefs, sizeof(mspd_codec_pref));
+        phone->allowed_codecs = mspd_global.global_phone.allowed_codecs;
+        MSPD_WARN (5, "Setting allowed codecs by global defaults %s\n",
+                ast_getformatname_multiple(buf, sizeof(buf), phone->allowed_codecs));
+    }
+
+    if (!(phone->allowed_codecs & mspd_global.global_phone.allowed_codecs))
+    {
+        char buf1[256], buf2[256];
+       MSPD_ERR("Codecs specified for phone %s is not globally allowed "
+                "(specified codecs=%s, globally supported=%s)\n", phone->name,
+                ast_getformatname_multiple (buf1, sizeof (buf1), phone->allowed_codecs),
+                ast_getformatname_multiple (buf2, sizeof (buf2), mspd_global.global_phone.allowed_codecs));
+        return 1;
+    }
+
+    /* By default copy global configuration to all phones */
+    for (i = 0; i < MSPD_MAX_PHONES; i++)
+    {
+        mspd_phone_t *local_phone = mspd_global.phones + i;
+
+        /* phone settings */
+        /*  BWE settings are applied for each phone by config_phone() */
+        local_phone->allowed_codecs    = phone->allowed_codecs;
+        local_phone->ud_enable         = phone->ud_enable;
+        local_phone->dsp_acp           = phone->dsp_acp;
+        local_phone->vad               = phone->vad;
+
+    }
+    return 0;
+}
+// -----------------------------------------------------------------------------------------------
+// Handles [phone] configuration
+int
+config_phone (struct ast_config *cfg, char *cat)
+{
+    struct ast_variable *v;
+    mspd_phone_t *phone = mspd_global.phones + mspd_global.n_phones;
+    mspd_phone_t *gphone = &mspd_global.global_phone;
+    S8 cfg_bwe_master = -1;
+    S8 cfg_bwe_high_band = -1;
+    S8 cfg_bwe_low_band = -1;
+    Boolean bwe_apply = False;
+
+    MSPD_LOG(2, "Phone%d\n", mspd_global.n_phones + 1);
+
+    if (mspd_global.n_phones >= MSPD_MAX_PHONES) {
+        MSPD_ERR("No more room for another phone\n");
+        return 1;
+    }
+
+    phone->wideband = mspd_global_get_wideband();
+    ++mspd_global.n_phones;
+
+    for (v = ast_variable_browse (cfg, cat); v; v = v->next)
+    {
+        if (!strcasecmp (v->name, "name")) {
+            if (!ast_strlen_zero(v->value))
+                phone->name = ast_strdup (v->value);
+            else
+                return 1;
+        }
+        else if (!strcasecmp (v->name, "tdmbus")) {
+            U16  i;
+
+            for (i = 0; i < mspd_global.n_buses; ++i) {
+                if (!strcmp (mspd_global.buses[i].name, v->value)) {
+                    phone->bus = &mspd_global.buses[i];
+                    break;
+                }
+            }
+
+            if (i >= mspd_global.n_buses) {
+                MSPD_ERR("Could not find TDM-bus %s of phone %s\n",
+                         v->value, phone->name);
+                return 1;
+            }
+
+            save_strdup (&phone->context, phone->bus->context);
+            phone->call_groups   = phone->bus->call_groups;
+            phone->pickup_groups = phone->bus->pickup_groups;
+        }
+        else if (!strcasecmp (v->name, "timeslot")) {
+            phone->timeslot = strtoul (v->value, NULL, 0);
+        }
+        else if (!strcasecmp (v->name, "context")) {
+            if (!phone->bus)
+                goto bus_first;
+
+            if (save_strdup (&(phone->context), v->value))
+                return 1;
+        }
+        else if (!strcasecmp (v->name, "callgroups")) {
+            if (!phone->bus)
+                goto bus_first;
+
+            phone->call_groups = ast_get_group (v->value);
+        }
+        else if (!strcasecmp (v->name, "pickupgroups")) {
+            if (!phone->bus)
+                goto bus_first;
+
+            phone->pickup_groups = ast_get_group (v->value);
+        }
+        else if (!strcasecmp (v->name, "callerid")) {
+            if (save_strdup (&phone->callerid, v->value))
+                return 1;
+        }
+        else if (!strcasecmp (v->name, "disallow")) {
+            ast_parse_allow_disallow (&phone->codec_prefs, &phone->allowed_codecs, v->value, DISALLOW);
+        }
+        else if (!strcasecmp (v->name, "allow")) {
+            ast_parse_allow_disallow (&phone->codec_prefs, &phone->allowed_codecs, v->value, ALLOW);
+        }
+        else if (!strcasecmp (v->name, "is_mapped_trunk")) {
+            phone->is_mapped_trunk = ast_true(v->value) ? True : False;
+        }
+        else if (!strcasecmp (v->name, "echocan")) {
+            phone->echocan.echocan_ctrl = strtoul (v->value, NULL, 0);
+        }
+        else if (!strcasecmp (v->name, "dualfilterechocan")) {
+            phone->echocan.dfec_ctrl = strtoul (v->value, NULL, 0);
+        }
+        else if (!strcasecmp(v->name, "dfec_tune_config")) {
+                if(!strcasecmp(v->value, "Config")) {
+                    if (!dfecparams_config_validate (v, &phone->echocan))
+                        phone->echocan.dfectune_default = False;
+                    else
+                        phone->echocan.dfectune_default = True;
+                }
+                else
+                    phone->echocan.dfectune_default = True;
+        }
+        else if (!strcasecmp (v->name, "enh_echocan")) {
+            phone->echocan.enh_echocan_ctrl = strtoul (v->value, NULL, 0);
+        }
+        else if (!strcasecmp (v->name, "ud_enable")) {
+            phone->ud_enable = ast_true(v->value) ? True : False;
+        }
+        else if (!strcasecmp (v->name, "dialout_number")) {
+            phone->dialout_number = strtoul (v->value, NULL, 0);
+        }
+        else if (!strcasecmp (v->name, "dsp_acp")) {
+            phone->dsp_acp = ast_true(v->value) ? True : False;
+        }
+        else if(!strcasecmp(v->name, "vad")) {
+            phone->vad = ast_true(v->value) ? True : False;
+        }
+        else if (!strcasecmp(v->name,"wideband")) {
+            phone->wideband = ast_true(v->value);
+        }
+        else if(!strcasecmp(v->name, "bwe_master")) {
+            cfg_bwe_master = ast_true(v->value) ? True : False;
+        }
+        else if (!strcasecmp (v->name, "bwe_high_band")) {
+            cfg_bwe_high_band = strtoul (v->value, NULL, 0);
+        }
+        else if (!strcasecmp (v->name, "bwe_low_band")) {
+            cfg_bwe_low_band = strtoul (v->value, NULL, 0);
+        }
+        else {
+            MSPD_ERR("Unknown field \"%s\" in [%s]\n", v->name, cat);
+        }
+    }
+
+    if(!phone->bwe.bwe_master) {
+        bwe_apply = True;
+    }
+
+    if(cfg_bwe_master == -1) {
+        if(!phone->bwe.bwe_master && gphone->bwe.bwe_master)
+            bwe_apply = True;
+        phone->bwe.bwe_master = gphone->bwe.bwe_master;
+    }
+    else {
+        if(!phone->bwe.bwe_master && cfg_bwe_master)
+            bwe_apply = True;
+        phone->bwe.bwe_master = cfg_bwe_master;
+    }
+
+    if (cfg_bwe_high_band == -1)
+        cfg_bwe_high_band = gphone->bwe.bwe_high_band;
+    if (cfg_bwe_high_band > BWE_HIGH_BAND_MAX)
+        cfg_bwe_high_band = BWE_HIGH_BAND_MAX;
+
+    if (cfg_bwe_low_band == -1)
+        cfg_bwe_low_band = gphone->bwe.bwe_low_band;
+    if (cfg_bwe_low_band > BWE_LOW_BAND_MAX)
+        cfg_bwe_low_band = BWE_LOW_BAND_MAX;
+
+    if (cfg_bwe_high_band != phone->bwe.bwe_high_band)
+        bwe_apply = True;
+    if (cfg_bwe_low_band != phone->bwe.bwe_low_band)
+        bwe_apply = True;
+
+    phone->bwe.bwe_high_band = cfg_bwe_high_band;
+    phone->bwe.bwe_low_band = cfg_bwe_low_band;
+
+    //If no codecs have been defined, we use global preferences
+    if (!phone->allowed_codecs) {
+	char buf[256];
+        memcpy(&phone->codec_prefs, &gphone->codec_prefs, sizeof(mspd_codec_pref));
+        phone->allowed_codecs = gphone->allowed_codecs;
+        MSPD_WARN (5, "Setting allowed codecs by phone defaults %s\n",
+                ast_getformatname_multiple(buf, sizeof(buf), phone->allowed_codecs));
+    }
+
+    if (!phone->name) {
+        MSPD_ERR("Phone has no name\n");
+        return 1;
+    }
+
+    if (!phone->bus) {
+        MSPD_ERR("Phone %s has no TDM-bus\n", phone->name);
+        return 1;
+    }
+
+    if (phone->bus->is_trunk)
+    {
+        MSPD_ERR("TDM-bus of phone %s is a trunk, this is not valid\n", phone->name);
+        return 1;
+    }
+
+    if (!(phone->allowed_codecs & mspd_global.global_phone.allowed_codecs))
+    {
+        char buf1[256], buf2[256];
+       MSPD_ERR("Codecs specified for phone %s is not globally allowed "
+                "(specified codecs=%s, globally supported=%s)\n", phone->name,
+                ast_getformatname_multiple (buf1, sizeof (buf1), phone->allowed_codecs),
+                ast_getformatname_multiple (buf2, sizeof (buf2), mspd_global.global_phone.allowed_codecs));
+        return 1;
+    }
+
+    if (phone->line && phone->line->channel) {
+        mspd_channel_t *channel = phone->line->channel;
+        mspd_channel_type_t  type = mspd_channel_get_type(channel);
+        switch (type) {
+            case MCT_VOIP:
+                if (mspd_channel_bwe_manager(channel, phone->wideband, NoBand, &phone->bwe, bwe_apply))
+                    MSPD_ERR("%s: Sending enabling BWE to channel %s failed\n",
+                        phone->line->name, mspd_channel_get_name(channel));
+                break;
+
+            case MCT_PART_TDM:
+            {
+                mspd_channel_pvt_t *pvt = mspd_channel_get_pvt(channel);
+                mspd_conference_t *conference = pvt->part.conference;
+                if (mspd_channel_bwe_manager(channel, phone->wideband, mspd_conference_get_mixer(conference), &phone->bwe, bwe_apply))
+                    MSPD_ERR("%s: Sending enabling BWE to channel %s failed\n",
+                        phone->line->name, mspd_channel_get_name(channel));
+                break;
+            }
+            default:
+                break;
+        }
+    }
+
+    return 0;
+
+bus_first:
+    MSPD_ERR("(%s): 'tdmbus' of phone needs to be defined before '%s'\n", phone->name, v->value);
+
+    return 1;
+}
+
+// -----------------------------------------------------------------------------------------------
+// Handles [ud_info] configuration
+int
+config_ud_info (struct ast_config *cfg, char *cat)
+{
+    struct ast_variable *v;
+
+    MSPD_LOG(2, "Reading Unified Diagnostic configuration\n");
+
+    for (v = ast_variable_browse (cfg, cat); v; v = v->next) {
+        if (!strcasecmp(v->name, "ud_enable")) {
+            mspd_global.ud_prefs.ud_enable_supvsr = ast_true(v->value) ? True : False;
+        }
+        else if (!strcasecmp(v->name, "ud_dest_ip_addr")) {
+            if (ast_parse_arg(v->value, PARSE_ADDR, &mspd_global.ud_prefs)) {
+                ast_log(LOG_ERROR, "Invalid address: %s\n", v->value);
+                mspd_global.ud_prefs.is_ud_info_set = False;
+                return 1;
+            }
+            mspd_global.ud_prefs.is_ud_info_set = True;
+        }
+        else if (!strcasecmp(v->name, "ud_src_port")) {
+            mspd_global.ud_prefs.ud_src_portno = atoi(v->value);
+        }
+        else if (!strcasecmp(v->name, "ud_dest_port")) {
+            mspd_global.ud_prefs.ud_dest_portno = atoi(v->value);
+        }
+        else if (!strcasecmp(v->name, "ud_tdm_tx")) {
+                mspd_global.ud_prefs.ud_enable_tdm_tx = ast_true(v->value) ? True : False;
+        }
+        else if (!strcasecmp(v->name, "ud_tdm_rx")) {
+                mspd_global.ud_prefs.ud_enable_tdm_rx = ast_true(v->value) ? True : False;
+        }
+        else if (!strcasecmp(v->name, "ud_pkt_tx")) {
+                mspd_global.ud_prefs.ud_enable_pkt_tx = ast_true(v->value) ? True : False;
+        }
+        else if (!strcasecmp(v->name, "ud_pkt_rx")) {
+                mspd_global.ud_prefs.ud_enable_pkt_rx = ast_true(v->value) ? True : False;
+        }
+        else if (!strcasecmp(v->name, "ud_report_cmd")) {
+                mspd_global.ud_prefs.ud_enable_report_cmd = ast_true(v->value) ? True : False;
+        }
+        else if (!strcasecmp(v->name, "ud_spu_instream")) {
+                mspd_global.ud_prefs.ud_enable_spu_in = ast_true(v->value) ? True : False;
+        }
+        else if (!strcasecmp(v->name, "ud_spu_outstream")) {
+                mspd_global.ud_prefs.ud_enable_spu_out = ast_true(v->value) ? True : False;
+        }
+        else if (!strcasecmp(v->name, "ud_spu_io_params")) {
+                mspd_global.ud_prefs.ud_enable_spu_io_params = ast_true(v->value) ? True : False;
+        }
+        else {
+            MSPD_ERR("Unknown field \"%s\" in [%s]\n", v->name, cat);
+        }
+    }//for(...)
+
+    MSPD_LOG(3, "UD-Enable:%d\tUD-Src-Port:%d"
+                "\tUD-Dest-Port:%d UD-Dest-Ip:%s\n",
+                mspd_global.ud_prefs.ud_enable_supvsr,
+                mspd_global.ud_prefs.ud_src_portno,
+                mspd_global.ud_prefs.ud_dest_portno,
+                ast_sockaddr_stringify(&mspd_global.ud_prefs.ud_dest_ipaddr));
+
+    //?? ast_sockaddr_stringify_port(const struct ast_sockaddr *addr)
+
+     MSPD_LOG(3, "UD Options:\n"
+                "\ttdm_tx=%d\ttdm_rx=%d\n"
+                "\tpkt_tx=%d\tpkt_rx=%d\n"
+                "\tspu_in=%d\tspu_out=%d\n"
+                "\tspu_io_param=%d\n"
+                "\tud_report_cmd=%d\n",
+                mspd_global.ud_prefs.ud_enable_tdm_tx,
+                mspd_global.ud_prefs.ud_enable_tdm_rx,
+                mspd_global.ud_prefs.ud_enable_pkt_tx,
+                mspd_global.ud_prefs.ud_enable_pkt_rx,
+                mspd_global.ud_prefs.ud_enable_spu_in,
+                mspd_global.ud_prefs.ud_enable_spu_out,
+                mspd_global.ud_prefs.ud_enable_spu_io_params,
+                mspd_global.ud_prefs.ud_enable_report_cmd);
+
+    return 0;
+}
+
+static int
+reload_config (enum channelreloadreason reason)
+{
+    struct ast_config *cfg;
+    char *cat = NULL;
+    int has_failed = 0;
+    int i;
+
+    struct ast_flags config_flags = { reason == CHANNEL_MODULE_LOAD ? 0 : CONFIG_FLAG_FILEUNCHANGED };
+
+    if (!(cfg = ast_config_load (MSPD_CONFIG_FILE, config_flags)) || cfg == CONFIG_STATUS_FILEINVALID) {
+        MSPD_ERR("Unable to load config \"%s\"\n", MSPD_CONFIG_FILE);
+        goto bail_out;
+    } else if (cfg == CONFIG_STATUS_FILEUNCHANGED)
+        return 0;
+
+    MSPD_LOG(2, "Reading the config file %s\n", MSPD_CONFIG_FILE);
+
+    memset (&mspd_global, 0, sizeof (mspd_global));
+
+    /*Global Defaults*/
+    if (save_strdup (&mspd_global.context, "default"))
+        goto bail_out;
+
+
+    mspd_global.pickup_groups      = ast_get_group (DEF_PICKUP_GROUP);
+    mspd_global.call_groups        = ast_get_group (DEF_CALL_GROUP);
+
+    ast_parse_allow_disallow (&mspd_global.codec_prefs,
+                              &mspd_global.global_phone.allowed_codecs,
+                              DEF_ALLOWED_CODECS,
+                              ALLOW);
+
+    mspd_global.interdigit_timeout = DEF_INTER_DIGIT_TIMEOUT;
+    mspd_global.dial_timeout       = DEF_DIAL_TIMEOUT;
+    mspd_global.fxo_call_delay     = DEF_FXO_CALL_DELAY;
+
+    /*Unidiag defaults*/
+    mspd_global.ud_prefs.ud_enable_supvsr = False;
+    ast_parse_arg(DEF_UD_IP_ADDR, PARSE_ADDR, &mspd_global.ud_prefs.ud_dest_ipaddr);
+    mspd_global.ud_prefs.ud_src_portno =    DEF_UD_SRC_PORT;
+    mspd_global.ud_prefs.ud_dest_portno =   DEF_UD_DST_PORT;
+
+    mspd_global.ec_type_prev = EC_TYPE_STD;
+
+    /*tdm bus defaults*/
+    for (i = 0;i < MSPD_MAX_BUSES; i++ )
+    {
+        mspd_bus_t *bus = mspd_global.buses + i;
+        mspd_device_t *dev = mspd_device_find_by_index(0);
+
+        memset (bus, 0, sizeof (mspd_bus_t));
+
+        if (save_strdup (&bus->name, DEF_TDMBUS_NAME))
+            return 1;
+        bus->dev = dev;
+
+        bus->n_lines  = DEF_BUS_NUMBER_OF_LINES;
+        bus->is_trunk = DEF_BUS_IS_TRUNK;
+    }
+
+    {
+        /*Echocan defaults*/
+        mspd_echocan_t *echocan = &mspd_global.global_echocan;
+
+        echocan->echocan_ctrl = DEF_ECHOCAN_CTRL;
+        echocan->enh_echocan_ctrl = DEF_ENH_ECHOCAN_CTRL;
+        echocan->dfec_ctrl = DEF_DFEC_CTRL;
+        echocan->dfectune_default = True; //Default
+
+        /*Default DFEC tune config */
+        echocan->dfectune_params.ec_tx_in_scf_frc    = DEF_EC_TX_IN_SCF_FRC;
+        echocan->dfectune_params.ec_tx_in_scf_int    = DEF_EC_TX_IN_SCF_INT;
+        echocan->dfectune_params.ec_tx_flt_coef      = DEF_EC_TX_FLT_COEF;
+        echocan->dfectune_params.ec_tx_det_thr_le    = DEF_EC_TX_DET_THR_LE;
+        echocan->dfectune_params.ec_tx_out_scf_frc   = DEF_EC_TX_OUT_SCF_FRC;
+        echocan->dfectune_params.ec_tx_out_scf_int   = DEF_EC_TX_OUT_SCF_INT;
+        echocan->dfectune_params.ec_rx_in_scf_frc    = DEF_EC_RX_IN_SCF_FRC;
+        echocan->dfectune_params.ec_rx_in_scf_int    = DEF_EC_RX_IN_SCF_INT;
+        echocan->dfectune_params.ec_rx_flt_coef      = DEF_EC_RX_FLT_COEF;
+        echocan->dfectune_params.ec_rx_det_thr       = DEF_EC_RX_DET_THR;
+        echocan->dfectune_params.ec_rx_out_scf_frc   = DEF_EC_RX_OUT_SCF_FRC;
+        echocan->dfectune_params.ec_rx_out_scf_int   = DEF_EC_RX_OUT_SCF_INT;
+        echocan->dfectune_params.ec_minerl           = DEF_EC_MINERL;
+        echocan->dfectune_params.ec_db_hng_reset     = DEF_EC_DB_HNG_RESET;
+        echocan->dfectune_params.ec_db_adj           = DEF_EC_DB_ADJ;
+        echocan->dfectune_params.ec_nl_hng           = DEF_EC_NL_HNG;
+        echocan->dfectune_params.ec_nl_hng_se        = DEF_EC_NL_HNG_SE;
+        echocan->dfectune_params.ec_nl_inc           = DEF_EC_NL_INC;
+        echocan->dfectune_params.ec_nl_inc_se        = DEF_EC_NL_INC_SE;
+        echocan->dfectune_params.ec_flt_res_sme_nl   = DEF_EC_FLT_RES_SME_NL;
+        echocan->dfectune_params.ec_flt_cng_sme_nl   = DEF_EC_FLT_CNG_SME_NL;
+        echocan->dfectune_params.ec_tx_out_thr_dbt_nl= DEF_EC_TX_OUT_THR_DBT_NL;
+        echocan->dfectune_params.ec_tx_out_thr_min_nl= DEF_EC_TX_OUT_THR_MIN_NL;
+        echocan->dfectune_params.ec_tx_out_pscf_nl   = DEF_EC_TX_OUT_PSCF_NL;
+        echocan->dfectune_params.ec_tx_c3_nl         = DEF_EC_TX_C3_NL;
+        echocan->dfectune_params.ec_tx_c4_nl         = DEF_EC_TX_C4_NL;
+        echocan->dfectune_params.ec_tx_nos_scf_nl    = DEF_EC_TX_NOS_SCF_NL;
+        echocan->dfectune_params.ec_tx_scf_max_nl    = DEF_EC_TX_SCF_MAX_NL;
+        echocan->dfectune_params.ec_tx_out_pwr_adj_nl= DEF_EC_TX_OUT_PWR_ADJ_NL;
+        echocan->dfectune_params.ec_tx_out_thr_del_nl= DEF_EC_TX_OUT_THR_DEL_NL;
+        echocan->dfectune_params.ec_nlp_off_inc      = DEF_EC_NLP_OFF_INC;
+        echocan->dfectune_params.ec_flt_chk_rst1     = DEF_EC_FLT_CHK_RST1;
+        echocan->dfectune_params.ec_flt_rin_min      = DEF_EC_FLT_RIN_MIN;
+        echocan->dfectune_params.ec_flt_thr1         = DEF_EC_FLT_THR1;
+        echocan->dfectune_params.ec_flt_scf1         = DEF_EC_FLT_SCF1;
+        echocan->dfectune_params.ec_flt_scf2         = DEF_EC_FLT_SCF2;
+        echocan->dfectune_params.ec_flt_epc3         = DEF_EC_FLT_EPC3;
+        echocan->dfectune_params.ec_flt_scf3         = DEF_EC_FLT_SCF3;
+        echocan->dfectune_params.ec_flt_thr4         = DEF_EC_FLT_THR4;
+        echocan->dfectune_params.ec_flt_thr2         = DEF_EC_FLT_THR2;
+        echocan->dfectune_params.ec_flt_cnt3         = DEF_EC_FLT_CNT3;
+        echocan->dfectune_params.ec_flt_scf4         = DEF_EC_FLT_SCF4;
+        echocan->dfectune_params.ec_flt_scf5         = DEF_EC_FLT_SCF5;
+        echocan->dfectune_params.ec_flt_nos_scf_min  = DEF_EC_FLT_NOS_SCF_MIN;
+        echocan->dfectune_params.ec_dat_rx_scf_min_st= DEF_EC_DAT_RX_SCF_MIN_ST;
+        echocan->dfectune_params.ec_dat_rese_lev     = DEF_EC_DAT_RESE_LEV;
+        echocan->dfectune_params.ec_dat_rese_dt_lev  = DEF_EC_DAT_RESE_DT_LEV;
+        echocan->dfectune_params.ec_dat_rx_lev       = DEF_EC_DAT_RX_LEV;
+        echocan->dfectune_params.ec_dat_tx_lev       = DEF_EC_DAT_TX_LEV;
+        echocan->dfectune_params.ec_tx_det_thr_se    = DEF_EC_TX_DET_THR_SE;
+        echocan->dfectune_params.ec_tx_out_thr_min_nl2 = DEF_EC_TX_OUT_THR_MIN_NL2;
+        echocan->dfectune_params.ec_tx_out_min_tx_nl2= DEF_EC_TX_OUT_MIN_TX_NL2;
+        echocan->dfectune_params.ec_tx_out_inc_nl2   = DEF_EC_TX_OUT_INC_NL2;
+        echocan->dfectune_params.ec_tx_out_cnt_rst_nl2 = DEF_EC_TX_OUT_CNT_RST_NL2;
+        echocan->dfectune_params.ec_dat_rx_mxl       = DEF_EC_DAT_RX_MXL;
+        echocan->dfectune_params.ec_flt_rxm_sme_nl   = DEF_EC_FLT_RXM_SME_NL;
+        echocan->dfectune_params.ec_dat_rx_scf_min_dt= DEF_EC_DAT_RX_SCF_MIN_DT;
+        echocan->dfectune_params.ec_tx_acom_nl       = DEF_EC_TX_ACOM_NL;
+        echocan->dfectune_params.ec_tx_rlim_nl       = DEF_EC_TX_RLIM_NL;
+        echocan->dfectune_params.ec_max_noise        = DEF_EC_MAX_NOISE;
+
+    }
+
+    /*global phone defaults*/
+    {
+        mspd_phone_t *gphone =  &mspd_global.global_phone;
+        mspd_echocan_t *echocan = &mspd_global.global_echocan;
+        mspd_bwe_t bwe = {False, False, BWE_NO_ENCHANCEMENT, DEF_BWE_HIGH_BAND, DEF_BWE_LOW_BAND};
+
+        ast_parse_allow_disallow (&gphone->codec_prefs,
+                                  &gphone->allowed_codecs,
+                                  DEF_ALLOWED_CODECS,
+                                  ALLOW);
+
+        memcpy(&gphone->echocan, echocan, sizeof(mspd_echocan_t));
+        memcpy(&gphone->bwe, &bwe, sizeof(mspd_bwe_t));
+        gphone->wideband     = mspd_global_get_wideband();
+        gphone->dsp_acp      = DEF_DSP_ACP;
+        gphone->vad          = DEF_VAD;
+        gphone->ud_enable    = DEF_UD_ENABLE;
+    }
+
+    /*phone defaults*/
+    for ( i = 0; i < MSPD_MAX_PHONES; i++ )
+    {
+        mspd_phone_t *gphone =  &mspd_global.global_phone;
+        mspd_phone_t *phone =  mspd_global.phones + i;
+        char name[20];
+
+        memset (phone, 0, sizeof (*phone));
+
+        sprintf (name,"%s%d",DEF_ANALOG_PHONE_NAME, i);
+        if (save_strdup (&phone->name, name ))
+            return 1;
+
+        /* copy echocan related */
+        memcpy(&phone->echocan, &gphone->echocan, sizeof(mspd_echocan_t));
+        memcpy(&phone->bwe,     &gphone->bwe,     sizeof(mspd_bwe_t));
+
+        phone->wideband      = gphone->wideband;
+        phone->dsp_acp       = gphone->dsp_acp;
+        phone->vad           = gphone->vad;
+        phone->ud_enable     = gphone->ud_enable;
+    }
+
+    //while (!has_failed && (cat = ast_category_browse (cfg, cat))) {
+    while ((cat = ast_category_browse (cfg, cat))) {
+        //ast_verbose("\n\nRELOAD CONFIG -----> CAT: %s\n", cat);
+        if      (!strcasecmp (cat, "global"))   has_failed = config_global  (cfg, cat);
+        else if (!strcasecmp (cat, "tdmbus"))   has_failed = config_tdmbus  (cfg, cat);
+        else if (!strcasecmp (cat, "echocan_settings"))    has_failed = config_echocan_settings   (cfg, cat);
+        else if (!strcasecmp (cat, "phone_settings"))    has_failed = config_phone_settings   (cfg, cat);
+        else if (!strcasecmp (cat, "phone"))    has_failed = config_phone   (cfg, cat);
+        else if (!strcasecmp (cat, "ud_info"))  has_failed = config_ud_info (cfg, cat);
+        else if (!strcasecmp (cat, "device"))   has_failed = 0;
+        else {
+            MSPD_ERR("Unknown category [%s]\n", cat);
+            has_failed = 1;
+        }
+        if (has_failed)
+            ast_verbose("We have some problems in category [%s]\n", cat);
+    }
+    ast_config_destroy (cfg);
+
+    if (has_failed) {
+        MSPD_ERR("Some configurations were not set correctly\n");
+        //goto bail_out;
+    }
+
+    return 0;
+
+bail_out:
+    return -1;
+}
+
+// -----------------------------------------------------------------------------------------------
+// Helpers
+// -----------------------------------------------------------------------------------------------
+// Asterisk module-function to get use-count of module
+int
+usecount (void)
+{
+    int rc;
+
+    MSPD_LOCK (use_count_lock, return use_count);
+    rc = use_count;
+    MSPD_UNLOCK (use_count_lock);
+
+    return rc;
+}
+
+// -----------------------------------------------------------------------------------------------
+
+void
+mspd_update_use_count (Boolean UP){
+    MSPD_LOCK (use_count_lock, /*ignore */ );
+    if (UP)
+        use_count++;
+    else
+        if (--use_count < 0)
+            MSPD_ERR("Module use_count < 0\n");
+    MSPD_UNLOCK (use_count_lock);
+
+    ast_update_use_count ();
+}
+
+
+// -----------------------------------------------------------------------------------------------
+// Asterisk module-function to get description of module
+char *
+description (void)
+{
+    return (char *) chan_tdesc;
+}
+
+// -----------------------------------------------------------------------------------------------
+// Asterisk module-function to get key of module (for modules that need license)
+char *
+key (void)
+{
+    return ASTERISK_GPL_KEY;
+}
+
+// -----------------------------------------------------------------------------------------------
+int
+parse_ipaddr (uint32_t * ip, struct ast_variable *v)
+{
+    struct in_addr addr;
+    if (!inet_aton (v->value, &addr)) {
+        MSPD_ERR("%s=%s is invalid\n", v->name, v->value);
+        return 1;
+    }
+    *ip = addr.s_addr;
+
+    return 0;
+}
+
+// -----------------------------------------------------------------------------------------------
+void
+ast_set_fxo_ext (void)
+{
+    memset(fxo_ext, 0, AST_MAX_EXTENSION);
+    strcpy(fxo_ext, "9");
+}
+
+// -----------------------------------------------------------------------------------------------
+char *
+ast_fxo_ext (void)
+{
+    return fxo_ext;
+}
+
+// ===============================================================================================
+// Asterisk CLI
+
+// -----------------------------------------------------------------------------------------------
+char *
+mspd_cli_show_phone_conf (struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
+{
+    mspd_phone_t *phone;
+    int i;
+    char buf1[256] = {0};
+
+    switch (cmd) {
+    case CLI_INIT:
+        e->command = "mspd show phone conf";
+        e->usage   = "Usage: mspd show phone conf\n"
+                     "       Shows phone configuration of mspd.conf file";
+        return NULL;
+    case CLI_GENERATE:
+        return NULL;
+    }
+
+    if (a->argc < 4)
+        return CLI_SHOWUSAGE;
+
+    ast_cli(a->fd, "\n\t : ==== MSPD Phones configuration ====\n\n");
+    ast_cli(a->fd, "\t : --- %d Phones found ---\n", mspd_global.n_phones);
+    for (i = 0; i < mspd_global.n_phones; i++) {
+        memset(buf1, 0, sizeof (buf1));
+        phone=&(mspd_global.phones[i]);
+        ast_cli(a->fd, "\t : Name=%s Line=%s {Bus=%s, Mode=%s, ",
+                        phone->name,
+                        phone->line ? phone->line->name : "no",
+                        phone->bus ? phone->bus->name : "no",
+                        phone->wideband ? "WB" : "NB");
+
+        if (phone->wideband)
+            ast_cli(a->fd, "TS={%d,%d,%d,%d}, DSP_on_ACP=%d}\n",
+                phone->timeslot * 2,
+                phone->timeslot * 2 + 1,
+                phone->timeslot * 2 + 16,
+                phone->timeslot * 2 + +16 + 1,
+                phone->dsp_acp);
+        else
+            ast_cli(a->fd, "TS=%d, DSP_on_ACP=%d}\n",
+                                phone->timeslot,
+                                phone->dsp_acp);
+
+            ast_cli(a->fd, "\t :      Allowed=%s\n",
+                        ast_getformatname_multiple (buf1, sizeof (buf1), phone->allowed_codecs));
+
+        if (!strstr(phone->name, "FXO")) // FXO port does not support Wide band mode
+            ast_cli(a->fd, "\t :      BWE(%s)={Master %s, high=%d, low=%d}\n",
+                phone->bwe.is_bwe_enabled ? "+" : "-",
+                phone->bwe.bwe_master ? "on" : "off",
+                phone->bwe.bwe_high_band,
+                phone->bwe.bwe_low_band);
+    }
+    return 0;
+}
+
+// -----------------------------------------------------------------------------------------------
+char *
+mspd_cli_show_global_conf (struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
+{
+    char buf1[256] = {0};
+
+    switch (cmd) {
+    case CLI_INIT:
+        e->command = "mspd show global conf";
+        e->usage   = "Usage: mspd show global conf\n"
+                     "       Shows channel module global configuration";
+        return NULL;
+    case CLI_GENERATE:
+        return NULL;
+    }
+
+    if (a->argc < 4)
+        return CLI_SHOWUSAGE;
+
+    ast_cli(a->fd,  "\n\t : ==== MSPD Global configuration ====\n\n"
+                    "\t : Allowed Codecs      = %s \n",
+                    ast_getformatname_multiple (buf1, sizeof (buf1),
+                    mspd_global.global_phone.allowed_codecs));
+
+    if (mspd_global.global_phone.allowed_codecs & AST_FORMAT_AMR)
+        ast_cli(a->fd, "\t : AMR    bitrate      = %d \n",
+                    mspd_global_get_bitrate_amr());
+
+    if (mspd_global.global_phone.allowed_codecs & AST_FORMAT_AMR_WB)
+        ast_cli(a->fd, "\t : AMR-WB bitrate      = %d \n",
+                    mspd_global_get_bitrate_amr_wb());
+
+    ast_cli(a->fd,  "\t : Number of Phones    = %d \n"
+                    "\t : Dialplan-Context    = %s \n"
+                    "\t : Flash button mode   = %s \n"
+                    "\t : VoIP call band      = %s \n"
+                    "\t : Three-way call band = %s \n"
+                    "\t : Interdigit-timeout  = %d \n"
+                    "\t : Dial-timeout        = %d \n"
+                    "\t : Fax mode            = %s \n"
+                    "\t : RTP cut-through     = %s \n",
+                    mspd_global.n_phones,
+                    mspd_global.context,
+                    mspd_global.flash_mode == THREEWAYCALL ? "Three-way calling" : "Call switching",
+                    mspd_global_get_wideband() ? "Wide" : "Narrow",
+                    mspd_global.threeway_band == Narrow ? "Narrow" : "Wide",
+                    mspd_global.dial_timeout,
+                    mspd_global.interdigit_timeout,
+                    mspd_global_fax_mode_to_string(mspd_global_get_fax_mode()),
+                    mspd_global_is_rtp_ct_mode() ? "Enabled" : "Disabled");
+
+    mspd_bwe_t *rsp_bwe = mspd_global_get_rsp_bwe();
+    if (rsp_bwe->bwe_master)
+        ast_cli(a->fd, "\t : RSP BWE Enabled     = %s \n"
+                       "\t : RSP BWE High band   = %d \n"
+                       "\t : RSP BWE Low  band   = %d \n",
+                       "yes",
+                       rsp_bwe->bwe_high_band,
+                       rsp_bwe->bwe_low_band);
+    else
+        ast_cli(a->fd, "\t : RSP BWE Enabled     = %s \n",
+                       "no");
+
+    return RESULT_SUCCESS;
+}
+
+// -----------------------------------------------------------------------------------------------
+
+#ifdef MSPD_DEBUG
+char *
+mspd_cli_show_lines_state (struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
+{
+    int i, j;
+    mspd_bus_t  *bus;
+    mspd_line_t *line;
+
+    switch (cmd) {
+    case CLI_INIT:
+        e->command = "mspd show lines state";
+        e->usage   = "Usage: mspd show lines state\n"
+                     "       Shows current states of all channel module lines";
+        return NULL;
+    case CLI_GENERATE:
+        return NULL;
+    }
+
+    if (a->argc < 4)
+        return CLI_SHOWUSAGE;
+
+    for (i = 0; i < mspd_global.n_buses; i++) {
+        bus = &(mspd_global.buses[i]);
+        ast_cli(a->fd, "\nBus%u: name=%s tdm=0x%x lines=%d trunk=%s context=%s\n\n",
+                i, bus->name,
+                bus->tdm,
+                bus->n_lines,
+                (bus->is_trunk) ? "yes" : "no",
+                bus->context);
+
+        for (j = 0; j < bus->n_lines; j++) {
+            line = bus->lines + j;
+            ast_cli(a->fd, " Line%u: Name=%s TS=%-3d State=%-15s Phone=%-6s Timer=%-3d Owner=%-20s Channel=%s\n",
+                    j,
+                    line->name,
+                    (line->timeslot == MAX_TIMESLOT_NUMBER) ? -1 : line->timeslot,
+                    sl_show_line_state(line),
+                    (line->phone) ? line->phone->name : "no",
+                    (line->state == MLS_IDLE) ? -1 :
+                    (line->state == MLS_DIALING_0) ? line->dial_timer_id : line->interdigit_timer_id,
+                    (line->owner) ? line->owner->name : "no",
+                    (line->channel) ? mspd_channel_get_name(line->channel) : "no");
+            ast_cli(a->fd, "      : Wait=%s     onHold=%s",
+                     line->is_call_wait    ? "yes" : "no",
+                     line->is_call_on_hold ? "yes" : "no");
+            if (line->is_call_wait || line->is_call_on_hold) {
+                ast_cli(a->fd, " | SUB_Real=%s,  SUB_Wait=%s\n",
+                    (line->subline[SUB_REAL].subline_owner) ?
+                     line->subline[SUB_REAL].subline_owner->name : "no",
+                    (line->subline[SUB_CALLWAIT].subline_owner) ?
+                     line->subline[SUB_CALLWAIT].subline_owner->name : "no");
+            }
+            else
+                ast_cli(a->fd, "\n");
+        }
+    }
+    return 0;
+}
+
+// -----------------------------------------------------------------------------------------------
+char *
+mspd_cli_reload_lines (struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
+{
+    int index = 0;
+    int i = 0;
+
+    switch (cmd) {
+    case CLI_INIT:
+        e->command = "mspd reload lines";
+        e->usage   = "Usage: mspd reload lines\n"
+                     "       Re-initializes channel module lines";
+        return NULL;
+    case CLI_GENERATE:
+        return NULL;
+    }
+
+    if (a->argc < 3)
+        return CLI_SHOWUSAGE;
+
+    ast_cli(a->fd, "--- Reloading MSPD lines ---\n\n");
+
+    MSPD_LOCK (mspd_global.lock, return CLI_FAILURE);
+    for (index = 0; index < mspd_global.n_buses; index++) {
+        mspd_bus_t *bus = mspd_global.buses + index;
+
+        ast_cli(a->fd, "\nBus %s with %d lines found.\n", bus->name, bus->n_lines);
+        for (i = 0; i < bus->n_lines; ++i) {
+            mspd_line_t *line = bus->lines + i;
+            ast_cli(a->fd, "\tResetting line  %s\n", line->name);
+
+            MSPD_LOCK(line->lock, return NULL);
+            if (line->owner) {
+                sl_do_ast_channel_action(line, &line->owner, mspd_hangup_ast_channel, NULL);
+                line->owner = NULL;
+            }
+
+            if (line->channel) {
+                mspd_channel_destroy(line->channel);
+                line->channel = NULL;
+            }
+
+            if (line->intern_rtp) {
+                ast_rtp_instance_destroy(line->intern_rtp);
+                line->intern_rtp = NULL;
+                line->subline[SUB_REAL].rtp = NULL;
+            }
+
+            if (line->subline[SUB_CALLWAIT].rtp) {
+                ast_rtp_instance_destroy(line->subline[SUB_CALLWAIT].rtp);
+                line->subline[SUB_CALLWAIT].rtp = NULL;
+            }
+
+            sl_set_line_state(line, MLS_IDLE);
+            line->timeslot          = MAX_TIMESLOT_NUMBER;
+            line->is_native_bridged = False;
+            line->phone             = NULL;
+            line->dialed[0]         = '\0';
+            line->link_id           = 0;
+
+            if (line->dial_timer_id)
+                line->dial_timer_id = ast_sched_del(sched, line->dial_timer_id);
+            line->dial_timer_id = 0;
+            if (line->interdigit_timer_id)
+                line->interdigit_timer_id = ast_sched_del(sched, line->interdigit_timer_id);
+            line->interdigit_timer_id = 0;
+
+            line->is_call_wait = False;
+            line->is_call_on_hold = False;
+            sl_clear_subline (line, SUB_REAL);
+            sl_clear_subline (line, SUB_CALLWAIT);
+            MSPD_UNLOCK(line->lock);
+        }
+    }
+    MSPD_UNLOCK (mspd_global.lock);
+
+    return 0;
+}
+
+#endif
+
+char *
+mspd_cli_count_active_lines (struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
+{
+    switch (cmd) {
+       case CLI_INIT:
+           e->command = "mspd count active lines";
+           e->usage   = "Usage: mspd count active lines\n"
+                        "       Counts non IDLE channel module lines";
+           return NULL;
+       case CLI_GENERATE:
+           return NULL;
+       }
+
+       if (a->argc < 4)
+           return CLI_SHOWUSAGE;
+
+    ast_cli(a->fd, " No of lines active: %d \n", mspd_count_active_lines());
+    return CLI_SUCCESS;
+}
+
+int
+mspd_count_active_lines ()
+{
+    int i, j;
+    mspd_bus_t  *bus;
+    mspd_line_t *line;
+    int count = 0;
+
+    for (i = 0; i < mspd_global.n_buses; i++) {
+        bus = &(mspd_global.buses[i]);
+        for (j = 0; j < bus->n_lines; j++) {
+            line = bus->lines + j;
+                    if(line->state != MLS_IDLE)
+                        count++;
+            }
+        }
+    return count;
+}
+
+// -----------------------------------------------------------------------------------------------
+char *
+mspd_cli_reload_conf (struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
+{
+    int i;
+    int has_failed = 0;
+    int prev_val   = 0;
+    char *cat = NULL;
+    struct ast_config *cfg;
+    mspd_ud_pref_t *prev_ud_pref = NULL;
+    char* res = CLI_FAILURE;
+
+    switch (cmd) {
+    case CLI_INIT:
+        e->command = "mspd reload conf";
+        e->usage   = "Usage: mspd reload conf\n"
+                     "       Reloads entire channel module configuration";
+        return NULL;
+    case CLI_GENERATE:
+        return NULL;
+    }
+
+    if (a->argc < 3)
+        return CLI_SHOWUSAGE;
+
+    ast_cli(a->fd,  "--- Reloading configuration ---\n");
+
+    struct ast_flags config_flags = { CONFIG_FLAG_WITHCOMMENTS };
+    //struct ast_flags config_flags = { reason == CHANNEL_MODULE_LOAD ? 0 : CONFIG_FLAG_FILEUNCHANGED };
+
+    if (!(cfg = ast_config_load (MSPD_CONFIG_FILE, config_flags)) || cfg == CONFIG_STATUS_FILEINVALID) {
+        MSPD_ERR("Unable to load config \"%s\"\n", MSPD_CONFIG_FILE);
+        return CLI_FAILURE;
+    } else if (cfg == CONFIG_STATUS_FILEUNCHANGED)
+        return CLI_SUCCESS;
+
+
+    prev_ud_pref = (mspd_ud_pref_t*) malloc(sizeof(mspd_ud_pref_t));
+    if (!prev_ud_pref) {
+        MSPD_ERR("Unable to allocate memory\n");
+	return CLI_FAILURE;
+    } else
+        memcpy(prev_ud_pref, &(mspd_global.ud_prefs), sizeof(mspd_ud_pref_t));
+
+    MSPD_LOCK (mspd_global.lock, goto FAIL);
+
+    prev_val = mspd_global.ud_prefs.ud_enable_supvsr;
+    for (i = 0; i < mspd_global.n_phones; ++i) {
+        mspd_phone_t *phone = &mspd_global.phones[i];
+
+        mspd_line_t *keep_line = phone->line;
+        mspd_bwe_t tmp_bwe;
+        memcpy (&tmp_bwe, &phone->bwe, sizeof(mspd_bwe_t));
+
+        free (phone->name);
+        if (phone->callerid)
+            free (phone->callerid);
+        free (phone->context);
+        memset (phone, 0, sizeof (*phone));
+
+        phone->line = keep_line;
+        memcpy (&phone->bwe, &tmp_bwe, sizeof(mspd_bwe_t));
+    }
+    mspd_global.n_phones = 0;
+    mspd_global.global_phone.allowed_codecs = 0;
+    memset(&(mspd_global.codec_prefs), 0, sizeof(mspd_codec_pref));
+    memset(&(mspd_global.ud_prefs), 0, sizeof(mspd_ud_pref_t));
+    while (!has_failed && (cat = ast_category_browse (cfg, cat))) {
+        if (!strcasecmp (cat, "global"))    has_failed = config_global  (cfg, cat);
+        else if (!strcasecmp (cat, "echocan_settings"))    has_failed = config_echocan_settings   (cfg, cat);
+        else if (!strcasecmp (cat, "phone_settings"))    has_failed = config_phone_settings   (cfg, cat);
+        else if (!strcasecmp (cat, "phone"))     has_failed = config_phone   (cfg, cat);
+        else if (!strcasecmp (cat, "ud_info"))   has_failed = config_ud_info (cfg, cat);
+    }
+    if (has_failed)
+        MSPD_ERR("Error in reloading mspd.conf [%s]\n", cat);
+
+    tempo_reload();
+
+    MSPD_UNLOCK (mspd_global.lock);
+    ast_config_destroy (cfg);
+
+    if (mspd_global_get_ec_type() != mspd_global.ec_type_prev) {
+        if (!mspd_count_active_lines()) {
+            mspd_device_t *dev = mspd_device_find_by_index(0);
+            MSPD_LOCK(mspd_global.lock, goto FAIL);
+            if(mspd_device_set_spu_features_control(dev)) {
+                MSPD_ERR("Error in changing SPU_FEATURES [%s]\n", cat);
+                mspd_global_set_ec_type(mspd_global.ec_type_prev);
+            }
+            else
+                mspd_global.ec_type_prev = mspd_global_get_ec_type();
+            MSPD_UNLOCK(mspd_global.lock);
+        }
+        else {
+            MSPD_ERR("EC type change not allowed when [%d] Active channel(s) are present\n", mspd_count_active_lines());
+            mspd_global_set_ec_type(mspd_global.ec_type_prev);
+        }
+    }
+
+    //unified diagnostics
+    //check the current supvsr-ud-value, if it is set then send ud-enable-cmd
+    //If the current-supvsr-ud-value is not set, check prev value. If prev-val
+    //was set, then send disable ud-trace-supvsr level
+    dc_check_send_ud_cmds_supvsr(prev_ud_pref);
+
+    res = CLI_SUCCESS;
+
+FAIL:
+    free(prev_ud_pref);
+
+    return res;
+}
+
+// -----------------------------------------------------------------------------------------------
+char *
+mspd_cli_reload_phone_conf (struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
+{
+    char *cat = NULL;
+    int i, has_failed = 0;
+    struct ast_config *cfg;
+
+    switch (cmd) {
+    case CLI_INIT:
+        e->command = "mspd reload phone conf";
+        e->usage   = "Usage: mspd reload phone conf\n"
+                     "       Reload phone configuration from mspd.conf file";
+        return NULL;
+    case CLI_GENERATE:
+        return NULL;
+    }
+
+    if (a->argc < 4)
+        return CLI_SHOWUSAGE;
+
+    ast_cli(a->fd, "--- Reloading phone configuration ---\n");
+
+    struct ast_flags config_flags = { CONFIG_FLAG_WITHCOMMENTS };
+    //struct ast_flags config_flags = { reason == CHANNEL_MODULE_LOAD ? 0 : CONFIG_FLAG_FILEUNCHANGED };
+
+    if (!(cfg = ast_config_load (MSPD_CONFIG_FILE, config_flags)) || cfg == CONFIG_STATUS_FILEINVALID) {
+        MSPD_ERR("Unable to load config \"%s\"\n", MSPD_CONFIG_FILE);
+        return CLI_FAILURE;
+    } else if (cfg == CONFIG_STATUS_FILEUNCHANGED)
+        return CLI_SUCCESS;
+
+    MSPD_LOG(1, "no of phones: %d\n",mspd_global.n_phones);
+    MSPD_LOCK (mspd_global.lock, return CLI_FAILURE);
+    for (i = 0; i < mspd_global.n_phones; ++i) {
+        mspd_phone_t *phone = &mspd_global.phones[i];
+        mspd_line_t *keep_line = phone->line;
+        mspd_bwe_t tmp_bwe;
+        memcpy (&tmp_bwe, &phone->bwe, sizeof(mspd_bwe_t));
+
+        free (phone->name);
+        if (phone->callerid)
+            free (phone->callerid);
+        free (phone->context);
+        memset (phone, 0, sizeof (*phone));
+
+        phone->line = keep_line;
+        memcpy (&phone->bwe, &tmp_bwe, sizeof(mspd_bwe_t));
+    }
+    mspd_global.n_phones = 0;
+
+    /* By default copy global configuration to all phones */
+    for ( i = 0; i < MSPD_MAX_PHONES; i++ )
+    {
+        mspd_phone_t *gphone =  &mspd_global.global_phone;
+        mspd_phone_t *phone =  mspd_global.phones + i;
+
+        /* copy echocan related */
+        memcpy(&phone->echocan, &gphone->echocan, sizeof(mspd_echocan_t));
+
+        phone->wideband      = gphone->wideband;
+        phone->dsp_acp       = gphone->dsp_acp;
+        phone->vad           = gphone->vad;
+        phone->ud_enable     = gphone->ud_enable;
+    }
+    while (!has_failed && (cat = ast_category_browse (cfg, cat))) {
+            if (!strcasecmp (cat, "phone"))
+            has_failed = config_phone (cfg, cat);
+    }
+    MSPD_UNLOCK (mspd_global.lock);
+
+    ast_config_destroy (cfg);
+
+    if (has_failed) {
+        MSPD_ERR("Error in reloading mspd.conf\n");
+        return CLI_FAILURE;
+    }
+    return CLI_SUCCESS;
+}
+
+// -----------------------------------------------------------------------------------------------
+char *
+mspd_cli_show_ud_conf (struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
+{
+    mspd_phone_t    *phone   = NULL;
+    mspd_ud_pref_t  *ud_info = &(mspd_global.ud_prefs);
+    int i = 0;
+
+    switch (cmd) {
+    case CLI_INIT:
+        e->command = "mspd show ud conf";
+        e->usage   = "Usage: mspd show ud conf\n"
+                     "       Shows the unified diagnostics configuration";
+        return NULL;
+    case CLI_GENERATE:
+        return NULL;
+    }
+
+    if (a->argc < 4)
+        return CLI_SHOWUSAGE;
+
+    ast_cli(a->fd, "\n\t : ==== MSPD Unified diagnostic configuration ====\n\n");
+    mspd_print_ud_info(ud_info);
+
+    ast_cli(a->fd, "\t : Name\t\tUD-Enable\n");
+    for (i = 0, phone = mspd_global.phones; i < mspd_global.n_phones; ++i, ++phone)
+        ast_cli(a->fd,  "\t : %s\t\t%s\n",
+                        phone->name ? phone->name : "NoPhone",
+                        phone->ud_enable ? "yes" : "no");
+
+   return CLI_SUCCESS;
+}
+
+static char *
+dect_cli_page (struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
+{
+	int mask = -1;
+
+	switch (cmd) {
+	case CLI_INIT:
+		e->command = "dect page";
+		e->usage   = "Usage: dect page <id>\n"
+                     "        Page selected phones. Handset ID ( e.g. 1,2,3,4 or all)\n";
+		return NULL;
+	case CLI_GENERATE:
+		return NULL;
+	}
+
+	if (option_debug > 10)
+		ast_log(LOG_ERROR, "--- Entering function ---\n");
+
+	if (a->argc < 3)
+		return CLI_SHOWUSAGE;
+
+	if (strcmp(a->argv[2], "all"))
+		mask = (1 << (strtoul(a->argv[2], NULL, 10) - 1));
+
+	if (tempo_dect_page(mask) != 0) {
+		ast_log(LOG_ERROR, "Error paging handset\n");
+		return CLI_FAILURE;
+	}
+
+	return CLI_SUCCESS;
+}
+
+static char *
+dect_cli_reset (struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
+{
+	switch (cmd) {
+	case CLI_INIT:
+		e->command = "dect reset";
+		e->usage   = "Usage: dect reset\n"
+                     "        Reset DSP module\n";
+		return NULL;
+	case CLI_GENERATE:
+		return NULL;
+	}
+
+	if (a->argc < 2)
+		return CLI_SHOWUSAGE;
+
+	tempo_dect_reset();
+
+	ast_cli(a->fd, "Reset done.\n");
+
+	return CLI_SUCCESS;
+}
+
+static char *
+dect_cli_register (struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
+{
+	int error;
+
+	if (option_debug > 10)
+		ast_log(LOG_ERROR, "--- Entering function ---\n");
+
+	switch (cmd) {
+	case CLI_INIT:
+		e->command = "dect register {on|off}";
+		e->usage   = "Usage: dect register\n"
+                     "        Sets the base up for phone registration\n";
+		return NULL;
+	case CLI_GENERATE:
+		return NULL;
+	}
+
+	if (a->argc < 3)
+		return CLI_SHOWUSAGE;
+
+	if (!strcmp(a->argv[2], "on")) {
+		error = tempo_dect_register_on();
+		if(error) {
+			ast_log(LOG_ERROR, "Error openning registration: %d\n", error);
+			return CLI_FAILURE;
+		}
+	}
+	else if (!strcmp(a->argv[2], "off")) {
+		error = tempo_dect_register_off();
+		if (error) {
+			ast_log(LOG_ERROR, "Error closing registration: %d\n", error);
+			return CLI_FAILURE;
+		}
+	}
+	else
+	    return CLI_SHOWUSAGE;
+
+	return CLI_SUCCESS;
+}
+
+static char *
+dect_cli_unregister (struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
+{
+	int mask = -1;
+
+	switch (cmd) {
+	case CLI_INIT:
+		e->command = "dect unregister";
+		e->usage   = "Usage: dect unregister <id>\n"
+                     "        Unregister selected phones. Handset ID ( e.g. 1,2,3,4 or all)\n";
+		return NULL;
+	case CLI_GENERATE:
+		return NULL;
+	}
+
+	if (a->argc < 3)
+		return CLI_SHOWUSAGE;
+
+	if (strcmp(a->argv[2], "all"))
+		mask = (1 << (strtoul(a->argv[2], NULL, 10) - 1));
+
+	if (tempo_dect_hs_unregister(mask) != 0) {
+		ast_log(LOG_ERROR, "Error unregistering handset\n");
+		return CLI_FAILURE;
+	}
+
+	return CLI_SUCCESS;
+}
+
+static char *
+dect_cli_show_pin (struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
+{
+	char buf[STI_DECT_PIN_LENGTH + 1] = {0};
+
+	switch (cmd) {
+	case CLI_INIT:
+		e->command = "dect show pin";
+		e->usage   = "Usage: dect show pin\n";
+		return NULL;
+	case CLI_GENERATE:
+		return NULL;
+	}
+
+	if (tempo_dect_get_pin(buf))
+		return CLI_FAILURE;
+
+	ast_cli(a->fd, "Auth PIN is %s\n", buf);
+
+	return CLI_SUCCESS;
+}
+
+static char *
+dect_cli_set_pin (struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
+{
+	switch (cmd) {
+	case CLI_INIT:
+		e->command = "dect set pin";
+		e->usage   = "Usage: dect set pin <PIN>\n";
+		return NULL;
+	case CLI_GENERATE:
+		return NULL;
+	}
+
+	if (a->argc < 4)
+		return CLI_SHOWUSAGE;
+
+	if (strlen(a->argv[3]) != STI_DECT_PIN_LENGTH)
+		return CLI_FAILURE;
+
+	if (tempo_dect_set_pin(a->argv[3]))
+		return CLI_FAILURE;
+
+	ast_cli(a->fd, "PIN set to %s\n", a->argv[3]);
+
+	return CLI_SUCCESS;
+}
+
+static char *
+dect_cli_show_rfpi (struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
+{
+	char buf[STI_DECT_RFPI_LENGTH + 1] = {0};
+
+	switch (cmd) {
+	case CLI_INIT:
+		e->command = "dect show rfpi";
+		e->usage   = "Usage: dect show rfpi\n";
+		return NULL;
+	case CLI_GENERATE:
+		return NULL;
+	}
+
+	if (tempo_dect_get_rfpi(buf))
+		return CLI_FAILURE;
+
+	ast_cli(a->fd, "Base RFPI is %s\n", buf);
+
+	return CLI_SUCCESS;
+}
+
+static char *
+dect_cli_set_rfpi (struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
+{
+	switch (cmd) {
+	case CLI_INIT:
+		e->command = "dect set rfpi";
+		e->usage   = "Usage: dect set rfpi <RFPI>\n";
+		return NULL;
+	case CLI_GENERATE:
+		return NULL;
+	}
+
+	if (a->argc < 4)
+		return CLI_SHOWUSAGE;
+
+	if (strlen(a->argv[3]) != STI_DECT_RFPI_LENGTH)
+		return CLI_FAILURE;
+
+	if (tempo_dect_set_rfpi(a->argv[3]))
+		return CLI_FAILURE;
+
+	ast_cli(a->fd, "RFPI set to %s\n", a->argv[3]);
+
+	return CLI_SUCCESS;
+}
+
+
+static char *
+dect_cli_show_subscribed (struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
+{
+	int hs_mask = -1;
+	int  i;
+
+	switch (cmd) {
+	case CLI_INIT:
+		e->command = "dect show subscribed";
+		e->usage   = "Usage: dect show subscribed\n";
+		return NULL;
+	case CLI_GENERATE:
+		return NULL;
+	}
+
+	if (tempo_dect_get_subscribed(&hs_mask))
+		return CLI_FAILURE;
+
+	ast_cli(a->fd, "List of subscribed handsets: ");
+	for (i = 0; i < sizeof(hs_mask) * 8; i++) {
+		if(hs_mask & (1 << i))
+			ast_cli(a->fd, "%d ", i + 1);
+	}
+	ast_cli(a->fd, "\n");
+
+	return CLI_SUCCESS;
+}
+
+/*! \brief DECT CLI commands definition */
+static struct ast_cli_entry cli_dect[] = {
+    AST_CLI_DEFINE(dect_cli_page, "Page dect phones"),
+    AST_CLI_DEFINE(dect_cli_reset, "Reset dect module"),
+    AST_CLI_DEFINE(dect_cli_register, "Register a dect phone"),
+    AST_CLI_DEFINE(dect_cli_unregister, "Unregister dect phones"),
+    AST_CLI_DEFINE(dect_cli_show_pin, "Show PIN of the base station"),
+    AST_CLI_DEFINE(dect_cli_set_pin, "Set PIN of the base station"),
+    AST_CLI_DEFINE(dect_cli_show_subscribed, "Show subscribed handsets"),
+	AST_CLI_DEFINE(dect_cli_show_rfpi, "show RFPI of the base station"),
+	AST_CLI_DEFINE(dect_cli_set_rfpi, "Set RFPI of the base station"),
+};
+
+// ===============================================================================================
+
+// Local functions
+
+// -----------------------------------------------------------------------------------------------
+// create a new *-channel with this channel-module as backend (i.e. a STI-line)
+// caller must hold line->lock!
+struct
+ast_channel *mspd_new_ast_channel (mspd_line_t * line,
+                                    format_t format,
+                                    int is_outgoing,
+                                    int *cause,
+                                    mspd_slic_type_t stype,
+                                    const char *chan_id,
+                                    const char *linkedid)
+{
+    char const *const dir = is_outgoing ? "outgoing" : "incoming";
+    mspd_line_state_t expected_line_state;
+
+    if (!line->is_call_wait)
+        expected_line_state = is_outgoing ? MLS_IDLE: MLS_DIALING;
+    else
+        expected_line_state = sl_get_line_state(line);
+
+    format_t const orig_format = format;
+    struct ast_channel *ast;
+
+    if (!line->phone) {
+        MSPD_ERR("(%s:%u): calls to non phone-lines not supported yet\n",
+                line->name, line->timeslot);
+        *cause = AST_CAUSE_BEARERCAPABILITY_NOTAVAIL;           // Can't find codec to connect to host
+        return NULL;
+    }
+    MSPD_LOG(2, "%s on %s Dir=%s line=%s:%u/%s trunk_line=%d\n",
+            ((stype == MSPD_SLIC_TYPE_FXS) ? "FXS" : "FXO"), chan_id,
+            dir, line->name, line->timeslot, sl_show_line_state(line),
+            line->phone->is_mapped_trunk);
+
+    mspd_line_state_t state = sl_get_line_state(line);
+    if ((state == MLS_RINGING) ||
+        (state == MLS_DISCONNECTING) ||
+        (state == MLS_DIALING_0))
+    {
+        *cause = AST_CAUSE_USER_BUSY;
+        return NULL;
+    }
+
+
+    /* Check for which subchannel, ast channel will be created
+     * normally is_call_wait will be '0'. It will set when busy outgoing channel is created.
+     */
+
+    if (!line->is_call_wait)
+        sub_line = &(line->subline[SUB_REAL]);
+    else {
+        sub_line = &(line->subline[SUB_CALLWAIT]);
+        expected_line_state = sl_get_line_state(line);
+    }
+    sub_line->subline_owner = NULL;
+
+    if (option_verbose > 2) {
+        char buf[256];
+        MSPD_LOG(3, "(%s:%u,%s): format=%s\n",
+                line->name, line->timeslot, dir,
+                ast_getformatname_multiple (buf, sizeof (buf), orig_format));
+    }
+
+    if (format & line->phone->allowed_codecs) {
+        format = ast_codec_choose (&(line->phone->codec_prefs),
+                                    format & line->phone->allowed_codecs, 1);
+    }
+
+    if (option_verbose > 2) {
+        char buf[256];
+        MSPD_LOG(3, "(%s:%u,%s): final format=%s\n",
+                line->name, line->timeslot, dir,
+                ast_getformatname_multiple (buf, sizeof (buf), format));
+    }
+
+    if (sl_get_line_state(line) != expected_line_state) {
+        MSPD_ERR("(%s:%u/%s,%s): invalid line state (should be %s)\n",
+                line->name, line->timeslot,
+                sl_show_line_state(line), dir,
+                sl_state2text (expected_line_state));
+        *cause = AST_CAUSE_SWITCH_CONGESTION;
+        return NULL;
+    }
+
+
+    if(!line->is_call_wait) {
+        if ((is_outgoing && line->channel) ||
+           (!is_outgoing && !line->channel))
+        {
+            MSPD_ERR("(%s:%u,%s): line %s channel\n",
+                    line->name, line->timeslot, dir,
+                    line->channel ? "already has a" : "has no");
+            return NULL;
+        }
+    }
+
+    if (sub_line->subline_owner)
+    {
+        MSPD_ERR("(%s:%u,%s): line already has %s as owner\n",
+                line->name, line->timeslot, dir,
+                line->owner->name);
+        *cause = AST_CAUSE_USER_BUSY;
+        return NULL;
+    }
+
+    if(!line->is_call_wait) {
+        if (sl_fixup_intern_rtp (line, is_outgoing, dir)) {
+            MSPD_ERR("(%s:%u,%s): fixup of intern-rtp has failed\n",
+                    line->name, line->timeslot, dir);
+            *cause = AST_CAUSE_SWITCH_CONGESTION;
+            return NULL;
+        }
+    }
+
+    // Checking this flag before Asterisk channel allocation
+    if (line->call_direction == MSPD_FLAG_CALL_WAITING)
+        if (!line->subline[SUB_CALLWAIT].rtp) {
+            MSPD_ERR("No RTP on subline SUB_CALLWAIT\n");
+            *cause = AST_CAUSE_SWITCH_CONGESTION;
+            return NULL;
+        }
+
+    char cid_name[256];
+    char cid_num [256];
+    memset(cid_name, 0, sizeof(cid_name));
+    memset(cid_num, 0, sizeof(cid_num));
+
+    if (line->phone->callerid) {
+        MSPD_LOG(5, "line->phone->callerid = %s\n", line->phone->callerid);
+        ast_callerid_split(line->phone->callerid, cid_name,
+                sizeof(cid_name), cid_num, sizeof(cid_num));
+        MSPD_LOG(5, " cid_name = %s\tcid_num = %s to be displayed\n",
+                cid_name, cid_num);
+    }
+    else {
+        MSPD_LOG(5,"line->phone->callerid is NULL\n");
+    }
+
+    ast = ast_channel_alloc (1, AST_STATE_DOWN,
+                            cid_num,
+                            cid_name,
+                            "",                   // acctcode is used by SIP only
+                            line->dialed,
+                            line->phone->context,
+                            linkedid,
+                            0,
+                            "%s/%s-%04x",
+                            chan_id,
+                            line->phone->name,
+                            ast_atomic_fetchadd_int((int *)&chan_idx, +1));
+
+    if (!ast) {
+        MSPD_ERR("(%s:%u,%s): failed to allocate Ast-channel structure\n",
+                line->name, line->timeslot, dir);
+        *cause = AST_CAUSE_SWITCH_CONGESTION;
+        return NULL;
+    }
+
+    int ast_fd1 = 0;
+    int ast_fd2 = 0;
+
+    if (line->call_direction == MSPD_FLAG_CALL_WAITING) {
+        if (line->subline[SUB_CALLWAIT].rtp) {
+            ast_fd1 = ast_rtp_instance_fd (line->subline[SUB_CALLWAIT].rtp, 0);
+            ast_fd2 = ast_rtp_instance_fd (line->subline[SUB_CALLWAIT].rtp, 1);
+        }
+    }
+    else {
+        ast_fd1 = ast_rtp_instance_fd (line->intern_rtp, 0);
+        ast_fd2 = ast_rtp_instance_fd (line->intern_rtp, 1);
+    }
+
+    ast_channel_set_fd(ast, MSPD_FD_RTP, ast_fd1);
+    ast_channel_set_fd(ast, MSPD_FD_RTCP, ast_fd2);
+
+    ast->pickupgroup = line->pickup_groups;
+    ast->callgroup = line->call_groups;
+    ast->nativeformats = format;
+
+    ast->rawreadformat = format;
+    ast->rawwriteformat = format;
+    ast->readformat = format;
+    ast->writeformat = format;
+    ast->tech_pvt = line;
+
+    //assinging mspd_tech instead of assing above parameters individually
+    if (stype == MSPD_SLIC_TYPE_FXS)
+        ast->tech = (struct ast_channel_tech *) &mspd_tech;
+    else
+        ast->tech = (struct ast_channel_tech *) &mspd_fxo_tech;
+    snprintf (ast->exten, sizeof (ast->exten), "%s", line->dialed[0] ? line->dialed : "s");
+
+// added for keeping the incoming channel info
+    if(!line->is_call_wait)
+        line->owner = ast;
+    sub_line->subline_owner = ast;
+    sub_line->is_native_bridged = False;
+    mspd_update_use_count (1);
+
+    MSPD_LOG(5, "Ast init done for asterisk channel %s, line=%s, timeslot=%u, direction=%s\n",
+            ast->name, line->name, line->timeslot, dir);
+
+    if (!line->is_call_wait) {
+        ast_setstate (ast, is_outgoing ? AST_STATE_DOWN : AST_STATE_RING);
+
+        if (is_outgoing) {
+            sl_set_line_state(line, MLS_RINGING);
+        }
+        else {
+            MSPD_DBG("MSPD calls to line->dialed=%s\n", line->dialed);
+            if (!strcmp (line->dialed, ast_pickup_ext ())) {
+                if (ast_pickup_call (ast)) {
+                    MSPD_LOG(5, "(%s:%u,%s): call pickup has failed\n",
+                            line->name, line->timeslot, dir);
+                    mspd_channel_set_tone (line->channel, DC_TONE_BUSY);
+                }
+                ast_hangup (ast);
+            }
+            else {
+                sl_set_line_state(line, MLS_CALL_PROCEEDING);
+
+                MSPD_LOG(5, "*** tech_pvt=%s, line=%s, TS=%u, channel=%s\n",
+                        ast->name, line->name, line->timeslot, mspd_channel_get_name(line->channel));
+
+                if (ast_pbx_start (ast) != AST_PBX_SUCCESS) {
+                    MSPD_ERR("(%s:%u,%s): unable to start PBX on %s\n",
+                            line->name, line->timeslot, dir, ast->name);
+                    ast_hangup (ast);
+                    *cause = AST_CAUSE_SWITCH_CONGESTION;
+                    ast = NULL;
+                }
+                else
+                    MSPD_LOG(3, "(%s:%u,%s): PBX started on %s\n",
+                            line->name, line->timeslot, dir, ast->name);
+            }
+        }
+    }
+    else
+        ast_setstate (ast, AST_STATE_IS_CALL_WAIT);
+    return sub_line->subline_owner;
+}
+
+// ===============================================================================================
+// Channel module technical description functions
+
+// -----------------------------------------------------------------------------------------------
+// This function properly responds to a call to this module
+// (i.e. a call to a SLIC phone or a tdmbus that is a trunk)
+struct ast_channel *
+mspd_request (const char *type, format_t format, const struct ast_channel *requestor, void *data, int *cause)
+{
+    char const *const called_name = (char *) data;
+    struct ast_channel *new_chan = NULL;
+    mspd_phone_t *phone;
+    uint i;
+    int is_busy = 0;
+    mspd_line_t *line;
+    mspd_line_state_t state;
+    uint line_number;
+
+    if (option_verbose > 1) {
+        char buf[256];
+        MSPD_LOG(2, "(%s, %s, %s)\n",
+                type,
+                ast_getformatname_multiple (buf, sizeof (buf), format),
+                called_name);
+    }
+
+    MSPD_LOCK (mspd_global.lock, return NULL);
+    for (i = 0, phone = mspd_global.phones; i < mspd_global.n_phones; ++i, ++phone) {
+        if (!strcmp (phone->name, called_name)) {
+            line_number = sl_get_line_num_by_ts(phone->bus, phone->timeslot);
+            if (line_number == MAX_LINE_NUMBER) {
+                line_number = sl_get_free_line_num(phone->bus);
+                if (line_number == MAX_LINE_NUMBER) {
+                    MSPD_LOG(1, "No free lines on the %s bus\n", phone->bus->name);
+                    return 0;
+                }
+                line = &phone->bus->lines[line_number];
+                line->phone = phone;
+                line->phone->line = line;
+                line->call_groups = phone->call_groups;
+                line->pickup_groups = phone->pickup_groups;
+                line->timeslot = phone->timeslot;
+		line->t38state = (mspd_global_get_fax_mode() == MSPD_FAXMODE_PASSTHRU) ? T38_STATE_UNAVAILABLE : T38_STATE_UNKNOWN;
+                MSPD_LOG(5, "Line %s:%u has been assigned\n",
+                        line->name, line->timeslot);
+            }
+            else {
+                line = &phone->bus->lines[line_number];
+                MSPD_LOG(5, "Line %s:%u has been found\n",
+                        line->name, line->timeslot);
+            }
+            mspd_slic_type_t type = MSPD_SLIC_TYPE_FXS;
+
+            MSPD_LOCK (line->lock, break);
+            if (!line->owner && sl_get_line_state(line) == MLS_IDLE) {
+                new_chan = mspd_new_ast_channel (line, format, 1, cause, type,
+                            (char *) mspd_chan_id, requestor ? requestor->linkedid : NULL);
+
+                if (!new_chan) {
+                    MSPD_ERR("(%s:%u): New asterisk channel is not created\n", line->name, line->timeslot);
+                    MSPD_UNLOCK (line->lock);
+                    break;
+                }
+
+                if (line->channel) {
+                    MSPD_ERR("(%s:%u): line has unexpected channel (%s)\n",
+                            line->name, line->timeslot, mspd_channel_get_name(line->channel));
+                    MSPD_UNLOCK (line->lock);
+                    break;
+                }
+
+                line->call_direction = MSPD_FLAG_OUTGOING_CALL;
+
+                if ((line->bus->tdm & BUS_MASK) == BUS_DECT)
+			line->channel = dc_create_voiposhm_channel(line, format);
+		else
+                line->channel = dc_create_voip_channel(line, format);
+
+                if (!line->channel) {
+                    MSPD_ERR("(%s:%u): voip-channel creation has failed\n",
+                            line->name, line->timeslot);
+                    MSPD_UNLOCK (line->lock);
+                    *cause = AST_CAUSE_SWITCH_CONGESTION;
+                    break;
+                }
+
+            }
+            else {
+                if (line->subline[SUB_CALLWAIT].subline_owner) {
+                    MSPD_ERR("(%s:%u): CALLWAIT subline already in use\n",
+                            line->name, line->timeslot);
+                    MSPD_UNLOCK (line->lock);
+                    break;
+                }
+
+                is_busy = 1;
+                char buf[256];
+                MSPD_LOG(1, "(%s, %s, %s): called line is busy (state=%s)\n",
+                        mspd_channel_type2text (type), ast_getformatname_multiple (buf, sizeof(buf), format),
+                        called_name, sl_show_line_state(line));
+                state = sl_get_line_state (line);
+                if ((state == MLS_DIALING) ||
+                    (state == MLS_DIALING_0) ||
+                    (state == MLS_RINGING) ||
+                    (state == MLS_DISCONNECTING) ||
+                    (state == MLS_DIALING_FXO) ||
+                    (state == MLS_THREEWAY) ||
+                    ((state == MLS_CONNECTED) && line->is_in_conference))
+                {
+                    *cause = AST_CAUSE_USER_BUSY;
+                    MSPD_UNLOCK (line->lock);
+                    break;
+                }
+
+                // change the state MLS_WAIT_FOR_FLASH to handle the flash
+                if ((state == MLS_CONNECTED) ||
+                    (state == MLS_CALL_PROCEEDING))
+                {
+                    sl_set_line_state (line, MLS_WAIT_FOR_FLASH);
+                    line->is_call_wait = 1;
+                    line->call_direction = MSPD_FLAG_CALL_WAITING;
+                    if (!line->subline[SUB_CALLWAIT].rtp)
+                        line->subline[SUB_CALLWAIT].rtp = mspd_rtp_allocate_new (line->bus->dev);
+                    MSPD_INFO_ABOUT_RTP(line->subline[SUB_CALLWAIT].rtp);
+                }
+                new_chan = mspd_new_ast_channel (line, format, 1, cause, type,
+                            (char *) mspd_chan_id, requestor ? requestor->linkedid : NULL);
+            }
+            MSPD_UNLOCK (line->lock);
+            break;
+        }
+    }//for loop
+    MSPD_UNLOCK (mspd_global.lock);
+
+    if (!new_chan) {
+        char buf[256];
+        if (!is_busy) {
+            *cause = AST_CAUSE_SWITCH_CONGESTION;
+            MSPD_WARN(5, "(%s, %s, %s): can't satisfy request (but not BUSY!)\n",
+                    type, ast_getformatname_multiple (buf, sizeof (buf), format), called_name);
+        }
+        else {
+            *cause = AST_CAUSE_USER_BUSY;
+            MSPD_WARN(5, "(%s, %s, %s): can't satisfy request (BUSY)\n",
+                    type, ast_getformatname_multiple (buf, sizeof (buf), format), called_name);
+        }
+    }
+    return new_chan;
+}
+
+// -----------------------------------------------------------------------------------------------
+// Called when Asterisk places an outgoing call to this channel-module
+// (e.g. a phone is called)
+int
+mspd_call (struct ast_channel *ast, char *dest, int timeout)
+{
+    mspd_line_t *const line = ast->tech_pvt;
+    struct DECT_CALL_PROPERTIES dect_props;
+    char called_number[MAX_PHONE_NUMBER_SIZE];
+    void *props = NULL;
+
+    if (!line) {
+        MSPD_ERR("(%s): Ast-channel has no line\n", ast->name);
+        return -1;
+    }
+
+    MSPD_LOCK (line->lock, return -1);
+    MSPD_LOG(3, AEP_FMT"Dest=%s, Timeout=%d\n", AEP_VAL (ast, line), dest, timeout);
+
+    if ((line->bus->tdm & BUS_MASK) == BUS_DECT) {
+        memset(&dect_props, 0, sizeof(dect_props));
+        props = &dect_props;
+
+        struct ast_party_caller caller;
+        ast_party_caller_set_init(&caller, &ast->caller);
+
+        if (caller.id.name.str)
+            strncpy(dect_props.caller_name, caller.id.name.str, sizeof(dect_props.caller_name));
+
+        if (caller.id.number.str)
+            strncpy(dect_props.caller_num, caller.id.number.str, sizeof(dect_props.caller_num));
+        called_number[0] = snprintf (called_number + 1, sizeof (called_number) - 1, "%d",
+                                     line->timeslot + 1);
+    }
+    else if ((line->bus->tdm & BUS_MASK) == BUS_PRI) {
+        if (line->phone->dialout_number)
+            called_number[0] = snprintf (called_number + 1, sizeof (called_number) - 1, "%d",
+                                        line->phone->dialout_number);
+        else
+            MSPD_ERR("Dialout_number is not set for phone %s on the %s bus!",
+                    line->phone->name, line->bus->name);
+        props = called_number;
+    }
+    else if ((line->bus->tdm & BUS_MASK) == BUS_SLIC) {
+        called_number[0] = snprintf (called_number + 1, sizeof (called_number) - 1, "%d",
+                                    line->timeslot);
+        props = called_number;
+    }
+    else {
+        called_number[0] = snprintf (called_number + 1, sizeof (called_number) - 1, "%d",
+                                    line->timeslot + 1);
+        props = called_number;
+    }
+
+    if (mspd_channel_prepare_callerid_msg(line->channel, ast, 1))
+        MSPD_ERR("Error in callerid msg preparation\n");
+    else
+        MSPD_LOG(5,"Caller ID msg prepared\n");
+
+    MSPD_LOG(5, "Line %s:%u: Making TEMPO outgoing call to TDM=0x%X: Number=%s (user_id=0x%X)\n",
+            line->name, line->timeslot,
+            line->bus->tdm, called_number + 1,
+            sl_get_usrid_of_line (line));
+
+    if (tempo_make_outgoing_call (sl_get_usrid_of_line (line),
+                                  line->bus->tdm,
+                                  line->timeslot,
+                                  props))
+    {
+        MSPD_ERR(AEP_FMT"Tempo_make_outgoing_call (%d, 0x%x, %s) has failed: %s\n",
+                AEP_VAL (ast, line),
+                sl_get_usrid_of_line (line), line->bus->tdm,
+                called_number + 1, strerror (errno));
+        MSPD_UNLOCK (line->lock);
+        return -1;
+    }
+    MSPD_UNLOCK (line->lock);
+
+    // Check for normal call scenario
+    if (line->owner == ast){
+        // gives a normal ring
+        if ((ast->_state != AST_STATE_FLASHED)&&(ast->_state != AST_STATE_IS_CALL_WAIT))
+            ast_setstate (ast, AST_STATE_CONNECTED);
+        ast_queue_control (ast, AST_CONTROL_RINGING);
+    }
+    else {
+        // Check for call wait scenario
+
+        /* Give the indication tone to the busy user
+         * commented for caller id generation
+         */
+        mspd_channel_set_tone(line->channel, DC_TONE_INDI);
+
+        // Give ring back tone without changing the state
+        ast_queue_control (ast, AST_CONTROL_RINGING);
+    }
+
+    return 0;
+}
+
+// -----------------------------------------------------------------------------------------------
+// Called by Asterisk when a call initiated by this channel-module is answered
+// (e.g. by Dial() or explicit Answer() in extensions.conf)
+int
+mspd_answer (struct ast_channel *ast)
+{
+    mspd_line_t *const line = ast->tech_pvt;
+
+    if (!line) {
+        MSPD_ERR("(%s): Ast-channel has no line\n", ast->name);
+        return -1;
+    }
+    if (!line->intern_rtp) {
+        MSPD_ERR(AEP_FMT"Line has no intern-rtp\n", AEP_VAL (ast, line));
+        return -1;
+    }
+
+    if ((ast->_state == AST_STATE_UP) ||
+        (ast->_state == AST_STATE_CONNECTED))
+        MSPD_LOG(5, AEP_FMT"Ast-state is already UP\n",AEP_VAL (ast, line));
+
+    MSPD_LOCK (line->lock, return -1);
+    MSPD_LOG(2, AEP_FMT"\n", AEP_VAL (ast, line));
+    if (line->channel) {
+        if (mspd_channel_set_tone (line->channel, DC_TONE_OFF) ||
+            mspd_channel_start_tx (line->channel))
+                MSPD_ERR(AEP_FMT"DC_TONE_OFF has failed\n", AEP_VAL (ast, line));
+
+        if (option_verbose > 2) {
+            char buf1[256], buf2[256], buf3[256], buf4[256], buf5[256];
+            MSPD_LOG(3, "%s: %s formats: read=%s (raw %s), write=%s (raw %s), native=%s\n",
+                        __func__, ast->name,
+                        ast_getformatname_multiple (buf1, sizeof (buf1),
+                            ast->readformat),
+                        ast_getformatname_multiple (buf2, sizeof (buf2),
+                            ast->rawreadformat),
+                        ast_getformatname_multiple (buf3, sizeof (buf3),
+                            ast->readformat),
+                        ast_getformatname_multiple (buf4, sizeof (buf4),
+                            ast->rawwriteformat),
+                        ast_getformatname_multiple (buf5, sizeof (buf5),
+                            ast->nativeformats));
+        }
+    }
+    else {
+        MSPD_ERR(AEP_FMT"Line misses channel\n", AEP_VAL (ast, line));
+    }
+
+    if ((ast->_state != AST_STATE_FLASHED)&&
+        (ast->_state != AST_STATE_IS_CALL_WAIT))
+        ast_setstate (ast, AST_STATE_CONNECTED);
+
+    if (!(line->is_call_on_hold))
+        sl_set_line_state (line, MLS_CONNECTED);
+    else {
+        sl_set_line_state (line, MLS_FLASHED);
+        ast_setstate (ast, AST_STATE_FLASHED);
+    }
+
+    MSPD_UNLOCK (line->lock);
+
+    return 0;
+}
+
+#define FORMAT_SWITCH_TIMEOUT 10000
+
+static int
+mspd_setoption(struct ast_channel *chan, int option, void *data, int datalen)
+{
+	struct mspd_line_t *line = (struct mspd_line_t *) chan->tech_pvt;
+	int res = -1;
+	format_t format = 0;
+	char buf[256];
+
+	MSPD_LOG(3, AEP_FMT "option %d received\n", AEP_VAL (chan, line), option);
+
+	ast_mutex_lock(&line->lock);
+
+	switch (option) {
+	case AST_OPTION_MAKE_COMPATIBLE:
+	{
+		struct ast_channel *peer = (struct ast_channel *)data;
+		format = peer->nativeformats;
+	    	format &= MSPD_SUPPORTED_CODECS;
+
+// remove optimisation, because we have no time to check for regressions
+#if 0
+		if (peer->tech == &mspd_tech)
+			/* This is MSPD CM -> MSPD CM call.
+			 * Change format to codec without compression
+			 * to save MSP MIPs and enhance voice quality.
+			 */
+			format = MSPD_DEFAULT_CODEC;
+#endif
+
+		/* Disable tone generation.
+		 * This is needed for blind call transfer scenario.
+		 * We need some indicator which says to us that a transferee has answered.
+		 * So that we could stop ringback tones to transfered peer.
+		 * Asterisk won't send any other indication to transfered peer (caller), because it's already answered.
+		 * So we never know when to stop MSP tone generation otherwise than here (AST_OPTION_MAKE_COMPATIBLE indication).
+		 *
+		 * For call switching we will have 2 Asterisk channels on a single MSPD line.
+		 * When second party calls to the active peer, the code below may mistakenly stop indication tones,
+		 * which indicate peer that the second call is waiting (line->owner != chan in this case).
+		 * So we need to disable tones only when Asterisk calls setoption() on the Asterisk channel that corresponds 
+		 * to "real" subline.
+		 * 
+		 */
+		if (line->owner == chan &&
+		    mspd_channel_get_tone(line->channel) != DC_TONE_OFF)
+			mspd_channel_set_tone(line->channel, DC_TONE_OFF);
+
+		if (format) {
+			/* switch peer to this format completely */
+			ast_set_read_format(peer, format);
+			ast_set_write_format(peer, format);
+		}
+
+		break;
+	}
+	case AST_OPTION_FORMAT_WRITE:
+	case AST_OPTION_FORMAT_READ:
+	{
+		format = *(format_t*)data;
+		format &= MSPD_SUPPORTED_CODECS;
+		break;
+	}
+	default:
+		MSPD_LOG(3, AEP_FMT "option %d not handled\n", AEP_VAL (chan, line), option);
+		break;
+	}
+
+	MSPD_LOG(3, AEP_FMT "asked to switch to %s\n", AEP_VAL (chan, line), ast_getformatname_multiple(buf, sizeof(buf), format));
+
+	if (format) {
+		if (line->channel &&
+		    ast_tvdiff_ms(ast_tvnow(), line->format_change_ts) > FORMAT_SWITCH_TIMEOUT) { /* this check prevents endless loop of format switching */
+			mspd_channel_lock(line->channel);
+    			if (mspd_channel_get_type(line->channel) == MCT_VOIP)
+				res = mspd_channel_enable(line->channel, format);
+			mspd_channel_unlock(line->channel);
+
+			if (!res)
+				chan->rawreadformat =
+				chan->rawwriteformat = format;
+		}
+
+		chan->readformat =
+		    chan->writeformat =
+		    chan->nativeformats =
+		    format;
+		res = 0;
+	}
+
+	ast_mutex_unlock(&line->lock);
+
+	return res;
+}
+
+static int
+mspd_queryoption(struct ast_channel *chan, int option, void *data, int *datalen)
+{
+        int res = -1;
+        struct mspd_line_t *line = (struct mspd_line_t *) chan->tech_pvt;
+
+        switch (option) {
+        case AST_OPTION_T38_STATE:
+                *((enum ast_t38_state *) data) = line->t38state;
+                res = 0;
+                break;
+        default:
+                break;
+        }
+
+        return res;
+}
+
+// -----------------------------------------------------------------------------------------------
+// this is called by Asterisk to play indication to user
+int
+mspd_indicate (struct ast_channel *ast, int condition, const void *data, size_t datalen)
+{
+    mspd_line_t *const line = ast->tech_pvt;
+    int rc = 0;
+
+    if (!line) {
+        MSPD_ERR("(%s): Ast-channel has no line\n", ast->name);
+        return -1;
+    }
+
+    MSPD_LOCK (line->lock, return -1);
+    MSPD_LOG(3, AEP_FMT"condition = %s (%d)\n", AEP_VAL (ast, line),
+            sl_condition2text(condition), condition);
+    //sl_subline_debug (line);
+
+    switch (condition) {
+        case AST_CONTROL_RINGING:
+
+            switch (sl_get_line_state (line)) {
+                case MLS_CALL_PROCEEDING:
+                case MLS_CONNECTED:
+                    if (line->channel) {
+                        if (mspd_channel_set_tone (line->channel, DC_TONE_ANSWER))
+                                MSPD_ERR(AEP_FMT"DC_TONE_ANSWER has failed\n", AEP_VAL (ast, line));
+                    }
+                    else
+                        MSPD_ERR(AEP_FMT"Line has no channel\n", AEP_VAL (ast, line));
+                break;
+                case MLS_IDLE:
+                case MLS_OFF_HOOK:
+                case MLS_DIALING_0:
+                case MLS_DIALING:
+                case MLS_RINGING:
+                case MLS_DISCONNECTING:
+                    MSPD_WARN(2, AEP_FMT"Can't handle condition AST_CONTROL_RINGING "
+                            "in this state\n", AEP_VAL (ast, line));
+                    rc = -1;
+                break;
+
+                default:
+                break;
+            }
+            break;
+
+        case AST_CONTROL_HOLD:
+            if (sl_get_line_state(line) == MLS_CONNECTED) {
+                if (mspd_channel_set_tone(line->channel, DC_TONE_HOLD) ||
+                    mspd_channel_stop_tx(line->channel))
+                        MSPD_ERR(AEP_FMT"HOLD has failed\n", AEP_VAL (ast, line));
+            }
+            // For CONNECTED and other cases we update WAIT flag
+            sl_set_call_wait(line, True);
+        break;
+
+        case AST_CONTROL_UNHOLD:
+            if (sl_get_line_state(line) == MLS_CONNECTED) {
+                if (mspd_channel_set_tone(line->channel, DC_TONE_OFF))
+                    MSPD_ERR(AEP_FMT"DC_TONE_OFF has failed\n", AEP_VAL (ast, line));
+                // If we are not on Hold, talk
+                if (!line->is_call_on_hold)
+                    if (mspd_channel_start_tx(line->channel))
+                        MSPD_ERR(AEP_FMT"UNHOLD has failed\n", AEP_VAL (ast, line));
+            }
+            // For CONNECTED and other cases we update WAIT flag
+            sl_set_call_wait(line, False);
+            break;
+
+        case AST_CONTROL_SRCUPDATE:
+            break;
+
+        case AST_CONTROL_MSPD_CHANNEL_SWITCH_MODE:
+            MSPD_LOG(1, "AST_CONTROL_MSPD_CHANNEL_SWITCH_MODE %s\n", line->name);
+            if (sl_get_line_state(line) == MLS_CONNECTED) {
+                mspd_channel_lock(line->channel);
+                mspd_channel_type_t type = mspd_channel_get_type(line->channel);
+                MSPD_LOG(1, "%s: %s found\n", line->name, mspd_channel_type2text(type));
+                mspd_channel_pvt_t *pvt = mspd_channel_get_pvt (line->channel);
+                if (!pvt->part.conference) {
+                    MSPD_WARN(1, "Channel %s has NO conference!\n", mspd_channel_get_name(line->channel));
+                    mspd_channel_unlock(line->channel);
+                    rc = -1;
+                    break;
+                }
+
+                MSPD_LOG(3, "Channel %s has conference %s \n",
+                    mspd_channel_get_name(line->channel),
+                    mspd_conference_get_name (pvt->part.conference));
+
+
+                if (type == MCT_PART_TDM){
+                    struct ast_sockaddr src, dst;
+                    struct ast_rtp_instance *rtp = NULL;
+
+                    if(mspd_channel_switch_to_voip (line->channel, line->phone->wideband, line->timeslot))
+                        MSPD_ERR("%s: Switching to VoIP failed\n", line->name);
+
+                    mspd_conference_dec_participants(pvt->part.conference);
+
+                    rtp = line->intern_rtp;
+                    if (rtp) {
+                         ast_rtp_instance_get_remote_address(rtp, &src);
+                         ast_rtp_instance_get_local_address(rtp, &dst);
+                         if (mspd_channel_set_ip_header(line->channel, &src, &dst))
+                             MSPD_ERR("Line mspd_channel_set_ip_header\n");
+                     }
+                     else
+                         MSPD_ERR("No intern RTP on Line %s\n", line->name);
+
+                     if (mspd_channel_bwe_manager(line->channel,
+                             line->phone->wideband,
+                             NoBand, // not applicable for VoIP
+                             &line->phone->bwe,
+                             True) ||
+                     mspd_channel_configure_voip(line->channel, &line->phone->echocan))
+                         MSPD_ERR("Channel %s configuration failed\n",
+                                 mspd_channel_get_name(line->channel));
+                } // ---------------------------------------------------------------
+                else {
+
+                    if(mspd_channel_switch_to_lsp_part (line->channel, line->phone->wideband, line->timeslot,
+                        mspd_conference_get_id(pvt->part.conference)))
+                            MSPD_ERR("%s: Switching to LSP failed\n", line->name);
+
+                    mspd_conference_inc_participants(pvt->part.conference);
+
+                    if (mspd_channel_bwe_manager(line->channel,
+                                    line->phone->wideband,
+                                    mspd_conference_get_mixer(pvt->part.conference),
+                                    &line->phone->bwe,
+                                    True) ||
+                        mspd_channel_configure_lsp_part(line->channel, &line->phone->echocan)) {
+                        MSPD_ERR("LSP channel %s configuration failed\n",
+                                mspd_channel_get_name(line->channel));
+
+                        if(mspd_channel_switch_to_voip (line->channel, line->phone->wideband, line->timeslot))
+                            MSPD_ERR("Line mspd_channel_set_ip_header\n");
+                    }
+                }
+                mspd_channel_unlock(line->channel);
+            }
+            break;
+
+        case -1: // No one picked up the phone
+                switch (sl_get_line_state (line)) {
+                    case MLS_CONNECTED:
+                    case MLS_FLASHED:
+                        if (!line->is_native_bridged && line->intern_rtp) {
+                            if (line->channel) {
+                                if (mspd_channel_set_tone (line->channel, DC_TONE_OFF) ||
+                                    mspd_channel_start_tx (line->channel))
+                                        MSPD_ERR(AEP_FMT"DC_TONE_OFF has failed\n", AEP_VAL (ast, line));
+                            }
+                            else
+                                MSPD_ERR(AEP_FMT"Line has no channel\n", AEP_VAL (ast, line));
+                        }
+                    default:
+                    break;
+                }  //switch (line->state)
+             break;
+
+        case AST_CONTROL_T38_PARAMETERS:
+                rc = mspd_t38_handle_parameters(line, data);
+                break;
+
+        default:
+            MSPD_WARN(5, AEP_FMT"Can't handle condition %d\n", AEP_VAL (ast, line), condition);
+            rc = -1;
+    } //switch (condition)
+    MSPD_UNLOCK (line->lock);
+
+    return rc;
+}
+
+static struct ast_frame *
+rtp_instance_read(struct ast_channel *ast, int rtcp)
+{
+        static struct ast_frame null_frame = { AST_FRAME_NULL };
+	mspd_line_t *const line = ast->tech_pvt;
+        struct ast_frame *frame;
+
+	if (ast == line->subline[SUB_REAL].subline_owner) {
+		if (option_verbose >= 14)
+    			ast_verbose("read SUB_REAL\n");
+		frame = (!line->intern_rtp) ? &null_frame : ast_rtp_instance_read (line->intern_rtp, rtcp);
+	} else {
+		if (option_verbose >= 14)
+        		ast_verbose("read SUB_CALLWAIT\n");
+	    	frame = (!line->subline[SUB_CALLWAIT].rtp) ? &null_frame : ast_rtp_instance_read (line->subline[SUB_CALLWAIT].rtp, rtcp);
+	}
+	return frame;
+}
+
+static int
+handle_pt(mspd_line_t* line)
+{
+    /* Below code handles switch voice->FPT.
+     * In FPT mode we shouldn't pass media through any media processing,
+     * like transcoding. Even if Asterisk expects media recording in to .g729 format.
+     * So we should switch whole media path to AST_FORMAT_ULAW.
+     * We can't perform this from VAPI callback, because it's unsafe to get ast_bridged_channel() from there.
+     * Here we are sure that we are called from the bridge code, and bridge cannot be destroyed until we return,
+     * so we can safely do this.
+     */
+    char buf[256];
+    struct ast_channel* ast = line->owner;
+    struct ast_channel* peer = ast_bridged_channel(ast);
+    format_t format;
+
+    if (line->pt_mode == MSPD_PT_MODE_FAX)
+	/* handle switching to fax */
+	format = MSPD_DEFAULT_CODEC;
+    else if (line->pt_mode == MSPD_PT_MODE_VOICE)
+	/* handle switching to voice */
+	format = line->answer_format;
+    else
+	return -1;
+
+    if (!line->channel)
+	/* drop */
+	return -1;
+
+    /* Switch ourselves to new format.
+     * We don't need to lock ast, because it's already locked when
+     * Asterisk calls read() API.
+     */
+
+    ast->nativeformats =
+	ast->rawreadformat =
+	ast->rawwriteformat =
+	ast->readformat =
+	ast->writeformat = format;
+
+    MSPD_LOG(3, "(%s) set nativeformats to %s\n", ast->name, ast_getformatname_multiple(buf, sizeof(buf), ast->nativeformats));
+
+    if (peer) {
+	while (ast_channel_trylock(peer)) {
+	    ast_mutex_unlock(&line->lock);
+	    ast_channel_unlock(ast);
+	    usleep(1);
+	    ast_channel_lock(ast);
+	    ast_mutex_lock(&line->lock);
+	}
+
+	/* switch peer to new format */
+	peer->nativeformats = (peer->nativeformats & (AST_FORMAT_VIDEO_MASK | AST_FORMAT_TEXT_MASK)) | format; /* save video & text capabilities */
+	/* If there are any translators active, drop them.
+	 * FPT mode implies no codec translation on the voice path.
+	 * Below Asterisk functions are expected to drop translators and set format.
+	 */
+	ast_set_read_format(peer, format);
+	ast_set_write_format(peer, format);
+    	MSPD_LOG(3, "(%s) set peer's nativeformats to %s\n", ast->name, ast_getformatname_multiple(buf, sizeof(buf), peer->nativeformats));
+
+	ast_channel_unlock(peer);
+    }
+
+    /* mode switching handled, prevent this code running on next RTP frame handling */
+    line->pt_mode = MSPD_PT_MODE_NONE;
+
+    return 0;
+}
+
+// -----------------------------------------------------------------------------------------------
+// Called by Asterisk to get a voice, or dtmf, or some frame from a MSPD *-channel
+struct ast_frame *
+mspd_read (struct ast_channel *ast)
+{
+    static struct ast_frame null_frame = { AST_FRAME_NULL };
+
+    mspd_line_t *const line = ast->tech_pvt;
+    struct ast_frame *frame = NULL;
+
+    if (!line) {
+	    MSPD_ERR("(%s): Ast-channel has no line\n", ast->name);
+	    return NULL;
+    }
+
+    ast_mutex_lock(&line->lock);
+
+    if (!line->channel) {
+	    /* no sense to read anything, no MSP channel is available */
+	    frame = &null_frame;
+	    goto END;
+    }
+
+    if (option_verbose >= 15)
+	    MSPD_LOG(5, "(%s/%s): rtp=%p\n",
+        		ast->name, sl_show_line_state(line), line->intern_rtp);
+
+    switch(ast->fdno) {
+    case MSPD_FD_UDPTL:
+	    if (line->udptl)
+		    frame = ast_udptl_read(line->udptl);
+	    break;
+
+    case MSPD_FD_RTP:
+	    frame = rtp_instance_read(ast, 0);
+	    if (frame &&
+		frame->frametype == AST_FRAME_VOICE &&  /* for p2p bridge we'll get AST_FRAME_NULL here */
+		line->owner &&
+		line->pt_mode != MSPD_PT_MODE_NONE) {
+		if (handle_pt(line)) {
+        	    ast_frfree (frame);
+        	    frame = &null_frame;
+		}
+	    }
+
+	    if (!line->answer_format && ast_bridged_channel(ast)) {
+    		/* Need to store original answer format in which call has been bridged
+		 * in order to restore it when going out from FPT.
+	         */
+		char buf[256];
+		line->answer_format = mspd_channel_get_format(line->channel);
+    		MSPD_LOG(3, AEP_FMT " saved answer format %s\n", AEP_VAL (ast, line), ast_getformatname_multiple(buf, sizeof(buf), line->answer_format));
+
+		if (mspd_global_get_fax_mode() == MSPD_FAXMODE_PASSTHRU)
+    		    mspd_channel_set_passthru_autoswitch(line->channel);
+	    }
+
+	    break;
+
+    case MSPD_FD_RTCP:
+	    frame = rtp_instance_read(ast, 1);
+	    break;
+
+    default:
+	    frame = &null_frame;
+	    break;
+    }
+
+    if (frame && frame->frametype == AST_FRAME_VOICE) {
+	    int drop = 0;
+    	    if (line->is_native_bridged)
+        	    drop = 1;
+            else if (mspd_channel_get_passthru_mode(line->channel)) {
+	    // do nothing
+	    } else if (frame->subclass.codec != ast->rawreadformat) {
+        	    MSPD_LOG(5, "(%s): dropping %s frame because rawreadformat=%s\n",
+                		ast->name,
+                		ast_getformatname (frame->subclass.codec),
+                		ast_getformatname (ast->rawreadformat));
+        	    drop = 1;
+    	    }
+    	    if (drop) {
+        	    ast_frfree (frame);
+        	    frame = &null_frame;
+    	    }
+    }
+
+END:
+    ast_mutex_unlock(&line->lock);
+    return frame;
+}
+
+// -----------------------------------------------------------------------------------------------
+// Called by Asterisk to put a voice, or dtmf or some frame into a MSPD *-channel
+int
+mspd_write (struct ast_channel *ast, struct ast_frame *frame)
+{
+    static struct ast_frame null_frame = { AST_FRAME_NULL };
+
+    mspd_line_t *const line = ast->tech_pvt;
+    int rc = 0;
+
+    if (!line)
+    {
+        MSPD_ERR("(%s): Ast-channel has no line\n", ast->name);
+        return 0;
+    }
+
+    ast_mutex_lock(&line->lock);
+
+    if (!line->channel) {
+	    /* no sense to write anything, no MSP channel is available */
+	    frame = &null_frame;
+	    goto END;
+    }
+
+    switch (frame->frametype)
+    {
+        case AST_FRAME_VOICE:
+            if ((frame->subclass.codec & ast->nativeformats) == 0) {
+		char buf1[256];
+		char buf2[256];
+		char buf3[256];
+                MSPD_LOG(5,"(%s/%s): asked to transmit %s frame "
+                        "while native formats is %s (read/write=%s/%s)\n",
+                        ast->name, sl_show_line_state(line),
+                        ast_getformatname (frame->subclass.codec), ast_getformatname_multiple(buf1, sizeof(buf1), ast->nativeformats),
+                        ast_getformatname_multiple(buf2, sizeof(buf2), ast->readformat), ast_getformatname_multiple(buf3, sizeof(buf3), ast->writeformat));
+                goto END;
+            }
+
+            if (ast == line->subline[SUB_REAL].subline_owner) {
+                if (option_verbose >= 14)
+                    ast_verbose("write SUB_REAL\n");
+            rc = (!line->intern_rtp || line->is_native_bridged)
+                    ? 0 : ast_rtp_instance_write (line->intern_rtp, frame);
+            }
+            else {
+                if (option_verbose >= 14)
+                    ast_verbose("write SUB_CALLWAIT\n");
+                rc = (!line->subline[SUB_CALLWAIT].rtp || line->is_native_bridged)
+                        ? 0 : ast_rtp_instance_write (line->subline[SUB_CALLWAIT].rtp, frame);
+            }
+
+            if (option_verbose >= 15)
+                MSPD_LOG(5, "(%s/%s): rtp=%p, frame=%s\n",
+                        ast->name, sl_show_line_state(line),
+                        line->intern_rtp, ast_getformatname (frame->subclass.codec));
+            break;
+        case AST_FRAME_MODEM:
+	    if (line->udptl)
+		ast_udptl_write(line->udptl, frame);
+	    else {
+                MSPD_ERR("%s recvd T38 packet while T.38 is not negotiated\n",
+                         line->name);
+	    }
+    	    break;
+        default:
+            MSPD_WARN(5, "(%s): can't handle %d type frames\n", ast->name, frame->frametype);
+    }
+
+END:
+    ast_mutex_unlock(&line->lock);
+    return rc;
+}
+
+// -----------------------------------------------------------------------------------------------
+// This is called by Asterisk during a call transfer or call pickup, i.e. after a masquerade
+// operation (see ast_do_masquerade()).
+int
+mspd_fixup (struct ast_channel *old_ast, struct ast_channel *new_ast)
+{
+    mspd_line_t *const line = new_ast->tech_pvt;
+
+    if (!line) {
+        MSPD_ERR("(%s): Ast-channel has no line\n", new_ast->name);
+        return -1;
+    }
+    MSPD_LOCK (line->lock, return -1);
+    MSPD_LOG(2, AEP_FMT"Old=%s|%s\n", AEP_VAL (new_ast, line), old_ast->name,
+            ast_state2str (old_ast->_state));
+    if (line->owner != old_ast) {
+        MSPD_ERR(AEP_FMT"Expected old channel to be %s (%p) but it is %s (%p)\n",
+                AEP_VAL(new_ast, line), line->owner->name, line->owner,
+                old_ast->name, old_ast);
+        goto bail_out;
+    }
+    line->owner = new_ast;
+
+    /* fixup owner for sublines */
+    line->subline[line->is_call_wait ? SUB_CALLWAIT : SUB_REAL].subline_owner = new_ast;
+
+    if (line->channel) {
+        switch (old_ast->_state) {
+            case AST_STATE_RING:
+                switch (sl_get_line_state (line)) {
+                    case MLS_IDLE:
+                    case MLS_OFF_HOOK:
+                    case MLS_DIALING_0:
+                    case MLS_DIALING:
+                    case MLS_RINGING:
+                    case MLS_DISCONNECTING:
+                        MSPD_ERR(AEP_FMT"Unxpected line state for old channel %s state == %s\n",
+                                AEP_VAL (new_ast, line), old_ast->name,
+                                ast_state2str (old_ast->_state));
+                        goto bail_out;
+                    case MLS_CONNECTED:
+                    case MLS_CALL_PROCEEDING:
+                        if (mspd_channel_stop_tx (line->channel) ||
+                            mspd_channel_enable (line->channel, old_ast->rawreadformat) ||
+                            mspd_channel_set_tone (line->channel, DC_TONE_ANSWER))
+                                MSPD_ERR(AEP_FMT"DC_TONE_ANSWER has failed\n",
+                                        AEP_VAL (new_ast, line));
+                        sl_set_line_state (line, MLS_CALL_PROCEEDING);
+                    break;
+		    default:
+                    break;
+                }
+            break;
+            case AST_STATE_UP:
+                switch (sl_get_line_state (line)) {
+                    case MLS_IDLE:
+                    case MLS_OFF_HOOK:
+                    case MLS_DIALING_0:
+                    case MLS_DIALING:
+                    case MLS_DISCONNECTING:
+                    case MLS_CALL_PROCEEDING:
+                        goto unexpected_line_state;
+                    case MLS_RINGING:
+                        if (mspd_channel_set_tone (line->channel, DC_TONE_OFF))
+                            MSPD_ERR(AEP_FMT"DC_TONE_OFF has failed\n",
+                                    AEP_VAL (new_ast, line));
+                    break;
+		    default:
+                    break;
+                }
+            break;
+            case AST_STATE_RINGING:
+                switch (sl_get_line_state (line)) {
+                    case MLS_IDLE:
+                    case MLS_OFF_HOOK:
+                    case MLS_DIALING_0:
+                    case MLS_DIALING:
+                    case MLS_RINGING:
+                    case MLS_DISCONNECTING:
+                    case MLS_CALL_PROCEEDING:
+                        goto unexpected_line_state;
+		    default:
+                    break;
+                }
+            break;
+            case AST_STATE_DOWN:
+                switch (sl_get_line_state (line)) {
+                    case MLS_IDLE:
+                    case MLS_OFF_HOOK:
+                    case MLS_DIALING_0:
+                    case MLS_DIALING:
+                    case MLS_RINGING:
+                    case MLS_DISCONNECTING:
+                    case MLS_CALL_PROCEEDING:
+                        goto unexpected_line_state;
+		    default:
+                    break;
+                }
+            break;
+            default:
+                MSPD_ERR(AEP_FMT"Old Ast-channel %s has unexpected state %s\n",
+                        AEP_VAL (new_ast, line), old_ast->name,
+                        ast_state2str (old_ast->_state));
+                goto bail_out;
+        }
+    }
+    else {
+        switch (sl_get_line_state (line)) {
+            case MLS_DIALING_0:
+            case MLS_DIALING:
+            case MLS_CALL_PROCEEDING:
+            case MLS_CONNECTED:
+            case MLS_DISCONNECTING:
+                MSPD_LOG(3, AEP_FMT"Old=%s, line has no channel\n",
+                        AEP_VAL (new_ast, line), old_ast->name);
+            break;
+	    default:
+            break;
+        }
+    }
+    MSPD_UNLOCK (line->lock);
+    return 0;
+
+unexpected_line_state:
+    MSPD_ERR(AEP_FMT"Unxpected line state for old channel %s state == %s\n",
+            AEP_VAL (new_ast, line), old_ast->name,
+            ast_state2str (old_ast->_state));
+bail_out:
+    MSPD_UNLOCK (line->lock);
+    return -1;
+}
+
+int
+mspd_hangup (struct ast_channel *ast)
+{
+    mspd_line_t *const line = ast->tech_pvt;
+    int destroychan = 0;
+
+    if (!line) {
+        MSPD_ERR("(%s): Ast-channel has no line\n", ast->name);
+        return -1;
+    }
+
+    MSPD_LOG(1, AEP_FMT"Staring hangup on MSPD channel \n", AEP_VAL (ast, line));
+    MSPD_LOCK (line->lock, return -1);
+
+    if (line->udptl && line->channel)
+	/* Hangup happened in a middle of a T.38 fax transfer.
+	 * line->channel can be NULL if current Asterisk channel has hanged up.
+	 * In case if bridged channel has hanged up, line->channel for current Asterisk channel won't be NULL (to play busytone).
+	 * We need to revert back to voice only if MSP channel is alive.
+	 */
+        mspd_t38_mode_change_voice(line);
+
+    switch (sl_get_line_state (line)) {
+        //----------------------------------------------------------------------------------------
+        case MLS_RINGING:
+            if (!line->channel)
+                MSPD_ERR("Channel should not be NULL when line state MLS_RINGING.\n");
+            else
+                destroychan = 1;
+
+            if (line->phone->is_mapped_trunk) {
+                MSPD_LOG(2,"Disconnect phone:%s\tline:%s/%s\n",
+                                line->phone->name,
+                                line->name,
+                                sl_show_line_state(line));
+                MSPD_LOG(5, "Line %s:%u: Making TEMPO FXO onhook on TDM=0x%X (user_id=0x%X, link_id=0x%X)\n",
+                        line->name, line->timeslot,
+                        line->bus->tdm,
+                        sl_get_usrid_of_line (line),
+                        line->link_id);
+
+                if (tempo_fxo_make_onhook(sl_get_usrid_of_line (line),
+                                          line->link_id,
+                                          0x0200)) // TODO
+                   MSPD_ERR("%s:Error in tempo_make_fxo_onhook\n", line->name);
+
+                destroychan = 1;
+            }
+            else {
+                MSPD_LOG(5, "Line %s:%u: TEMPO Disconnect call on TDM=0x%X (user_id=0x%X, link_id=0x%X)\n",
+                        line->name, line->timeslot,
+                        line->bus->tdm,
+                        sl_get_usrid_of_line (line),
+                        line->link_id);
+                if (tempo_disconnect_call (sl_get_usrid_of_line (line),
+                                           line->link_id,
+                                           line->bus->tdm))
+                {
+                    MSPD_ERR(AEP_FMT"Tempo_disconnect_call has failed: %s\n",
+                            AEP_VAL (ast, line), strerror (errno));
+                    MSPD_UNLOCK(line->lock);
+                    return -1;
+                }
+            }
+            sl_reset_line(line, destroychan);
+            sl_set_line_state(line, MLS_IDLE);
+        break;
+
+        //----------------------------------------------------------------------------------------
+        case MLS_DIALING_0:
+        case MLS_DIALING:
+        case MLS_DIALING_FXO:
+            // when one party is on hold and waiting to connect to other
+            // party by dialing digits, but before time duration will
+            // get over if the hold party goes
+            // hangup we need to keep the line in dialing state
+
+            if (line->subline[SUB_CALLWAIT].subline_owner) {
+                sl_clear_subline (line, SUB_CALLWAIT);
+                line->is_call_on_hold = 0;
+
+                MSPD_LOG(3, "disconnect phone:%s\tline:%s/%s\n",
+                        line->phone->name, line->name, sl_state2text (line->state));
+            }
+            else {
+                sl_reset_line(line, 0);
+                sl_set_line_state (line, MLS_DISCONNECTING);
+            }
+        break;
+
+        //----------------------------------------------------------------------------------------
+        case MLS_CALL_PROCEEDING:
+            if (line->phone->is_mapped_trunk) {
+                MSPD_LOG(3, "disconnect phone:%s\tline:%s/MLS_CALL_PROCEEDING\n",
+                        line->phone->name, line->name);
+                MSPD_LOG(5, "Line %s:%u: Making TEMPO FXO onhook on TDM=0x%X (user_id=0x%X, link_id=0x%X)\n",
+                        line->name, line->timeslot,
+                        line->bus->tdm,
+                        sl_get_usrid_of_line (line),
+                        line->link_id);
+
+                if(tempo_fxo_make_onhook (sl_get_usrid_of_line (line),
+                                          line->link_id,
+                                          0x0200)) // TODO
+                        MSPD_ERR("%s:Error in tempo_make_fxo_onhook\n", line->name);
+                sl_reset_line(line, 1);
+                sl_set_line_state (line, MLS_IDLE);
+            }
+            else {
+                if (line->channel &&
+                    (mspd_channel_stop_tx (line->channel) ||
+                     mspd_channel_set_tone (line->channel, DC_TONE_BUSY)))
+                        MSPD_ERR("%s Error in setting dialtone\n", line->name);
+
+                if (line->is_call_on_hold){
+                    sl_set_line_state (line, MLS_WAIT_FOR_FLASH);
+                    line->owner = line->subline[SUB_REAL].subline_owner = NULL;
+                    line->subline[SUB_REAL].is_native_bridged = 0;
+                }
+
+                sl_reset_line(line, 0);
+                sl_set_line_state (line, MLS_DISCONNECTING);
+            }
+        break;
+
+        //----------------------------------------------------------------------------------------
+        case MLS_OFF_HOOK:
+        case MLS_CONNECTED:
+            if (ast != line->owner) {
+                sl_clear_subline (line, SUB_CALLWAIT);
+                line->is_call_on_hold = 0;
+                goto FINISH;
+            }
+
+            sl_set_line_state (line, MLS_DISCONNECTING);
+
+            if (line->channel) {
+                if (mspd_channel_stop_tx  (line->channel) ||
+                    mspd_channel_set_tone (line->channel, DC_TONE_BUSY))
+                        MSPD_ERR(AEP_FMT"DC_TONE_BUSY has failed\n", AEP_VAL (ast, line));
+
+                if (line->is_call_on_hold){
+                    MSPD_DBG("Disconnecting: is_call_on_hold\n");
+                    sl_set_line_state (line, MLS_WAIT_FOR_FLASH);
+
+                    line->owner = line->subline[SUB_REAL].subline_owner = NULL;
+                    line->subline[SUB_REAL].is_native_bridged = 0;
+                }
+                else
+                {
+                    MSPD_DBG("Disconnecting: NOT is_call_on_hold\n");
+                    sl_set_line_state (line, MLS_DISCONNECTING);
+                }
+            }
+            else
+                MSPD_ERR(AEP_FMT"Line misses channel\n", AEP_VAL (ast, line));
+
+            if (line->phone->is_mapped_trunk) {
+                MSPD_LOG(3, "%s/MLS_CONNECTED is trunk, disconnect\n", line->name);
+                MSPD_LOG(5, "Line %s:%u: Making TEMPO FXO onhook on TDM=0x%X (user_id=0x%X, link_id=0x%X)\n",
+                        line->name, line->timeslot,
+                        line->bus->tdm,
+                        sl_get_usrid_of_line (line),
+                        line->link_id);
+                tempo_fxo_make_onhook(sl_get_usrid_of_line (line),
+                                      line->link_id,
+                                      0x0200); // TODO
+                sl_reset_line(line, 1);
+                sl_set_line_state (line, MLS_IDLE);
+            }
+            else
+                sl_reset_line(line, 0);
+        break;
+
+        //----------------------------------------------------------------------------------------
+        case MLS_IDLE:
+        break;
+
+        //----------------------------------------------------------------------------------------
+        case MLS_DISCONNECTING:
+            sl_reset_line (line, destroychan);
+            sl_set_line_state (line, MLS_IDLE);
+        break;
+
+        //----------------------------------------------------------------------------------------
+        case MLS_THREEWAY:
+            if (ast == line->owner) {
+                MSPD_LOG(1, "%s/MLS_THREEWAY: SUB_REAL hangup. Converting to usual call\n", line->name);
+
+                if (line->subline[SUB_CALLWAIT].subline_owner) {
+                    sl_clear_subline(line, SUB_REAL);
+                    sl_swap_sublines(line);
+
+                    if (line->threeway_channels[SUB_REAL]) {
+                        mspd_channel_destroy (line->threeway_channels[SUB_REAL]);
+                        line->threeway_channels[SUB_REAL] = NULL;
+                    }
+                }
+            }
+            else {
+                MSPD_LOG(5, "%s/MLS_THREEWAY: SUB_CALLWAIT hangup. Converting to usual call\n", line->name);
+                MSPD_LOG(5, "Ast->name=%s <<<\n", ast->name);
+
+                sl_clear_subline(line, SUB_CALLWAIT);
+
+                if (line->threeway_channels[SUB_CALLWAIT]){
+                    mspd_channel_destroy (line->threeway_channels[SUB_CALLWAIT]);
+                    line->threeway_channels[SUB_CALLWAIT] = NULL;
+                }
+            }
+
+            ast_setstate (line->owner, AST_STATE_CONNECTED);
+            sl_set_line_state (line, MLS_CONNECTED);
+            line->call_direction = 0;
+            if(twc_restore_2way_call(line))
+                MSPD_ERR("Some problems with 3WC convertion\n");
+
+	    goto FINISH;
+        break;
+
+        //----------------------------------------------------------------------------------------
+        case MLS_WAIT_FOR_FLASH:
+            // if new incoming call has hang up then does following
+            if(ast != line->owner) {
+                MSPD_LOG(5, "Waiting call terminated without "
+                        "allowing us to switch to\n");
+
+                //reset the line information
+                sl_clear_subline(line, SUB_CALLWAIT);
+                line->is_call_wait = 0;
+
+                /* Stop callerid in case the remote phone hungup before even completion of callerid
+                 * (i.e., before getting CND_DONE).
+                 *
+                 * A very rare case???
+                 */
+                //dc_send_msg(line->channel, FC_CND_STOP, DC_EOM);
+
+                if (line->subline[SUB_REAL].subline_owner) {
+                    // chaneg the state to connected
+                    sl_set_line_state (line, MLS_CONNECTED);
+
+                    // change the state of ast channel
+                    ast_setstate(ast, AST_STATE_CONNECTED);
+                    /* Stop the call-waiting tone beeps */
+                    mspd_channel_set_tone (line->channel, DC_TONE_OFF);
+                }
+                else {
+                    // No current call
+
+                    /* TODO :- Once we start using OH callerid, we will not need this
+                     * as we already will be getting busy tone.
+                     */
+                    mspd_channel_set_tone (line->channel, DC_TONE_BUSY);
+
+                    sl_set_line_state (line, MLS_OFF_HOOK);
+                }
+            }
+            else {
+                /*No need to do any thing
+                 *clearance of subline[SUB_REAL] is done in sl_handle_flash().
+                 */
+                //ast_log(LOG_NOTICE, MSPD_FMT": Doing nothing in mspd_hangup\n", MSPD_WHERE);
+                if (ast == line->owner) {
+                    /* We are here because the current party has hungup.
+                     * We still have hold party to switch to.
+                     */
+
+                    MSPD_LOG(5, "Ongoing call terminated "
+                            "we still have a waiting call we can switch to\n");
+
+                    // Clear up ongoing chanel we will switch CALL_WAIT here at FLASH
+                    line->owner = line->subline[SUB_REAL].subline_owner = NULL;
+                    if (line->channel) {
+                        if (mspd_channel_stop_tx (line->channel)
+                            || mspd_channel_enable (line->channel, ast->rawreadformat)
+                            || mspd_channel_set_tone (line->channel, DC_TONE_BUSY))
+                            MSPD_ERR(AEP_FMT"DC_TONE_BUSY has failed\n", AEP_VAL (ast, line));
+                    }
+                    else
+                        MSPD_ERR(AEP_FMT"Line misses channel\n", AEP_VAL (ast, line));
+                }
+                else
+                    MSPD_ERR(AEP_FMT"REAL party should not be NULL in"
+                            " WAIT_FOR_FLASH state!\n", AEP_VAL (ast, line));
+
+            }
+	    goto FINISH;
+
+        //----------------------------------------------------------------------------------------
+        case MLS_FLASHED:
+            if (ast == line->owner) {
+                /* We are here because the current party has hungup.
+                 * We still have hold party to switch to.
+                 */
+                MSPD_LOG(5, "%s/MLS_FLASHED: Ongoing call terminated - "
+                        "hold call still available \n", line->name);
+               //!@2 just checking
+                if (line->subline[SUB_CALLWAIT].subline_owner) {
+                    // Clear up ongoing chanel we will switch CALL_WAIT here at FLASH
+                    line->owner = line->subline[SUB_REAL].subline_owner = NULL;
+                    if (line->channel) {
+                        if (mspd_channel_stop_tx (line->channel)
+                            || mspd_channel_set_tone (line->channel, DC_TONE_BUSY))
+                            MSPD_ERR(AEP_FMT"DC_TONE_BUSY has failed\n", AEP_VAL (ast, line));
+                    }
+                    else
+                        MSPD_ERR(AEP_FMT"Line misses channel\n", AEP_VAL (ast, line));
+
+                    // change the state to WAIT FOR FLASH
+                    sl_set_line_state (line, MLS_WAIT_FOR_FLASH);
+                }
+                else
+                    MSPD_ERR(AEP_FMT"HOLD party should not be NULL in FLASHED state!\n",
+                            AEP_VAL (ast, line));
+            }
+            else {
+                 // Party on hold got bored and hungup! Reset SUB_CALLWAIT
+                MSPD_LOG(5, "Remote party on hold hung up\n");
+                sl_clear_subline (line, SUB_CALLWAIT);
+                line->is_call_on_hold = False;
+
+                /*The following two lines are added for changing the state
+                 * when only one active channel is present.
+                 */
+                // set state of ast channel
+                ast_setstate (line->owner, AST_STATE_CONNECTED);
+
+                // change the state to flashed
+                sl_set_line_state (line, MLS_CONNECTED);
+            }
+
+            // Reset the line information
+            line->is_call_wait = 0;
+
+	    goto FINISH;
+    }
+
+    if (line->is_call_on_hold == 0)
+        switch (line->state) {
+            case MLS_DIALING_0:
+            case MLS_DIALING:
+            case MLS_DIALING_FXO:
+            break;
+            default:
+                sl_reset_line (line, destroychan);
+        }
+
+    ast_setstate (ast, AST_STATE_DOWN);
+
+    if (line->state == MLS_IDLE)
+        line->phone = NULL;
+
+    line->owner = line->subline[SUB_REAL].subline_owner = NULL;
+    line->subline[SUB_REAL].is_native_bridged = 0;
+
+    if (line->is_call_wait || line->is_call_on_hold) {
+        sl_swap_sublines(line);
+        line->is_call_on_hold = 0;
+        line->is_call_wait = 0;
+    }
+
+FINISH:
+    ast->tech_pvt = NULL;
+
+    /* Unlink hanged up channel from wherever possible,
+     * After this function returns, "ast" pointer will be
+     * invalid, because Asterisk will free the memory that it points to.
+     */
+    if(ast == line->owner)
+	line->owner = NULL;
+    if(ast == line->subline[SUB_REAL].subline_owner)
+	line->subline[SUB_REAL].subline_owner = NULL;
+    if(ast == line->subline[SUB_CALLWAIT].subline_owner)
+	line->subline[SUB_CALLWAIT].subline_owner = NULL;
+
+    MSPD_UNLOCK (line->lock);
+    MSPD_LOG(3, AEP_FMT"Phone hung up\n", AEP_VAL (ast, line));
+
+    mspd_update_use_count(0);
+
+    return 0;
+}
+
+// -----------------------------------------------------------------------------------------------
+static int
+mspd_senddigit_begin(struct ast_channel *ast, char digit)
+{
+    mspd_line_t *const line = ast->tech_pvt;
+    MSPD_LOCK (line->lock, return -1);
+
+    mspd_channel_play_dtmftone(line->channel, digit);
+
+    MSPD_UNLOCK (line->lock);
+    return 0;
+}
+
+static int
+mspd_senddigit_end(struct ast_channel *ast, char digit, unsigned int duration)
+{
+    mspd_line_t *const line = ast->tech_pvt;
+    MSPD_LOCK (line->lock, return -1);
+
+    mspd_channel_set_tone(line->channel, DC_TONE_OFF);
+
+    MSPD_UNLOCK (line->lock);
+    return 0;
+}
+
+// ===============================================================================================
+//FXO
+mspd_line_t *
+mspd_get_fxo_line (void)
+{
+    uint i = 0;
+    uint line_number;
+    mspd_phone_t *phone;
+    mspd_line_t  *line;
+
+    for (i = 0, phone = mspd_global.phones; i < mspd_global.n_phones; ++i, ++phone) {
+        if (phone->is_mapped_trunk != 0) {                                          // FXO mapped
+            line_number = sl_get_line_num_by_ts(phone->bus, phone->timeslot);
+            if (line_number == MAX_LINE_NUMBER) {
+                line_number = sl_get_free_line_num(phone->bus);
+                if (line_number == MAX_LINE_NUMBER) {
+                    MSPD_ERR("No free lines on the %s bus\n", phone->bus->name);
+                    return 0;
+                }
+                line = &phone->bus->lines[line_number];
+                line->phone = phone;
+                line->phone->line = line;
+                line->call_groups = phone->call_groups;
+                line->pickup_groups = phone->pickup_groups;
+                line->timeslot = phone->timeslot;
+                MSPD_LOG(3, "Line %s:%u has been assigned\n",
+                        line->name, line->timeslot);
+            }
+            else {
+                line = &phone->bus->lines[line_number];
+                MSPD_LOG(3, "Line %s:%u has been found\n",
+                        line->name, line->timeslot);
+            }
+            return line;
+        }
+    }
+
+    return NULL;
+}
+
+// -----------------------------------------------------------------------------------------------
+// This function properly responds to a FXO-call to this module
+// (i.e. a call to a SLIC phone or a tdmbus that is a trunk)
+struct ast_channel *
+mspd_fxo_request (const char *type, format_t format, const struct ast_channel *requestor, void *data, int *cause)
+{
+    char const *const called_exten = (char *) data;
+    struct ast_channel *dest_chan  = NULL;
+    mspd_line_t *line = NULL;
+    int is_busy = 0;
+    char buf[256];
+
+    MSPD_LOG(2, "(%s, %s, %s)\n",
+            type, ast_getformatname_multiple (buf, sizeof (buf), format), called_exten);
+
+    line = mspd_get_fxo_line();
+    if (!line) {
+        MSPD_ERR(" FXO line is absent\n");
+        return NULL;
+    }
+
+
+    MSPD_LOCK(line->lock, break);
+    MSPD_LOG(3, "(%s/%s:%u/%s)\n",
+            type, line->name, line->timeslot, sl_show_line_state(line));
+
+    line->t38state = (mspd_global_get_fax_mode() == MSPD_FAXMODE_PASSTHRU) ? T38_STATE_UNAVAILABLE : T38_STATE_UNKNOWN;
+
+    if (!line->owner && (sl_get_line_state (line) == MLS_IDLE)) {
+        dest_chan = mspd_new_ast_channel (line, format, 1, cause,
+                                          MSPD_SLIC_TYPE_FXO, (char *) chan_fxo_type,
+                                          requestor ? requestor->linkedid : NULL);
+        if (!dest_chan) {
+            MSPD_ERR("(%s:%u): New asterisk channel is not created\n", line->name, line->timeslot);
+            MSPD_UNLOCK (line->lock);
+            *cause = AST_CAUSE_SWITCH_CONGESTION;
+            return NULL;
+        }
+
+	if ((line->bus->tdm & BUS_MASK) == BUS_DECT)
+		line->channel = dc_create_voiposhm_channel(line, format);
+	else
+        line->channel = dc_create_voip_channel(line, format);
+        if (!line->channel) {
+              MSPD_LOG(3, "(%s:%u): voip-channel creation has failed\n",
+                      line->name, line->timeslot);
+              MSPD_UNLOCK (line->lock);
+              *cause = AST_CAUSE_SWITCH_CONGESTION;
+        }
+
+        MSPD_LOG(3, "%s:%u->channel=%s\n",
+                line->name, line->timeslot, mspd_channel_get_name(line->channel));
+    }
+    else
+        is_busy = 1;
+
+    MSPD_UNLOCK (line->lock);
+
+    if (!dest_chan) {
+        if (!is_busy) {
+            *cause = AST_CAUSE_SWITCH_CONGESTION;
+            MSPD_WARN(3,"(%s, %s, %s): can't satisfy request (but not BUSY!)\n",
+                    type, ast_getformatname_multiple(buf, sizeof (buf), format), called_exten);
+        }
+        else {
+            *cause = AST_CAUSE_USER_BUSY;
+            MSPD_WARN(3, "(%s, %s, %s): can't satisfy request (BUSY!)\n",
+                    type, ast_getformatname_multiple(buf, sizeof (buf), format), called_exten);
+        }
+    }
+
+    return dest_chan;
+}
+
+// -----------------------------------------------------------------------------------------------
+// Called when Asterisk places an outgoing call to this channel-module
+// (e.g. a phone is called)
+int
+mspd_fxo_call (struct ast_channel *ast, char *dest, int timeout)
+{
+    int  i = 0;
+    char called_number[32];
+    mspd_line_t *const line = ast->tech_pvt;
+
+    MSPD_LOG(1, "--- FXO call ---\n");
+
+    if (!line) {
+        MSPD_ERR("(%s): Ast-channel has no line\n", ast->name);
+        return -1;
+    }
+
+    MSPD_LOCK (line->lock, return -1);
+
+    called_number[0] = snprintf (called_number + 1,
+                                sizeof (called_number) - 1, "%d",
+                                line->timeslot);
+
+    MSPD_LOG(3, AEP_FMT"Dest=%s\tchannel-name=%s\tcalled-number=%s\n",
+            AEP_VAL (ast, line), dest,
+            mspd_channel_get_name(line->channel), called_number);
+    MSPD_LOG(5,"Line %s:%u: Making TEMPO FXO outgoing call to TDM=0x%X: Number=%s (user_id=0x%X)\n",
+            line->name, line->timeslot,
+            line->bus->tdm, called_number + 1,
+            sl_get_usrid_of_line (line));
+
+    if (tempo_make_outgoing_call (sl_get_usrid_of_line (line),
+                                  line->bus->tdm,
+				   line->timeslot,
+                                  (unsigned char*)called_number))
+    {
+        MSPD_ERR(AEP_FMT"Tempo_make_outgoing_call(%d, 0x%x, %s) has failed: %s\n",
+                AEP_VAL (ast, line),
+                sl_get_usrid_of_line (line), line->bus->tdm,
+                called_number + 1, strerror (errno));
+        return -1;
+    }
+    MSPD_UNLOCK (line->lock);
+    MSPD_LOG(3, "Waiting for a responce from remote side, %d ms \n", mspd_global.fxo_call_delay);
+    usleep(mspd_global.fxo_call_delay * 1000);  // Sleep for some time to wait for a SLIC reaction to fxo_outgoing_call
+
+    // send dialed digits to other end
+    mspd_channel_start_tx(line->channel);
+    for (i = 0; i < strlen(dest); i++) {
+        MSPD_LOG(3, "Sending dtmf tone:%d on channel:%s on line:%s:%u\n",
+                dest[i]- '0', mspd_channel_get_name(line->channel), line->name, line->timeslot);
+        mspd_channel_play_dtmftone(line->channel, dest[i]);
+        usleep(200 * 1000);  // Sleep for 200 ms = ToneON + ToneOFF + 40 additional ms
+    }
+    sl_set_line_state (line, MLS_CONNECTED);
+    if (sl_do_ast_channel_action(line, &line->owner,
+                (int (*)(struct ast_channel*, void*))&ast_queue_frame,
+    		&(struct ast_frame){.frametype = AST_FRAME_CONTROL,
+	        .subclass = {AST_CONTROL_ANSWER}}))
+    {
+        MSPD_ERR("(%s:%u/%s): queueing answer control-frame has failed\n",
+                line->name, line->timeslot, sl_show_line_state(line));
+    }
+
+    return 0;
+}
+
+// -----------------------------------------------------------------------------------------------
+// Called by Asterisk when the FXO-channel is shut down
+// (i.e. when ast_hangup() is executed)
+int
+mspd_fxo_hangup (struct ast_channel *ast)
+{
+    mspd_line_t *const line = ast->tech_pvt;
+
+    MSPD_LOG(1, "--- FXO hangup ---\n");
+
+    if (!line)
+        return -1;
+
+    MSPD_LOG(3, "Hangup %s/%s trunk=%d usr_id=%x link_id=%x\n",
+            line->name, sl_show_line_state (line),
+            line->phone->is_mapped_trunk,
+            sl_get_usrid_of_line (line), line->link_id);
+
+    MSPD_LOG(5,"Line %s:%u: TEMPO FXO Disconnect call on TDM=0x%X (user_id=0x%X, link_id=0x%X)\n",
+            line->name, line->timeslot,
+            line->bus->tdm,
+            sl_get_usrid_of_line (line),
+            line->link_id);
+
+    mspd_hangup(ast);
+    MSPD_LOCK (line->lock, return -1);
+
+    if (tempo_disconnect_call (sl_get_usrid_of_line (line),
+                               line->link_id,
+                               line->bus->tdm))
+    {
+        MSPD_ERR(AEP_FMT"Tempo_disconnect_call has failed: %s\n",
+                AEP_VAL (ast, line), strerror (errno));
+        MSPD_UNLOCK (line->lock);
+        return -1;
+    }
+
+    MSPD_LOG(3,"Line %s:%u has been released\n",
+             line->name, line->timeslot);
+
+    sl_set_line_state (line, MLS_IDLE);
+    line->timeslot = MAX_TIMESLOT_NUMBER;
+    MSPD_UNLOCK (line->lock);
+    return 0;
+}
+
+// -----------------------------------------------------------------------------------------------
+int
+mspd_hangup_ast_channel(struct ast_channel* ast, void* data)
+{
+    return ast_queue_hangup(ast);
+}
+
+static enum channelreloadreason mspd_reloadreason;       /*!< Reason for last reload/load of configuration */
+
+// ===============================================================================================
+// Loading, configuration & initialization
+// ===============================================================================================
+// MODULE ENTRY POINT
+int
+load_module (void)
+{
+    enum ast_module_load_result retcode = AST_MODULE_LOAD_SUCCESS;
+
+    if (!option_verbose)
+         option_verbose = 1;
+    MSPD_LOG(1, "MSPD Channel Module loading ...\n");
+
+    sched = sched_context_create();
+    if (!sched)
+        MSPD_WARN(2, "Unable to create schedule context\n");
+
+    ast_mutex_init (&mspd_global.lock);
+    MSPD_LOCK (mspd_global.lock, goto bail_out);
+
+    mspd_reloadreason = CHANNEL_MODULE_LOAD;
+
+    if(reload_config(mspd_reloadreason)) { /* Load the configuration from mspd.conf */
+        retcode = AST_MODULE_LOAD_DECLINE;
+        goto bail_out_locked;
+    }
+
+    if (sl_init()) {
+        retcode = AST_MODULE_LOAD_DECLINE;
+        goto bail_out_locked;
+    }
+
+    /*if (option_debug > 1) {
+            MSPD_LOG (1, "Setting VAPI debug level to %d\n", option_debug - 1);
+            VAPI_SetDebugLevel (option_debug - 1, option_debug - 1);
+        }*/
+
+    mspd_global.ec_type_prev = mspd_global_get_ec_type();
+
+    /* Registering our MSPD channel type */
+    MSPD_LOG(1, "Registering %s channel type\n", mspd_tech.type);
+    if (ast_channel_register (&mspd_tech)) {
+        MSPD_ERR("Unable to register channel type %s\n", chan_type);
+        retcode = AST_MODULE_LOAD_FAILURE;
+        goto bail_out_locked;
+    }
+
+    MSPD_LOG(1, "Registering %s channel typ\n", mspd_fxo_tech.type);
+    if (ast_channel_register (&mspd_fxo_tech)) {
+        MSPD_ERR("Unable to register channel type %s\n", chan_fxo_type);
+        retcode = AST_MODULE_LOAD_FAILURE;
+        goto bail_out_locked;
+    }
+
+    /* Tell the RTP engine about our RTP glue */
+    MSPD_LOG(3, "Registering %s RTP protocol\n", mspd_rtp_glue.type);
+    if (ast_rtp_glue_register(&mspd_rtp_glue)) {
+        MSPD_ERR("Unable to register %s RTP protocol\n", mspd_rtp_glue.type);
+        retcode = AST_MODULE_LOAD_FAILURE;
+        goto bail_out_locked;
+    }
+
+    /* Tell the RTP engine about our RTP glue for FXO */
+    MSPD_LOG(3, "Registering %s RTP protocol\n", mspd_rtp_fxo_glue.type);
+    if (ast_rtp_glue_register(&mspd_rtp_fxo_glue)) {
+        MSPD_ERR("Unable to register %s RTP protocol\n", mspd_rtp_fxo_glue.type);
+        retcode = AST_MODULE_LOAD_FAILURE;
+        goto bail_out_locked;
+    }
+
+    // TODO: add udptl support
+    /* Tell the UDPTL subdriver that we're here */
+    //ast_udptl_proto_register(&mspd_udptl);
+
+    MSPD_LOG(3, "Registering MSPD CLI commands\n");
+    /* Register all CLI functions for MSPD */
+    if (ast_cli_register_multiple(cli_mspd, ARRAY_LEN(cli_mspd))) {
+        MSPD_WARN(1, "Some CLI commands are not registered\n");
+    }
+
+#ifdef MSPD_DEBUG
+    if (ast_cli_register_multiple(cli_mspd_debug, ARRAY_LEN(cli_mspd_debug))) {
+            MSPD_WARN(1, "Some debug CLI commands are not registered\n");
+    }
+#endif
+
+    if (ast_cli_register_multiple(cli_dect, ARRAY_LEN(cli_dect)))
+        MSPD_WARN(1, "Some DECT CLI commands are not registered\n");
+
+
+    MSPD_LOG(3, "Registering MSPD FXO extension\n");
+    ast_set_fxo_ext();
+
+    MSPD_LOG(3, "Starting up STI lines layer\n");
+    if (sl_startup ()) {
+        retcode = AST_MODULE_LOAD_FAILURE;
+        goto bail_out_locked;
+    }
+
+    if (mspd_global.ud_prefs.is_ud_info_set) {
+        MSPD_LOG(3, "Enabling Supervisor Unified diagnostic\n");
+        dc_send_enable_ud_cmds_supvsr();
+    }
+
+/*#ifdef MSPD_CONFERENCE
+    if (load_conf_app_info()) {
+        MSPD_ERR("Unable to load MSPD Conference Module\n");
+    }
+    MSPD_LOG(1, "=== MSPD Conference Module loaded ===\n");
+#endif*/
+
+    MSPD_LOG(1, "=== MSPD Channel Module loaded ===\n");
+    MSPD_UNLOCK (mspd_global.lock);
+
+    return retcode;
+
+bail_out_locked:
+    MSPD_UNLOCK (mspd_global.lock);
+bail_out:
+    unload_module ();
+
+    return retcode;
+}
+
+// ===============================================================================================
+// MODULE EXIT POINT
+int
+unload_module (void)
+{
+    U16  i, j;
+    mspd_bus_t *bus;
+    mspd_line_t *line;
+    int line_in_use = 0;
+
+    MSPD_LOG(1, " MSPD Channel Module unloading...\n");
+
+    MSPD_LOCK (mspd_global.lock, return -1);
+
+    ast_channel_unregister (&mspd_tech);
+    ast_channel_unregister (&mspd_fxo_tech);
+
+    for (i = 0, bus = mspd_global.buses; i < mspd_global.n_buses; ++i, ++bus) {
+        for (j = 0, line = bus->lines; j < bus->n_lines; ++j, ++line) {
+            MSPD_LOCK (line->lock, /*ignore */ );
+            if (line->owner) {
+                MSPD_LOG(2, "Hanging up %s\n", line->owner->name);
+                ast_softhangup (line->owner, AST_SOFTHANGUP_APPUNLOAD);
+                line_in_use = 1;
+            }
+            MSPD_UNLOCK (line->lock);
+        }
+    }
+
+    if (line_in_use) {
+        MSPD_UNLOCK (mspd_global.lock);
+        MSPD_LOG(2, "Some lines are active -> can't unload\n");
+        return -1;
+    }
+
+    if (sl_shutdown_and_cleanup ()) {
+        MSPD_ERR("TEMPO shutdown has failed\n");
+        MSPD_UNLOCK (mspd_global.lock);
+        return -1;
+    }
+
+    for (i = 0; i < mspd_global.n_phones; ++i) {
+        mspd_phone_t *phone = &mspd_global.phones[i];
+        free (phone->name);
+        if (phone->callerid)
+            free (phone->callerid);
+        free (phone->context);
+        phone->line = NULL;
+    }
+
+    mspd_global.n_phones = 0;
+
+    if (mspd_global.context)
+        free (mspd_global.context);
+
+    mspd_global.context = NULL;
+
+    MSPD_UNLOCK (mspd_global.lock);
+    ast_mutex_destroy (&mspd_global.lock);
+
+/*#ifdef MSPD_CONFERENCE
+    unload_conf_app_info();
+#endif*/
+
+    MSPD_LOG(1, "=== MSPD channel module unloaded ===\n");
+
+    return 0;
+}
+
+AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_LOAD_ORDER, "Mindspeed channel module",
+		.load = load_module,
+		.unload = unload_module,
+		.reload = NULL,  //reload_module,
+		.load_pri = AST_MODPRI_CHANNEL_DRIVER,
+		.nonoptreq = "",
+	);
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/channels/chan_multicast_rtp.c asterisk-1.8.2.3.new/channels/chan_multicast_rtp.c
--- asterisk-1.8.2.3/channels/chan_multicast_rtp.c	2010-08-18 18:00:40.000000000 +0530
+++ asterisk-1.8.2.3.new/channels/chan_multicast_rtp.c	2011-06-24 16:59:32.000000000 +0530
@@ -139,7 +139,7 @@
 		goto failure;
 	}
 
-	if (!(instance = ast_rtp_instance_new("multicast", NULL, &control_address, multicast_type))) {
+	if (!(instance = ast_rtp_instance_new("multicast", NULL, &control_address, multicast_type, 0))) {
 		goto failure;
 	}
 
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/channels/chan_sip.c asterisk-1.8.2.3.new/channels/chan_sip.c
--- asterisk-1.8.2.3/channels/chan_sip.c	2010-12-10 03:48:19.000000000 +0530
+++ asterisk-1.8.2.3.new/channels/chan_sip.c	2011-06-24 16:59:32.000000000 +0530
@@ -4786,13 +4786,13 @@
 	}
 
 	ast_sockaddr_copy(&bindaddr_tmp, &bindaddr);
-	if (!(dialog->rtp = ast_rtp_instance_new(dialog->engine, sched, &bindaddr_tmp, NULL))) {
+	if (!(dialog->rtp = ast_rtp_instance_new(dialog->engine, sched, &bindaddr_tmp, NULL, 0))) {
 		return -1;
 	}
 
 	if (ast_test_flag(&dialog->flags[1], SIP_PAGE2_VIDEOSUPPORT_ALWAYS) ||
 			(ast_test_flag(&dialog->flags[1], SIP_PAGE2_VIDEOSUPPORT) && (dialog->capability & AST_FORMAT_VIDEO_MASK))) {
-		if (!(dialog->vrtp = ast_rtp_instance_new(dialog->engine, sched, &bindaddr_tmp, NULL))) {
+		if (!(dialog->vrtp = ast_rtp_instance_new(dialog->engine, sched, &bindaddr_tmp, NULL, 0))) {
 			return -1;
 		}
 		ast_rtp_instance_set_timeout(dialog->vrtp, global_rtptimeout);
@@ -4802,7 +4802,7 @@
 	}
 
 	if (ast_test_flag(&dialog->flags[1], SIP_PAGE2_TEXTSUPPORT)) {
-		if (!(dialog->trtp = ast_rtp_instance_new(dialog->engine, sched, &bindaddr_tmp, NULL))) {
+		if (!(dialog->trtp = ast_rtp_instance_new(dialog->engine, sched, &bindaddr_tmp, NULL, 0))) {
 			return -1;
 		}
 		ast_rtp_instance_set_timeout(dialog->trtp, global_rtptimeout);
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/channels/chan_skinny.c asterisk-1.8.2.3.new/channels/chan_skinny.c
--- asterisk-1.8.2.3/channels/chan_skinny.c	2010-09-21 02:59:46.000000000 +0530
+++ asterisk-1.8.2.3.new/channels/chan_skinny.c	2011-06-24 16:59:32.000000000 +0530
@@ -3728,9 +3728,9 @@
 	ast_mutex_lock(&sub->lock);
 	/* Allocate the RTP */
 	ast_sockaddr_from_sin(&bindaddr_tmp, &bindaddr);
-	sub->rtp = ast_rtp_instance_new("asterisk", sched, &bindaddr_tmp, NULL);
+	sub->rtp = ast_rtp_instance_new("asterisk", sched, &bindaddr_tmp, NULL, 0);
 	if (hasvideo)
-		sub->vrtp = ast_rtp_instance_new("asterisk", sched, &bindaddr_tmp, NULL);
+		sub->vrtp = ast_rtp_instance_new("asterisk", sched, &bindaddr_tmp, NULL, 0);
 
 	if (sub->rtp) {
 		ast_rtp_instance_set_prop(sub->rtp, AST_RTP_PROPERTY_RTCP, 1);
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/channels/chan_unistim.c asterisk-1.8.2.3.new/channels/chan_unistim.c
--- asterisk-1.8.2.3/channels/chan_unistim.c	2010-07-14 21:18:36.000000000 +0530
+++ asterisk-1.8.2.3.new/channels/chan_unistim.c	2011-06-24 16:59:32.000000000 +0530
@@ -2068,7 +2068,7 @@
 	if (unistimdebug)
 		ast_verb(0, "Starting RTP. Bind on %s\n", ast_inet_ntoa(sout.sin_addr));
 	ast_sockaddr_from_sin(&sout_tmp, &sout);
-	sub->rtp = ast_rtp_instance_new("asterisk", sched, &sout_tmp, NULL);
+	sub->rtp = ast_rtp_instance_new("asterisk", sched, &sout_tmp, NULL, 0);
 	if (!sub->rtp) {
 		ast_log(LOG_WARNING, "Unable to create RTP session: %s binaddr=%s\n",
 				strerror(errno), ast_inet_ntoa(sout.sin_addr));
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/channels/Makefile asterisk-1.8.2.3.new/channels/Makefile
--- asterisk-1.8.2.3/channels/Makefile	2010-06-08 01:34:42.000000000 +0530
+++ asterisk-1.8.2.3.new/channels/Makefile	2011-10-25 19:59:07.000000000 +0530
@@ -1,6 +1,6 @@
 #
 # Asterisk -- A telephony toolkit for Linux.
-# 
+#
 # Makefile for channel drivers
 #
 # Copyright (C) 1999-2006, Digium, Inc.
@@ -90,6 +90,28 @@
 endif
 endif
 
+#
+# Mindspeed Comcerto channel module
+
+MSPD_OBJS   := mspd/mspd_dev-channels.o mspd/mspd_sti-lines.o mspd/mspd_rtp.o mspd/mspd_threeway.o mspd/t38.o chan_mspd.o
+
+MSPD_DEBUG:=1
+MSPD_FLAGS:= -DMSPD_CONFERENCE -DTEMPO_NEW_API -Werror
+MSPD_LIBS:= -lrt -lvapi -lgtlcommon -lgtlcsme -lsti
+AST_INCLUDE:= -Iinclude -I../include -Imspd
+
+ifeq ($(MSPD_DEBUG), 1)
+	MSPD_FLAGS += -DMSPD_DEBUG
+endif
+
+$(MSPD_OBJS): %.o: %.c
+	$(ECHO_PREFIX) echo "   [CC] $^ -> $@"
+	$(CC) -c $(CC_CFLAGS) $(EXTRA_CFLAGS) $(MSPD_FLAGS) $< -o $@
+
+chan_mspd.so: $(MSPD_OBJS)
+	$(ECHO_PREFIX) echo "   [LD] $^ -> $@"
+	$(CC) $(SOLINK) $(MSPD_OBJS) -o $@ $(EXTRA_LDFLAGS) $(MSPD_LIBS)
+
 chan_misdn.o: _ASTCFLAGS+=-Imisdn
 
 misdn_config.o: _ASTCFLAGS+=-Imisdn
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/channels/.moduleinfo asterisk-1.8.2.3.new/channels/.moduleinfo
--- asterisk-1.8.2.3/channels/.moduleinfo	2011-01-27 02:48:32.000000000 +0530
+++ asterisk-1.8.2.3.new/channels/.moduleinfo	2011-03-09 22:13:09.000000000 +0530
@@ -46,6 +46,8 @@
 	<depend>misdn</depend>
 	<depend>suppserv</depend>
 </member>
+<member name="chan_mspd" displayname="Mindspeed channel module" remove_on_change="channels/chan_mspd.o channels/chan_mspd.so">
+</member>
 <member name="chan_multicast_rtp" displayname="Multicast RTP Paging Channel" remove_on_change="channels/chan_multicast_rtp.o channels/chan_multicast_rtp.so">
 </member>
 <member name="chan_nbs" displayname="Network Broadcast Sound Support" remove_on_change="channels/chan_nbs.o channels/chan_nbs.so">
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/channels/mspd/include/chan_mspd.h asterisk-1.8.2.3.new/channels/mspd/include/chan_mspd.h
--- asterisk-1.8.2.3/channels/mspd/include/chan_mspd.h	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/channels/mspd/include/chan_mspd.h	2011-12-20 21:43:27.000000000 +0530
@@ -0,0 +1,141 @@
+/*
+ * Mindspeed Comcerto - Channel module for line handling.
+ *
+ *  Copyright (C) 2004,2005 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef _CHAN_MSPD_H_
+#define _CHAN_MSPD_H_
+
+// ===============================================================================================
+// Includes
+
+#include <string.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <errno.h>
+#include <time.h>
+#include <unistd.h>
+#include <signal.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <assert.h>
+
+#include "mspd_common.h"
+#include "asterisk/mspd/macro.h"
+#include "asterisk/mspd/defaults.h"
+
+#include <vapi/gtl.h>
+
+#include "asterisk.h"
+#include "asterisk/lock.h"
+#include "asterisk/channel.h"
+#include "asterisk/config.h"
+#include "asterisk/logger.h"
+#include "asterisk/module.h"
+#include "asterisk/pbx.h"
+#include "asterisk/options.h"
+#include "asterisk/utils.h"
+#include "asterisk/cli.h"
+#include "asterisk/rtp_engine.h"
+#include "asterisk/translate.h"
+
+// ===============================================================================================
+// Proto
+int                     load_module (void);   // MSPD Channel module entry point
+int                     unload_module (void);// MSPD Channel module exit point
+
+int                     mspd_call       (struct ast_channel *ast, char *dest, int timeout);
+struct ast_channel *    mspd_request    (const char *type, format_t format, const struct ast_channel *requestor, void *data, int *cause);
+int                     mspd_hangup     (struct ast_channel *ast);
+int                     mspd_answer     (struct ast_channel *ast);
+int                     mspd_indicate   (struct ast_channel *c, int condition, const void *data, size_t datalen);
+struct ast_frame*       mspd_read       (struct ast_channel *ast);
+int                     mspd_write      (struct ast_channel *ast, struct ast_frame *frame);
+#if 0
+enum ast_bridge_result  mspd_bridge     (struct ast_channel *ast0,
+                                         struct ast_channel *ast1,
+                                         int flags,
+                                         struct ast_frame **stopping_frame,
+                                         struct ast_channel **stopping_ast);
+void                    mspd_bridge_stop_tdm_hairpin (struct ast_channel *ast,
+                                                      mspd_line_t * line,
+                                                      uint channel_tag,
+                                                      uint format);
+#endif
+
+struct ast_channel *    mspd_new_ast_channel (mspd_line_t * line,
+                                              format_t format,
+                                              int is_outgoing,
+                                              int *cause,
+                                              mspd_slic_type_t stype,
+                                              const char *chan_id,
+                                              const char *linkedid);
+
+int                     mspd_hangup_ast_channel(struct ast_channel* ast, void* data);
+
+mspd_line_t *           mspd_get_fxo_line (void);
+
+
+int                     mspd_fixup      (struct ast_channel *old_ast,
+                                         struct ast_channel *new_ast);
+int                     mspd_senddigit  (struct ast_channel *ast, char digit);
+int                     mspd_change_codec_format (struct ast_channel *chan, format_t fmt);
+
+int                     mspd_fxo_call   (struct ast_channel *ast, char *dest, int timeout);
+int                     mspd_fxo_hangup (struct ast_channel *ast);
+struct ast_channel *    mspd_fxo_request (const char *type, format_t format, const struct ast_channel *requestor, void *data, int *cause);
+
+int                     usecount (void);
+void                    mspd_update_use_count (Boolean UP);
+char *                  description (void);
+char *                  key (void);
+
+//-------------------------------------------------------------------------------
+int config_global  (struct ast_config *cfg, char *cat);
+int config_device  (struct ast_config *cfg, char *cat);
+int config_tdmbus  (struct ast_config *cfg, char *cat);
+int config_phone   (struct ast_config *cfg, char *cat);
+int config_ud_info (struct ast_config *cfg, char *cat);
+
+int parse_ipaddr (uint32_t * ip, struct ast_variable *v);
+//-------------------------------------------------------------------------------
+
+//-------------------------------------------------------------------------------
+// CLI Service functions prototypes
+char * complete_mspdch             (const char *line, const char *word, int pos, int state);
+char * mspd_cli_send_cmd_channel   (struct ast_cli_entry *e, int cmd, struct ast_cli_args *a, const mspd_channel_t *channel, const mspd_device_t* dev);
+char * mspd_cli_show_phone_conf    (struct ast_cli_entry *e, int cmd, struct ast_cli_args *a);
+char * mspd_cli_show_global_conf   (struct ast_cli_entry *e, int cmd, struct ast_cli_args *a);
+char * mspd_cli_show_lines_state   (struct ast_cli_entry *e, int cmd, struct ast_cli_args *a);
+#ifdef MSPD_DEBUG
+char * mspd_cli_reload_lines       (struct ast_cli_entry *e, int cmd, struct ast_cli_args *a);
+char * mspd_cli_count_active_lines (struct ast_cli_entry *e, int cmd, struct ast_cli_args *a);
+#endif
+int    mspd_count_active_lines     (void);
+char * mspd_cli_reload_conf        (struct ast_cli_entry *e, int cmd, struct ast_cli_args *a);
+char * mspd_cli_reload_phone_conf  (struct ast_cli_entry *e, int cmd, struct ast_cli_args *a);
+char * mspd_cli_show_ud_conf       (struct ast_cli_entry *e, int cmd, struct ast_cli_args *a);
+char * mspd_cli_send_cmd           (struct ast_cli_entry *e, int cmd, struct ast_cli_args *a);
+
+//-------------------------------------------------------------------------------
+
+void   ast_set_fxo_ext(void);
+char * ast_fxo_ext (void);
+
+//-------------------------------------------------------------------------------
+
+void set_vapi_config (SCSMEUsrData *vapi_gtl_dev_conf);
+
+//-------------------------------------------------------------------------------
+
+#endif // _CHAN_MSPD_H_
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/channels/mspd/include/mspd_common.h asterisk-1.8.2.3.new/channels/mspd/include/mspd_common.h
--- asterisk-1.8.2.3/channels/mspd/include/mspd_common.h	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/channels/mspd/include/mspd_common.h	2012-02-03 16:32:39.000000000 +0530
@@ -0,0 +1,301 @@
+/*
+ * Mindspeed Comcerto Channel module.
+ *
+ *  Copyright (C) 2004 - 2011 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef _MSPD_COMMON_H_
+#define _MSPD_COMMON_H_
+
+// ===============================================================================================
+// Includes
+
+#include "asterisk.h"
+
+#include <stdint.h>
+#include <stdio.h>
+
+#include <sti.h>
+#include <vapi/vapi.h>
+#include <vapi/gtl.h>
+
+#include "asterisk/mspd/queue.h"
+#include "asterisk/mspd/utils.h"
+#include "asterisk/mspd/defaults.h"
+#include "asterisk/mspd/macro.h"
+#include "asterisk/mspd/common.h"
+#include "asterisk/mspd/device.h"
+#include "asterisk/mspd/channel.h"
+#include "asterisk/mspd/conference.h"
+
+#include <asterisk/channel.h>
+#include <asterisk/rtp_engine.h>
+#include <asterisk/lock.h>
+#include <asterisk/term.h>
+#include <asterisk/frame_defs.h>
+
+// ===============================================================================================
+
+#define MSPD_FLAG_EMPTY         (0)
+#define MSPD_FLAG_OUTGOING_CALL (1)
+#define MSPD_FLAG_CALL_WAITING  (2)
+
+// TEMPO types of TDM bus
+#define BUS_PRI                 (TEMPO_LINE_TYPE_PRI  << 8)
+#define BUS_SLIC                (TEMPO_LINE_TYPE_SLIC << 8)
+#define BUS_DECT                (TEMPO_LINE_TYPE_DECT << 8)
+// mask rejects an index of bus
+#define BUS_MASK                (0xFF << 8)
+
+#define MSPD_DIAL_TIMEOUT_VAL         (8000)
+#define MSPD_INTERDIGIT_TIMEOUT_VAL   (1300)
+
+#define MSPD_CID_MSG_MAX_LENGTH 256
+
+#define SUB_LINES         2
+#define SUB_REAL          0
+#define SUB_CALLWAIT      1
+
+#define MSPD_FD_RTP	0
+#define MSPD_FD_RTCP	1
+#define MSPD_FD_UDPTL	5
+
+// -----------------------------------------------------------------------------------------------
+// types
+
+// the state of a line
+typedef enum mspd_line_state {
+    MLS_IDLE,
+    MLS_RINGING,
+    MLS_OFF_HOOK,
+    MLS_DIALING_FXO,
+    MLS_DIALING_0,
+    MLS_DIALING,
+    MLS_CALL_PROCEEDING,
+    MLS_CONNECTED,
+    MLS_DISCONNECTING,
+    MLS_WAIT_FOR_FLASH,
+    MLS_FLASHED,
+    MLS_THREEWAY
+} mspd_line_state_t;
+
+typedef struct mspd_dtmf_freq {
+    U16 prim_freq;
+    U16 secnd_freq;
+} mspd_dtmf_freq_t;
+
+typedef enum mspd_slic_type {
+    MSPD_SLIC_TYPE_FXS,     // Foreign eXchange Subscriber
+    MSPD_SLIC_TYPE_FXO      // Foreign Exchange Office
+} mspd_slic_type_t;
+
+enum mspd_allow {
+    DISALLOW  = 0,
+    ALLOW  = 1
+};
+
+typedef enum {
+    SWITCH,
+    THREEWAYCALL
+} FlashMode;
+
+#define AST_STATE_CONNECTED    10  /*! line is in conversation */
+#define AST_STATE_IS_CALL_WAIT 11  /*! line is busy and incoming call came on the same line */
+#define AST_STATE_FLASHED      12  /*! line is flashed */
+
+//early typedefs for pointers to parent structures
+typedef struct ast_codec_pref       mspd_codec_pref;
+
+typedef struct mspd_channel_tdm_t   mspd_channel_tdm_t;
+typedef struct mspd_channel_rtp_t   mspd_channel_rtp_t;
+typedef struct mspd_channel_part_t  mspd_channel_part_t;
+
+typedef struct mspd_phone_t         mspd_phone_t;
+
+typedef struct mspd_line_t          mspd_line_t;
+typedef struct mspd_bus_t           mspd_bus_t;
+typedef struct mspd_global_t        mspd_global_t;
+typedef struct mspd_ud_pref_t       mspd_ud_pref_t ;
+
+// a phone, i.e. specific SLIC-line with additional information like caller-id and context
+struct mspd_phone_t {
+    char                *name;
+    char                *context;
+    U16                 pickup_groups;
+    U16                 call_groups;
+    format_t            allowed_codecs;
+    mspd_codec_pref     codec_prefs;
+
+    mspd_bus_t          *bus;
+    mspd_line_t         *line;
+
+    BandMode            wideband;
+    U16                 timeslot;
+    char                *callerid;
+
+    U16                 is_mapped_trunk;
+    mspd_echocan_t      echocan;
+    U16                 ud_enable;
+    U16                 dialout_number;
+    U16                 dsp_acp;
+    U16                 vad;
+    mspd_bwe_t          bwe;
+};
+
+// feature-specific channel information
+//(channel features can be deduced from the channel type, see MSPD_HAS_*() macros)
+struct mspd_channel_tdm_t {
+    mspd_line_t         *line;
+    U16                 timeslot;
+    U16                 tone_id;
+    U32                 tone_timestamp;
+    U16                 tone_power;
+};
+
+struct mspd_channel_part_t {
+    mspd_conference_t   *conference;
+};
+
+typedef struct mspd_channel_pvt {
+    mspd_channel_tdm_t  tdm;
+    mspd_channel_part_t part;
+} mspd_channel_pvt_t;
+
+typedef struct{
+    struct ast_channel      *subline_owner;
+    struct ast_rtp_instance *rtp;
+    Boolean                 is_native_bridged;
+} mspd_subline_t;
+
+typedef enum mspd_pt_mode {
+    MSPD_PT_MODE_NONE,
+    MSPD_PT_MODE_FAX,
+    MSPD_PT_MODE_VOICE,
+} mspd_pt_mode_t;
+
+// a STI-line (this is used for ast_channel->pvt->pvt)
+struct mspd_line_t {
+    char                *name;
+    struct ast_channel  *owner;
+
+    enum ast_t38_state  t38state;
+    struct ast_udptl	*udptl;
+
+    struct ast_rtp_instance *intern_rtp;
+    mspd_bus_t          *bus;
+    mspd_phone_t        *phone;
+    U16                 timeslot;
+    U32                 link_id;
+    mspd_line_state_t   state;
+
+    pthread_t           consumer;
+    ast_mutex_t         lock;
+    U16                 pickup_groups;
+    U16                 call_groups;
+
+    queue_t             *queue;
+    S16                 dial_timer_id;
+    S16                 interdigit_timer_id;
+    U16                 recv_1st_digit;
+
+    mspd_channel_t      *channel;
+    char                dialed[AST_MAX_EXTENSION];
+    Boolean             is_native_bridged;
+    mspd_subline_t      subline[SUB_LINES];
+    Boolean             is_call_wait;
+    Boolean             is_flash;
+    Boolean             is_call_on_hold;
+    Boolean             is_in_conference;
+    mspd_channel_t     *threeway_channels[2];
+
+    timer_t             flash_timer;
+    Boolean             is_timer_started;
+    Boolean             is_flash_probe_on;
+    struct TEMPO_EVENT_DESC  **ptr_holder;
+    void (*onhook_event)(union sigval value);
+
+    U16                 call_direction;
+    format_t            answer_format;
+    struct timeval      format_change_ts;
+    mspd_pt_mode_t      pt_mode;
+} ;
+
+// a TDM-bus, i.e. a numer of lines that have the same source (e.g. SLIC0 or PRI1),
+// the timeslots of the lines start with 0 and have no holes
+struct mspd_bus_t {
+    char                *name;
+    char                *context;
+    U16                 pickup_groups;
+    U16                 call_groups;
+
+    mspd_device_t       *dev;
+    mspd_line_t         *lines;
+    U16                 n_lines;
+    U16                 index;
+    Boolean             is_trunk;
+    U16                 starting_timeslot;
+
+    U16                 tdm;
+};
+
+struct mspd_ud_pref_t {
+    U16                 is_ud_info_set;
+    U16                 ud_enable_supvsr; //ud enabled at Supvsr Level
+    U16                 ud_enable_error;
+
+    U16                 ud_enable_tdm_tx;
+    U16                 ud_enable_tdm_rx;
+    U16                 ud_enable_pkt_tx;
+    U16                 ud_enable_pkt_rx;
+    U16                 ud_enable_report_cmd;
+    U16                 ud_enable_spu_in;
+    U16                 ud_enable_spu_out;
+    U16                 ud_enable_spu_io_params;
+
+    struct ast_sockaddr ud_dest_ipaddr;
+    U16                 ud_dest_portno;
+    U16                 ud_src_portno;
+};
+
+
+// global values (ip-addresses etc. in network byte order)
+struct mspd_global_t {
+    char                *context;
+    U16                 pickup_groups;
+    U16                 call_groups;
+    mspd_codec_pref     codec_prefs;
+    ast_mutex_t         lock;
+
+    mspd_bus_t          buses[MSPD_MAX_BUSES];
+    U16                 n_buses;
+
+    mspd_phone_t        phones[MSPD_MAX_PHONES];
+    mspd_phone_t        global_phone;
+    mspd_echocan_t      global_echocan;
+    U16                 n_phones;
+
+    U32                 interdigit_timeout;
+    U32                 dial_timeout;
+    U32                 fxo_call_delay;
+
+    mspd_ud_pref_t      ud_prefs;
+    ECType              ec_type_prev;
+    FlashMode           flash_mode;
+    BandMode            threeway_band;
+};
+
+// ===============================================================================================
+// Global
+
+extern mspd_global_t    mspd_global;
+extern char const       mspd_chan_id[];
+
+extern mspd_timer       load_module_time;
+
+#endif // _MSPD_COMMON_H_
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/channels/mspd/include/mspd_dev-channels.h asterisk-1.8.2.3.new/channels/mspd/include/mspd_dev-channels.h
--- asterisk-1.8.2.3/channels/mspd/include/mspd_dev-channels.h	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/channels/mspd/include/mspd_dev-channels.h	2014-05-07 14:49:35.000000000 +0530
@@ -0,0 +1,106 @@
+/*
+ * Mindspeed Comcerto Channel module.
+ *
+ *  Copyright (C) 2004 - 2011 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef _MSPD_DEV_CHANNELS_H_
+#define _MSPD_DEV_CHANNELS_H_
+
+// ===============================================================================================
+// Includes
+
+#include "asterisk.h"
+
+#include <stddef.h>
+#include <netinet/in.h>
+
+#include <vapi/vapi.h>
+
+#include "mspd_common.h"
+#include "asterisk/mspd/utils.h"
+#include "asterisk/mspd/defaults.h"
+
+#include "asterisk/rtp_engine.h"
+
+// ===============================================================================================
+
+#define TONECTRL_DTMF         0x01
+#define TONECTRL_FPT          0x02
+#define TONECTRL_MTP          0x04
+#define TONECTRL_CNG          0x10
+
+// ===============================================================================================
+// Proto
+//fax proto
+char *faxstate2str(U16 data);
+U8 dc_get_fax_state(U16 data);
+U8 dc_get_fax_ctrl_state(U16 data);
+
+mspd_channel_t *
+dc_create_channel (mspd_channel_type_t  type,
+                    mspd_line_t         *line,
+                    format_t                 ast_format,
+                    struct ast_rtp_instance *rtp,
+                    mspd_conference_t   *conference);
+
+int  dc_destroy_all_device_channels(mspd_device_t *dev);
+
+int  dc_set_default_ip_header (mspd_line_t *line);
+int  dc_set_ts_assignment (mspd_channel_t *channel, U16 timeslot);
+
+int  dc_send_ud_cmd (const mspd_channel_t *channel, const mspd_device_t *dev, U16 func_code, Boolean enable);
+int  dc_send_enable_ud_cmds_supvsr  (void);
+int  dc_send_disable_ud_cmds_supvsr (void);
+void dc_send_ud_cmds_to_msp         (mspd_channel_t *chan);
+void dc_send_disable_ud_cmds_to_msp (mspd_ud_pref_t *prefs, const mspd_channel_t *chan, const mspd_device_t *dev);
+int  dc_check_send_ud_cmds_supvsr   (mspd_ud_pref_t *old_ud_prefs);
+void dc_send_enable_ud_cmds_to_msp  (const mspd_channel_t *chan, const mspd_device_t *dev) ;
+int  dc_send_redirection_cmd_to_msp (void);
+char toneid2digit (int tone_id);
+int  mspd_line_handle_digit(mspd_line_t *line, char digit);
+
+void dc_channel_destructor(mspd_channel_t *channel);
+
+
+// ===============================================================================================
+// Macros
+
+// frontends to dc_create_channel()
+#define dc_create_voip_channel(line, ast_format) \
+    dc_create_channel(MCT_VOIP, line, ast_format, NULL, NULL)
+#define dc_create_voiposhm_channel(line, ast_format) \
+    dc_create_channel(MCT_VOIPOSHM, line, ast_format, NULL, NULL)
+#define dc_create_tdm_participant(conference, line, ast_format) \
+    dc_create_channel(MCT_PART_TDM, line, ast_format, NULL, conference)
+
+#define dc_send_disable_ud_cmds_to_msp_channel(prefs, chan) \
+    dc_send_disable_ud_cmds_to_msp(prefs, chan, NULL)
+#define dc_send_disable_ud_cmds_to_msp_device(prefs, dev) \
+    dc_send_disable_ud_cmds_to_msp(prefs, NULL, dev)
+#define dc_send_enable_ud_cmds_to_msp_channel(chan) \
+    dc_send_enable_ud_cmds_to_msp(chan, NULL)
+#define dc_send_enable_ud_cmds_to_msp_device(dev) \
+    dc_send_enable_ud_cmds_to_msp(NULL, dev)
+
+#define dc_send_enable_ud_cmds_channel(line)\
+    if(line && line->phone->ud_enable && line->channel)\
+    dc_send_enable_ud_cmds_to_msp_channel(line->channel);
+#define dc_send_disable_ud_cmds_channel(line)\
+    if(line && line->phone->ud_enable && line->channel)\
+    dc_send_disable_ud_cmds_to_msp_channel(NULL, line->channel);
+
+#define mspd_check_ud_vals(prev_val, new_val, diag_type, dev)\
+    if ( prev_val && !(new_val))\
+        dc_send_ud_cmd(NULL, dev, diag_type, False);\
+    \
+    if ( !(prev_val) && new_val)\
+        dc_send_ud_cmd(NULL, dev, diag_type, True);\
+
+#endif // _MSPD_DEV_CHANNELS_H_
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/channels/mspd/include/mspd_rtp.h asterisk-1.8.2.3.new/channels/mspd/include/mspd_rtp.h
--- asterisk-1.8.2.3/channels/mspd/include/mspd_rtp.h	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/channels/mspd/include/mspd_rtp.h	2012-02-17 20:57:01.000000000 +0530
@@ -0,0 +1,36 @@
+/*
+ * Mindspeed Comcerto Channel module.
+ *
+ *  Copyright (C) 2004 - 2011 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef _MSPD_RTP_H_
+#define _MSPD_RTP_H_
+
+#include "mspd_common.h"
+
+#include "asterisk.h"
+#include "asterisk/rtp_engine.h"
+
+struct ast_rtp_glue  mspd_rtp_glue;
+struct ast_rtp_glue  mspd_rtp_fxo_glue;
+
+enum ast_rtp_glue_result  mspd_get_rtp_info (struct ast_channel *ast, struct ast_rtp_instance **instance);
+enum ast_rtp_glue_result  mspd_get_vrtp_info(struct ast_channel *chan, struct ast_rtp_instance **instance);
+enum ast_rtp_glue_result  mspd_get_trtp_info(struct ast_channel *chan, struct ast_rtp_instance **instance);
+format_t                  mspd_get_codec(struct ast_channel *ast);
+int                       mspd_set_rtp_info(struct ast_channel *ast,
+                                            struct ast_rtp_instance *instance,
+                                            struct ast_rtp_instance *vinstance,
+                                            struct ast_rtp_instance *tinstance,
+                                            format_t codecs,
+                                            int nat_active);
+
+#endif
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/channels/mspd/include/mspd_sti-lines.h asterisk-1.8.2.3.new/channels/mspd/include/mspd_sti-lines.h
--- asterisk-1.8.2.3/channels/mspd/include/mspd_sti-lines.h	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/channels/mspd/include/mspd_sti-lines.h	2011-12-12 20:42:58.000000000 +0530
@@ -0,0 +1,112 @@
+/*
+ * Mindspeed Comcerto Channel module.
+ *
+ *  Copyright (C) 2004 - 2011 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef _MSPD_STI_LINES_H_
+#define _MSPD_STI_LINES_H_
+
+// ===============================================================================================
+// Includes
+
+#include <sti.h>
+#include "mspd_common.h"
+
+#include "asterisk.h"
+#include "asterisk/channel.h"
+
+// ===============================================================================================
+// Defines
+
+// this value shows that line is free
+#define MAX_TIMESLOT_NUMBER        (256)
+// return this number in case of all lines are used
+#define MAX_LINE_NUMBER            (256)            // TODO: reuse MAX_N_LINES_PER_BUS
+
+// -----------------------------------------------------------------------------------------------
+// user-side id to be used for specific STI-line
+typedef union sl_usrid {
+    ulong u;
+    struct {
+        uint16_t timeslot;
+        uint16_t bus;
+    } s;
+} sl_usrid_t;
+
+
+// ===============================================================================================
+// Proto
+
+char const *    sl_event_type2text (U8 event_type);
+char const *    sl_state2text (mspd_line_state_t state);
+char const *    sl_condition2text (int cond);
+mspd_line_t *   sl_connection2line (U32 connection);
+U32             sl_get_usrid_of_line (mspd_line_t *line);
+U32             sl_usrid2bus (U32 u);
+U32             sl_usrid2timeslot (U32 u);
+
+void            sl_reset_line (mspd_line_t *line, Boolean destroy_channel);
+int             sl_init_lines_of_bus (mspd_bus_t *bus);
+U16             sl_get_free_line_num (mspd_bus_t *bus);
+U16             sl_get_line_num_by_ts (mspd_bus_t *bus, U16 ts);
+mspd_line_state_t
+                sl_get_line_state (mspd_line_t *line);
+void            sl_set_line_state (mspd_line_t *line, mspd_line_state_t new_state);
+char const *    sl_show_line_state (mspd_line_t *line);
+Boolean         sl_get_call_wait (mspd_line_t *line);
+void            sl_set_call_wait (mspd_line_t *line, Boolean new_state);
+Boolean         sl_get_line_hold_call (mspd_line_t *line);
+void            sl_set_line_hold_call (mspd_line_t *line, Boolean new_state);
+
+int             sl_init(void);
+int             sl_startup (void);
+int             sl_shutdown_and_cleanup (void);
+int             sl_do_ast_channel_action (mspd_line_t *line,
+                                          struct ast_channel **chan,
+                                          int (*action) (struct ast_channel*, void*),
+                                          void *arg);
+int             sl_new_intern_rtp (mspd_line_t *line);
+int             sl_fixup_intern_rtp (mspd_line_t *line,
+                                    Boolean allocate_new_rtp,
+                                    char const *dir);
+format_t        sl_get_mspd_default_codec (void);
+int             sl_get_mspd_default_codec_phone (mspd_phone_t *phone);
+
+void            sl_swap_sublines (struct mspd_line_t *line);
+void            sl_clear_subline (struct mspd_line_t *line, int sub);
+
+int             handle_dialed_number (mspd_line_t *line);
+
+int             sl_handle_incoming_call     (mspd_line_t *line,
+                                            struct TEMPO_EVENT_DESC const *event);
+int             sl_handle_fxo_incoming_call (mspd_line_t *line,
+                                            struct TEMPO_EVENT_DESC const *event);
+int             sl_handle_call_connected    (mspd_line_t *line,
+                                            struct TEMPO_EVENT_DESC const *event);
+int             sl_handle_disconnect_call   (mspd_line_t *line,
+                                            struct TEMPO_EVENT_DESC const *event);
+int             sl_handle_callerid_gen      (mspd_line_t *line,
+                                            struct TEMPO_EVENT_DESC const *event);
+int             sl_handle_flash             (mspd_line_t *line,
+                                            struct TEMPO_EVENT_DESC const *event);
+void            sl_handle_event             (mspd_line_t *line,
+                                            struct TEMPO_EVENT_DESC const *event);
+void            sl_subline_debug (mspd_line_t *line);
+Boolean         sl_check_bridge_mspd (struct ast_channel *bridged_channel);
+
+
+void *          sl_consumer (void *data);
+void *          sl_producer (void *data);
+
+void            onhook_event (union sigval value);
+void *          sl_timer (void *data);
+
+#endif // _MSPD_STI_LINES_H_
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/channels/mspd/include/mspd_threeway.h asterisk-1.8.2.3.new/channels/mspd/include/mspd_threeway.h
--- asterisk-1.8.2.3/channels/mspd/include/mspd_threeway.h	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/channels/mspd/include/mspd_threeway.h	2011-09-13 17:47:49.000000000 +0530
@@ -0,0 +1,52 @@
+/*
+ * Mindspeed Comcerto Channel module.
+ *
+ *  Copyright (C) 2004 -2011 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef _MSPD_THREEWAY_H_
+#define _MSPD_THREEWAY_H_
+
+//#include "asterisk.h"
+#include "mspd_common.h"
+
+#define CHAN_TYPE_MSPD 1
+#define CHAN_TYPE_SIP  2
+#define CHAN_TYPE_OTHER 3
+
+#define ERR_NO_LINE        -1
+#define ERR_NO_CHAN        -2
+#define ERR_NO_COMPAT_CHAN -3
+#define ERR_NO_SUB_LINE    -4
+
+#define ERR_NO_RESOURCE            -10
+#define ERR_NULL_POINTER           -11
+#define ERR_OPERATION_UNSUCCESSFUL -12
+
+// -----------------------------------------------------------------------------------------------
+
+int twc_make_threeway_call (mspd_line_t *master_line);
+
+
+int twc_add_lsp_part (mspd_line_t *line, mspd_conference_t *conf);
+int twc_add_rsp_part (mspd_conference_t *conf, U16 part_id, BandMode conf_mode);
+int twc_replace_lsp_part (mspd_line_t *line, mspd_conference_t *conf);
+
+int twc_restore_2way_call(mspd_line_t *master_line);
+int twc_release_threeway_call (mspd_line_t *master_line);
+
+int twc_get_party_type (mspd_line_t *master_line,
+                                struct ast_channel *ast_sub_line);
+
+void twc_print_info (mspd_line_t *line);
+
+// -----------------------------------------------------------------------------------------------
+
+#endif
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/channels/mspd/include/t38.h asterisk-1.8.2.3.new/channels/mspd/include/t38.h
--- asterisk-1.8.2.3/channels/mspd/include/t38.h	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/channels/mspd/include/t38.h	2011-11-21 21:23:51.000000000 +0530
@@ -0,0 +1,24 @@
+/*
+ * Mindspeed Comcerto Channel module.
+ *
+ *  Copyright (C) 2004 - 2011 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef _MSPD_T38_H_
+#define _MSPD_T38_H_
+
+#include "asterisk.h"
+#include "asterisk/channel.h"
+
+int mspd_t38_handle_parameters(struct mspd_line_t *line, const struct ast_control_t38_parameters *parameters);
+int mspd_t38_request_mode_change_foip (mspd_line_t  *line);
+int mspd_t38_request_mode_change_voip (mspd_line_t  *line);
+int mspd_t38_mode_change_voice(struct mspd_line_t *line);
+
+#endif
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/channels/mspd/mspd_dev-channels.c asterisk-1.8.2.3.new/channels/mspd/mspd_dev-channels.c
--- asterisk-1.8.2.3/channels/mspd/mspd_dev-channels.c	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/channels/mspd/mspd_dev-channels.c	2014-05-07 14:49:35.000000000 +0530
@@ -0,0 +1,1626 @@
+/*
+ * Mindspeed Comcerto Channel module.
+ *
+ *  Copyright (C) 2004 - 2011 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+// ===============================================================================================
+// Includes
+
+#include "asterisk.h"
+
+//ASTERISK_FILE_VERSION(__FILE__, "$Revision: 1.53 $")
+
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <pthread.h>
+#include <signal.h>
+#include <time.h>
+#include <errno.h>
+
+#include <vapi/vapi.h>
+#include <vapi/comcerto-api-defs.h>
+
+#include "include/mspd_common.h"
+#include "asterisk/mspd/defaults.h"
+#include "asterisk/mspd/macro.h"
+#include "asterisk/mspd/utils.h"
+#include "asterisk/mspd/device.h"
+#include "asterisk/mspd/global.h"
+#include "asterisk/mspd/channel.h"
+#include "asterisk/mspd/conference.h"
+#include "include/chan_mspd.h"
+#include "include/mspd_sti-lines.h"
+#include "include/mspd_dev-channels.h"
+#include "include/mspd_threeway.h"
+#include "include/t38.h"
+
+#include "asterisk/utils.h"
+#include "asterisk/rtp_engine.h"
+#include "asterisk/lock.h"
+#include "asterisk/logger.h"
+#include "asterisk/pbx.h"
+#include "asterisk/options.h"
+#include "asterisk/features.h"
+#include "asterisk/term.h"
+#include "asterisk/sched.h"
+
+// ===============================================================================================
+// Global
+
+extern struct sched_context *sched;
+extern int dialtimeout (void *data);
+
+// ===============================================================================================
+// Local constants and macros
+
+// size of indication work-queues
+#define INDICATION_QUEUE_SIZE       (32)
+
+// ===============================================================================================
+// Helpers
+
+// -----------------------------------------------------------------------------------------------
+// Set Default IP header for the chanel (using intern rtp)
+int
+dc_set_default_ip_header (mspd_line_t *line)
+{
+    struct ast_rtp_instance* rtp;
+    if (line) {
+        rtp = line->intern_rtp;
+        if (!rtp) {
+            MSPD_ERR("(0x%x, %p): line %s:%u has no intern-rtp, can't set ip\n",
+                    (U32) line,  rtp, line->name, line->timeslot);
+            return -1;
+        }
+    }
+    else
+        return -1;
+
+    mspd_channel_t * const channel = line->channel;
+    struct ast_sockaddr src, dst;
+    ast_rtp_instance_get_remote_address(rtp, &src);
+    ast_rtp_instance_get_local_address(rtp, &dst);
+
+    if (mspd_channel_set_ip_header(channel, &src, &dst)) {
+        MSPD_ERR("(%s): csm-msg has failed\n", mspd_channel_get_name(channel));
+        return -1;
+    }
+
+    return 0;
+}
+
+// --------------------------------------------------------------------------------------------
+// Sends Enable/Disable traces command to MSP.
+// this function will be called only when ud_enable is set globally
+int
+dc_send_ud_cmd (const mspd_channel_t *channel, 
+		const mspd_device_t *dev, 
+		U16 func_code, 
+		Boolean enable)
+{
+    if (mspd_global.ud_prefs.ud_enable_error)
+        return 1;
+
+    if(dev)
+	return mspd_device_send_ud_cmd(dev, func_code, enable);
+
+    if(channel)
+	return mspd_channel_send_ud_cmd(channel, func_code, enable);
+
+    return -1;
+}
+
+// -----------------------------------------------------------------------------------------------
+void
+dc_channel_destructor(mspd_channel_t *channel)
+{
+    const mspd_device_t *dev = mspd_channel_get_device(channel);
+    mspd_channel_pvt_t *pvt = mspd_channel_get_pvt(channel);
+    int rc = 0;
+    VSTATUS vstatus = 0xFF;
+    char buf[256] = {0};
+
+    if (option_verbose > 2) {
+        int n = 0;
+        if (MSPD_HAS_TDM(mspd_channel_get_type(channel))) {
+            if (pvt->tdm.line)
+                n += snprintf(buf + n, sizeof(buf) - n, ", %s:%u",
+                            pvt->tdm.line->bus->name, pvt->tdm.line->timeslot);
+            else
+                n += snprintf(buf + n, sizeof(buf) - n, ", ts=%u",
+                            pvt->tdm.timeslot);
+        }
+        if (MSPD_IS_PART(mspd_channel_get_type(channel)))
+            n += snprintf(buf + n, sizeof(buf) - n, ", %s",
+                        mspd_conference_get_name(pvt->part.conference));
+
+        MSPD_LOG(2, "(%s): i=%s\n", mspd_channel_get_name(channel), buf);
+    }
+
+    if (MSPD_IS_PART(mspd_channel_get_type(channel))) {
+        if (mspd_channel_get_type(channel) == MCT_PART_TDM) { 
+                MSPD_LOG(1, "%s: DevID=%d, ConfName=%s, ConfID=%d, Name=%s, TS=%d\n", 
+                        term_color(buf, "CONF_DESTROY_PARTICIPANT (0x9313)", 
+                                    COLOR_BRGREEN, 0, sizeof (buf)), 
+                        mspd_device_get_id(dev), 
+                        mspd_conference_get_name(pvt->part.conference), 
+                        mspd_conference_get_id(pvt->part.conference), 
+                        pvt->tdm.line->name, 
+                        pvt->tdm.line->timeslot); 
+                        pvt->tdm.line->is_in_conference = False; 
+        } 
+        else { 
+            MSPD_LOG(1, "%s: DevID=%d, ConfName=%s, ConfID=%d\n", 
+                    term_color(buf, "CONF_DESTROY_PARTICIPANT (0x9313)", 
+                                COLOR_BRGREEN, 0, sizeof (buf)), 
+                		mspd_device_get_id(dev), 
+                        	mspd_conference_get_name(pvt->part.conference), 
+                        	mspd_conference_get_id(pvt->part.conference)); 
+        } 
+ 
+        vstatus = VAPI_DestroyParticipant(mspd_channel_get_id(channel), NULL); 
+ 
+        VAPI_REPORT (vstatus, "CONF_DESTROY_PARTICIPANT"); 
+        if (vstatus) 
+            rc = 1; 
+    } else if ((mspd_channel_get_type(channel) == MCT_VOIP) || (mspd_channel_get_type(channel) == MCT_VOIPOSHM) ||
+        (mspd_channel_get_type(channel) == MCT_FOIP)) {
+            MSPD_LOG(1, "%s: DevID=%d, ChID=%d, Name=%s, TS=%d\n",
+                        term_color(buf, "SUPVSR_DESTROY_CHANNEL (0x0011)",
+                                    COLOR_BRGREEN, 0, sizeof (buf)),
+                        mspd_device_get_id(dev), mspd_channel_get_id(channel), pvt->tdm.line->name,
+                        pvt->tdm.line->timeslot);
+
+            vstatus = VAPI_DestroyConnection(mspd_channel_get_id(channel), NULL);
+
+            VAPI_REPORT (vstatus, "SUPVSR_DESTROY_CHANNEL");
+            if (vstatus)
+                rc = 1;
+    }
+
+    if (!rc) {
+        if (option_verbose) {
+            uint n = 0;
+            n += snprintf(buf + n, sizeof(buf) - n, "(%s): done", mspd_channel_get_name(channel));
+
+            if (MSPD_HAS_TDM(mspd_channel_get_type(channel))) {
+                if (pvt->tdm.line)
+                    n += snprintf(buf + n, sizeof(buf) - n, ", %s:%u",
+                                pvt->tdm.line->name, pvt->tdm.line->timeslot);
+                else
+                    n += snprintf(buf + n, sizeof(buf) - n, ", ts=%u",
+                                pvt->tdm.timeslot);
+            }
+
+            if (MSPD_IS_PART(mspd_channel_get_type(channel)))
+                n += snprintf(buf + n, sizeof(buf) - n, ", %s (%u left)",
+                        mspd_conference_get_name(pvt->part.conference),
+                        mspd_conference_get_participants_count(pvt->part.conference));
+
+            MSPD_LOG(1, "Destroying %s\n", buf);
+        }
+
+        if (pvt->tdm.line) {
+            pvt->tdm.line->channel = NULL;
+            pvt->tdm.line->is_native_bridged = False;
+            pvt->tdm.line->timeslot = MAX_TIMESLOT_NUMBER;
+            pvt->tdm.line = NULL;
+        }
+
+        if (MSPD_IS_PART(mspd_channel_get_type(channel)))
+	    mspd_conference_dec_participants(pvt->part.conference);
+    }
+}
+
+static void dc_consumer (mspd_channel_t *channel, const vapi_queue_element_t *Item);
+
+// -----------------------------------------------------------------------------------------------
+// create a new channel (as object and in device)
+mspd_channel_t *
+dc_create_channel (mspd_channel_type_t  type,
+                    mspd_line_t         *line,
+                    format_t                 ast_format,
+                    struct ast_rtp_instance *rtp,
+                    mspd_conference_t   *conference)
+{
+    char    color_buf [256]= {0};
+    VSTATUS vstatus = 0xFF;
+    U16 timeslots[4] = {0, 0, 0, 0};
+	EConnType ctype;
+
+	if(type == MCT_VOIPOSHM)
+	{
+		MSPD_LOG(2, "DEBUG VOSHM (%s) line ts %d wideband %d)\n", mspd_channel_type2text(type), line->timeslot, line->phone->wideband);
+	}
+	
+	
+    if (!(type == MCT_VOIP ||
+          type == MCT_PART_TDM ||
+	  type == MCT_PART_RTP ||
+	  type == MCT_VOIPOSHM)
+        || !line == MSPD_HAS_TDM(type)
+	|| !rtp  == (type == MCT_PART_RTP)
+        || !conference == MSPD_IS_PART(type))
+    {
+        MSPD_ERR("(%s, %p, %s, %p, %p): invalid arguments, "
+                "can't create channel\n",
+                mspd_channel_type2text(type), line, ast_getformatname(ast_format), rtp, conference);
+        return NULL;
+    }
+
+    mspd_device_t * dev;
+    if((type == MCT_VOIP) || (type == MCT_VOIPOSHM))
+		dev = line->bus->dev;
+	else
+		dev = mspd_conference_get_device(conference);
+
+    if (line) {
+        rtp = line->intern_rtp;
+        if (!rtp) {
+            MSPD_ERR("(%s, %p, %s, %p, %p): line %s has no intern-rtp, "
+                    "can't create channel\n",
+                    mspd_channel_type2text(type), line, ast_getformatname(ast_format), rtp, conference, line->name);
+            return NULL;
+        }
+    }
+
+    struct ast_sockaddr src, dst;
+    if (rtp) {
+        ast_rtp_instance_get_remote_address(rtp, &src);
+        ast_rtp_instance_get_local_address(rtp, &dst);
+
+        if (ast_sockaddr_cmp_addr(&src, mspd_device_get_ipaddr(dev)) ||
+            ast_sockaddr_cmp_addr(&dst, mspd_global_get_ipaddr()))
+        {
+            MSPD_ERR("(%s, %s, %s, %s, %s): invalid RTP %s -> %s, "
+                    "can't create channel\n",
+                    mspd_channel_type2text(type),
+                    line ? line->name : "no_line",
+                    ast_getformatname(ast_format),
+                    rtp ? "RTP" : "no RTP",
+                    conference ? "Conf" : "no Conf",
+                    ast_sockaddr_stringify (&src),
+                    ast_sockaddr_stringify (&dst));
+            return NULL;
+        }
+    }
+
+    if (ast_format && line && !(ast_format & line->phone->allowed_codecs)) {
+        char buf[256];
+        MSPD_WARN(4, "(%s,%s): invalid requested format(s) %s, falling back to %s\n",
+                mspd_device_get_name(dev), mspd_channel_type2text(type),
+                ast_getformatname_multiple(buf, sizeof(buf), ast_format),
+                ast_getformatname(MSPD_DEFAULT_CODEC));
+        ast_format = MSPD_DEFAULT_CODEC;
+    }
+
+    if (option_verbose > 1) {
+        char buf[256];
+        int n = 0;
+        if (line)
+            n += snprintf(buf + n, sizeof(buf) - n, ", %s:%u", line->name, line->timeslot);
+
+        if (ast_format) {
+            char cbuf[256];
+            ast_getformatname_multiple(cbuf, sizeof(cbuf), ast_format),
+            n += snprintf(buf + n, sizeof(buf) - n, ", %s", cbuf);
+        }
+
+        if (rtp) {
+            n += snprintf(buf + n, sizeof(buf) - n, ", %s->%s",
+                ast_sockaddr_stringify (&src),
+                ast_sockaddr_stringify (&dst));
+        }
+
+        if (conference)
+            n += snprintf(buf + n, sizeof(buf) - n, ", %s conf-id:0x%x",
+                mspd_conference_get_name(conference), mspd_conference_get_id(conference));
+
+        MSPD_LOG(2, "Creating (%s%s)\n", mspd_channel_type2text(type), buf);
+    }
+
+    ///--- --== Allocating Channel resources ==-- ---///
+    mspd_channel_t * const channel = mspd_channel_create(dev, 
+							 type,
+							 ast_format,
+							 line->phone->vad,
+							 sizeof(mspd_channel_pvt_t),
+							 dc_consumer,
+							 dc_channel_destructor);
+
+    if (!channel) {
+        MSPD_ERR("(%s,%s): allocating new channel has failed\n",
+                mspd_device_get_name(dev), mspd_channel_type2text(type));
+        return NULL;
+    }
+
+    mspd_channel_pvt_t *pvt = mspd_channel_get_pvt(channel);
+    pvt->tdm.tone_id = 0xff;
+
+    if (line) {
+        pvt->tdm.timeslot = line->timeslot;
+        pvt->tdm.line = line;
+        line->channel = channel;
+		if ((type != MCT_VOIP) && (type != MCT_VOIPOSHM))
+			line->is_native_bridged = 1;
+        if (line->phone)
+            line->phone->line = line;
+    }
+
+    if (conference)
+        pvt->part.conference = conference;
+
+    if (MSPD_HAS_TDM(type))
+        if (line->phone->wideband) {
+            if ((line->bus->tdm & BUS_MASK) == BUS_DECT) {
+                /* DECT: consecutive */
+                 timeslots[0] = line->timeslot;
+                 timeslots[1] = line->timeslot + 1;
+                 timeslots[2] = line->timeslot + 2;
+                 timeslots[3] = line->timeslot + 3;
+            }
+            else if ((line->bus->tdm & BUS_MASK) == BUS_SLIC) {
+                /* SLIC: must be 16 slot spaced */
+                 timeslots[0] = line->timeslot;
+                 timeslots[1] = line->timeslot + 1;
+                 timeslots[2] = line->timeslot + 16;
+                 timeslots[3] = line->timeslot + 16 + 1;
+            } else {
+                 MSPD_ERR("(%s): Wide band mode is not supported "
+                         "or Base TS = %d is incorrect\n",
+                         line->name, line->timeslot);
+                 goto send_failed;
+            }
+            MSPD_LOG(1, "Line %s:%u in WB mode, TS={%d,%d,%d,%d} assigned\n",
+                     line->name, line->timeslot,
+                     timeslots[0], timeslots[1],
+                     timeslots[2], timeslots[3]);
+    }
+
+    switch (type) {
+        //----------------------------------------------------------------------------------------
+        case MCT_VOIP:
+		case MCT_VOIPOSHM:
+        {
+			if(type == MCT_VOIP)
+				ctype = eVOIP;
+			else
+				ctype = eVOIPOSHM;
+			
+            if (line->phone->dsp_acp) {
+                MSPD_LOG(1, "Using %s feature\n",
+                        term_color(color_buf, "DSP_on_ACP", COLOR_BRGREEN, 0, sizeof (color_buf)));
+
+                if (mspd_device_set_next_channel_on_acp(dev))
+                    MSPD_ERR("(%s):SUPVSR_NEXT_VOIP_CHAN_ON_ACP failed\n", line->name);
+            }
+
+            if (!line->phone->wideband) {
+                ///--- --== Create Channel. NARROW band case ==-- ---///
+                MSPD_LOG(1, "%s: %s, eNarrowBand, DevID=%d, ChID=%d, Name=%s, TS=%d\n",
+                        term_color(color_buf, "SUPVSR_CREATE_CHANNEL (0x0010)",
+                                    COLOR_BRGREEN, 0, sizeof (color_buf)), (ctype == eVOIP) ? "eVOIP":"eVOIPOSHM",
+                        mspd_device_get_id(dev), mspd_channel_get_id(channel), line->name, line->timeslot);
+
+                vstatus = VAPI_AllocateConnection(mspd_device_get_id(dev),
+                            mspd_channel_get_id(channel),
+                            ctype,
+                            eNarrowBand,
+                            1, &line->timeslot,
+                            NULL, NULL);
+
+                VAPI_REPORT_ACT (vstatus, "SUPVSR_CREATE_CHANNEL (0x0010)", goto send_failed);
+            }
+            else {
+                ///--- --== Create Channel. WIDE band case ==-- ---///
+                MSPD_LOG(1, "%s: %s, eWideBand, DevID=%d, ChID=%d, Name=%s, TS={%d,%d,%d,%d}\n",
+                        term_color(color_buf, "SUPVSR_CREATE_CHANNEL (0x0010)",
+                                    COLOR_BRGREEN, 0, sizeof (color_buf)), (ctype == eVOIP) ? "eVOIP":"eVOIPOSHM",
+                        mspd_device_get_id(dev), mspd_channel_get_id(channel), line->name,
+                        timeslots[0], timeslots[1], timeslots[2], timeslots[3]);
+
+                vstatus = VAPI_AllocateConnection(mspd_device_get_id(dev),
+                            mspd_channel_get_id(channel),
+                            ctype,
+                            eWideBand,
+                            4, timeslots,
+                            NULL, NULL);
+
+                VAPI_REPORT_ACT (vstatus, "SUPVSR_CREATE_CHANNEL (0x0010)", goto send_failed);
+            }
+        }
+        break;
+
+        //----------------------------------------------------------------------------------------
+        case MCT_PART_TDM:
+        {
+            if (line->phone->dsp_acp) {
+                MSPD_LOG(1, "Using %s feature\n",
+                        term_color(color_buf, "DSP_on_ACP", COLOR_BRGREEN, 0, sizeof (color_buf)));
+
+                if (mspd_device_set_next_channel_on_acp(dev))
+                    MSPD_ERR("(%s):SUPVSR_NEXT_VOIP_CHAN_ON_ACP failed\n", line->name);
+            }
+
+            if (!line->phone->wideband) {
+                ///--- --== Create LSP participant. NARROW band case ==-- ---///
+                MSPD_LOG(1, "%s: TDM, eNarrowBand, DevID=%d, ConfID=%d, Name=%s, TS=%d\n",
+                        term_color(color_buf, "CONF_CREATE_PARTICIPANT (0x9312)",
+                                    COLOR_BRGREEN, 0, sizeof (color_buf)),
+                        mspd_device_get_id(dev), mspd_conference_get_id(conference), line->name, line->timeslot);
+
+                vstatus = VAPI_AllocateParticipant (mspd_conference_get_id(conference), mspd_channel_get_id(channel),
+                                                    eLSP,
+                                                    1, &line->timeslot,
+                                                    NULL, NULL);
+                VAPI_REPORT_ACT (vstatus, "LSP CONF_CREATE_PARTICIPANT (0x9312)", goto send_failed);
+            }
+            else {
+                ///--- --== Create LSP participant. WIDE band case ==-- ---///
+                MSPD_LOG(1, "%s: TDM, eWideBand, DevID=%d, ConfID=%d, Name=%s, TS={%d,%d,%d,%d}\n",
+                        term_color(color_buf, "SUPVSR_CREATE_CHANNEL (0x0010)",
+                                    COLOR_BRGREEN, 0, sizeof (color_buf)),
+                        mspd_device_get_id(dev), mspd_conference_get_id(conference), line->name,
+                        timeslots[0], timeslots[1], timeslots[2], timeslots[3]);
+
+                vstatus = VAPI_AllocateParticipant (mspd_conference_get_id(conference), mspd_channel_get_id(channel),
+                                                    eLSPWB,
+                                                    4, timeslots,
+                                                    NULL, NULL);
+                VAPI_REPORT_ACT (vstatus, "LSP CONF_CREATE_PARTICIPANT (0x9312)", goto send_failed);
+            }
+        }
+        break;
+
+        case MCT_PART_RTP: 
+        { 
+            if (!(ast_format & WIDE_BAND_CODECS)) {
+                ///--- --== Create RSP participant. NARROW band case ==-- ---/// 
+                MSPD_LOG(1, "%s: RTP, eNarrowBand, DevID=%d, ConfName=%s, ConfID=%d\n", 
+                        term_color(color_buf, "CONF_CREATE_PARTICIPANT (0x9312)", 
+                                    COLOR_BRGREEN, 0, sizeof (color_buf)), 
+                        mspd_device_get_id(dev), mspd_conference_get_name(conference), mspd_conference_get_id(conference)); 
+ 
+                U16 vapi_ts = 0; 
+                vstatus = VAPI_AllocateParticipant (mspd_conference_get_id(conference), mspd_channel_get_id(channel), 
+                                                    eRSP, 
+                                                    1, &vapi_ts,    // not used internally 
+                                                    NULL, NULL); 
+                VAPI_REPORT_ACT (vstatus, "RSP CONF_CREATE_PARTICIPANT (0x9312)", goto send_failed); 
+            } 
+            else { 
+                ///--- --== Create RSP participant. WIDE band case ==-- ---/// 
+                MSPD_LOG(1, "%s: RTP, eWideBand, DevID=%d, ConfName=%s, ConfID=%d\n", 
+                        term_color(color_buf, "CONF_CREATE_PARTICIPANT (0x9312)", 
+                                    COLOR_BRGREEN, 0, sizeof (color_buf)), 
+                        mspd_device_get_id(dev), mspd_conference_get_name(conference), mspd_conference_get_id(conference)); 
+ 
+                vstatus = VAPI_AllocateParticipant (mspd_conference_get_id(conference), mspd_channel_get_id(channel), 
+                                                    eRSPWB, 
+                                                    4, timeslots,   // not used internally 
+                                                    NULL, NULL); 
+                VAPI_REPORT_ACT (vstatus, "RSP CONF_CREATE_PARTICIPANT (0x9312)", goto send_failed); 
+            } 
+        } 
+        break; 
+
+        //----------------------------------------------------------------------------------------
+        default:
+        break;
+    }
+
+    switch (type){
+        case MCT_VOIP:
+		case MCT_VOIPOSHM:
+            if (line->call_direction == MSPD_FLAG_OUTGOING_CALL
+                 &&(line->bus->tdm & BUS_MASK) == BUS_PRI) {
+                        // Do nothing for PRI outgoing call (T1/E1)
+                        // MSP channel configuration for PRI call
+                        // will be done in sl_handle_call_connected()
+                break;
+            }           // else --> we configure the channel as same as in MCT_PART_RTP section + dc_set_tonectrl()
+            else {
+                if (mspd_channel_set_ip_header(channel, &src, &dst))              goto send_failed;
+                if (mspd_channel_bwe_manager(channel,
+                    line->phone->wideband,
+                    NoBand, // not applicable for VoIP
+                    &line->phone->bwe,
+                    True)) /* always send to new channel */                       goto send_failed;
+                if (mspd_channel_configure_voip(channel, &line->phone->echocan))  goto send_failed;
+            }
+        break;
+
+        case MCT_PART_RTP: 
+            if (mspd_channel_set_ip_header(channel, &src, &dst))                  goto send_failed; 
+            if (mspd_channel_bwe_manager(channel,
+                NoBand,  // RSP has no TDM
+                mspd_conference_get_mixer(conference),
+                mspd_global_get_rsp_bwe(),
+                True)) /* always send to new channel */                     goto send_failed;
+            if (mspd_channel_configure_rsp_part(channel))                   goto send_failed; 
+        break; 
+
+        case MCT_PART_TDM:
+            if (mspd_channel_bwe_manager(channel,
+                line->phone->wideband,
+                mspd_conference_get_mixer(conference),
+                &line->phone->bwe,
+                True)) /* always send to new channel */                           goto send_failed;
+            if (mspd_channel_configure_lsp_part(channel, &line->phone->echocan))  goto send_failed;
+            line->is_in_conference = True;
+        break;
+
+        default:
+        break;
+    } // switch (type)
+
+    if (MSPD_HAS_TDM(type))
+        if (mspd_channel_set_dtmfpar (channel))                                   goto send_failed;
+
+    dc_send_enable_ud_cmds_channel(line);
+
+    if (option_verbose) {
+        char buf[256];
+        uint n = 0;
+        if (line)
+            n += snprintf(buf + n, sizeof(buf) - n, ", %s:%u", line->name, line->timeslot);
+
+        if (ast_format) {
+            char cbuf[256];
+            ast_getformatname_multiple(cbuf, sizeof(cbuf), ast_format),
+            n += snprintf(buf + n, sizeof(buf) - n, ", %s", cbuf);
+        }
+
+        if (rtp) {
+            n += snprintf(buf + n, sizeof(buf) - n, ", %s->%s",
+                    ast_sockaddr_stringify (&src),
+                    ast_sockaddr_stringify (&dst));
+        }
+
+        if (conference)
+            n += snprintf(buf + n, sizeof(buf) - n, ", %u. in %s ",
+                  mspd_conference_get_participants_count(conference), mspd_conference_get_name(conference));
+
+        MSPD_LOG(2, "(%s%s): done channel->id=0x%x\n",
+                mspd_channel_get_name(channel), buf, mspd_channel_get_id(channel));
+    }
+
+    return channel;
+
+send_failed:
+    MSPD_ERR("(%s): Channel configuration has failed\n", mspd_channel_get_name(channel));
+    mspd_channel_destroy(channel);
+    line->phone->line = NULL;
+    return NULL;
+}
+
+// -----------------------------------------------------------------------------------------------
+int
+dc_set_ts_assignment (mspd_channel_t *channel, U16 timeslot)
+{
+    VSTATUS status  = 1;
+    void *message   = NULL;
+    U32 resp_len    = MAX_FIFO_SIZE;
+    U8  dev_resp     [MAX_FIFO_SIZE];
+
+    message = VAPI_AllocateMessage(MAX_FIFO_SIZE);
+    if (!message) {
+        MSPD_ERR("VAPI_AllocateMessage has failed\n");
+        return -1;
+    }
+
+    status = VAPI_SetMessage(message,
+                CMD_CLASS_LEGACY_MSG,
+                CMD_TYPE_SET_TSA,
+                    0x0000,             // FuncCode = DNC
+                        2,
+                        timeslot,       // new logical timeslot
+                        0x0002);        // logical timeslot enable
+    if (status)
+        VAPI_REPORT_ACT (status, "Setting CT_SETTSA", goto msg_err);
+
+    status = VAPI_SendConnectionMessage(mspd_channel_get_id(channel),
+                (SMsg *)message, NULL,
+                dev_resp, &resp_len);
+    VAPI_REPORT_ACT (status, "Sending CT_SETTSA", goto msg_err);
+
+msg_err:
+    VAPI_FreeMessage(message);
+
+    return status;
+}
+
+// -----------------------------------------------------------------------------------------------
+static int
+interdigit_timeout (const void *data)
+{
+    mspd_line_t *line = (mspd_line_t*)data;
+    mspd_line_state_t state;
+
+    if (!line->phone)
+        return -1;
+
+    MSPD_LOCK(line->lock, return 0);
+
+    MSPD_LOG(3, "Line=%s:%u, Dialed[%s], InterDigit timer %u ms, Dial timer %u ms\n",
+            line->name, line->timeslot, line->dialed,
+            line->interdigit_timer_id, line->dial_timer_id);
+
+    if (line->dial_timer_id)
+        line->dial_timer_id = ast_sched_del(sched, line->dial_timer_id);
+
+    state = sl_get_line_state (line);
+
+    if (state == MLS_DIALING)
+        handle_dialed_number(line);
+
+    line->interdigit_timer_id = 0;
+    line->dial_timer_id = 0;
+    MSPD_UNLOCK(line->lock);
+
+    return 0;
+}
+
+char toneid2digit (int tone_id)
+{
+    static char const id2digit[0x10] = {
+        '0', '1', '2', '3', '4', '5', '6', '7','8', '9',
+        '*', '#', 'A', 'B', 'C', 'D'};
+
+    return (tone_id < 0x10) ? id2digit[tone_id] : VOIP_TONEDET_TONE_END;
+}
+
+int mspd_line_handle_digit(mspd_line_t *line, char digit)
+{
+    mspd_channel_t *channel = line->channel;
+    mspd_channel_pvt_t *pvt = mspd_channel_get_pvt(channel);
+    char  last_digit        = toneid2digit(pvt->tdm.tone_id);
+
+    if (digit != VOIP_TONEDET_TONE_END)
+        MSPD_LOG(3, "Line %s:%s got a digit %c\n",
+            line->name, sl_show_line_state(line), digit);
+
+    switch (sl_get_line_state(line)) {
+        case MLS_DIALING_0:
+            if (line->dial_timer_id){
+                MSPD_LOG(5, "%s: Dialing Timer stopped, dial_timer_id=%d\n",
+                        line->name, line->dial_timer_id);
+
+                line->dial_timer_id = ast_sched_del(sched, line->dial_timer_id);
+                line->dial_timer_id = 0;
+            }
+
+            if (mspd_channel_set_tone(channel, DC_TONE_OFF))
+                goto msg_failed;
+            sl_set_line_state (line, MLS_DIALING);
+
+        case MLS_DIALING_FXO :
+            sl_set_line_state (line, MLS_DIALING);
+
+        case MLS_DIALING:
+            if (digit != VOIP_TONEDET_TONE_END) {
+                char buf[2] = {digit, '\0'};
+                strncat(line->dialed, buf, 1);
+            }
+
+            MSPD_LOG(3, "(%s:%u/%s): (context=%s) Dialed so far [%s]\n",
+                    line->name, line->timeslot,
+                    sl_show_line_state(line),
+                    line->phone->context, line->dialed);
+
+            if (!strcmp(line->dialed, ast_fxo_ext())) {
+                /* Check the line state
+                 * If line state == DIALING_0,
+                 *    create channel (ast and mspd) for fxs #
+                 *    make FXO go offhook
+                 *    change the line state to DIALING_FXO_0
+                 *    send beep tone to fxs #
+                 * If line state == DIALING_FXO
+                 *    line->dialed contains the dialed number
+                 * */
+                if (sl_get_line_state (line) == MLS_DIALING) {
+                    char temp_digit = '0';
+                    if (mspd_channel_play_dtmftone(line->channel, temp_digit))
+                            goto msg_failed;
+                    sl_set_line_state (line, MLS_DIALING_FXO);
+
+                    MSPD_LOG(3, "FXO line-state=%s, line->linkid=0x%x\n",
+                            sl_show_line_state(line), line->link_id);
+                    MSPD_LOG(5, "Line %s:%u: TEMPO FXO Off-Hook on TDM=0x%X (user_id=0x%X, link_id=0x%X)\n",
+                            line->name, line->timeslot,
+                            line->bus->tdm,
+                            sl_get_usrid_of_line (line),
+                            line->link_id);
+
+                    tempo_fxo_make_offhook(sl_get_usrid_of_line (line),
+                                           line->link_id,
+                                           0x0200); // TODO: use define
+                }
+            }
+
+            if (line->interdigit_timer_id)
+                line->interdigit_timer_id = ast_sched_del(sched, line->interdigit_timer_id);
+
+            line->interdigit_timer_id = ast_sched_add(sched,
+                                                      mspd_global.interdigit_timeout,
+                                                      interdigit_timeout,
+                                                      (void*) line);
+
+            MSPD_LOG(5, "%s: Started Interdigit timer %d ms, id=%d\n",
+                    line->name, mspd_global.interdigit_timeout, line->interdigit_timer_id);
+
+        break;
+
+        case MLS_CONNECTED:
+            if (digit == VOIP_TONEDET_TONE_END) {
+                if (sl_do_ast_channel_action(line, &line->owner,
+                    (int (*)(struct ast_channel*, void*))&ast_queue_frame,
+                     &(struct ast_frame){.frametype = AST_FRAME_DTMF_END, .subclass = {last_digit}}))
+                            MSPD_ERR("(%s:%u/%s): queueing AST_FRAME_DTMF_END has failed\n",
+                                line->name, line->timeslot,
+                                sl_show_line_state(line));
+            }
+            else {
+                if (sl_do_ast_channel_action(line, &line->owner,
+                    (int (*)(struct ast_channel*, void*))&ast_queue_frame,
+                     &(struct ast_frame){.frametype = AST_FRAME_DTMF_BEGIN, .subclass = {digit}}))
+                            MSPD_ERR("(%s:%u/%s): queueing AST_FRAME_DTMF_BEGIN frame '%c' has failed\n",
+                                line->name, line->timeslot,
+                                sl_show_line_state(line), digit);
+            }
+        break;
+
+	default:
+        break;
+    }
+    return 0;
+
+msg_failed:
+    MSPD_ERR("(%s:%u/%s): csm-msg has failed\n",
+            line->name, line->timeslot, sl_show_line_state(line));
+    return 1;
+}
+
+static void
+handle_fax_start_tone(mspd_line_t *line)
+{
+	if (mspd_global_get_fax_mode() != MSPD_FAXMODE_T38 &&
+	    (mspd_global_get_fax_mode() != MSPD_FAXMODE_AUTO || mspd_channel_get_passthru_mode(line->channel))) {
+		MSPD_LOG(3, "%s: T.38 mode is not applicable\n", line->name);
+		return; 
+	}
+
+	if (!line->owner) {
+		MSPD_LOG(3, "%s: No owner to send T.38 indication\n", line->name);
+		return;
+	}
+
+	if (!ast_bridged_channel(line->owner)) {
+		MSPD_LOG(3, "%s: No bridged channel to send T.38 indication\n", line->owner->name);
+		return;
+	}
+
+	if (mspd_t38_request_mode_change_foip(line)) {
+		MSPD_LOG(3, "%s: Error in switching to foip-mode \n", line->name);
+		if (mspd_global_get_fax_mode() == MSPD_FAXMODE_AUTO)
+			mspd_channel_switch_to_passthru_mode(line->channel);
+		else if(line->owner)
+			sl_do_ast_channel_action(line, &line->owner, mspd_hangup_ast_channel, NULL);
+	}
+}
+
+// ===============================================================================================
+// CSM-indication consumer/handler thread
+// -----------------------------------------------------------------------------------------------
+// handle tone or event detected indication (depending on FIRMIX_TONEDET_IS_BROKEN_FOR_LSP)
+
+static int
+dc_consumer_handle_tone_vapi (mspd_line_t *line, const vapi_queue_element_t *Item)
+{
+    char digit = 0;
+    mspd_channel_t *channel = line->channel;
+    mspd_channel_pvt_t *pvt = mspd_channel_get_pvt(channel);
+
+    uint const this_id          = Item->event.usDetectedTone;
+    uint const this_timestamp   = Item->event.uTimestamp;
+    uint const this_power       = Item->event.usPpowerLevel;
+
+    uint const last_id          = pvt->tdm.tone_id;
+    uint const last_timestamp   = pvt->tdm.tone_timestamp;
+    uint const last_power       = pvt->tdm.tone_power;
+    uint const last_length      = (this_timestamp - last_timestamp + 4) / 8;
+
+    if (this_id <= VOIP_TONEDET_TONE_START_DTMF_D) {
+        digit = toneid2digit(this_id);
+        if (last_power > 300 || (mspd_channel_get_type(channel) != MCT_PART_TDM && last_length < 30)) {
+            MSPD_WARN(3, "(%s:%u/%s): ignoring invalid '%c' @ -%d/10 dBov\n",
+                    line->name, line->timeslot, sl_show_line_state(line),
+                    digit, this_power);
+            return -1;
+        }
+
+    } else if ((this_id == VOIP_TONEDET_TONE_END)                  //0xFF
+            && (last_id <= VOIP_TONEDET_TONE_START_DTMF_D)) {
+      digit = VOIP_TONEDET_TONE_END;
+      MSPD_LOG(3, "(%s/%s): DTMF '%c', -%d/10 dBov, %d ms [%s]\n",
+                line->name, sl_show_line_state(line),
+                toneid2digit(last_id), last_power, last_length, line->dialed);
+    }
+
+    if (digit) {
+        int rc = mspd_line_handle_digit(line, digit);
+        pvt->tdm.tone_id        = this_id;
+        pvt->tdm.tone_timestamp = this_timestamp;
+        pvt->tdm.tone_power     = this_power;
+        return rc;
+    }
+    else {
+        switch (this_id) {
+            case VOIP_TONEDET_TONE_START_V_25_ANSWER_NO_PHASEREV:   //0x10
+                MSPD_LOG(3, "--- V.25 answer tone w/o phase reversals detected \n");
+                handle_fax_start_tone(line);
+            break;
+
+            case VOIP_TONEDET_TONE_START_V_25_ANSWER_PHASEREV:      //0x11
+                MSPD_LOG(3, "--- V.25 answer tone with phase reversals detected \n");
+                handle_fax_start_tone(line);
+            break;
+
+            case VOIP_TONEDET_TONE_START_V_8_ANSAM_PHASEREV:        //0x12
+                MSPD_LOG(3, "--- V.8 ansam tone with phase reversals detected \n");
+            break;
+
+            case VOIP_TONEDET_TONE_START_V_8_ANSAM_NO_PHASEREV:     //0x13
+                MSPD_LOG(3, "--- V.8 ansam tone w/o phase reversals detected \n");
+            break;
+
+            case VOIP_TONEDET_TONE_START_V_8BIS_CRE:                //0x14
+                MSPD_LOG(3, "--- V.8bis CRE tone detected \n");
+            break;
+
+            case VOIP_TONEDET_TONE_START_V_18_BAUDOT:               //0x15
+                MSPD_LOG(3, "--- V.18 BAUDOT tone detected \n");
+            break;
+
+            case VOIP_TONEDET_TONE_START_V_18_EDT:                  //0x17
+                MSPD_LOG(3, "--- V.18 EDT tone detected \n");
+            break;
+
+            case VOIP_TONEDET_TONE_T30_CNG_START:                   //0x20
+                MSPD_LOG(3, "--- T.30 CNG start detected (fax calling tone) detected \n");
+                handle_fax_start_tone(line);
+            break;
+
+            case VOIP_TONEDET_TONE_START_V21_FLAGS:                 //0x22
+                MSPD_LOG(3, "--- V.21 flags detected (fax without answer tone) detected \n");
+                MSPD_LOG(5, "%s: Fax mode %s\n", mspd_channel_get_name(line->channel),
+                        mspd_global_fax_mode_to_string(mspd_global_get_fax_mode()));
+
+                handle_fax_start_tone(line);
+            break;
+
+            case VOIP_TONEDET_TONE_START_CPT:                        //0x30
+                MSPD_LOG(3, "--- Call Progress Tone detected \n");
+            break;
+
+            case VOIP_TONEDET_TONE_INACTIVITY_TIMEOUT:               //0x31
+                MSPD_LOG(3, "(%s:%d/%s/%s): Inactivity Timeout tone detected\n",
+                    line->name, line->timeslot,
+                    sl_show_line_state(line), mspd_channel_get_name(line->channel));
+		mspd_t38_request_mode_change_voip(line);
+            break;
+
+            case VOIP_TONEDET_TONE_START_2010_HZ:                    //0x50
+                MSPD_LOG(3, "--- SS7/COT tone detected \n");
+            break;
+
+            case VOIP_TONEDET_TONE_START_1780_HZ:                    //0x51
+                MSPD_LOG(3, "--- SS7/COT tone detected \n");
+            break;
+
+            case VOIP_TONEDET_TONE_EARLY_CAS_DET:                    //0x70
+                MSPD_LOG(3, "--- EARLY_CAS_DET tone detected \n");
+            break;
+
+            case VOIP_TONEDET_TONE_CAS_DET:                          //0x71
+                MSPD_LOG(3, "--- CAS_DET tone detected \n");
+            break;
+
+
+            //TODO: Handle MSP events in dc_consumer_handle_tone_vapi()
+            case VOIP_EVENTDET_EVENT_START_FAX_CNG_TONE:             //0x41
+                MSPD_LOG(3, "--- Fax CNG tone with correct cadence detected \n");
+                MSPD_LOG(5, "%s:%d/%s: Detected FAX CNG tone Passthru mode=%s\n",
+                    line->name, line->timeslot,
+                    mspd_channel_get_name(line->channel),
+                    mspd_global_fax_mode_to_string(mspd_global_get_fax_mode()));
+            break;
+
+            case VOIP_EVENTDET_EVENT_END_FAX_CNG_TONE:               //0x42
+                MSPD_LOG(3, "--- End of fax CNG sequence \n");
+                MSPD_LOG(5, "%s:%d/%s:detected End FAX CNG tone passthru_mode=%s\n",
+                     line->name, line->timeslot,
+                     mspd_channel_get_name(line->channel), mspd_global_fax_mode_to_string(mspd_global_get_fax_mode()));
+            break;
+
+            case VOIP_EVENTDET_EVENT_SPECIAL_TONE:                   //0x43
+                MSPD_LOG(3, "--- Special Information Tone / No Circuit Tone detected \n");
+            break;
+
+            case VOIP_EVENTDET_EVENT_START_PASS_THROUGH:             //0x46
+                MSPD_LOG(3, "%s:%d/%s: Auto-switch to Passthru mode\n",
+                    line->name, line->timeslot, mspd_channel_get_name(line->channel));
+            break;
+
+            case VOIP_EVENTDET_EVENT_START_CONCURRENT_PASS_THROUGH_MULAW: //0x47
+                MSPD_LOG(3, "%s:%d/%s:Entered Passthru mode thru u-law\n",
+                    line->name, line->timeslot, mspd_channel_get_name(line->channel));
+            break;
+
+            default:
+                MSPD_LOG(5, "(%s:%u/%s): Tone 0x%x detected, -%d/10 dBov @ %u (last tone 0x%x)\n",
+                        line->name, line->timeslot,
+                        sl_show_line_state(line),
+                        this_id, this_power,
+                        this_timestamp, last_id);
+        }
+        pvt->tdm.tone_id        = this_id;
+        pvt->tdm.tone_timestamp = this_timestamp;
+        pvt->tdm.tone_power     = this_power;
+        return 0;
+    }
+}
+
+/*-----------------------------------------------------------------------------
+ *Function: faxstate2str()
+ * Input: unsigned int data (fax state in hex word)
+ * Output: NIL
+ * Return: char string (fax state in string)
+ * Description: Changes the faxstate hex word to the string
+ * -----------------------------------------------------------------------------*/
+char*
+faxstate2str(U16 data)
+{
+    U8 fasc_ctrl_field, faxstate;
+    char *str = NULL;
+
+    fasc_ctrl_field = dc_get_fax_ctrl_state(data);
+    faxstate = dc_get_fax_state(data);
+    switch(fasc_ctrl_field){
+       case FAX_CTRL_STATE_00:
+          switch(faxstate){
+            case FAX_STATE_IDLE:
+                return " IDLE";
+            case FAX_STATE_NO_SIG:
+                return " No Signal";
+            case FAX_STATE_CNG_RCVD_FRM_PCM:
+                return " CNG received from PCM";
+            case FAX_STATE_CNG_SNT_TO_PCM:
+                return " CNG sent to PCM";
+            case FAX_STATE_CED_RCVD_FRM_PCM:
+                return " CED received from PCM";
+            case FAX_STATE_CED_SNT_TO_PCM:
+                return " CED sent to PCM";
+            case FAX_STATE_V21_CH2_DEMOD:
+                return " V.21 Ch 2 demod";
+            case FAX_STATE_V21_CH2_REMOD:
+                return " V.21 Ch 2 remod";
+            case FAX_STATE_V27_TER_2400_DEMOD:
+                return " V.27 ter 2400 demod";
+            case FAX_STATE_V27_TER_2400_REMOD:
+                return " V.27 ter 2400 remod";
+            case FAX_STATE_V27_TER_4800_DEMOD:
+                return " V.27 ter 4800 demod";
+            case FAX_STATE_V27_TER_4800_REMOD:
+                return " V.27 ter 4800 remod";
+            case FAX_STATE_V29_7200_DEMOD:
+                return " V.29 7200 demod";
+            case FAX_STATE_V29_7200_REMOD:
+                return " V.29 7200 remod";
+            case FAX_STATE_V29_9600_DEMOD:
+                return " V.29 9600 demod";
+            case FAX_STATE_V29_9600_REMOD:
+                return " V.29 9600 remod";
+            case FAX_STATE_V17_7200_SH_TRN_DEMOD:
+                return " V.17 7200 short train demod";
+            case FAX_STATE_V17_7200_SH_TRN_REMOD:
+                return " V.17 7200 short train remod";
+            case FAX_STATE_V17_7200_LNG_TRN_DEMOD:
+                return " V.17 7200 long train demod(V.33)";
+            case FAX_STATE_V17_7200_LNG_TRN_REMOD:
+                return " V.17 7200 long train remod(V.33)";
+            case FAX_STATE_V17_9600_SH_TRN_DEMOD:
+                return " V.17 9600 short train demod";
+            case FAX_STATE_V17_9600_SH_TRN_REMOD:
+                return " V.17 9600 short train remod";
+            case FAX_STATE_V17_9600_LNG_TRN_DEMOD:
+                return " V.17 9600 long train demod(V.33)";
+            case FAX_STATE_V17_9600_LNG_TRN_REMOD:
+                return " V.17 9600 long train remod(V.33)";
+            case FAX_STATE_V17_12000_SH_TRN_DEMOD:
+                return " V.17 12000 short train demod";
+            case FAX_STATE_V17_12000_SH_TRN_REMOD:
+                return " V.17 12000 short train remod";
+            case FAX_STATE_V17_12000_LNG_TRN_DEMOD:
+                return " V.17 12000 long train demod(V.33)";
+            case FAX_STATE_V17_12000_LNG_TRN_REMOD:
+                return " V.17 12000 long train remod(V.33)";
+            case FAX_STATE_V17_14400_SH_TRN_DEMOD:
+                return " V.17 14400 short train demod";
+            case FAX_STATE_V17_14400_SH_TRN_REMOD:
+                return " V.17 14400 short train remod";
+            case FAX_STATE_V17_14400_LNG_TRN_DEMOD:
+                return " V.17 14400 long train demod(V.33)";
+            case FAX_STATE_V17_14400_LNG_TRN_REMOD:
+                return " V.17 14400 long train remod(V.33)";
+            default:
+                return str;
+        }
+        case FAX_CTRL_STATE_DIS:
+            return " DIS";
+        case FAX_CTRL_STATE_CSI:
+            return " CSI";
+        case FAX_CTRL_STATE_NSF:
+            return " NSF";
+        case FAX_CTRL_STATE_CFR:
+            return " CFR";
+        case FAX_CTRL_STATE_FTT:
+            return " FTT";
+        case FAX_CTRL_STATE_MCF:
+            return " MCF";
+        case FAX_CTRL_STATE_RTN:
+            return " RTN";
+        case FAX_CTRL_STATE_RTP:
+            return " RTP";
+        case FAX_CTRL_STATE_DCN_1:
+        case FAX_CTRL_STATE_DCN_2:
+            return " DCN";
+        case FAX_CTRL_STATE_DCS:
+            return " DCS";
+        case FAX_CTRL_STATE_TSI:
+            return " TSI";
+        case FAX_CTRL_STATE_EOM:
+            return " EOM";
+        case FAX_CTRL_STATE_MPS:
+            return " MPS";
+        case FAX_CTRL_STATE_EOP:
+            return " EOP";
+        case FAX_CTRL_STATE_7E:
+            switch(faxstate){
+                case 0x06:
+                    return " TCF sent to IP";
+                case 0x07:
+                    return " TCF rcvd from IP";
+            }
+        case FAX_CTRL_STATE_7F:
+            switch(faxstate){
+                case 0x06:
+                    return " TCF demod from PCM";
+                case 0x07:
+                    return " TCF remod to PCM";
+            }
+        default:
+            return str;
+    }
+}
+
+/*-----------------------------------------------------------------------------
+ * Name: dc_get_fax_ctrl_state()
+ * Input: unsigned int data (FAXSTATE)
+ * Output: NIL
+ * Return: T.30 Message FCF byte
+ * Description: Service function to get T.30 message FCF field from faxstate
+ *              word
+ *-----------------------------------------------------------------------------*/
+U8
+dc_get_fax_ctrl_state(U16 data)
+{
+    /*Interested only in T.30 Message Facsimile Control Field (FCF)*/
+    return (U8)((data>>8)&0x00ff);
+}
+
+/*-----------------------------------------------------------------------------
+ * Name: dc_get_fax_state()
+ * Input: unsigned int data (FAXSTATE)
+ * Output: NIL
+ * Return: T.30 Message FCF byte
+ * Description: Service function to get T.30 message FCF field from faxstate
+ *              word
+ *-----------------------------------------------------------------------------*/
+U8
+dc_get_fax_state(U16 data)
+{
+    return (U8)(data&0x00ff);
+}
+/*-----------------------------------------------------------------------------
+ * Name: dc_handle_faxstate()
+ * Input: mspd_line_t* line
+ *        csm msg from MSP
+ * Output: NIL
+ * Return: result SUCCESS(0) or FAILURE(1)
+ * Description: Handles the faxstate message; only T.30 DCN messages are handled
+ *-----------------------------------------------------------------------------*/
+static int
+dc_handle_faxstate (mspd_line_t *line, const vapi_queue_element_t *vItem)
+{
+    char buf[2048];
+    char tmp[256];
+    U16 data;
+    U8 modem_state;
+    char *faxstate_str;
+    int result = 0;
+
+    data = vItem->event.usDetectedTone;
+    faxstate_str = faxstate2str(data);
+
+    sprintf(buf,"FAXSTATE CH IND:");
+    if(faxstate_str != NULL)
+    {   /*some unsupported faxstate is reported; so check is necessary*/
+        strcat(buf,faxstate_str);
+    }
+    else
+    {
+        sprintf(tmp, " Data[%04x]", data);
+        strcat(buf,tmp);
+    }
+
+    MSPD_LOG(5, "%s:%d/%s %s\n",
+               line->name, line->timeslot, mspd_channel_get_name(line->channel), buf);
+
+    modem_state = dc_get_fax_ctrl_state(data);
+    if((modem_state == FAX_CTRL_STATE_DCN_1)||(modem_state == FAX_CTRL_STATE_DCN_2))
+    {
+        /*DCN received; switch from FoIP to VoIP*/
+        /*destroy FoIP channel and create VoIP channel*/
+        result = mspd_t38_request_mode_change_voip(line);
+    }
+    return result;
+}
+// --------------------------------------------------------------------------------------
+// handle payload-type changed indication
+static int
+dc_consumer_handle_payload_type_changed_vapi (mspd_line_t *line, const vapi_queue_element_t *Item)
+{
+    mspd_channel_t *channel = line->channel;
+    int const new_payload_type = Item->event.usDetectedTone;
+    format_t const current_codec = mspd_channel_get_format(channel);
+    int const channel_is_native_bridged = (!line || line->is_native_bridged);
+    format_t new_codec = 0;
+    VSTATUS status  = 1;
+    void *message   = NULL;
+    U32 resp_len    = MAX_FIFO_SIZE;
+    U8  dev_resp     [MAX_FIFO_SIZE];
+
+    if (!MSPD_HAS_RTP(mspd_channel_get_type(channel))) {
+        MSPD_ERR("(%s): wrong channel type\n", mspd_channel_get_name(channel));
+        return 1;
+    }
+
+    switch (new_payload_type) {
+    case 0x00: new_codec = AST_FORMAT_ULAW;     break;
+    case 0x02: new_codec = AST_FORMAT_G726_32;  break;
+    case 0x03: new_codec = AST_FORMAT_GSM;      break;
+    case 0x04: new_codec = AST_FORMAT_G723_1;   break;
+    case 0x08: new_codec = AST_FORMAT_ALAW;     break;
+    case 0x09: new_codec = AST_FORMAT_G722;     break;
+    case 0x12: new_codec = AST_FORMAT_G729A;    break;
+    case 0x1D: new_codec = AST_FORMAT_ILBC_1;   break;
+    case 0x1E: new_codec = AST_FORMAT_ILBC;     break;
+    case 0x27: new_codec = AST_FORMAT_AMR;      break;
+    case 0x40: new_codec = AST_FORMAT_AMR_WB;   break;
+    case 0x5A: new_codec = AST_FORMAT_G726_40;  break;
+    case 0x5B: new_codec = AST_FORMAT_G726_16;  break;
+    case 0x5C: new_codec = AST_FORMAT_G726_24;  break;
+    default:   new_codec = 0;
+    }
+    if (!mspd_channel_get_passthru_mode(channel)) {
+    if (new_codec) {
+        if (channel_is_native_bridged) {
+            if (new_codec == current_codec)
+                return 0;
+            mspd_channel_enable(channel, new_codec);
+        }
+        else {
+            message = VAPI_AllocateMessage(MAX_FIFO_SIZE);
+            if (!message) {
+                MSPD_ERR("VAPI_AllocateMessage has failed\n");
+                return -1;
+            }
+
+            status = VAPI_SetMessage(message,
+                        CMD_CLASS_CONF_CHANNEL,
+                        CMD_TYPE_CONF_CHANGE,
+                            FC_VOIP_INDCTRL,
+                                1,
+                                0x0004);
+            if (status)
+                VAPI_REPORT_ACT (status, "Setting VOIP_INDCTRL", goto msg_err);
+
+
+            status = VAPI_SendConnectionMessage(mspd_channel_get_id(channel),
+                        (SMsg *)message, NULL,
+                        dev_resp, &resp_len);
+            VAPI_REPORT (status, "Sending VOIP_INDCTRL");
+        }
+    }
+    ast_log((new_codec ? __LOG_NOTICE : __LOG_ERROR), _A_, MSPD_FMT
+            "(%s): got %s '%s/%d' packet, codec=%s, native-bridged=%s\n",
+            MSPD_WHERE, mspd_channel_get_name(channel), new_codec ? "unexpected" : "unsupported",
+            ast_getformatname(new_codec), new_payload_type, ast_getformatname(current_codec),
+            channel_is_native_bridged ? "yes" : "no");
+    }
+
+msg_err:
+    VAPI_FreeMessage(message);
+
+    return status;
+}
+
+// --------------------------------------------------------------------------------------
+// handle indication
+static void
+dc_consumer_handle_indication_vapi (mspd_line_t *line, const vapi_queue_element_t *Item)
+{
+    int not_handled = 1;
+    if (!line) {
+        MSPD_ERR("No LINE bound to indication!\n");
+        return;
+    }
+
+    switch (Item->usFnCode) {
+        case FC_VOIP_TONEDET:
+            MSPD_LOG(1, "=== VOIP_TONEDET\n");
+            if (line)
+                not_handled = dc_consumer_handle_tone_vapi(line, Item);
+        break;
+
+        case FC_VOIP_EVENTDET:
+            MSPD_LOG(1, "=== VOIP_EVENTDET \n");
+            not_handled = 0;
+        break;
+
+        case FC_VOIP_PTCHNG:
+            MSPD_LOG(1, "=== VOIP_PTCHNG \n");
+            not_handled = dc_consumer_handle_payload_type_changed_vapi(line, Item);
+        break;
+
+        case FC_VOIP_SSRCCHG:
+            MSPD_LOG(1, "=== VOIP_SSRCCHG \n");
+        case FC_VOIP_TCMPLT:
+            MSPD_LOG(1, "=== VOIP_TCMPLT \n");
+            not_handled = 0;
+        break;
+
+        case FC_FAXSTATE:
+            not_handled = dc_handle_faxstate(line, Item);
+        break;
+
+        case FC_VOIP_REMDET:
+            MSPD_LOG(1, "%s VOIP_REMDET recvd. Fax mode=%s \n",
+                    line->name, mspd_global_fax_mode_to_string(mspd_global_get_fax_mode()));
+	    /* It's impossible to see this indication,
+	     * as we should switch to T.38 in signaling and switch MSP channel.
+	     * We should get UDPTL only after this.
+	     * Otherwise (if T.38 negotiation fails) Asterisk won't send UDPTL to us.
+	     */
+	    break;
+        break;
+
+        case FC_VOIP_IPTONEDET:
+            MSPD_LOG(1, "=== VOIP_REMDET \n");
+        break;
+
+        case FC_PASSTHRU_AUTOSWITCH_IND:
+            MSPD_LOG(1, "%s: VOIP_PASSTHRU_AUTOSWITCH_IND (%d) received\n",
+                         line->name, Item->uPassthruMode);
+
+            /* block any format changes for some time */
+            line->format_change_ts = ast_tvnow();
+
+            if ((Item->uPassthruMode & 0x7) == PASSTHRU_AUTOSWITCH_IND_SWITCH_TYPE_ST_PT)
+		line->pt_mode = MSPD_PT_MODE_FAX;
+            if ((Item->uPassthruMode & 0x7) == PASSTHRU_AUTOSWITCH_IND_SWITCH_TYPE_ST_VOICE)
+		line->pt_mode = MSPD_PT_MODE_VOICE;
+
+            not_handled = 0;
+            break;
+    }
+
+    if (not_handled)
+                MSPD_LOG(1, "=== unhandled indication!\n");
+
+}
+
+// -----------------------------------------------------------------------------------------------
+// consumer callback
+static void
+dc_consumer (mspd_channel_t *channel, const vapi_queue_element_t *Item)
+{
+    mspd_line_t *       line    = NULL;
+    mspd_channel_pvt_t	*pvt = mspd_channel_get_pvt(channel);
+
+    if (MSPD_HAS_TDM(mspd_channel_get_type(channel))) {
+        line = pvt->tdm.line;
+        if (!line) {
+            MSPD_ERR("DC consumer thread has no line for channel %s\n", mspd_channel_get_name(channel));
+            return;
+        }
+    }
+
+    if (line) {
+        struct timeval start = {0, 0};
+        while (ast_mutex_trylock(&line->lock)) {
+            if (!start.tv_sec)
+                gettimeofday(&start, NULL);
+            else {
+                struct timeval now = {0, 0};
+                gettimeofday(&now, NULL);
+                long const waited =
+                    (now.tv_sec - start.tv_sec) * 1000 + (now.tv_usec - start.tv_usec) / 1000;
+                if (waited >= 1000) {
+                    MSPD_ERR("(%s): failed to lock %s:%u for %ld ms -> dropping indication\n",
+                            mspd_channel_get_name(channel), line->name, line->timeslot, waited);
+                    return;
+                }
+            }
+            usleep(10);
+        }
+        if (!line->channel) {
+            MSPD_ERR("(%s): line %s:%u has lost channel\n",
+                    mspd_channel_get_name(channel), line->name, line->timeslot);
+            MSPD_UNLOCK(line->lock);
+            return;
+        }
+        if (line->channel != channel) {
+            if (line->channel != channel)
+                MSPD_ERR("(%s): %s:%u has changed channel (%p->%p(%s))\n",
+                        mspd_channel_get_name(channel), line->name, line->timeslot,
+                        channel, line->channel, mspd_channel_get_name(line->channel));
+            MSPD_UNLOCK(line->lock);
+            return;
+        }
+    }
+    else {
+        MSPD_ERR("Where is the line??\n");
+
+        if (pvt->tdm.line) {
+            MSPD_LOG (1, "channel %s, type %s, tdm.line %s\n",
+                    mspd_channel_get_name(channel), mspd_channel_type2text(mspd_channel_get_type(channel)), pvt->tdm.line->name);
+            line = pvt->tdm.line;
+        }
+        else {
+            MSPD_ERR("Indeed, no line bound...\n");
+            return;
+        }
+    }
+
+    dc_consumer_handle_indication_vapi(line, Item);
+
+    if (line)
+        MSPD_UNLOCK(line->lock);
+}
+
+// ================================================================================================
+// global functions for startup, device initialization and shutdown
+
+// -----------------------------------------------------------------------------------------------
+// macro to build one PKT_RULE_CONFIG rule to match on ip-address and to send the packet to a new
+// destination (address and netmask in network byte order)
+#define mpr_newdest_for_network(i, address, netmask, newport) \
+    ((i)*12 +  5), 0x0001,             \
+    ((i)*12 +  6), 0x0010,             \
+    ((i)*12 +  7), (netmask) >> 16,         \
+    ((i)*12 +  8), (netmask) & 0xffff,         \
+    ((i)*12 +  9), ntohl(address) >> 16,     \
+    ((i)*12 + 10), ntohl(address) & 0xffff,     \
+    ((i)*12 + 11), ntohl(address) >> 16,     \
+    ((i)*12 + 12), ntohl(address) & 0xffff,     \
+    ((i)*12 + 13), 0x0001,             \
+    ((i)*12 + 14), (newport),             \
+    ((i)*12 + 15), 0x0000,             \
+    ((i)*12 + 16), 0x0000
+
+// -----------------------------------------------------------------------------------------------
+// This function sends ud-trace cmds to MSP for a given mspd_channel_t
+
+void
+dc_send_enable_ud_cmds_to_msp (const mspd_channel_t *chan, const mspd_device_t * dev)
+{
+    if (!chan)
+        return;
+
+    MSPD_LOG(5, "Sending UD commands to %s\n", chan ? mspd_channel_get_name(chan) : mspd_device_get_name(dev));
+
+    if (mspd_global.ud_prefs.ud_enable_tdm_rx)
+        dc_send_ud_cmd(chan, dev, DIAG_TDM_RX, True);
+
+    if (mspd_global.ud_prefs.ud_enable_tdm_tx)
+        dc_send_ud_cmd(chan, dev, DIAG_TDM_TX, True);
+
+    if (mspd_global.ud_prefs.ud_enable_pkt_rx)
+        dc_send_ud_cmd(chan, dev, DIAG_PACKET_RX, True);
+
+    if (mspd_global.ud_prefs.ud_enable_pkt_tx)
+        dc_send_ud_cmd(chan, dev, DIAG_PACKET_TX, True);
+
+    if (mspd_global.ud_prefs.ud_enable_spu_in)
+        dc_send_ud_cmd(chan, dev, DIAG_SPU_INSTREAM, True);
+
+    if (mspd_global.ud_prefs.ud_enable_spu_out)
+        dc_send_ud_cmd(chan, dev, DIAG_SPU_OUTSTREAM, True);
+
+    if (mspd_global.ud_prefs.ud_enable_spu_io_params)
+        dc_send_ud_cmd(chan, dev, DIAG_SPU_IOPARAMS, True);
+
+    if (mspd_global.ud_prefs.ud_enable_report_cmd)
+        dc_send_ud_cmd(chan, dev, DIAG_REPORTCMD, True);
+}
+
+// -----------------------------------------------------------------------------------------------
+// This function sends cmds to disable ud-trace to MSP for a given mspd_channel_t
+void
+dc_send_disable_ud_cmds_to_msp (mspd_ud_pref_t *prefs, 
+				const mspd_channel_t *chan, 
+				const mspd_device_t *dev)
+{
+    if (!chan)
+        return;
+
+    MSPD_LOG(3, "Sending UDC commands to %s\n", chan ? mspd_channel_get_name(chan) : mspd_device_get_name(dev));
+
+    mspd_ud_pref_t *ud_prefs = prefs;
+    if (!prefs)
+        ud_prefs = &(mspd_global.ud_prefs);
+
+    if (ud_prefs->ud_enable_tdm_rx)
+        dc_send_ud_cmd(chan, dev, DIAG_TDM_RX, False);
+
+    if (ud_prefs->ud_enable_tdm_tx)
+        dc_send_ud_cmd(chan, dev, DIAG_TDM_TX, False);
+
+    if (ud_prefs->ud_enable_pkt_tx)
+        dc_send_ud_cmd(chan, dev, DIAG_PACKET_RX, False);
+
+    if (ud_prefs->ud_enable_pkt_rx)
+        dc_send_ud_cmd(chan, dev, DIAG_PACKET_TX, False);
+
+    if (ud_prefs->ud_enable_spu_in)
+        dc_send_ud_cmd(chan, dev, DIAG_SPU_INSTREAM, False);
+
+    if (ud_prefs->ud_enable_spu_out)
+        dc_send_ud_cmd(chan, dev, DIAG_SPU_OUTSTREAM, False);
+
+    if (ud_prefs->ud_enable_spu_io_params)
+        dc_send_ud_cmd(chan, dev, DIAG_SPU_IOPARAMS, False);
+
+    if (ud_prefs->ud_enable_report_cmd)
+        dc_send_ud_cmd(chan, dev, DIAG_REPORTCMD, False);
+}
+
+// -----------------------------------------------------------------------------------------------
+// This function sends cmds to disable ud trace at Supvsr level
+int
+dc_send_disable_ud_cmds_supvsr (void)
+{
+    mspd_device_t *dev = mspd_device_find_by_index(0);
+
+    if (!dev)
+        return -1;
+
+    dc_send_disable_ud_cmds_to_msp_device(NULL, dev);
+    MSPD_LOG(3, "UD trace disable cmds sent\n");
+
+    return 0;
+}
+
+// -----------------------------------------------------------------------------------------------
+// This function sends FC_TDM_SELECT_BUS_MODE, FC_TDM_ENABLE_BUS, FC_SETUP_TDM_PARAMS
+int
+dc_send_enable_ud_cmds_supvsr (void)
+{
+    mspd_device_t *dev = mspd_device_find_by_index(0);
+
+    if (!dev)
+        return -1;
+
+    MSPD_LOG(4, "UD trace cmd %s\n", mspd_device_get_name(dev));
+
+    if( mspd_global.ud_prefs.is_ud_info_set)
+        if (mspd_device_send_redirection_cmd(&mspd_global.ud_prefs.ud_dest_ipaddr, &mspd_global.ud_prefs.ud_enable_error))
+            return -1;
+
+    if (mspd_global.ud_prefs.ud_enable_supvsr)
+    {
+        dc_send_enable_ud_cmds_to_msp_device(dev);
+        MSPD_LOG(5, "UD trace enable cmds sent\n");
+    }
+    return 0;
+}
+
+// -----------------------------------------------------------------------------------------------
+int
+dc_check_send_ud_cmds_supvsr (mspd_ud_pref_t *old_ud_prefs)
+{
+    mspd_device_t *dev = mspd_device_find_by_index(0);
+
+    if (!dev)
+        return -1;
+
+    if( mspd_global.ud_prefs.is_ud_info_set)
+        if (mspd_device_send_redirection_cmd(&mspd_global.ud_prefs.ud_dest_ipaddr, &mspd_global.ud_prefs.ud_enable_error))
+            return -1;
+
+    mspd_ud_pref_t * new_ud_prefs = &(mspd_global.ud_prefs);
+    if (!(new_ud_prefs->ud_enable_supvsr)) {                //not-set
+        //check prev value of supvsr.
+        if (old_ud_prefs->ud_enable_supvsr)                 //set
+            dc_send_disable_ud_cmds_to_msp_device(old_ud_prefs, dev);
+        return 0;
+    }
+    if (!(old_ud_prefs->ud_enable_supvsr)) {                //not-set
+        //check value of supvsr.
+        if (new_ud_prefs->ud_enable_supvsr)                 //set
+            dc_send_enable_ud_cmds_to_msp_device(dev);
+        return 0;
+    }
+
+    //check TDM TX
+    mspd_check_ud_vals(old_ud_prefs->ud_enable_tdm_tx,
+                    new_ud_prefs->ud_enable_tdm_tx,
+                    DIAG_TDM_RX,
+                    dev);
+
+    //check TDM RX
+    mspd_check_ud_vals(old_ud_prefs->ud_enable_tdm_rx,
+                    new_ud_prefs->ud_enable_tdm_rx,
+                    DIAG_TDM_TX,
+                    dev);
+
+    //check PKT TX
+    mspd_check_ud_vals(old_ud_prefs->ud_enable_pkt_tx,
+                    new_ud_prefs->ud_enable_pkt_tx,
+                    DIAG_PACKET_RX,
+                    dev);
+
+    //check PKT RX
+    mspd_check_ud_vals(old_ud_prefs->ud_enable_pkt_rx,
+                    new_ud_prefs->ud_enable_pkt_rx,
+                    DIAG_PACKET_TX,
+                    dev);
+
+    //check SPU instream
+    mspd_check_ud_vals(old_ud_prefs->ud_enable_spu_in,
+                    new_ud_prefs->ud_enable_spu_in,
+                    DIAG_SPU_INSTREAM,
+                    dev);
+
+    //check SPU outstream
+    mspd_check_ud_vals(old_ud_prefs->ud_enable_spu_out,
+                    new_ud_prefs->ud_enable_spu_out,
+                    DIAG_SPU_OUTSTREAM,
+                    dev);
+
+    //check SPU io-params
+    mspd_check_ud_vals(old_ud_prefs->ud_enable_spu_io_params,
+                    new_ud_prefs->ud_enable_spu_io_params,
+                    DIAG_SPU_IOPARAMS,
+                    dev);
+
+    //check ud report cmd
+    mspd_check_ud_vals(old_ud_prefs->ud_enable_report_cmd,
+                    new_ud_prefs->ud_enable_report_cmd,
+                    DIAG_REPORTCMD,
+                    dev);
+
+    MSPD_LOG(1, "Device released\n");
+
+    return 0;
+}
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/channels/mspd/mspd_rtp.c asterisk-1.8.2.3.new/channels/mspd/mspd_rtp.c
--- asterisk-1.8.2.3/channels/mspd/mspd_rtp.c	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/channels/mspd/mspd_rtp.c	2012-02-17 20:57:01.000000000 +0530
@@ -0,0 +1,225 @@
+/*
+ * Mindspeed Comcerto Channel module.
+ *
+ *  Copyright (C) 2004 - 2011 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+// ===============================================================================================
+// Includes
+
+#include "asterisk.h"
+
+//ASTERISK_FILE_VERSION(__FILE__, "$Revision: 1.12 $")
+
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+
+#include "include/mspd_common.h"
+#include "include/mspd_sti-lines.h"
+#include "include/mspd_dev-channels.h"
+#include "include/mspd_rtp.h"
+#include "asterisk/mspd/macro.h"
+#include "asterisk/mspd/global.h"
+
+#include "asterisk/options.h"
+#include "asterisk/channel.h"
+#include "asterisk/logger.h"
+#include "asterisk/utils.h"
+
+// ===============================================================================================
+// Global data
+
+struct ast_rtp_glue mspd_rtp_glue = {
+	.type = "MSPD",
+	.get_rtp_info = mspd_get_rtp_info,
+	.get_vrtp_info = NULL,
+	.get_trtp_info = NULL,
+	.update_peer = mspd_set_rtp_info,
+	.get_codec = mspd_get_codec,
+};
+
+struct ast_rtp_glue mspd_rtp_fxo_glue = {
+	.type = "MSPD_FXO",
+	.get_rtp_info = mspd_get_rtp_info,
+	.get_vrtp_info = NULL,
+	.get_trtp_info = NULL,
+	.update_peer = mspd_set_rtp_info,
+	.get_codec = mspd_get_codec,
+};
+
+
+// ===============================================================================================
+// RTP-protcol functions
+
+// -----------------------------------------------------------------------------------------------
+// get voice RTP info of channel
+enum ast_rtp_glue_result
+mspd_get_rtp_info (struct ast_channel *ast, struct ast_rtp_instance **instance)
+{
+	enum ast_rtp_glue_result res = AST_RTP_GLUE_RESULT_LOCAL;
+
+    mspd_line_t * const line = ast->tech_pvt;
+    if (!line) {
+        MSPD_ERR("(%s): Ast-channel has no line\n", ast->name);
+        return AST_RTP_GLUE_RESULT_FORBID;
+    }
+
+	MSPD_LOCK(line->lock,);
+	if (!(line->intern_rtp)) {
+		MSPD_UNLOCK(line->lock);
+		return AST_RTP_GLUE_RESULT_FORBID;
+	}
+
+	ao2_ref(line->intern_rtp, +1);
+	*instance = line->intern_rtp;
+	MSPD_UNLOCK(line->lock);
+
+	return res;
+}
+
+
+enum ast_rtp_glue_result
+mspd_get_vrtp_info(struct ast_channel *chan, struct ast_rtp_instance **instance)
+{
+    return AST_RTP_GLUE_RESULT_FORBID;
+}
+
+enum ast_rtp_glue_result
+mspd_get_trtp_info(struct ast_channel *chan, struct ast_rtp_instance **instance)
+{
+    return AST_RTP_GLUE_RESULT_FORBID;
+}
+
+// -----------------------------------------------------------------------------------------------
+// get codecs supported by RTP peer (i.e. a VoIP channel in the MSP)
+format_t
+mspd_get_codec(struct ast_channel *ast)
+{
+    mspd_line_t *const line = ast->tech_pvt;
+    return line->phone->allowed_codecs;
+}
+
+// -----------------------------------------------------------------------------------------------
+// set new RTP peer
+int
+mspd_set_rtp_info(struct ast_channel *ast,
+                    struct ast_rtp_instance *instance,
+                    struct ast_rtp_instance *vinstance,
+                    struct ast_rtp_instance *tinstance,
+                    format_t codecs,
+                    int nat_active)
+{
+
+     mspd_line_t * const line = ast->tech_pvt;
+
+    if (!line) {
+        MSPD_ERR("(%s): Ast-channel has no line\n", ast->name);
+        return -1;
+    }
+    if (vinstance) {
+        MSPD_ERR("(%s): vinstance argument is not NULL\n", ast->name);
+        return -1;
+    }
+    if (tinstance) {
+        MSPD_ERR("(%s): tinstance argument is not NULL\n", ast->name);
+        return -1;
+    }
+    if (!instance)
+        MSPD_DBG("(%s): instance argument is NULL\n", ast->name);
+
+
+    MSPD_LOCK(line->lock, return -1);
+    mspd_channel_t * const channel = line->channel;
+
+    if (!channel) {
+        MSPD_ERR("(%s|%s,%s:%u|%s): line has no channel\n",
+            ast->name,
+            ast_state2str(ast->_state),
+            line->name,
+            line->timeslot,
+            sl_show_line_state(line));
+        goto bail_out;
+    }
+    if (mspd_channel_get_type(channel) != MCT_VOIP) {
+        MSPD_ERR("(%s,%s|%s:%d|%s,%s): channel has invalid type\n",
+            ast->name,
+            ast_state2str(ast->_state),
+            line->name,
+            line->timeslot,
+            sl_show_line_state(line),
+            mspd_channel_get_name(channel));
+        goto bail_out;
+    }
+
+    if (option_verbose) {
+        char buf[256];
+        MSPD_LOG(3, "(%s|%s,%s:%u|%s,%s,%p,%p,%s)\n",
+                ast->name,
+                ast_state2str(ast->_state),
+                line->name,
+                line->timeslot,
+                sl_show_line_state(line),
+                mspd_channel_get_name(channel),
+                instance,
+                vinstance,
+                ast_getformatname_multiple(buf, sizeof(buf),
+                codecs));
+        }
+
+// REDO for mspd CM
+	/* if this peer cannot handle reinvites of the media stream to devices
+	   that are known to be behind a NAT, then stop the process now
+
+	if (nat_active && !ast_test_flag(&p->flags[0], SIP_DIRECT_MEDIA_NAT)) {
+		sip_pvt_unlock(p);
+		return 0;
+	}
+    */
+
+/*	if (instance) {
+		changed |= ast_rtp_instance_get_and_cmp_remote_address(instance, &p->redirip);
+	} else if (!ast_sockaddr_isnull(&p->redirip)) {
+		memset(&p->redirip, 0, sizeof(p->redirip));
+		changed = 1;
+	}
+*/
+
+    if (instance && (codecs & mspd_global.global_phone.allowed_codecs) == 0) {
+        char buf[256];
+        MSPD_ERR("(%s): no common codecs with new peer (%s)\n",
+                mspd_channel_get_name(channel),
+                ast_getformatname_multiple(buf, sizeof(buf),
+                codecs));
+        goto bail_out;
+    }
+
+    int const bridging_codec = (ast->rawreadformat & codecs)
+        ? ast->rawreadformat
+        : ast_codec_choose(&mspd_global.codec_prefs,
+                            (codecs & mspd_global.global_phone.allowed_codecs), 1);
+
+    if(mspd_channel_set_rtp_peer(channel, line->intern_rtp, instance,
+            bridging_codec))
+    {
+        MSPD_ERR("(%s|%s,%s:%u|%s,%s): line has no intern-rtp\n",
+                ast->name, ast_state2str(ast->_state),
+                line->name, line->timeslot,
+                sl_show_line_state(line), mspd_channel_get_name(channel));
+        goto bail_out;
+    }
+    //line->is_native_bridged = (instance != NULL);
+    MSPD_UNLOCK(line->lock);
+    return 0;
+
+bail_out:
+    MSPD_UNLOCK(line->lock);
+    return -1;
+}
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/channels/mspd/mspd_sti-lines.c asterisk-1.8.2.3.new/channels/mspd/mspd_sti-lines.c
--- asterisk-1.8.2.3/channels/mspd/mspd_sti-lines.c	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/channels/mspd/mspd_sti-lines.c	2014-05-07 14:49:35.000000000 +0530
@@ -0,0 +1,1959 @@
+/*
+ * Mindspeed Comcerto Channel module.
+ *
+ *  Copyright (C) 2004 - 2011 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+// ===============================================================================================
+// Includes
+
+#include "asterisk.h"
+
+//ASTERISK_FILE_VERSION(__FILE__, "$Revision: 1.51 $")
+
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <pthread.h>
+#include <signal.h>
+#include <time.h>
+#include <errno.h>
+
+#include <vapi/vapi.h>
+#include <vapi/comcerto-api-defs.h>
+
+#include "include/mspd_common.h"
+#include "asterisk/mspd/macro.h"
+#include "asterisk/mspd/defaults.h"
+#include "asterisk/mspd/rtp.h"
+#include "asterisk/mspd/global.h"
+#include "include/chan_mspd.h"
+#include "include/mspd_rtp.h"
+#include "include/mspd_sti-lines.h"
+#include "include/mspd_dev-channels.h"
+#include "include/mspd_threeway.h"
+
+#include "asterisk/rtp_engine.h"
+#include "asterisk/utils.h"
+#include "asterisk/lock.h"
+#include "asterisk/frame.h"
+#include "asterisk/channel.h"
+#include "asterisk/logger.h"
+#include "asterisk/options.h"
+#include "asterisk/musiconhold.h"
+#include "asterisk/features.h"
+#include "asterisk/callerid.h"
+#include "asterisk/term.h"
+#include "asterisk/sched.h"
+#include "asterisk/channelstate.h"
+
+
+// ===============================================================================================
+// Global data
+
+extern struct sched_context *sched;
+
+// ===============================================================================================
+// Defines
+
+// size of STI-event work-queues
+#define QUEUESIZE               (8)
+
+// maximum number of lines per TDM-bus (absolute maximum is determined by sl_usrid_t type)
+#define MAX_N_LINES_PER_BUS     (256)
+
+// ===============================================================================================
+// Local data
+
+// the STI-event reader thread
+static pthread_t producer = AST_PTHREADT_NULL;
+static pthread_t timer    = AST_PTHREADT_NULL;
+
+// ===============================================================================================
+// Helper functions
+// -----------------------------------------------------------------------------------------------
+// for each bus prints in a loop an information about lines connected to it
+void
+sl_print_busdetails (void)
+{
+    U8 i, j;
+    mspd_bus_t  *bus;
+    mspd_line_t *line;
+
+    for (i = 0; i < mspd_global.n_buses; i++) {
+        bus=&(mspd_global.buses[i]);
+        ast_verbose(VERBOSE_PREFIX_1 "=== Bus[%u:%s] {tdm=0x%x, n_lines=%d, context=%s} ===\n",
+                i, bus->name, bus->tdm, bus->n_lines, bus->context);
+
+        for (j = 0; j < bus->n_lines; j++) {
+            line=bus->lines+j;
+            ast_verbose(VERBOSE_PREFIX_1" Line[%u:%s:%-3u] {ts=%-3u, bus=%s, state=%-15s, timer=%u}\n",
+                    j, line->name, line->timeslot,
+                    line->timeslot,
+                    line->bus->name,
+                    sl_show_line_state(line),
+                    line->is_timer_started);
+        }
+    }
+}
+
+// -----------------------------------------------------------------------------------------------
+// prints an information about each phone connected to all buses
+void
+sl_print_phonedetails (void)
+{
+    mspd_phone_t *phone;
+    int i;
+
+    ast_log(LOG_NOTICE, MSPD_FMT"==== %d PHONES found ====\n",
+            MSPD_WHERE, mspd_global.n_phones);
+    for (i = 0; i < mspd_global.n_phones; i++) {
+        phone = &(mspd_global.phones[i]);
+        ast_log(LOG_NOTICE, " Phone[%d:%s] {bus=%s, timeslot=%d, line=%s, is_trunk=%d}\n",
+            i, phone->name, phone->bus->name,
+            phone->timeslot, phone->line ? phone->line->name : "NO LINE",
+            phone->is_mapped_trunk);
+    }
+
+}
+
+// -----------------------------------------------------------------------------------------------
+// prints aninformation about each phone connected to all buses
+void
+sl_print_echocandetails (void)
+{
+    mspd_phone_t *phone;
+    int i;
+
+    ast_verbose(VERBOSE_PREFIX_1" ECHO Canceler & ENHanced ECHO Canceler details\n");
+    for (i = 0; i < mspd_global.n_phones; i++) {
+        phone = &(mspd_global.phones[i]);
+        ast_verbose(VERBOSE_PREFIX_2" Phone[%d:%s] {echocan=0x%x, enh_echocan=0x%x}\n",
+                    i, phone->name, phone->echocan.echocan_ctrl, phone->echocan.enh_echocan_ctrl);
+    }
+}
+
+// -----------------------------------------------------------------------------------------------
+char const *
+sl_event_type2text (U8 event_type)
+{
+    switch (event_type) {
+        case TEMPO_EVENT_INCOMING_CALL:             return "INCOMING_CALL";
+        case TEMPO_EVENT_ANSWER_INCOMING_CALL:      return "ANSWER_INCOMING_CALL";
+        case TEMPO_EVENT_INCOMING_CALL_CONNECTED:   return "INCOMING_CALL_CONNECTED";
+        case TEMPO_EVENT_OUTGOING_CALL_CONNECTED:   return "OUTGOING_CALL_CONNECTED";
+        case TEMPO_EVENT_DISCONNECT_CALL:           return "DISCONNECT_CALL";
+        case TEMPO_EVENT_FLASH:                     return "FLASH";
+        case TEMPO_EVENT_CALLERID_GEN :             return "CALLERID_GEN";
+        case TEMPO_EVENT_DIGIT:                     return "DIGIT";
+    }
+    return "**UNKNOWN_EVENT**";
+}
+
+// -----------------------------------------------------------------------------------------------
+char const *
+sl_state2text (mspd_line_state_t state)
+{
+    switch (state) {
+        case MLS_IDLE:              return "IDLE";
+        case MLS_OFF_HOOK:          return "OFF_HOOK";
+        case MLS_RINGING:           return "RINGING";
+        case MLS_DIALING_0:         return "DIALING_0";
+        case MLS_DIALING:           return "DIALING";
+        case MLS_CALL_PROCEEDING:   return "CALL_PROCEEDING";
+        case MLS_CONNECTED:         return "CONNECTED";
+        case MLS_DISCONNECTING:     return "DISCONNECTING";
+        case MLS_DIALING_FXO:       return "DIALING_FXO";
+        case MLS_WAIT_FOR_FLASH:    return "WAIT_FOR_FLASH";
+        case MLS_FLASHED:           return "FLASHED";
+        case MLS_THREEWAY:          return "THREEWAY";
+    }
+    return "**UNKNOWN_STATE**";
+}
+
+// -----------------------------------------------------------------------------------------------
+char const *
+sl_condition2text (int cond)
+{
+    /* Control frame types */
+
+    switch (cond) {
+            /*! Other end has hungup */
+        case AST_CONTROL_HANGUP:                return "CONTROL_HANGUP";
+            /*! Local ring */
+        case AST_CONTROL_RING:                  return "CONTROL_RING";
+            /*! Remote end is ringing */
+        case AST_CONTROL_RINGING:               return "CONTROL_RINGING";
+            /*! Remote end has answered */
+        case AST_CONTROL_ANSWER:                return "CONTROL_ANSWER";
+            /*! Remote end is busy */
+        case AST_CONTROL_BUSY:                  return "CONTROL_BUSY";
+            /*! Make it go off hook */
+        case AST_CONTROL_TAKEOFFHOOK:           return "CONTROL_TAKEOFFHOOK";
+            /*! Line is off hook */
+        case AST_CONTROL_OFFHOOK:               return "CONTROL_OFFHOOK";
+            /*! Congestion (circuits busy) */
+        case AST_CONTROL_CONGESTION:            return "CONTROL_CONGESTION";
+            /*! Flash hook */
+        case AST_CONTROL_FLASH:                 return "CONTROL_FLASH";
+            /*! Wink */
+        case AST_CONTROL_WINK:                  return "CONTROL_WINK";
+            /*! Set a low-level option */
+        case AST_CONTROL_OPTION:                return "CONTROL_OPTION";
+            /*! Key Radio */
+        case	AST_CONTROL_RADIO_KEY:          return "CONTROL_RADIO_KEY";
+            /*! Un-Key Radio */
+        case	AST_CONTROL_RADIO_UNKEY:        return "CONTROL_RADIO_UNKEY";
+            /*! Indicate PROGRESS */
+        case AST_CONTROL_PROGRESS:              return "CONTROL_PROGRESS";
+            /*! Indicate CALL PROCEEDING */
+        case AST_CONTROL_PROCEEDING:            return "CONTROL_PROCEEDING";
+            /*! Indicate call is placed on hold */
+        case AST_CONTROL_HOLD:                  return "CONTROL_HOLD";
+            /*! Indicate call is left from hold */
+        case AST_CONTROL_UNHOLD:                return "CONTROL_UNHOLD";
+            /*! Indicate video frame update */
+        case AST_CONTROL_VIDUPDATE:             return "CONTROL_VIDUPDATE";
+            /*!< Indicate source of media has changed */
+        case AST_CONTROL_SRCUPDATE:             return "CONTROL_SRCUPDATE";
+            /*!< T.38 */
+        case AST_CONTROL_T38_PARAMETERS:        return "CONTROL_T38_PARAMETERS";
+            /*! No one picked up the phone */
+        case -1:                                return "CONTROL_NO_ANSWER";
+        }
+
+    return "**UNKNOWN_CONDITION**";
+}
+
+// -----------------------------------------------------------------------------------------------
+char const *
+sl_show_line_state (mspd_line_t *line)
+{
+    return (line) ? sl_state2text (line->state) : NULL;
+}
+
+// -----------------------------------------------------------------------------------------------
+mspd_line_t *
+sl_connection2line (U32 connection)
+{
+    int bus_num  = 0;
+    int line_num = 0;
+    mspd_bus_t  *bus  = mspd_global.buses;
+
+    while (bus_num++ < mspd_global.n_buses) {
+        if (bus == NULL) {
+            ++bus;
+        }
+        else {
+            do {
+                if (bus->lines &&
+                    bus->lines[line_num].channel &&
+                    mspd_channel_get_id(bus->lines[line_num].channel) == connection) {
+                    return &bus->lines[line_num];
+                }
+            } while (line_num++ < bus->n_lines);
+            line_num = 0;
+        }
+    }
+    if (bus == NULL) {
+        MSPD_ERR("no TDM-bus found!\n");
+        return NULL;
+    }
+
+    MSPD_ERR(" === No Line bound with connection %u ===\n", connection);
+    return NULL;
+}
+
+// -----------------------------------------------------------------------------------------------
+U32
+sl_get_usrid_of_line (mspd_line_t *line)
+{
+    sl_usrid_t id = (sl_usrid_t) {
+        .s.bus = line->bus->index,
+        .s.timeslot = line->timeslot
+    };
+    return id.u;
+}
+
+// -----------------------------------------------------------------------------------------------
+U32
+sl_usrid2bus (U32 u)
+{
+    sl_usrid_t id = (sl_usrid_t) {.u = u};
+    return id.s.bus;
+}
+
+// -----------------------------------------------------------------------------------------------
+U32
+sl_usrid2timeslot (U32 u)
+{
+    sl_usrid_t id = (sl_usrid_t) {.u = u};
+    return id.s.timeslot;
+}
+
+// -----------------------------------------------------------------------------------------------
+// Release/reset line's resources.
+void
+sl_reset_line (mspd_line_t *line, Boolean destroy_channel)
+{
+    MSPD_LOG(5, "(%s:%u/%s): usrID=0x%x, linkID=0x%x destroy? - %s\n",
+            line->name, line->timeslot, sl_show_line_state(line),
+            sl_get_usrid_of_line(line), line->link_id, destroy_channel ? "yes" : "no");
+
+    if (destroy_channel) {
+        if (line->phone)
+            dc_send_disable_ud_cmds_channel(line);
+
+        mspd_channel_t * const channel = line->channel;
+
+        if (channel) {
+            if (MSPD_IS_PART(mspd_channel_get_type(channel)) && line->owner) {
+                sl_do_ast_channel_action(line, &line->owner, mspd_hangup_ast_channel, NULL);
+                line->owner = NULL;
+            }
+
+            mspd_channel_destroy(channel);
+            line->channel = NULL;
+        }
+        if (sl_get_line_state(line)) { // line->state != MSL_IDLE
+            MSPD_LOG(5, "Line %s:%u has been released \n", line->name, line->timeslot);
+            line->timeslot = MAX_TIMESLOT_NUMBER;
+        }
+    }
+    if (line->intern_rtp) {
+        ast_rtp_instance_destroy(line->intern_rtp);
+        line->intern_rtp = NULL;
+        line->subline[SUB_REAL].rtp = NULL;
+    }
+    if (line->subline[SUB_CALLWAIT].rtp) {
+        ast_rtp_instance_destroy(line->subline[SUB_CALLWAIT].rtp);
+        line->subline[SUB_CALLWAIT].rtp = NULL;
+    }
+    if (line->udptl) {
+	ast_udptl_destroy(line->udptl);
+	line->udptl = NULL;
+    }
+    line->link_id           = 0;
+    line->dialed[0]         = '\0';
+    line->is_native_bridged = False;
+    line->answer_format     = 0;
+    line->call_direction    = MSPD_FLAG_EMPTY;
+    line->pt_mode           = MSPD_PT_MODE_NONE;
+}
+
+// -----------------------------------------------------------------------------------------------
+// Lock the asterisk channel bound to the line (owner or subline owner)  while holding the lock of the line.
+static int
+sl_lock_line_owner (mspd_line_t *line, struct ast_channel **chan)
+{
+    while (*chan && ast_channel_trylock(*chan)) {
+        MSPD_UNLOCK(line->lock);
+        usleep(10);
+        MSPD_LOCK(line->lock, return 1);
+    }
+    if (!*chan) {
+        MSPD_ERR("(%s:%u/%s): line has no owner\n",
+                line->name, line->timeslot, sl_show_line_state(line));
+        return 1;
+    }
+    return 0;
+}
+
+// -----------------------------------------------------------------------------------------------
+// Perform action on *-channel while already holding the lock of the line (lock order inversion!)
+int
+sl_do_ast_channel_action (mspd_line_t *line,
+                          struct ast_channel **chan,
+                          int (*action)(struct ast_channel*, void*),
+                          void *arg)
+{
+    //struct ast_channel * const orig_owner = line->owner;
+    struct ast_channel * const orig_owner = *chan;
+
+    if (!orig_owner) {
+        MSPD_ERR("(%s:%u/%s): line has no owner\n",
+                line->name, line->timeslot, sl_show_line_state(line));
+        return 1;
+    }
+    if (sl_lock_line_owner(line, chan)) {
+        MSPD_ERR("(%s:%u/%s): locking line owner has failed\n",
+                line->name, line->timeslot, sl_show_line_state(line));
+        return 1;
+    }
+    int rc;
+    if (orig_owner == *chan) {
+        rc = action(orig_owner, arg);
+        if (rc)
+            MSPD_ERR("(%s:%u/%s): action has failed (%p->%p)\n",
+                line->name, line->timeslot,
+                sl_show_line_state(line), orig_owner, *chan);
+    } else {
+        rc = 1;
+        MSPD_ERR("(%s:%u/%s): owner has changed (%p->%p)\n",
+            line->name, line->timeslot,
+            sl_show_line_state(line), orig_owner, *chan);
+    }
+    ast_channel_unlock(*chan);
+    return rc;
+}
+
+// -----------------------------------------------------------------------------------------------
+// allocate new intern_rtp for a line
+int
+sl_new_intern_rtp (mspd_line_t *line)
+{
+    if (line->intern_rtp) {
+        MSPD_LOG(5, "(%s:%u/%s): line has unexpected intern-rtp\n",
+            line->name, line->timeslot, sl_show_line_state(line));
+        ast_rtp_instance_destroy(line->intern_rtp);
+    }
+    line->intern_rtp = mspd_rtp_allocate_new (line->bus->dev);
+
+    struct ast_sockaddr us, peer;
+    ast_rtp_instance_get_remote_address (line->intern_rtp, &peer);
+    ast_rtp_instance_get_local_address (line->intern_rtp, &us);
+
+    line->subline[SUB_REAL].rtp = line->intern_rtp;
+    if (!line->intern_rtp) {
+        MSPD_ERR("(%s:%u/%s): failed to allocate intern RTP\n",
+                line->name, line->timeslot, sl_show_line_state(line));
+        return 1;
+    }
+
+    return 0;
+}
+
+// -----------------------------------------------------------------------------------------------
+// make sure that intern_rtp of a line exists, while making sure that it has initially the right
+// state (NULL or !NULL), allocates new rtp if necessary
+int
+sl_fixup_intern_rtp (mspd_line_t *line, Boolean allocate_new_rtp, char const *dir)
+{
+    if (allocate_new_rtp) {
+        if (line->intern_rtp) {
+            MSPD_ERR("(%s:%u/%s,%s): line has unexpected intern-rtp\n",
+                    line->name, line->timeslot, sl_show_line_state(line), dir);
+            return 1;
+        }
+        if (sl_new_intern_rtp(line)) {
+            MSPD_ERR("(%s:%u/%s,%s): failed to get new intern-rtp\n",
+                    line->name, line->timeslot, sl_show_line_state(line), dir);
+            return 1;
+        }
+    }
+    if (!line->intern_rtp) {
+        MSPD_ERR("(%s:%u/%s,%s): line is expected to have an intern-rtp\n",
+                line->name, line->timeslot, sl_show_line_state(line), dir);
+        return 1;
+    }
+    return 0;
+}
+
+// -----------------------------------------------------------------------------------------------
+format_t
+sl_get_mspd_default_codec (void)
+{
+    format_t codec = -1;
+
+    /*check the codec present in the mspd_global structure*/
+    if(!mspd_global.global_phone.allowed_codecs)
+        return -1;
+
+    /*pick one of the codec mentioned in mspd.conf */
+    codec = ast_codec_choose(&(mspd_global.codec_prefs), mspd_global.global_phone.allowed_codecs, 0);
+
+    return (codec > 0 ? codec : (-1));
+}
+
+// -----------------------------------------------------------------------------------------------
+int
+sl_get_mspd_default_codec_phone (mspd_phone_t *phone)
+{
+    format_t codec = 0;
+
+    /*check the codec present in the mspd_global structure*/
+    if(!mspd_global.global_phone.allowed_codecs)
+        return MSPD_DEFAULT_CODEC;
+
+    /*pick one of the codec mentioned in mspd.conf */
+    codec = ast_codec_choose(&phone->codec_prefs, phone->allowed_codecs, 1);
+
+    return (codec == 0 ? MSPD_DEFAULT_CODEC : codec);
+}
+
+// ===============================================================================================
+// STI-event handler/consumer thread functions
+
+// -----------------------------------------------------------------------------------------------
+int
+sl_handle_incoming_call (mspd_line_t *line, struct TEMPO_EVENT_DESC const *event)
+{
+    U32 const usrid = sl_get_usrid_of_line(line);
+
+    MSPD_LOG(5, "(%s:%u/%s,%s): usrid=0x%x, linkid=0x%x, owner=%s\n",
+            line->name, line->timeslot,
+            sl_show_line_state(line), "incoming",
+            usrid, (U32) event->link_id, line->owner ? line->owner->name : "x");
+
+    if (line->owner) {
+        MSPD_WARN(2, "(%s:%u/%s,%s): line has left-over owner %s\n",
+                line->name, line->timeslot,
+                sl_show_line_state(line), "incoming", line->owner->name);
+        sl_do_ast_channel_action(line, &line->owner, mspd_hangup_ast_channel, NULL);
+        line->owner = NULL;
+    }
+
+    if (sl_get_line_state(line) != MLS_IDLE) {
+        MSPD_WARN(2, "(%s:%u/%s,%s): unexpected line state\n",
+                line->name, line->timeslot,
+                sl_show_line_state(line), "incoming");
+        sl_set_line_state (line, MLS_IDLE);      // To prevent from clearing line->timeslot
+    }
+
+    if (line->channel || line->intern_rtp) {
+    if (line->channel)
+        MSPD_WARN(2, "(%s:%u/%s,%s): line has left-over voip-channel %p\n",
+            line->name, line->timeslot,
+            sl_show_line_state(line), "incoming", line->channel);
+    if (line->intern_rtp)
+        MSPD_WARN(2, "(%s:%u/%s,%s): line has left-over intern-rtp %p\n",
+            line->name, line->timeslot,
+            sl_show_line_state(line), "incoming", line->intern_rtp);
+        sl_reset_line(line, 1);                  // Free line resources
+    }
+
+    line->link_id = event->link_id;
+    sl_set_line_state (line, MLS_OFF_HOOK);
+    line->is_call_on_hold = False;
+
+    MSPD_LOG(5,"Line %s:%u: TEMPO answer incoming call on TDM=0x%X (user_id=0x%X, link_id=0x%X)\n",
+            line->name, line->timeslot,
+            line->bus->tdm,
+            sl_get_usrid_of_line (line),
+            line->link_id);
+
+    if (tempo_answer_incoming_call(usrid, line->link_id, line->bus->tdm)) {
+    MSPD_ERR("(%s:%u/%s): tempo_answer_incoming_call has failed "
+            "(usrid=0x%x, linkid=0x%x): %s\n",
+            line->name, line->timeslot,
+            sl_show_line_state(line), usrid,
+            line->link_id, strerror(errno));
+    return 1;
+    }
+
+    return 0;
+}
+
+// -----------------------------------------------------------------------------------------------
+int
+sl_handle_fxo_incoming_call (mspd_line_t *line, struct TEMPO_EVENT_DESC const *event)
+{
+    U32 const usrid = sl_get_usrid_of_line(line);
+
+    MSPD_LOG(2, " (%s:%u/%s,%s): usrid=0x%x, linkid=0x%x, owner=%s\n",
+            line->name, line->timeslot,
+            sl_show_line_state(line), "incoming",
+            usrid, (U32) event->link_id, line->owner ? line->owner->name : "x");
+
+    if (sl_get_line_state(line) != MLS_IDLE)
+        MSPD_WARN(2, "(%s:%u/%s,%s): unexpected line state\n",
+                line->name, line->timeslot,
+                sl_show_line_state(line), "incoming");
+    if (line->channel)
+        MSPD_WARN(2, "(%s:%u/%s,%s): line has left-over voip-channel %p\n",
+                line->name, line->timeslot,
+                sl_show_line_state(line), "incoming", line->channel);
+    if (line->intern_rtp)
+        MSPD_WARN(2, "(%s:%u/%s,%s): line has left-over intern-rtp %p\n",
+                line->name, line->timeslot,
+                sl_show_line_state(line), "incoming", line->intern_rtp);
+
+    sl_reset_line(line, 1);
+    line->link_id = event->link_id;
+    sl_set_line_state(line, MLS_OFF_HOOK);
+
+    MSPD_LOG(5,"Line %s:%u: TEMPO FXO answer incoming call on TDM=0x%X (user_id=0x%X, link_id=0x%X)\n",
+            line->name, line->timeslot,
+            line->bus->tdm,
+            sl_get_usrid_of_line (line),
+            line->link_id);
+
+    if (tempo_answer_incoming_call(usrid, line->link_id, line->bus->tdm)) {
+        MSPD_ERR("(%s:%u/%s): tempo_answer_incoming_call has failed "
+                "(usrid=0x%x, linkid=0x%x): %s\n",
+                line->name, line->timeslot,
+                sl_show_line_state(line), usrid, (U32) line->link_id, strerror(errno));
+        return 1;
+    }
+    return 0;
+}
+
+// -----------------------------------------------------------------------------------------------
+int
+sl_handle_call_connected (mspd_line_t *line, struct TEMPO_EVENT_DESC const *event)
+{
+    int                  const  is_incoming = (event->type == TEMPO_EVENT_INCOMING_CALL_CONNECTED);
+    char const *         const  dir = is_incoming ? "incoming" : "outgoing";
+    mspd_line_state_t    const  expected_line_state = is_incoming ? MLS_OFF_HOOK : MLS_RINGING;
+    struct ast_channel * const  owner = line->owner;
+    mspd_channel_t *            channel = NULL;
+    int                         hangup_owner = 0;
+    int                         send_failed = 0;
+
+    if (!is_incoming)
+        line->link_id = event->link_id;
+
+     MSPD_LOG(1, "(%s:%u/%s,%s): usrid=0x%x, linkid=0x%x, owner=%s\n",
+            line->name,
+            line->timeslot,
+            sl_show_line_state(line),
+            dir,
+            sl_get_usrid_of_line(line),
+            line->link_id,
+            owner ? owner->name : "x");
+
+    if (sl_get_line_state(line) != expected_line_state) {
+        MSPD_WARN(2, "(%s:%u/%s,%s): unexpected line state (should be %s)\n",
+                line->name, line->timeslot, sl_show_line_state(line), dir,
+                sl_state2text(expected_line_state));
+        return 1;
+    }
+    if ((line->bus->tdm & BUS_MASK) == BUS_PRI) {
+        if (!is_incoming) {
+            struct ast_sockaddr src, dst;
+            struct ast_rtp_instance* rtp;
+            rtp = line->intern_rtp;
+
+            ast_rtp_instance_get_remote_address(rtp, &src);
+            ast_rtp_instance_get_local_address(rtp, &dst);
+
+            // For PRI outgoing calls (T1/E1)
+            // we have to change MSP channel's TS to obtained one from the event (Madge)
+            if (dc_set_ts_assignment(line->channel, event->line_timeslot))  return 1;
+            if (mspd_channel_set_ip_header(line->channel, &src, &dst))                return 1;
+            if (mspd_channel_bwe_manager(line->channel,
+                             line->phone->wideband,
+                             NoBand, // not applicable for VoIP
+                             &line->phone->bwe,
+                             True))                                                   return 1;
+            if (mspd_channel_configure_voip(line->channel, &line->phone->echocan))    return 1;
+        }
+    }
+    line->call_direction = 0; // uncheck OUTGOING_CALL_FLAG after usage
+
+    if (!is_incoming) {
+        if (line->channel) {
+             if (mspd_channel_cid_gen_in_progress(line->channel)) {
+                 // Stopping CID generation to avoid the noise in the phone
+                 VSTATUS status = VAPI_StopCallerId(mspd_channel_get_id(line->channel), NULL);
+                 VAPI_REPORT(status, "CND_STOP");
+             }
+        }
+        else {
+            ast_log(LOG_ERROR, MSPD_FMT"(%s:%u/%s,%s): line doesn't have any channel\n",
+                    MSPD_WHERE, line->bus->name, line->timeslot, sl_show_line_state(line), dir);
+            return 1;
+        }
+    }
+    else
+        if (is_incoming)
+            if (line->channel) {
+                MSPD_ERR("(%s:%u/%s,%s): line has unexpected channel\n",
+                        line->name, line->timeslot,
+                        sl_show_line_state(line), dir);
+                return 1;
+            }
+
+    if ((is_incoming && owner) ||
+       (!is_incoming && !owner))
+    {
+        MSPD_WARN(3, "(%s:%u/%s,%s): line should have %s owner, but is has %s\n",
+                line->name, line->timeslot,
+                sl_show_line_state(line), dir,
+                is_incoming ? "no" : "a", is_incoming ? "one" : "none");
+        return 1;
+    }
+
+    if (sl_fixup_intern_rtp(line, is_incoming, dir)) {
+        MSPD_ERR("(%s:%u,%s): fixup of intern-rtp has failed\n",
+                line->name, line->timeslot, dir);
+        return 1;
+    }
+
+
+    if (is_incoming) {
+         format_t def_codec = sl_get_mspd_default_codec();
+         format_t codec = owner ? owner->rawreadformat : def_codec;
+
+        if(codec < 0) {
+            MSPD_ERR("(%s:%u/%s,%s): voip-channel creation has failed:"
+                    "No Codec supported\n",
+                    line->name, line->timeslot,
+                    sl_show_line_state(line), dir);
+            return 1;
+        }
+
+        if ((line->bus->tdm & BUS_MASK) == BUS_DECT)
+		channel = dc_create_voiposhm_channel(line, codec);
+	else
+        channel = dc_create_voip_channel(line, codec);
+        if (!channel) {
+            MSPD_ERR("(%s:%u/%s,%s): voip-channel creation has failed\n",
+                    line->name, line->timeslot,
+                    sl_show_line_state(line), dir);
+            return 1;
+        }
+    }
+    else {
+        channel = line->channel;
+    }
+
+    if (is_incoming) {
+        if (mspd_channel_set_tone(channel, DC_TONE_DIAL))
+            send_failed = 1;
+    }
+    else
+        if (mspd_channel_start_tx(channel))
+            send_failed = 1;
+
+    if (send_failed) {
+        MSPD_ERR("(%s:%u/%s,%s): csm-msg has failed\n",
+                line->name, line->timeslot,
+                sl_show_line_state(line), dir);
+        hangup_owner = 1;
+    }
+
+    if (!hangup_owner) {
+        MSPD_LOG(5, "Line (%s:%u) chanel %s is READY FOR USAGE\n",
+                line->name, line->timeslot, mspd_channel_get_name(channel));
+
+        if (is_incoming)
+            sl_set_line_state(line, MLS_DIALING_0);
+        else {
+            sl_set_line_state(line, MLS_CONNECTED);
+
+            if (!line->owner)
+                MSPD_LOG(5, "Owner is NULL, still trying to send frame\n");
+
+                if (sl_do_ast_channel_action(line, &line->owner,
+                        (int (*)(struct ast_channel*, void*))&ast_queue_frame,
+                        &(struct ast_frame){.frametype = AST_FRAME_CONTROL,
+                                            .subclass  = {AST_CONTROL_ANSWER}}))
+                {
+                    MSPD_ERR("(%s:%u/%s): queueing answer control-frame has failed\n",
+                            line->name, line->timeslot,
+                            sl_show_line_state(line));
+                    hangup_owner = 1;
+                }
+        }
+    }//if (!hangup_owner)
+
+    return hangup_owner;
+}
+
+// -----------------------------------------------------------------------------------------------
+int
+sl_handle_disconnect_call (mspd_line_t *line, struct TEMPO_EVENT_DESC const *event)
+{
+    MSPD_LOG(1, "(%s:%u/%s): usrid=0x%x, linkid=0x%x\n",
+            line->name, line->timeslot, sl_show_line_state(line),
+            sl_get_usrid_of_line(line), line->link_id);
+
+    mspd_line_state_t state = sl_get_line_state(line);
+    if (state == MLS_DIALING_FXO) {
+        MSPD_LOG(5, "Line %s:%u: TEMPO FXO On-Hook on TDM=0x%X (user_id=0x%X, link_id=0x%X)\n",
+            line->name, line->timeslot,
+            line->bus->tdm,
+            sl_get_usrid_of_line (line),
+            line->link_id);
+        if (tempo_fxo_make_onhook(sl_get_usrid_of_line (line),
+                                  line->link_id,
+                                  0x0200))            // TODO: replace with definition
+            MSPD_ERR("%s: Error in tempo_fxo_make_onhook\n", line->name);
+    }
+    else if (state == MLS_THREEWAY) {
+        line->call_direction = 0;
+        twc_release_threeway_call(line);
+    }
+
+    sl_reset_line(line, 1);
+
+    if (line->dial_timer_id)
+        line->dial_timer_id = ast_sched_del(sched, line->dial_timer_id);
+
+    if (line->interdigit_timer_id)
+        line->interdigit_timer_id = ast_sched_del(sched, line->interdigit_timer_id);
+
+    line->interdigit_timer_id = 0;
+    line->dial_timer_id = 0;
+
+    MSPD_LOG(3, "Phone on line %s hung up\n", line->name);
+    MSPD_LOG(1, "=== Call is finished ===\n\n");
+
+    sl_set_line_state (line, MLS_IDLE);
+    if (line->phone) {
+        line->phone->bwe.is_bwe_enabled = False;
+        line->phone->line = NULL;
+        line->phone = NULL;
+    }
+
+    return 1;
+}
+
+// -----------------------------------------------------------------------------------------------
+int
+sl_handle_callerid_gen (mspd_line_t *line,
+                        struct TEMPO_EVENT_DESC const *event)
+{
+    MSPD_LOG(1, "(%s:%u/%s) Generating Caller ID\n",
+            line->name, line->timeslot, sl_show_line_state(line));
+
+    // Sending ON_HOOK caller ID
+    return mspd_channel_send_caller_id (line->channel);
+}
+
+// -----------------------------------------------------------------------------------------------
+
+void
+sl_subline_debug (mspd_line_t *line)
+{
+    mspd_subline_t *sub_real = &line->subline[SUB_REAL];
+    mspd_subline_t *sub_wait = &line->subline[SUB_CALLWAIT];
+
+    if (sub_real->subline_owner) {
+        MSPD_DBG("--- SUB_REAL: owner=%s, native=%d ---\n",
+                sub_real->subline_owner->name,
+                sub_real->is_native_bridged);
+    }
+    else
+        MSPD_DBG("--- SUB_REAL: no Ast channel\n");
+    if (sub_wait->subline_owner) {
+        MSPD_DBG("--- SUB_CALLWAIT: owner=%s, native=%d ---\n",
+                sub_wait->subline_owner->name,
+                sub_wait->is_native_bridged);
+    }
+    else
+        MSPD_DBG("--- SUB_CALLWAIT: no Ast channel\n");
+
+    if (line->intern_rtp)
+        MSPD_INFO_ABOUT_RTP (line->intern_rtp);
+}
+
+
+// -----------------------------------------------------------------------------------------------
+
+Boolean
+sl_check_bridge_mspd (struct ast_channel *bridged_channel)
+{
+    struct ast_channel *channel = NULL;
+    if (bridged_channel)
+        channel = ast_bridged_channel(bridged_channel);
+    if (channel) {
+        MSPD_DBG ("Bridged channel %s\n", channel->name);
+        if (strstr (channel->name, "MSPD"))
+            return True;
+        else
+            return False;
+    }
+    else
+        return False;
+}
+
+// -----------------------------------------------------------------------------------------------
+
+int
+sl_handle_flash (mspd_line_t *line, struct TEMPO_EVENT_DESC const *event)
+{
+    mspd_subline_t *sub_real = &line->subline[SUB_REAL];
+    mspd_subline_t *sub_wait = &line->subline[SUB_CALLWAIT];
+    struct ast_channel *hold_bridged_channel = NULL;
+    struct ast_channel *new_incoming_channel = NULL;
+    struct ast_sockaddr src, dst;
+
+    MSPD_LOG(3, "Flash on line %s:%u, state=%s, owner=%s\n",
+            line->name, line->timeslot,
+            sl_show_line_state(line),
+            line->owner ? line->owner->name : "no");
+
+    /* flash event will come in two states MLS_WAIT_FOR_FLASH or MLS_FLASHED */
+    switch(sl_get_line_state(line)) {
+        case MLS_FLASHED:
+            if (!sub_wait->subline_owner) {
+                MSPD_LOG(1, "FLASH pressed without any call wait\"\n");
+                break;
+            }
+
+            if (mspd_global.flash_mode == THREEWAYCALL) {
+                if (line->call_direction != MSPD_FLAG_CALL_WAITING) {
+                    if (sub_real->subline_owner && ast_bridged_channel (sub_real->subline_owner) &&
+                        sub_wait->subline_owner && ast_bridged_channel (sub_wait->subline_owner)) {
+                            if (twc_make_threeway_call(line) == OK)
+                                return 0;
+
+                            // if error detected, perform switch scenario
+                            MSPD_WARN(1, "Three-way call failed - switch back\n");
+                    }
+                }
+            }
+
+        case MLS_WAIT_FOR_FLASH:
+        case MLS_CALL_PROCEEDING:
+        case MLS_DIALING_0:
+            if (!sub_wait->subline_owner) {
+                MSPD_LOG(1, "FLASH pressed without any call wait\"\n");
+                break;
+            }
+
+            sl_swap_sublines(line);
+            ast_rtp_instance_get_remote_address(line->intern_rtp, &src);
+            ast_rtp_instance_get_local_address(line->intern_rtp, &dst);
+            mspd_channel_set_ip_header(line->channel, &src, &dst);
+            /* We need to restore a codec.
+             * For example first we called SIP party A with G.729,
+             * and then switched to FXS/SIP party B with G.711. 
+             * When switching back to party A we need to restore a codec which was used there.
+             */
+            mspd_channel_enable(line->channel, sub_real->subline_owner->rawreadformat);
+
+            /* get the corrsponding bridged channel*/
+            if (sub_wait->subline_owner)
+                hold_bridged_channel = ast_bridged_channel (sub_wait->subline_owner);
+            if (sub_real->subline_owner)
+                new_incoming_channel = ast_bridged_channel (sub_real->subline_owner);
+
+            if (hold_bridged_channel) {
+                line->is_call_on_hold = True;
+                mspd_channel_set_tone(line->channel, DC_TONE_OFF);
+
+                /* Notifying bridged channel to hold */
+                ast_indicate(hold_bridged_channel, AST_CONTROL_HOLD);
+
+                // SIP Channel has to handle AST_CONTROL_HOLD and play MOH by itlsef
+                // MSPD Channel does not need MOH, since we use DC_TONE_HOLD
+                // if (!sl_check_bridge_mspd(sub_wait->subline_owner))
+                //    ast_moh_start(hold_bridged_channel, NULL);
+
+                /* set state of ast channel */
+                ast_setstate (sub_real->subline_owner, AST_STATE_FLASHED);
+            }
+            else {
+                if (sub_wait->subline_owner) {
+                    sl_do_ast_channel_action(line, &sub_wait->subline_owner, mspd_hangup_ast_channel, NULL);
+                    sub_wait->subline_owner = NULL;
+                }
+            }
+
+            /* change the state to flashed */
+            ast_setstate (line->owner, AST_STATE_FLASHED);
+            sl_set_line_state (line, MLS_FLASHED);
+
+            if(new_incoming_channel) {
+                /* Indicate the party on hold that we are ready to continue call       */
+                /* SIP Channel has to handle AST_CONTROL_UNHOLD and stop MOH by itlsef */
+                //if (!sl_check_bridge_mspd(sub_wait->subline_owner))
+                //    ast_moh_stop(new_incoming_channel);
+                if (line->is_call_on_hold) {
+                    if (!hold_bridged_channel)
+                        sl_set_line_state (line, MLS_CONNECTED);
+                    else
+                        sl_set_line_state (line, MLS_FLASHED);
+                    line->is_call_on_hold = False;
+                    mspd_channel_set_tone (line->channel, DC_TONE_OFF);
+                    mspd_channel_start_tx (line->channel);
+                }
+                else
+                {
+                    sl_set_line_state (line, MLS_CONNECTED);
+                    mspd_channel_set_tone (line->channel, DC_TONE_OFF);
+                    mspd_channel_start_tx (line->channel);
+                }
+                /* Notifying bridged channel to unhold */
+                ast_indicate(new_incoming_channel, AST_CONTROL_UNHOLD);
+            }
+
+            /* start action for new voice call with new channel */
+            if (sl_do_ast_channel_action(line, &line->owner,
+                    (int (*)(struct ast_channel*, void*))&ast_queue_frame,
+                    &(struct ast_frame){.frametype = AST_FRAME_CONTROL,
+                                        .subclass = {AST_CONTROL_ANSWER}}))
+            {
+                MSPD_ERR("(%s:%u/%s,%s): queueing answer control-frame has failed\n",
+                        line->name, line->timeslot,
+                        sl_show_line_state(line), "POTS");
+            }
+        break;
+
+        case MLS_CONNECTED:
+            if (!(line->owner)) {
+                MSPD_ERR("Line owner is NULL, not handling flash\n");
+                break;
+            }
+
+            /* If flash pressed for the first time while conversation then we will hold the
+             * existing user and should give dial tone and start up a new call
+             */
+            hold_bridged_channel = ast_bridged_channel(sub_real->subline_owner);
+
+            if (!hold_bridged_channel) {
+                MSPD_ERR("Channel is not in the bridge \n");
+                break;
+            }
+
+            /* Notifying bridged channel to hold */
+            ast_indicate(hold_bridged_channel, AST_CONTROL_HOLD);
+            /* MSPD Channel does not need MOH, since we use DC_TONE_HOLD */
+            // if (!sl_check_bridge_mspd(sub_wait->subline_owner))
+            //    ast_moh_start(hold_bridged_channel, NULL);
+
+            mspd_channel_set_tone(line->channel, DC_TONE_DIAL);
+            mspd_channel_stop_tx (line->channel);
+
+            /* allocate new RTP for new subline, swap sublines and update MSP channel */
+            if (!line->subline[SUB_CALLWAIT].rtp)
+                line->subline[SUB_CALLWAIT].rtp = mspd_rtp_allocate_new (line->bus->dev);
+            sl_swap_sublines(line);
+            ast_rtp_instance_get_remote_address(line->intern_rtp, &src);
+            ast_rtp_instance_get_local_address(line->intern_rtp, &dst);
+            mspd_channel_set_ip_header(line->channel, &src, &dst);
+
+            sl_set_line_state (line, MLS_DIALING_0);
+            line->dialed[0] = '\0';
+            line->is_call_on_hold = True;
+        break;
+
+        case MLS_DISCONNECTING:
+            if (!sub_wait->subline_owner) {
+                MSPD_LOG(1, "FLASH pressed without any call wait\"\n");
+                break;
+            }
+
+            sl_swap_sublines(line);
+            if (sub_real->subline_owner) {
+                new_incoming_channel = ast_bridged_channel(sub_real->subline_owner);
+                ast_indicate(new_incoming_channel, AST_CONTROL_UNHOLD);
+            }
+
+            sl_set_line_state (line, MLS_CONNECTED);
+            line->is_call_on_hold = False;
+
+            mspd_channel_set_tone (line->channel, DC_TONE_OFF);
+            mspd_channel_start_tx (line->channel);
+        break;
+
+        default:
+            /* dont handle the flash */
+            MSPD_LOG(3, "%s:%u/%s NOT handling FLASH\n",
+                    line->name, line->timeslot,
+                    sl_show_line_state(line));
+    } //end of switch
+
+    return 0;
+}
+
+// -----------------------------------------------------------------------------------------------
+void
+sl_swap_sublines (struct mspd_line_t *line)
+{
+    struct ast_channel *tmp_owner;
+    U16 tmp_bridged;
+    struct ast_rtp_instance *tmp_rtp;
+
+    MSPD_DBG("Swapping SUB_REAL and SUB_CALLWAIT\n");
+
+    tmp_owner   = line->subline[SUB_REAL].subline_owner;
+    tmp_bridged = line->subline[SUB_REAL].is_native_bridged;
+    tmp_rtp     = line->subline[SUB_REAL].rtp;
+
+    line->subline[SUB_REAL].subline_owner     = line->subline[SUB_CALLWAIT].subline_owner;
+    line->subline[SUB_REAL].is_native_bridged = line->subline[SUB_CALLWAIT].is_native_bridged;
+    line->subline[SUB_REAL].rtp               = line->subline[SUB_CALLWAIT].rtp;
+
+    line->owner             = line->subline[SUB_REAL].subline_owner;
+    line->is_native_bridged = line->subline[SUB_REAL].is_native_bridged;
+    line->intern_rtp        = line->subline[SUB_REAL].rtp;
+
+    line->subline[SUB_CALLWAIT].subline_owner     = tmp_owner;
+    line->subline[SUB_CALLWAIT].is_native_bridged = tmp_bridged;
+    line->subline[SUB_CALLWAIT].rtp = tmp_rtp;
+}
+
+// -----------------------------------------------------------------------------------------------
+void
+sl_clear_subline (struct mspd_line_t *line, int sub)
+{
+    line->subline[sub].subline_owner     = NULL;
+    line->subline[sub].is_native_bridged = 0;
+
+    if (line->subline[sub].rtp)
+        ast_rtp_instance_destroy(line->subline[sub].rtp);
+    line->subline[sub].rtp               = NULL;
+}
+
+
+//-----------------------------------------------------------------------------------------------
+// added for stop dial tone when no digit is pressed
+
+int
+handle_dialed_number (mspd_line_t *line)
+{
+    mspd_channel_t * channel = NULL ;
+
+    channel = line->channel;
+    MSPD_LOG(2, "%s/%s/%s dialed [%s]\n",
+            line->name,
+            line->channel ? mspd_channel_get_name(line->channel) : "NULL_CHANNEL",
+            line->phone   ? line->phone->name   : "NULL_PHONE",
+            line->dialed);
+
+    int ans = ast_canmatch_extension(NULL,
+                                    line->phone->context,
+                                    line->dialed,
+                                    1,
+                                    line->phone->callerid);
+    if (ans || !strcmp(line->dialed, ast_pickup_ext())) {
+        char cid_name[80];
+        char cid_num[80];
+        ast_callerid_split(line->phone->callerid, cid_name,
+            sizeof(cid_name), cid_num, sizeof(cid_num));
+        if (!strcmp(cid_num, line->dialed)) {
+	    MSPD_LOG(1, "Cannot call self\n");
+	    goto ERR;
+        }
+
+        int cause = 0;
+        format_t format = 0;
+
+        if (mspd_channel_get_passthru_mode(line->channel))
+	    /* This case is possible if we already went to FPT mode
+	     * (fax auto dialing machine).
+	     * In this case it's preferrable to create Asterisk channel in ULAW from the beginning,
+	     * rather then relying on switch to ULAW on first ULAW frame which is done
+	     * in mspd_read(). It's preferrable because in this case we'll send ULAW as the most preferred codec
+	     * when dialed extension is SIP.
+	     */
+#if MSPD_PCM_DEFAULT_IS_ALAW
+            format = MSPD_DEFAULT_G711;
+#else
+            format = AST_FORMAT_ULAW;
+#endif
+
+        else
+            format = mspd_channel_get_format(line->channel);
+
+        struct ast_channel * const
+        ast = mspd_new_ast_channel (line,
+                                    format,
+                                    0,
+                                    &cause,
+                                    MSPD_SLIC_TYPE_FXS,
+                                    (char *) mspd_chan_id, NULL);
+
+        if (!ast) {
+	    MSPD_ERR("(%s/%s): failed to get new Ast-channel\n",
+		    line->name, sl_show_line_state(line));
+	    goto ERR;
+        }
+    }
+    else {
+        if (!ans && strncmp(line->dialed, ast_pickup_ext(), strlen(line->dialed))) {
+	    MSPD_LOG(3,"(%s/%s): number can never match in context '%s' dialed so far [%s]\n",
+		    line->name, sl_show_line_state(line),
+		    line->phone->context, line->dialed);
+	    goto ERR;
+        }
+    }
+
+    return 0;
+
+ERR:
+    if (line->phone->is_mapped_trunk) {
+	MSPD_LOG(3, "Disconnecting %s\n", line->name);
+	MSPD_LOG(5,"Line %s:%u: TEMPO FXO Disconnect call on TDM=0x%X (user_id=0x%X, link_id=0x%X)\n",
+	    line->name, line->timeslot,
+	    line->bus->tdm,
+	    sl_get_usrid_of_line (line),
+	    line->link_id);
+
+	if (tempo_disconnect_call(sl_get_usrid_of_line (line),
+				  line->link_id,
+				  0x0200)) // TODO: use define
+	    MSPD_ERR("%s:Error in tempo_disconnect_call\n", line->name);
+	sl_reset_line(line, 1);
+	sl_set_line_state(line, MLS_IDLE);
+    } else {
+	/*
+	 * If we were in call-with-hold state, don't go to disconnect, wait for flash
+	 * instead
+	 */
+	if (line->subline[SUB_CALLWAIT].subline_owner)
+	    sl_set_line_state(line, MLS_WAIT_FOR_FLASH);
+	else
+	    sl_set_line_state(line, MLS_DISCONNECTING);
+
+	if (mspd_channel_set_tone(channel, DC_TONE_BUSY))
+	    MSPD_ERR("(%s/%s): csm-msg has failed\n", line->name, sl_show_line_state(line));
+    }
+
+    return -1;
+}
+
+//-----------------------------------------------------------------------------------------------
+static int
+dialtimeout (const void *data)
+{
+    mspd_line_t *line = (mspd_line_t*) data;
+    if (!line->phone) return -1;
+
+    MSPD_LOCK(line->lock, return 1);
+    MSPD_LOG(5, "Line %s:%u/%s timer_id=%d\n",
+                line->name, line->timeslot,
+                sl_show_line_state(line), line->dial_timer_id);
+
+    if (sl_get_line_state(line) == MLS_DIALING)
+        handle_dialed_number(line);
+    else {
+        if (!line->is_call_on_hold)
+            sl_set_line_state(line, MLS_DISCONNECTING);
+        else
+            sl_set_line_state(line, MLS_WAIT_FOR_FLASH);
+
+        if (line->phone->is_mapped_trunk) {
+            MSPD_LOG(5,"Line %s:%u: TEMPO FXO On-Hook on TDM=0x%X (user_id=0x%X, link_id=0x%X)\n",
+                    line->name, line->timeslot,
+                    line->bus->tdm,
+                    sl_get_usrid_of_line (line),
+                    line->link_id);
+            if (tempo_fxo_make_onhook(sl_get_usrid_of_line (line),
+                                      line->link_id,
+                                      0x0200)) // TODO: use define
+                MSPD_ERR("%s: error in tempo_fxo_make_onhook\n", line->name);
+            sl_reset_line(line, 1);
+            sl_set_line_state (line, MLS_IDLE);
+        }
+        else {
+            if (mspd_channel_set_tone(line->channel, DC_TONE_BUSY))
+                MSPD_ERR("%s: error in setting busy-tone\n", line->name);
+            if (!line->is_call_on_hold)
+                sl_reset_line(line, 0);
+        }
+    }
+    line->dial_timer_id = 0;
+    MSPD_UNLOCK(line->lock);
+    return 0;
+}
+
+// -----------------------------------------------------------------------------------------------
+// dispatch STI-event to sub-handlers
+void
+sl_handle_event (mspd_line_t *line, struct TEMPO_EVENT_DESC const *event)
+{
+    int hangup_owner = 1;
+
+    MSPD_LOCK(line->lock, return);
+    switch (event->type) {
+        case TEMPO_EVENT_INCOMING_CALL:
+	    if (!line->phone->is_mapped_trunk)
+                hangup_owner = sl_handle_incoming_call(line, event);
+	    else
+	         hangup_owner = sl_handle_fxo_incoming_call(line, event);
+        break;
+        case TEMPO_EVENT_OUTGOING_CALL_CONNECTED:
+        case TEMPO_EVENT_INCOMING_CALL_CONNECTED:
+            hangup_owner = sl_handle_call_connected(line, event);
+        break;
+        case TEMPO_EVENT_DISCONNECT_CALL:
+            hangup_owner = sl_handle_disconnect_call(line, event);
+        break;
+
+        case TEMPO_EVENT_FLASH:
+            hangup_owner = sl_handle_flash (line, event);
+        break;
+
+        case TEMPO_EVENT_CALLERID_GEN:
+            hangup_owner = sl_handle_callerid_gen (line, event);
+        break;
+
+        case TEMPO_EVENT_DIGIT:
+        {
+            char* i;
+            for (i = (char *)event->called_number; *i != '\0'; i++) {
+                hangup_owner = mspd_line_handle_digit (line, *i);
+                if (hangup_owner)
+                    break;
+            }
+        }
+        break;
+
+        default:
+            hangup_owner = 0;
+            MSPD_WARN(1, "(%s:%u/%s): unhandled event %s/%d "
+                    "(tdm=%04x:%u, usrid=0x%x, linkid=0x%x)\n",
+                    line->name, line->timeslot,
+                    sl_show_line_state(line), sl_event_type2text(event->type),
+                    event->type, event->line_tdm, event->line_timeslot,
+                    (U32) event->usr_id, (U32) event->link_id);
+    }
+
+    if (hangup_owner && line->owner) {
+        MSPD_LOG(1, "(%s:%u/%s): hanging up Ast-channel %s\n",
+                line->name, line->timeslot,
+                sl_show_line_state(line), line->owner->name);
+
+        if (sl_do_ast_channel_action(line, &line->owner, mspd_hangup_ast_channel, NULL))
+            MSPD_ERR("(%s:%u/%s): hanging up owner has failed\n",
+                    line->name, line->timeslot, sl_show_line_state(line));
+        else
+            MSPD_LOG(5, "%s:%u/%s): Sent hang up to the line's owner\n",
+                    line->name, line->timeslot, sl_show_line_state(line));
+    }
+
+    /*
+         * If we were having another party on hold, we have to indicate hangup to hold party too!
+         */
+    if (hangup_owner && line->subline[SUB_CALLWAIT].subline_owner) {
+        /* Do switch to hold party. Just to make things logical */
+        sl_swap_sublines(line);
+
+        MSPD_LOG(1, "(%s:%u/%s): hanging up *-subline-channel %s\n",
+                line->name, line->timeslot,
+                sl_show_line_state(line), line->owner->name);
+
+        if (sl_do_ast_channel_action(line, &line->owner, mspd_hangup_ast_channel, NULL))
+            MSPD_ERR("(%s:%u/%s): hanging up owner has failed\n",
+                    line->name, line->timeslot, sl_show_line_state(line));
+        else
+            MSPD_LOG(5, "%s:%u/%s): Sent hang up to the subline's owner\n",
+                    line->name, line->timeslot, sl_show_line_state(line));
+    }
+
+/*
+ * for stopping dial tone when no digit is pressed
+ */
+
+    if (sl_get_line_state(line) == MLS_DIALING_0) {
+        if (!line->dial_timer_id) {
+            line->dial_timer_id = ast_sched_add(sched,
+                                                mspd_global.dial_timeout,
+                                                dialtimeout,
+                                                (void*) line);
+            MSPD_LOG(5, "Line %s:%u Dialing Timer started (%d msec), "
+                        "Waiting for digits to dialled, dial_timer_id=%d\n",
+                        line->name, line->timeslot,
+                        mspd_global.dial_timeout, line->dial_timer_id);
+        }
+    }
+    else {
+        if (line->dial_timer_id) {
+            MSPD_LOG(5, "Line %s:%u STOPPING Dialing Timer(%d msec), "
+                    "Waiting for digits to dialled, dial_timer_id=%d\n",
+                    line->name, line->timeslot,
+                    mspd_global.dial_timeout, line->dial_timer_id);
+            line->dial_timer_id = ast_sched_del(sched, line->dial_timer_id);
+            line->dial_timer_id = 0;
+        }
+    }
+
+    MSPD_UNLOCK(line->lock);
+
+    MSPD_LOG(5, "--- Event %s handled ---\n", sl_event_type2text(event->type));
+
+}
+
+// -----------------------------------------------------------------------------------------------
+// STI-event handler/consumer thread-function.
+void *
+sl_consumer (void *data)
+{
+    mspd_line_t *         	line = data;
+    queue_t *             	queue = line->queue;
+    struct TEMPO_EVENT_DESC *event;
+
+    MSPD_LOG(1, "(%s:%u/%s): SL Consumer thread started\n",
+                line->name, line->timeslot,
+                sl_show_line_state(line));
+
+    if (pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL)) {
+        MSPD_ERR("(%s:%u): unable to disable thread's cancelability, shutting down\n",
+                line->name, line->timeslot);
+
+        while ((void *) (event = (struct TEMPO_EVENT_DESC *) mspd_queue_get_tempo(queue)) != QUEUE_STOP_ITEM.tempo)
+            if (event && (void *) event != QUEUE_START_ITEM.tempo)
+                free(event);
+        goto stop_thread;
+    }
+
+    while(1) {
+        event = (struct TEMPO_EVENT_DESC *) mspd_queue_get_tempo(queue);
+        if ((void *) event == QUEUE_STOP_ITEM.tempo)
+            break;
+        if (!event || (void *) event == QUEUE_START_ITEM.tempo) {
+            MSPD_ERR("(%s:%u/%s): got %s from queue\n", line->name, line->timeslot,
+                    sl_show_line_state(line), event ? "QUEUE_START_ITEM" : "NULL");
+            continue;
+        }
+        if (option_verbose > 2) {
+            char buf [256];
+            term_color(buf, sl_event_type2text(event->type),COLOR_YELLOW, 0, sizeof (buf));
+            MSPD_LOG(3, "(%s:%u/%s): event %s\n", line->name, line->timeslot,
+                        sl_show_line_state(line), buf);
+        }
+        sl_handle_event(line, event);
+        free(event);
+    }
+
+stop_thread:
+    MSPD_LOG(1, "(%s:%u/%s): SL consumer thread stopped\n",
+                line->name, line->timeslot, sl_show_line_state(line));
+
+    return NULL;
+}
+
+// -----------------------------------------------------------------------------------------------
+U16
+sl_get_free_line_num (mspd_bus_t *bus)
+{
+    U16 num = 0;
+    do {
+        if (bus->lines[num].timeslot == MAX_TIMESLOT_NUMBER) {
+            return num;
+        }
+    } while (++num < bus->n_lines);
+
+    return MAX_LINE_NUMBER;
+}
+
+// -----------------------------------------------------------------------------------------------
+U16
+sl_get_line_num_by_ts (mspd_bus_t *bus, U16 ts)
+{
+
+    U16 num = 0;
+    do {
+        if (bus->lines[num].timeslot == ts) {
+            return num;
+        }
+    } while (++num < bus->n_lines);
+    return MAX_LINE_NUMBER;
+}
+
+// -----------------------------------------------------------------------------------------------
+
+mspd_line_state_t
+sl_get_line_state (mspd_line_t *line)
+{
+    MSPD_DBG("Line %s: state = %s\n",
+            line->name, sl_show_line_state(line));
+    return line->state;
+}
+
+// -----------------------------------------------------------------------------------------------
+
+void
+sl_set_line_state (mspd_line_t *line, mspd_line_state_t new_state)
+{
+    MSPD_DBG("Line %s: state = %s --> %s\n",
+            line->name, sl_show_line_state(line), sl_state2text (new_state));
+    line->state = new_state;
+}
+
+// -----------------------------------------------------------------------------------------------
+
+Boolean
+sl_get_call_wait (mspd_line_t *line) {
+    MSPD_DBG("Line %s: call wait = %s\n",
+            line->name,
+            line->is_call_wait ? "yes" : "no");
+
+    return line->is_call_wait;
+}
+
+// -----------------------------------------------------------------------------------------------
+
+void
+sl_set_call_wait (mspd_line_t *line, Boolean new_state) {
+    MSPD_DBG("Line %s: call wait = %s --> %s\n",
+            line->name,
+            line->is_call_wait ? "yes" : "no",
+            new_state          ? "yes" : "no");
+
+    line->is_call_wait = new_state;
+}
+
+
+// -----------------------------------------------------------------------------------------------
+
+Boolean
+sl_get_line_hold_call (mspd_line_t *line) {
+    MSPD_DBG("Line %s: hold call = %s\n",
+            line->name,
+            line->is_call_on_hold ? "yes" : "no");
+
+    return line->is_call_on_hold;
+}
+
+// -----------------------------------------------------------------------------------------------
+
+void
+sl_set_line_hold_call (mspd_line_t *line, Boolean new_state) {
+    MSPD_DBG("Line %s: hold call = %s --> %s\n",
+            line->name,
+            line->is_call_on_hold ? "yes" : "no",
+            new_state            ? "yes" : "no");
+
+    line->is_call_on_hold = new_state;
+}
+
+
+// -----------------------------------------------------------------------------------------------
+void
+onhook_event (union sigval value)
+{
+    struct TEMPO_EVENT_DESC *event = *(struct TEMPO_EVENT_DESC **)value.sival_int;
+    queue_t *queue;
+    uint timeslot;
+    uint line_number;
+    mspd_bus_t *bus;
+    struct mspd_line_t *line;
+    U32 i = sl_usrid2bus(event->usr_id);
+
+    MSPD_LOG(3, "Inside on-hook event timer (%#x)\n", (U32) event);
+
+    if (event->type != TEMPO_EVENT_DISCONNECT_CALL) {
+        MSPD_ERR("Unexpected event %s in on-hook hdlr\n",
+                sl_event_type2text(event->type));
+    }
+
+    timeslot = sl_usrid2timeslot(event->usr_id);
+    if (i >= mspd_global.n_buses) {
+        MSPD_ERR("Invalid usrid=0x%x for event %s (tdm=%04x:%u, linkid=0x%x)\n",
+                (U32) event->usr_id, sl_event_type2text(event->type),
+                event->line_tdm, event->line_timeslot, (U32) event->link_id);
+        return;
+    }
+    bus = &mspd_global.buses[i];
+
+    line_number = sl_get_line_num_by_ts(bus, timeslot);
+    if (line_number == MAX_LINE_NUMBER) {
+        MSPD_ERR("No free lines on the %s bus\n", bus->name);
+        return;
+    }
+    line = &bus->lines[line_number];
+    queue = line->queue;
+    MSPD_LOG(2, "Line %s:%u has been found\n", line->name, line->timeslot);
+    MSPD_LOG(3, "Event %s for line %s:%u (linkid=0x%x)\n",
+            sl_event_type2text(event->type),
+            line->name, line->timeslot, (U32) event->link_id);
+
+    if (queue->n_items >= queue->queue_size) {
+        MSPD_ERR("Line-queue is full -> dropping event %s for line %s:%u\n",
+                sl_event_type2text(event->type), line->name, line->timeslot);
+        return;
+    }
+    if (mspd_queue_put(queue, (queue_item_t){.tempo = (tempo_queue_element_t *) event})) {
+        MSPD_ERR("Queue-add has failed -> dropping event %s for line %s:%u\n",
+                sl_event_type2text(event->type), line->name, line->timeslot);
+        return;
+    }
+    line->is_timer_started = False;
+    *(struct TEMPO_EVENT_DESC **)value.sival_int = NULL;
+}
+
+// ===============================================================================================
+// STI-event reader/producer thread-function.
+#define FLASH_TIME_MSEC    1000
+
+void *
+sl_producer (void *data)
+{
+    struct TEMPO_EVENT_DESC *event = NULL;
+    queue_t *queue;
+    uint timeslot;
+    uint i;
+    mspd_bus_t *bus;
+    mspd_phone_t *phone;
+    struct mspd_line_t *line;
+    uint line_number;
+    int rc;
+
+    MSPD_LOG(1, "SL Producer started\n");
+
+    if (pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL)) {
+        MSPD_ERR("Unable to disable thread's cancelability\n");
+        return NULL;
+    }
+
+    while(1) {
+        if (!event) {
+            event = malloc(sizeof(*event));
+            if (!event) {
+                MSPD_ERR("out of memory\n");
+                break;
+            }
+        }
+        if ((rc = tempo_read_event(event)) != 0) {
+            if (option_verbose > 5)
+                MSPD_WARN(5, "read-event has failed: %d\n", rc);
+
+            break;
+        }
+        else
+            MSPD_LOG(5, "=== Got new TEMPO event ===\n");
+
+        if (event->type == TEMPO_EVENT_INCOMING_CALL) {
+            bus = NULL;
+            for (i = 0, bus = mspd_global.buses;
+                i < mspd_global.n_buses && bus->tdm != event->line_tdm;
+                ++i, ++bus)  // Searching the bus an event belongs to
+            ;
+
+            if (!bus) {
+                MSPD_ERR("No TDM-bus matches event %s with tdm=%04x:%u\n",
+                        sl_event_type2text(event->type),
+                        event->line_tdm, event->line_timeslot);
+                continue;
+            }
+            timeslot = event->line_timeslot;
+            line_number = sl_get_free_line_num(bus);
+            if (line_number == MAX_LINE_NUMBER) {
+                MSPD_LOG(3, "No free lines on the %s bus\n", bus->name);
+                continue;
+            }
+            line = &bus->lines[line_number];
+
+            for (i = 0, phone = mspd_global.phones; i < mspd_global.n_phones; ++i, ++phone)
+                if (phone->timeslot == timeslot) {
+                    line->phone = phone;
+                    line->phone->line = line;
+                    line->call_groups = phone->call_groups;
+                    line->pickup_groups = phone->pickup_groups;
+                    line->timeslot = timeslot;
+                    line->t38state = (mspd_global_get_fax_mode() == MSPD_FAXMODE_PASSTHRU) ? T38_STATE_UNAVAILABLE : T38_STATE_UNKNOWN;
+                    MSPD_LOG(5, "Line %s:%u has been assigned\n", line->name, line->timeslot);
+                    break;
+                }
+
+            if(!line->phone) {
+                MSPD_ERR("We could not find a phone with TS %d\n", timeslot);
+                continue;
+            }
+        }
+        else {
+            i = sl_usrid2bus(event->usr_id);
+            timeslot = sl_usrid2timeslot(event->usr_id);
+
+            if (i >= mspd_global.n_buses) {
+                 MSPD_ERR("Invalid usrid=0x%x for event %s (tdm=%04x:%u, linkid=0x%x)\n",
+                        (U32) event->usr_id, sl_event_type2text(event->type),
+                        event->line_tdm, event->line_timeslot, (U32) event->link_id);
+                continue;
+            }
+            bus = &mspd_global.buses[i];
+            line_number = sl_get_line_num_by_ts(bus, timeslot);
+            if (line_number == MAX_LINE_NUMBER) {
+                MSPD_LOG(3, "No free lines on the %s bus\n", bus->name);
+                continue;
+            }
+            line = &bus->lines[line_number];
+            MSPD_LOG(3, "Line %s:%u has been found\n", line->name, line->timeslot);
+        }
+
+        /*
+         * TODO - We will have to handle is_timer_started with line level
+         *        lock to avoid race condition in FLASH detection with
+         *        onhook_event handler.
+         */
+
+        if ((event->type != TEMPO_EVENT_DISCONNECT_CALL) &&
+            line->is_timer_started)
+        {
+            //ast_log(LOG_NOTICE, MSPD_FMT": ##### treating as FLASH (%d)\n",
+            //        MSPD_WHERE, line->is_timer_started);
+
+            MSPD_LOG(5, "Treating TEMPO_EVENT_DISCONNECT_CALL as FLASH (%d)\n",
+                    line->is_timer_started);
+
+            struct itimerspec timeout;
+            memset (&timeout, 0, sizeof (timeout));
+
+            timer_settime (line->flash_timer,
+                            !TIMER_ABSTIME,
+                            &timeout,
+                            NULL);
+            line->is_timer_started = False;
+            line->is_flash_probe_on = True;
+        }
+
+        if (event->type == TEMPO_EVENT_INCOMING_CALL) {
+            if (line->is_flash_probe_on) {
+                U32 usrid = sl_get_usrid_of_line(line);
+                MSPD_LOG(5, "=== NOT clearing up FLASH flag on 1st entry ===\n");
+                MSPD_LOG(5,"Line %s:%u: TEMPO answer incoming call on TDM=0x%X (user_id=0x%X, link_id=0x%X)\n",
+                        line->name, line->timeslot,
+                        line->bus->tdm,
+                        sl_get_usrid_of_line (line),
+                        line->link_id);
+
+                if (tempo_answer_incoming_call(usrid, event->link_id, line->bus->tdm))
+                    MSPD_ERR("*** tempo_answer_incoming_call has failed ");
+
+                //is_flash_probe_on = False;
+                continue;
+            }
+        }
+        else
+
+        if (line->is_flash_probe_on) {
+            MSPD_LOG(5, "=== Clearing up FLASH flag on 2nd entry ===\n");
+            line->is_flash_probe_on = False;
+            event->type = TEMPO_EVENT_FLASH;
+        }
+
+        char buf [256];
+        term_color(buf, sl_event_type2text(event->type),COLOR_YELLOW, 0, sizeof (buf));
+
+        queue = line->queue;
+        if (queue->n_items >= queue->queue_size) {
+             MSPD_ERR("Line-queue is full -> dropping event %s for line %s:%u\n",
+                    buf, line->name, timeslot);
+            continue;
+        }
+        if (mspd_queue_put(queue, (queue_item_t){.tempo = (tempo_queue_element_t *) event})) {
+            MSPD_ERR("Queue-add has failed -> dropping event %s for line %s:%u\n",
+                    buf, line->name, timeslot);
+            continue;
+        }
+        else {
+            MSPD_LOG(3, "Event %s put in the queue %s:%u queue\n",
+                    buf, line->name, timeslot);
+        }
+        event = NULL;
+    }
+
+    if (event)
+        free(event);
+
+    MSPD_LOG(1, "SL producer thread stopped\n");
+
+    return NULL;
+}
+
+// ================================================================================================
+// global functions for startup, line initialization and shutdown
+// -----------------------------------------------------------------------------------------------
+int
+sl_init_lines_of_bus (mspd_bus_t *bus)
+{
+    uint i;
+    mspd_line_t *lines;
+    mspd_line_t *line;
+
+    MSPD_LOG(1, "Initializing lines on %s bus\n", bus->name);
+
+    if (!bus->n_lines) {
+        MSPD_ERR("TDM-bus %s has no lines\n", bus->name);
+        return 1;
+    }
+    if (bus->n_lines > MAX_N_LINES_PER_BUS) {
+        MSPD_ERR("TDM-bus %s has too much lines\n", bus->name);
+        return 1;
+    }
+    if (bus->lines) {
+        MSPD_ERR("Lines of TDM-bus %s were already initialized\n", bus->name);
+        return 1;
+    }
+
+    lines = calloc(bus->n_lines, sizeof(*lines));
+    if (!lines) {
+        MSPD_ERR("Out of memory while allocating %u lines "
+                "for TDM-bus %s\n", bus->n_lines, bus->name);
+        return 1;
+    }
+    bus->lines = lines;
+    for (i = 0; i < bus->n_lines; ++i) {
+        line = bus->lines + i;
+        line->name = mspd_asprintf("%s_line%u", bus->name, i);
+        line->timeslot = MAX_TIMESLOT_NUMBER;
+        line->bus = bus;
+        line->call_groups = bus->call_groups;
+        line->pickup_groups = bus->pickup_groups;
+        line->consumer = AST_PTHREADT_NULL;
+        ast_mutex_init(&(line->lock));
+        sl_set_line_state(line, MLS_IDLE);
+        MSPD_LOG(3, " Line %s at bus %s started with state %s\n",
+                 line->name, bus->name, sl_show_line_state(line));
+    }
+    for (i = 0; i < bus->n_lines; ++i) {
+        line = bus->lines + i;
+        line->queue = mspd_queue_create(QUEUESIZE);
+        if (!line->queue) {
+            MSPD_ERR("Out of memory while allocating queue "
+                    "for line %u of TDM-bus %s\n", i, bus->name);
+            goto clean_up_and_exit;
+        }
+
+        line->ptr_holder = malloc (sizeof (struct TEMPO_EVENT_DESC*));
+
+        struct sigevent sig;
+        memset (&sig, 0, sizeof (sig));
+        sig.sigev_notify = SIGEV_THREAD;
+        sig.sigev_signo = 0;                                     // not used
+        sig.sigev_value.sival_int = (int) line->ptr_holder;
+        sig.sigev_notify_function = onhook_event;
+        line->is_timer_started = False;
+
+        int res = timer_create(CLOCK_REALTIME, &sig, &(line->flash_timer));
+        if (res < 0)
+            if (option_verbose > 6)
+                MSPD_ERR("Unable create timer for flash (%d)\n", res);
+
+        if (ast_pthread_create(&(line->consumer), NULL, sl_consumer, line) < 0) {
+            MSPD_ERR("Unable to start event-handler thread "
+                    "for line %u of TDM-bus %s\n", i, bus->name);
+clean_up_and_exit:
+            sl_shutdown_and_cleanup();
+            return 1;
+        }
+    }
+
+    return 0;
+}
+
+// -----------------------------------------------------------------------------------------------
+void *
+sl_timer (void *data)
+{
+    int res;
+
+    if (pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL)) {
+        MSPD_ERR("Unable to disable thread's cancelability\n");
+        return NULL;
+    }
+    MSPD_LOG(2, "SL Timer thread started\n");
+
+    while (1) {
+        res = ast_sched_wait(sched);
+        if (res < 0 || res > 500)
+	    /* No actions scheduled or the nearest scheduled action is more
+	     * than 500 ms in future.
+	     * Keep reaction time 500 ms for new scheduled events for this case.
+	     */
+            res = 500;
+
+        usleep(res * 1000); /* usleep argument is in microseconds */
+
+        ast_sched_runq(sched);
+    }
+}
+
+int
+sl_init(void)
+{
+    MSPD_LOG(1, "Initializing Tempo...\n");
+
+    return tempo_init();
+}
+
+// -----------------------------------------------------------------------------------------------
+int
+sl_startup (void)
+{
+    MSPD_LOG(1, "Starting sl_producer\n");
+
+    if (ast_pthread_create(&timer, NULL, sl_timer, NULL) < 0)
+        MSPD_ERR("unable to start timer thread\n");
+
+
+    if (ast_pthread_create(&producer, NULL, sl_producer, NULL) < 0) {
+        MSPD_ERR("unable to start event-reader thread\n");
+        sl_shutdown_and_cleanup();
+    }
+    return 0;
+}
+
+// -----------------------------------------------------------------------------------------------
+// shutdown all threads, release resources etc.
+int
+sl_shutdown_and_cleanup (void)
+{
+    uint i, j;
+    mspd_bus_t *bus;
+    mspd_line_t *line;
+
+    MSPD_LOG(1, "n_buses=%u, SL producer=%ld\n", mspd_global.n_buses, (long)producer);
+
+    MSPD_LOG(2, "stopping SL consumers\n");
+
+    tempo_cleanup();
+
+    for (i = 0, bus = mspd_global.buses; i < mspd_global.n_buses; ++i, ++bus) {
+        for (j = 0, line = bus->lines; j < bus->n_lines; ++j, ++line) {
+            if (line->channel) {
+                MSPD_ERR("line %s:%u still has a channel\n", line->name, line->timeslot);
+                return 1;
+            }
+            if (line->owner) {
+                MSPD_ERR("line %s:%u still has an owner\n", line->name, line->timeslot);
+                return 1;
+            }
+            if (line->consumer != AST_PTHREADT_NULL) {
+                mspd_queue_stop(line->queue);
+                pthread_join(line->consumer, NULL);
+                line->consumer = AST_PTHREADT_NULL;
+            }
+        }
+    }
+    MSPD_LOG(2, "stopping SL producer\n");
+    if (producer != AST_PTHREADT_NULL) {
+        pthread_kill(producer, SIGURG);
+        pthread_join(producer, NULL);
+        producer = AST_PTHREADT_NULL;
+    }
+
+    for (i = 0, bus = mspd_global.buses; i < mspd_global.n_buses; ++i, ++bus) {
+        for (j = 0, line = bus->lines; j < bus->n_lines; ++j, ++line) {
+            if (line->intern_rtp) {
+                ast_rtp_instance_destroy(line->intern_rtp);
+                line->intern_rtp = NULL;
+                line->subline[SUB_REAL].rtp = NULL;
+            }
+
+            if (line->subline[SUB_CALLWAIT].rtp) {
+                ast_rtp_instance_destroy(line->subline[SUB_CALLWAIT].rtp);
+                line->subline[SUB_CALLWAIT].rtp = NULL;
+            }
+
+            if (line->queue) {
+                mspd_queue_destroy(line->queue);
+                line->queue = NULL;
+            }
+            if (line->name) {
+                free(line->name);
+                line->name = NULL;
+            }
+            ast_mutex_destroy(&line->lock);
+        }
+
+        bus->n_lines = 0;
+        if (bus->lines) {
+            free(bus->lines);
+            bus->lines = NULL;
+        }
+        if (bus->name) {
+            free(bus->name);
+            bus->name = NULL;
+        }
+        if (bus->context) {
+            free(bus->context);
+            bus->context = NULL;
+        }
+    }
+    mspd_global.n_buses = 0;
+    return 0;
+}
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/channels/mspd/mspd_threeway.c asterisk-1.8.2.3.new/channels/mspd/mspd_threeway.c
--- asterisk-1.8.2.3/channels/mspd/mspd_threeway.c	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/channels/mspd/mspd_threeway.c	2012-02-22 16:45:57.000000000 +0530
@@ -0,0 +1,644 @@
+/*
+ * Mindspeed Comcerto Channel module.
+ *
+ *  Copyright (C) 2004 -2011 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+// ===============================================================================================
+// Includes
+
+#include "asterisk.h"
+
+//ASTERISK_FILE_VERSION(__FILE__, "$Revision: 1.18 $")
+
+#include <stdio.h>
+#include <string.h>
+
+#include "include/mspd_common.h"
+#include "asterisk/mspd/defaults.h"
+#include "asterisk/mspd/macro.h"
+#include "asterisk/mspd/channel.h"
+#include "asterisk/mspd/global.h"
+#include "asterisk/mspd/common.h"
+#include "include/mspd_dev-channels.h"
+#include "include/mspd_threeway.h"
+#include "include/mspd_sti-lines.h"
+
+#include <asterisk/logger.h>
+#include <asterisk/options.h>
+
+// -----------------------------------------------------------------------------------------------
+// Creates a 3-way call conference and participants according to channel types
+int
+twc_make_threeway_call(mspd_line_t *master_line) {
+    MSPD_LOG(1, "SL MAKE 3 WAY CALL %s\n\n", master_line->name);
+
+    mspd_subline_t *sub_real = &master_line->subline[SUB_REAL];
+    mspd_subline_t *sub_wait = &master_line->subline[SUB_CALLWAIT];
+    struct ast_channel *ast_sub_real = ast_bridged_channel (sub_real->subline_owner);
+    struct ast_channel *ast_sub_wait = ast_bridged_channel (sub_wait->subline_owner);
+    int sub_real_type;
+    int sub_wait_type;
+
+    mspd_line_t *line2 = NULL;
+    mspd_line_t *line3 = NULL;
+
+    struct ast_sockaddr src, dst;
+
+    if (!(ast_sub_real && ast_sub_wait)) {
+        MSPD_ERR ("No bridged channels to make 3-way call!\n");
+        return ERR_NO_SUB_LINE;
+    }
+
+    if ((sub_real_type = twc_get_party_type (master_line, ast_sub_real)) < 0) {
+        MSPD_ERR("Unable to create 3-way call conference\n");
+        return sub_real_type;
+    }
+    if ((sub_wait_type = twc_get_party_type (master_line, ast_sub_wait)) < 0) {
+        MSPD_ERR("Unable to create 3-way call conference\n");
+        return sub_wait_type;
+    }
+
+    ast_indicate (ast_sub_wait, AST_CONTROL_UNHOLD);
+    master_line->is_call_on_hold = False;
+
+    mspd_device_t *dev = mspd_device_find_by_index(0);
+    BandMode conf_mode =  mspd_global.threeway_band ? eWideBand : eNarrowBand;
+    mspd_conference_t *mspd_conf = mspd_conference_create(dev, (U8) conf_mode);
+    if(!mspd_conf) {
+        MSPD_ERR("Unable to create 3-way call conference\n");
+        return ERR_NO_RESOURCE;
+    }
+
+    /// ----------------------------------------------------------------------
+    if (twc_add_lsp_part (master_line, mspd_conf)) {
+        MSPD_ERR("Error while adding line %s to TWC\n", master_line->name);
+        goto bail_out_Master;
+    }
+    if (mspd_channel_bwe_manager(master_line->channel,
+                    master_line->phone->wideband,
+                    mspd_conference_get_mixer(mspd_conf),
+                    &master_line->phone->bwe,
+                    True) ||
+        mspd_channel_configure_lsp_part (master_line->channel, &master_line->phone->echocan)) {
+        MSPD_ERR("TWC: Error occured while %s configuraion on line %s\n",
+                        mspd_channel_get_name(master_line->channel), master_line->name);
+                goto bail_out_1;
+    }
+
+    /// ----------------------------------------------------------------------
+
+    switch (sub_real_type) {
+        case CHAN_TYPE_MSPD:
+        {
+            MSPD_LOG(1, "TWC: second MSP channel on POTS\n");
+            line2 = (mspd_line_t *)(ast_sub_real->tech_pvt);
+            if (twc_add_lsp_part (line2, mspd_conf)) {
+                MSPD_ERR("Error while adding line %s to TWC\n", line2->name);
+                goto bail_out_1;
+            }
+
+            if (mspd_channel_bwe_manager(line2->channel,
+                                line2->phone->wideband,
+                                mspd_conference_get_mixer(mspd_conf),
+                                &line2->phone->bwe,
+                                True) ||
+            mspd_channel_configure_lsp_part (line2->channel, &line2->phone->echocan)) {
+                MSPD_ERR("TWC: Error occured while %s configuraion on line %s\n",
+                    mspd_channel_get_name(line2->channel), line2->name);
+                goto bail_out_2LSP;
+            }
+            break;
+        }
+        case CHAN_TYPE_SIP:
+        {
+            mspd_channel_t *channel = mspd_channel_create (dev,
+							   MCT_PART_RTP,
+							   ast_sub_real->readformat,
+							   master_line->phone->vad,
+							   sizeof(mspd_channel_pvt_t),
+							   NULL,
+							   dc_channel_destructor);
+            if (!channel)
+                goto bail_out_1;
+
+	    mspd_channel_pvt_t *pvt = mspd_channel_get_pvt(channel);
+            pvt->part.conference = mspd_conf;
+            master_line->threeway_channels[0] = channel;
+            BandMode conf_mode = Narrow;
+            if (twc_add_rsp_part (mspd_conf, mspd_channel_get_id(channel), conf_mode)){
+                MSPD_ERR("Error while adding new RSP to TWC\n");
+                goto bail_out_1;
+            }
+
+            ast_rtp_instance_get_remote_address(master_line->intern_rtp, &src);
+            ast_rtp_instance_get_local_address(master_line->intern_rtp, &dst);
+
+            if (mspd_channel_set_ip_header(channel, &src, &dst))                  goto bail_out_2RSP;
+            if (mspd_channel_bwe_manager(channel,
+                NoBand,  // RSP has no TDM
+                mspd_conference_get_mixer(mspd_conf),
+                mspd_global_get_rsp_bwe(),
+                True))                                                           goto bail_out_2RSP;
+            if (mspd_channel_configure_rsp_part (channel))                  	  goto bail_out_2RSP;
+            if (mspd_channel_start_conf_tx (channel))                             goto bail_out_2RSP;
+            break;
+        }
+    }
+
+    /// ----------------------------------------------------------------------
+
+    switch (sub_wait_type) {
+        case CHAN_TYPE_MSPD:
+        {
+            MSPD_LOG(1, "TWC: third MSP channel on POTS\n");
+            line3 = (mspd_line_t *)(ast_sub_wait->tech_pvt);
+            if (twc_add_lsp_part (line3, mspd_conf)) {
+                MSPD_ERR("Error while adding line %s to TWC\n", line3->name);
+                goto bail_out_3;
+            }
+
+            if (mspd_channel_bwe_manager(line3->channel,
+                                line3->phone->wideband,
+                                mspd_conference_get_mixer(mspd_conf),
+                                &line3->phone->bwe,
+                                True) ||
+            mspd_channel_configure_lsp_part (line3->channel, &line3->phone->echocan)) {
+                MSPD_ERR("TWC: Error occured while %s configuraion on line %s\n",
+                    mspd_channel_get_name(line3->channel), line3->name);
+                goto bail_out_3LSP;
+            }
+            break;
+        }
+        case CHAN_TYPE_SIP:
+        {
+            mspd_channel_t *channel = mspd_channel_create (dev,
+							   MCT_PART_RTP,
+							   ast_sub_wait->readformat,
+							   master_line->phone->vad,
+							   sizeof(mspd_channel_pvt_t),
+							   NULL,
+							   dc_channel_destructor);
+            if (! channel)
+                goto bail_out_3;
+
+	    mspd_channel_pvt_t *pvt = mspd_channel_get_pvt(channel);
+            pvt->part.conference = mspd_conf;
+            master_line->threeway_channels[1] = channel;
+            BandMode conf_mode = Narrow;
+            if (twc_add_rsp_part (mspd_conf, mspd_channel_get_id(channel), conf_mode)){
+                MSPD_ERR("Error while adding new RSP to TWC\n");
+                goto bail_out_3;
+            }
+
+            ast_rtp_instance_get_remote_address(master_line->subline[SUB_CALLWAIT].rtp, &src);
+            ast_rtp_instance_get_local_address(master_line->subline[SUB_CALLWAIT].rtp, &dst);
+
+            if (mspd_channel_set_ip_header(channel, &src, &dst))                  goto bail_out_3RSP;
+            ast_indicate(ast_sub_wait, AST_CONTROL_UNHOLD);
+            if (mspd_channel_bwe_manager(channel,
+                NoBand,  // RSP has no TDM
+                mspd_conference_get_mixer(mspd_conf),
+                mspd_global_get_rsp_bwe(),
+                True))                                                           goto bail_out_3RSP;
+            if (mspd_channel_configure_rsp_part (channel))                  goto bail_out_3RSP;
+            if (mspd_channel_start_conf_tx (channel))                             goto bail_out_3RSP;
+            break;
+        }
+    }
+
+    sl_set_line_state (master_line, MLS_THREEWAY);
+
+    return 0;
+
+    // -------------------------------------------
+bail_out_3LSP:
+    if(twc_replace_lsp_part (line3, mspd_conf))
+        MSPD_ERR("Error while restoring VoIP\n");
+
+    if (sub_real_type == CHAN_TYPE_SIP) goto bail_out_2RSP;
+    else                                goto bail_out_2LSP;
+
+
+bail_out_3RSP:
+    mspd_channel_destroy (master_line->threeway_channels[1]);
+    master_line->threeway_channels[1] = NULL;
+
+    if (sub_real_type == CHAN_TYPE_SIP) goto bail_out_2RSP;
+    else                                goto bail_out_2LSP;
+
+bail_out_3:
+    if (sub_real_type == CHAN_TYPE_SIP) goto bail_out_2RSP;
+    else                                goto bail_out_2LSP;
+
+bail_out_2LSP:
+    if(twc_replace_lsp_part (line2, mspd_conf))
+        MSPD_ERR("Error while destroying LSP part1\n");
+
+    goto bail_out_1;
+
+bail_out_2RSP:
+    mspd_channel_destroy (master_line->threeway_channels[0]);
+    master_line->threeway_channels[0] = NULL;
+
+bail_out_1:
+    if(twc_replace_lsp_part (master_line, mspd_conf))
+        MSPD_ERR("Error while destroying LSP master part\n");
+
+bail_out_Master:
+    mspd_conference_destroy (mspd_conf);
+
+    return ERR_OPERATION_UNSUCCESSFUL;
+}
+
+// -----------------------------------------------------------------------------------------------
+// Creates a new LSP participant in 3-way call conference
+int
+twc_add_lsp_part (mspd_line_t *line, mspd_conference_t *conf)
+{
+    mspd_channel_t *chan = line->channel;
+    mspd_channel_pvt_t *pvt = mspd_channel_get_pvt(line->channel);
+
+    MSPD_LOG(3, "TWC: %s: Switching VoIP to LSP\n", line->name);
+
+    if(mspd_channel_switch_to_lsp_part (chan, line->phone->wideband, line->timeslot, mspd_conference_get_id(conf)))
+        goto msg_err;
+
+    pvt->part.conference = conf;
+    mspd_conference_inc_participants(conf);
+
+    return 0;
+
+msg_err:
+    if(mspd_channel_switch_to_voip (chan, line->phone->wideband, line->timeslot))
+        MSPD_ERR("Line %s:%s Error while restoring VoIP mode\n",
+            line->name, mspd_channel_get_name (chan));
+    else
+        MSPD_WARN(1, "Line %s:%s VoIP mode restored\n",
+            line->name, mspd_channel_get_name (chan));
+
+    return ERR_OPERATION_UNSUCCESSFUL;
+}
+
+// -----------------------------------------------------------------------------------------------
+// Removes LSP participant from 3-way call conference and restores VOIP channel on this MSPD channel line
+int
+twc_replace_lsp_part (mspd_line_t *line, mspd_conference_t *conf)
+{
+    mspd_channel_t *chan = line->channel;
+    mspd_channel_pvt_t *pvt = mspd_channel_get_pvt(line->channel);
+
+    MSPD_LOG(3, "TWC: %s:Replacing LSP by VoIP\n", line->name);
+    if(mspd_channel_switch_to_voip (chan, line->phone->wideband, line->timeslot))
+        return ERR_OPERATION_UNSUCCESSFUL;
+
+    pvt->part.conference = NULL;
+    mspd_conference_dec_participants(conf);
+
+    return 0;
+}
+
+// -----------------------------------------------------------------------------------------------
+// Creates a new RSP participant in 3-way call conference
+int
+twc_add_rsp_part (mspd_conference_t *conf, U16 part_id, BandMode conf_mode)
+{
+    U16 timeslots = 0;
+    VSTATUS vstatus = 0xFF;
+    char buf [100];
+
+    MSPD_LOG(1, "TWC: RSP channel for SIP phone\n");
+    vstatus = VAPI_AllocateParticipant (mspd_conference_get_id(conf), part_id,
+                                       (conf_mode == Wide) ? eRSPWB : eRSP,
+                                       (conf_mode == Wide) ? 4 : 1,
+                                        &timeslots,   // not used internally
+                                        NULL, NULL);
+
+    sprintf(buf, "TWC: VAPI Allocate RSP Participant in %s band mode",
+           (conf_mode == Wide) ? "Wide" : "Narrow");
+    VAPI_REPORT_ACT(vstatus, buf,
+                    return ERR_OPERATION_UNSUCCESSFUL);
+    mspd_conference_inc_participants(conf);
+
+    return 0;
+}
+
+
+// -----------------------------------------------------------------------------------------------
+// Removes 3-way call conference and participants and restores one of two VOIP call existing before (third party has gone)
+int
+twc_restore_2way_call(mspd_line_t *master_line)
+{
+    mspd_subline_t *sub_real = &master_line->subline[SUB_REAL];
+
+    struct ast_channel *ast_sub_real = NULL;
+    mspd_line_t *line2 = NULL;
+    mspd_channel_t *chan2 = NULL;
+
+    MSPD_LOG(3, "TWC: %s:Restoring VoIP-VoIP call\n", master_line->name);
+
+    mspd_channel_t *chan1 = master_line->channel;
+
+    if (sub_real->subline_owner)
+        if (!(ast_sub_real = ast_bridged_channel (sub_real->subline_owner)))
+            return -1;
+
+    if (strstr(ast_sub_real->name, "MSPD"))
+        line2 = (mspd_line_t *)(ast_sub_real->tech_pvt);
+
+    if (line2)
+        chan2 = line2->channel;
+    else {
+        if (master_line->threeway_channels[0]) {
+            MSPD_LOG(1, "Using first TWC channel\n");
+            chan2 = master_line->threeway_channels[0];
+            master_line->threeway_channels[0] = NULL;
+        }
+        else {
+            MSPD_LOG(1, "Using second TWC channel\n");
+            chan2 = master_line->threeway_channels[1];
+            master_line->threeway_channels[1] = NULL;
+        }
+    }
+
+    struct ast_sockaddr src, dst;
+    struct ast_rtp_instance *rtp = NULL;
+    mspd_channel_pvt_t *pvt = mspd_channel_get_pvt(master_line->channel);
+    mspd_conference_t *mspd_conf = pvt->part.conference;
+    if(!mspd_conf) {
+        MSPD_ERR("3-way call conference not found!\n");
+        return ERR_NULL_POINTER;
+    }
+
+    if (line2) {
+        if(mspd_channel_switch_to_voip (chan2, line2->phone->wideband, line2->timeslot))
+            MSPD_ERR("Line %s:%s Error while switching to VoIP\n",
+                    line2->name, mspd_channel_get_name (chan2));
+        mspd_conference_dec_participants(mspd_conf);
+    }
+    else {
+        MSPD_LOG(1, "DESTROYING RSP participant\n");
+        mspd_channel_destroy (chan2);
+        ast_indicate(ast_sub_real, AST_CONTROL_ANSWER);
+    }
+
+    if(mspd_channel_switch_to_voip (chan1, master_line->phone->wideband, master_line->timeslot))
+        MSPD_ERR("Line %s:%s Error while switching master to VoIP\n",
+                master_line->name, mspd_channel_get_name (chan1));
+    mspd_conference_dec_participants(mspd_conf);
+
+    rtp = master_line->intern_rtp;
+    if (rtp) {
+        ast_rtp_instance_get_remote_address(rtp, &src);
+        ast_rtp_instance_get_local_address(rtp, &dst);
+        if (mspd_channel_set_ip_header(chan1, &src, &dst))          MSPD_ERR("Line1 mspd_channel_set_ip_header\n");
+    }
+    else
+        MSPD_ERR("No intern RTP on Line1\n");
+    if (mspd_channel_bwe_manager(chan1,
+                             master_line->phone->wideband,
+                             NoBand, // not applicable for VoIP
+                             &master_line->phone->bwe,
+                             True))                                                  MSPD_ERR("Line1 mspd_channel_bwe_manager\n");
+    if (mspd_channel_configure_voip(chan1, &master_line->phone->echocan))            MSPD_ERR("Line1 mspd_channel_configure_voip\n");
+
+    if (line2) {
+        rtp = line2->intern_rtp;
+        if (rtp) {
+            ast_rtp_instance_get_remote_address(rtp, &src);
+            ast_rtp_instance_get_local_address(rtp, &dst);
+            if (mspd_channel_set_ip_header(chan2, &src, &dst))      MSPD_ERR("Line2 mspd_channel_set_ip_header\n");
+        }
+        else
+            MSPD_ERR("No intern RTP on Line2\n");
+        if (mspd_channel_bwe_manager(chan2,
+                                 line2->phone->wideband,
+                                 NoBand, // not applicable for VoIP
+                                 &line2->phone->bwe,
+                                 True))                                              MSPD_ERR("Line2 mspd_channel_bwe_manager\n");
+        if (mspd_channel_configure_voip(chan2, &line2->phone->echocan))              MSPD_ERR("Line2 mspd_channel_configure_voip\n");
+    }
+
+    mspd_conference_destroy (mspd_conf);
+
+    if (mspd_channel_start_tx (chan1))          MSPD_ERR("%s: Error in mspd_channel_start_tx line1\n", master_line->name);
+    if (line2)
+        if (mspd_channel_start_tx (chan2))            MSPD_ERR("%s: Error in mspd_channel_start_tx line2\n", master_line->name);
+
+
+    /* start action for new voice call with new channel */
+    if (sl_do_ast_channel_action(master_line, &master_line->owner,
+            (int (*)(struct ast_channel*, void*))&ast_queue_frame,
+            &(struct ast_frame){.frametype = AST_FRAME_CONTROL,
+                                .subclass = {AST_CONTROL_ANSWER}}))
+    {
+        MSPD_ERR("(%s:%u/%s,%s): queueing answer control-frame has failed\n",
+                master_line->name, master_line->timeslot,
+                sl_show_line_state(master_line), "POTS");
+    }
+
+    MSPD_LOG(1, "3 way call released\n");
+    return 0;
+}
+
+// -----------------------------------------------------------------------------------------------
+// Removes 3-way call conference and participants. Master MSPD channel hung up
+int
+twc_release_threeway_call(mspd_line_t *master_line)
+{
+    MSPD_LOG(1, "Releasing 3 WAY CALL on %s\n\n", master_line->name);
+
+    VSTATUS vstatus = 0xFF;
+    mspd_subline_t *sub_real = &master_line->subline[SUB_REAL];
+    mspd_subline_t *sub_wait = &master_line->subline[SUB_CALLWAIT];
+    struct ast_channel *ast_sub_real = NULL;
+    struct ast_channel *ast_sub_wait = NULL;
+
+    if (sub_real->subline_owner)
+        ast_sub_real = ast_bridged_channel (sub_real->subline_owner);
+    if (sub_wait->subline_owner)
+        ast_sub_wait = ast_bridged_channel (sub_wait->subline_owner);
+
+    mspd_line_t *line2 = NULL;
+    mspd_line_t *line3 = NULL;
+    mspd_channel_t *chan2 = NULL;
+    mspd_channel_t *chan3 = NULL;
+
+    if (!(ast_sub_real && ast_sub_wait)) {
+        MSPD_ERR ("No bridged channels to release 3-way call!\n");
+        return ERR_NO_SUB_LINE;
+    }
+
+    if (strstr(ast_sub_real->name, "MSPD")) {
+        line2 = (mspd_line_t *)(ast_sub_real->tech_pvt);
+        chan2 = line2->channel;
+    }
+    else {
+        if (master_line->threeway_channels[0]) {
+            chan2 = master_line->threeway_channels[0];
+        }
+        else {
+            chan2 = master_line->threeway_channels[1];
+        }
+    }
+
+    if (strstr(ast_sub_wait->name, "MSPD")) {
+        line3 = (mspd_line_t *)(ast_sub_wait->tech_pvt);
+        chan3 = line3->channel;
+    }
+    else {
+        MSPD_LOG(1, "USING TWC channels\n");
+        if (master_line->threeway_channels[1]) {
+            chan3 = master_line->threeway_channels[1];
+        }
+        else {
+            chan3 = master_line->threeway_channels[0];
+        }
+    }
+
+    mspd_channel_t *chan1 = master_line->channel;
+
+    struct ast_sockaddr src, dst;
+    struct ast_rtp_instance *rtp = NULL;
+    mspd_channel_pvt_t *pvt = mspd_channel_get_pvt(master_line->channel);
+    mspd_conference_t *mspd_conf = pvt->part.conference;
+    if(!mspd_conf) {
+        MSPD_ERR("3-way call conference not found!\n");
+        return ERR_NULL_POINTER;
+    }
+
+    if(mspd_channel_switch_to_voip (chan1, master_line->phone->wideband, master_line->timeslot))
+        MSPD_ERR("Line %s:%s Error while switching master to VoIP\n",
+                master_line->name, mspd_channel_get_name (chan1));
+    mspd_conference_dec_participants(mspd_conf);
+
+    if (line2) {
+        if(mspd_channel_switch_to_voip (chan2, line2->phone->wideband, line2->timeslot))
+            MSPD_ERR("Line %s:%s Error while switching to VoIP\n",
+                    line2->name, mspd_channel_get_name (chan2));
+        mspd_conference_dec_participants(mspd_conf);
+
+        if (mspd_channel_set_coding_defaults(chan2)) MSPD_ERR("Line2 mspd_channel_set_coding_defaults");
+
+        rtp = line2->intern_rtp;
+        if (rtp) {
+            ast_rtp_instance_get_remote_address(rtp, &src);
+            ast_rtp_instance_get_local_address(rtp, &dst);
+            if (mspd_channel_set_ip_header(chan2, &src, &dst))      MSPD_ERR("Line2 mspd_channel_set_ip_header\n");
+        }
+        else
+            MSPD_ERR("No intern RTP on Line2\n");
+
+        if (mspd_channel_enable(chan2, mspd_channel_get_format(chan2)))              MSPD_ERR("%s: Error in mspd_channel_enable\n", master_line->name);
+    }
+    else {
+        MSPD_LOG(1, "ast_sub_real DESTROYING RSP participant\n");
+        vstatus = VAPI_DestroyParticipant (mspd_channel_get_id(chan2), NULL);
+        VAPI_REPORT (vstatus, "VAPI_DestroyParticipant chan2");
+        mspd_conference_dec_participants(mspd_conf);
+    }
+
+    if(line3) {
+        if(mspd_channel_switch_to_voip (chan3, line3->phone->wideband, line3->timeslot))
+            MSPD_ERR("Line %s:%s Error while switching to VoIP\n",
+                    line3->name, mspd_channel_get_name (chan3));
+	mspd_conference_dec_participants(mspd_conf);
+
+        if (mspd_channel_set_coding_defaults(chan3))  MSPD_ERR("Line3 dc_set_coding_defaults");
+
+        rtp = line3->intern_rtp;
+        if (rtp) {
+            ast_rtp_instance_get_remote_address(rtp, &src);
+            ast_rtp_instance_get_local_address(rtp, &dst);
+            if (mspd_channel_set_ip_header(chan3, &src, &dst))      MSPD_ERR("Line3 mspd_channel_set_ip_header\n");
+        }
+        else
+            MSPD_ERR("No intern RTP on Line3\n");
+        if (mspd_channel_enable(chan3, mspd_channel_get_format(chan3)))              MSPD_ERR("%s: Error in mspd_channel_enable\n", line2->name);
+    }
+    else {
+        MSPD_LOG(1, "ast_sub_wait DESTROYING RSP participant\n");
+        vstatus = VAPI_DestroyParticipant (mspd_channel_get_id(chan3), NULL);
+        VAPI_REPORT (vstatus, "VAPI_DestroyParticipant chan3");
+        mspd_conference_dec_participants(mspd_conf);
+    }
+    mspd_conference_destroy(mspd_conf);
+
+    return 0;
+}
+
+// -----------------------------------------------------------------------------------------------
+// Returns a type of channel bridged with current MSPD channel
+int
+twc_get_party_type (mspd_line_t *master_line,
+                       struct ast_channel *ast_sub_line)
+{
+    mspd_line_t *sub_line = NULL;
+
+    U8 type = CHAN_TYPE_MSPD;
+
+    if (!master_line->channel) {
+        MSPD_ERR("Master Line %s has no Channel\n\n", master_line->name);
+        return ERR_NO_CHAN;
+    }
+
+    ///-------------------------------------
+
+    if (strstr(ast_sub_line->name,"MSPD")) {
+        MSPD_LOG(1, "We found MSPD channel at ast2\n");
+
+        sub_line = (mspd_line_t *)(ast_sub_line->tech_pvt);
+        if (sub_line->channel) {
+            MSPD_LOG(1, "Sub Line %s, Channel %s (%d)\n\n",
+            sub_line->name, mspd_channel_get_name(sub_line->channel), mspd_channel_get_type(sub_line->channel));
+        }
+        else {
+            MSPD_ERR("Master's %s sub Line %s has no Channel\n\n",
+                master_line->name, sub_line->name);
+            return ERR_NO_CHAN;
+        }
+    }
+    else {
+        if (strstr(ast_sub_line->name, "SIP")) {
+            MSPD_LOG(1, "We found SIP channel at ast2\n\n");
+            type = CHAN_TYPE_SIP;
+        }
+        else {
+            MSPD_ERR("Ast subline has no compatible channel for Threeway-call\n\n");
+            return ERR_NO_COMPAT_CHAN;
+        }
+    }
+
+    return type;
+}
+
+// -----------------------------------------------------------------------------------------------
+// Prints 3-way call channels information
+void
+twc_print_info (mspd_line_t *line)
+{
+    if (!line)
+        return;
+    ast_verbose("\n-------------------------------\n");
+    ast_verbose("Line %s owned by %s (sub owner %s)\n",
+            line->name,
+            line->owner?line->owner->name:"NULL",
+            line->subline[SUB_CALLWAIT].subline_owner?line->subline[SUB_CALLWAIT].subline_owner->name:"NULL");
+
+    ast_verbose("Line TWC first channel name %s, type %s\n",
+        line->threeway_channels[0] ? mspd_channel_get_name(line->threeway_channels[0]) : "NULL",
+        line->threeway_channels[0] ? mspd_channel_type2text(mspd_channel_get_type(line->threeway_channels[0])) : "NULL");
+
+    ast_verbose("Line TWC second channel name %s, type %s\n",
+        line->threeway_channels[1] ? mspd_channel_get_name(line->threeway_channels[1]) : "NULL",
+        line->threeway_channels[1] ? mspd_channel_type2text(mspd_channel_get_type(line->threeway_channels[1])) : "NULL");   ast_verbose("\n-------------------------------\n");
+}
+
+// -----------------------------------------------------------------------------------------------
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/channels/mspd/t38.c asterisk-1.8.2.3.new/channels/mspd/t38.c
--- asterisk-1.8.2.3/channels/mspd/t38.c	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/channels/mspd/t38.c	2011-12-12 20:42:57.000000000 +0530
@@ -0,0 +1,320 @@
+/*
+ * Mindspeed Comcerto - T.38 support.
+ *
+ *  Copyright (C) 2004,2005 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+// ===============================================================================================
+// Includes
+
+#include "asterisk.h"
+
+//ASTERISK_FILE_VERSION(__FILE__, "$Revision: 1.20 $")
+
+#include <stdlib.h>
+#include <stdint.h>
+#include <unistd.h>
+#include <string.h>
+#include <errno.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <time.h>
+#include <pthread.h>
+
+#include "include/mspd_common.h" 
+#include "asterisk/mspd/defaults.h" 
+#include "asterisk/mspd/macro.h" 
+#include "asterisk/mspd/channel.h" 
+#include "asterisk/mspd/global.h" 
+#include "asterisk/mspd/common.h" 
+#include "include/mspd_dev-channels.h" 
+#include "include/mspd_threeway.h" 
+#include "include/mspd_sti-lines.h" 
+#include "include/t38.h"
+
+#define MSP_MAX_DATAGRAM 512
+
+extern struct sched_context *sched;
+
+static void
+t38_set_msp_constraints(struct ast_control_t38_parameters *parameters)
+{
+	parameters->version = 0;
+	parameters->transcoding_mmr = 0;
+	parameters->transcoding_jbig = 0;
+}
+
+static void
+t38_set_default_parameters(struct ast_control_t38_parameters *parameters)
+{
+	t38_set_msp_constraints(parameters);
+	parameters->rate = AST_T38_RATE_14400;
+	parameters->rate_management = AST_T38_RATE_MANAGEMENT_TRANSFERRED_TCF;
+	parameters->fill_bit_removal = 0;
+}
+
+static struct ast_udptl *
+mspd_udptl_allocate_new (mspd_device_t *dev)
+{
+	struct ast_sockaddr bindaddr_tmp;
+	ast_sockaddr_copy(&bindaddr_tmp, mspd_global_get_ipaddr());
+
+	struct ast_udptl *instance = ast_udptl_new_with_bindaddr(NULL, NULL, 0, &bindaddr_tmp);
+	if (!instance) {
+		MSPD_ERR("(%s): failed to allocate UDPTL instanse\n", mspd_device_get_name(dev));
+		return NULL;
+        }
+	ast_udptl_set_error_correction_scheme(instance, UDPTL_ERROR_CORRECTION_NONE);
+	ast_udptl_set_far_max_datagram(instance, MSP_MAX_DATAGRAM);
+
+	struct ast_sockaddr us, peer;
+	ast_udptl_get_us(instance, &us);
+
+	int port = ast_sockaddr_port(&us);
+	port -= 10000;
+
+	ast_sockaddr_copy(&peer, mspd_device_get_ipaddr(dev));
+	ast_sockaddr_set_port(&peer, port);
+	ast_udptl_set_peer(instance, &peer);
+
+	ast_udptl_get_peer(instance, &peer);
+	ast_udptl_get_us(instance, &us);
+
+	if (option_verbose > 2) {
+		ast_verbose("(%s): New UDPTL allocated: us=%s,", mspd_device_get_name(dev),
+			    ast_sockaddr_stringify (&us));
+		ast_verbose("peer=%s\n",
+			    ast_sockaddr_stringify (&peer));
+	}
+
+	return instance;
+}
+
+//-------------------------------------------------------------------------
+// Handles indication from Asterisk side
+int mspd_t38_mode_change_voice(struct mspd_line_t *line)
+{
+	int res = mspd_channel_switch_to_voip_and_configure(line->channel, 
+							    line->phone->wideband, 
+							    line->timeslot,
+							    &line->phone->echocan,
+							    line->intern_rtp);
+	if (res != 0)
+		MSPD_ERR("Unable to switch to voice mode\n");
+
+	ast_udptl_destroy(line->udptl);
+	line->udptl = NULL;
+
+	ast_channel_set_fd(line->owner, MSPD_FD_UDPTL, -1);
+
+	return res;
+}
+
+//-------------------------------------------------------------------------
+// Handles indication from Asterisk side
+static int mode_change_t38(struct mspd_line_t *line, struct ast_control_t38_parameters *parameters)
+{
+	struct t38_profile profile;
+	int res;
+
+	/* UDPTL instance should be already created in case if
+	 * we where the initiator of switch to T.38
+	 */
+	if (!line->udptl) {
+		line->udptl = mspd_udptl_allocate_new(line->bus->dev);
+		if (!line->udptl)
+			return -1;
+	}
+
+	t38_set_msp_constraints(parameters);
+
+	ast_udptl_set_local_max_ifp(line->udptl, parameters->max_ifp); /* needed to get max datagram attribute from udptl instance */
+	/* We want to accomodate to peer's max datagram, because MSP supports this */
+	profile.max_datagram = ast_udptl_get_local_max_datagram(line->udptl);
+	while (profile.max_datagram > MSP_MAX_DATAGRAM) { /* this is MSP contraint */
+		/* Max datagram is calculated basing on max IFP,
+		 * decrease max IFP and try again
+		 */
+		parameters->max_ifp--;
+		ast_udptl_set_local_max_ifp(line->udptl, parameters->max_ifp);
+		profile.max_datagram = ast_udptl_get_local_max_datagram(line->udptl);
+	}
+	/* We will change MSP "max datagram" option, 
+	 * therefore we need to adjust it in UDPTL instance as well,
+	 * so they will be synchronized
+	 */
+	ast_udptl_set_far_max_datagram(line->udptl, profile.max_datagram);
+	profile.ast = *parameters;
+
+	res = mspd_channel_switch_to_foip_and_configure(line->channel, &profile, line->udptl);
+	if (res != 0)
+		goto ERR_SWITCH;
+
+	ast_channel_set_fd(line->owner, MSPD_FD_UDPTL, ast_udptl_fd(line->udptl));
+
+	return 0;
+
+ERR_SWITCH:
+	ast_udptl_destroy(line->udptl);
+	line->udptl = NULL;
+	return -1;
+}
+
+int mspd_t38_handle_parameters(struct mspd_line_t *line, const struct ast_control_t38_parameters *parameters)
+{
+	int res = -1;
+	ast_mutex_lock(&line->lock);
+
+	if (line->t38state == T38_STATE_UNAVAILABLE)
+		goto FINISH;
+
+	switch (parameters->request_response) {
+	case AST_T38_REQUEST_NEGOTIATE:
+		if (line->t38state == T38_STATE_UNKNOWN) {
+			struct ast_control_t38_parameters params = *parameters;
+			res = mode_change_t38(line, &params);
+			if (res == 0) {
+				params.request_response = AST_T38_NEGOTIATED;
+				line->t38state = T38_STATE_NEGOTIATED;
+				res = ast_queue_control_data(line->owner, AST_CONTROL_T38_PARAMETERS, &params, sizeof(params));
+			}
+		} else if (line->t38state == T38_STATE_NEGOTIATED) {
+			/* already negotiated, send confirmation to bridged peer immediately */
+			struct ast_control_t38_parameters params;
+			memset(&params, 0, sizeof(params));
+			params.request_response = AST_T38_NEGOTIATED;
+			res = ast_queue_control_data(line->owner, AST_CONTROL_T38_PARAMETERS, &params, sizeof(params));
+		}
+		break;
+	case AST_T38_REQUEST_TERMINATE:
+		/* bridged peer requests to terminate T38 session */
+		if (line->t38state == T38_STATE_NEGOTIATED || line->t38state == T38_STATE_NEGOTIATING) {
+			res = mspd_t38_mode_change_voice(line) || mspd_channel_start_tx(line->channel);
+			if (res == 0) {
+				struct ast_control_t38_parameters params;
+				memset(&params, 0, sizeof(params));
+				params.request_response = AST_T38_TERMINATED;
+				line->t38state = T38_STATE_UNKNOWN;
+				res = ast_queue_control_data(line->owner, AST_CONTROL_T38_PARAMETERS, &params, sizeof(params));
+			}
+		}
+		break;
+	case AST_T38_REFUSED:
+		/* bridged peer indicates that he has refused to start T38 session */
+		if (line->t38state == T38_STATE_NEGOTIATING)
+			line->t38state = T38_STATE_UNKNOWN;
+		if (mspd_global_get_fax_mode() == MSPD_FAXMODE_AUTO)
+			mspd_channel_switch_to_passthru_mode(line->channel);
+		break;
+	case AST_T38_TERMINATED:
+		/* bridged peer indicates that he has terminated T38 session */
+		if (line->t38state == T38_STATE_NEGOTIATED || line->t38state == T38_STATE_NEGOTIATING) {
+			if (line->t38state == T38_STATE_NEGOTIATED) {
+				/* AST_T38_TERMINATED sent to us without request from our side.
+				 * This is a bug in bridged channel, but we will handle this anyway.
+				 */
+				res = mspd_t38_mode_change_voice(line) || mspd_channel_start_tx(line->channel);
+				if (res == 0)
+					line->t38state = T38_STATE_UNKNOWN;
+			} else
+				/* we got ack for our AST_T38_REQUEST_TERMINATE */
+				line->t38state = T38_STATE_UNKNOWN;
+		}
+		break;
+	case AST_T38_NEGOTIATED:
+		if (line->t38state == T38_STATE_NEGOTIATING) {
+			struct ast_control_t38_parameters params = *parameters;
+			res = mode_change_t38(line, &params);
+			if (res == 0)
+				line->t38state = T38_STATE_NEGOTIATED;
+		}
+		break;
+	case AST_T38_REQUEST_PARMS:
+	{
+		struct ast_control_t38_parameters params;
+		memset(&params, 0, sizeof(params));
+		params.request_response = AST_T38_REQUEST_NEGOTIATE;
+
+		t38_set_default_parameters(&params);
+
+		if (line->udptl)
+			params.max_ifp = ast_udptl_get_far_max_ifp(line->udptl);
+
+		if (line->owner)
+			ast_queue_control_data(line->owner, AST_CONTROL_T38_PARAMETERS, &params, sizeof(params));
+
+		res = AST_T38_REQUEST_PARMS;
+		break;
+	}
+	default:
+		break;
+	}
+
+FINISH:
+	ast_mutex_unlock(&line->lock);
+	return res;
+}
+
+static int t38_control_action(struct ast_channel* chan, void* data)
+{
+	struct ast_control_t38_parameters* parameters = (struct ast_control_t38_parameters*)data;
+	return ast_queue_control_data(chan, AST_CONTROL_T38_PARAMETERS, parameters, sizeof(*parameters));
+}
+
+//-------------------------------------------------------------------------
+// Handles indication from MSP side
+int
+mspd_t38_request_mode_change_foip (mspd_line_t *line)
+{
+	struct ast_control_t38_parameters params;
+	int res = -1;
+
+	if (line->t38state == T38_STATE_NEGOTIATED || line->t38state == T38_STATE_NEGOTIATING) {
+		MSPD_LOG(3, "--- T.38 mode already enabled/negotiating\n");
+		return 0;
+	}
+
+	line->udptl = mspd_udptl_allocate_new(line->bus->dev);
+	if(!line->udptl)
+		return -1;
+
+	memset(&params, 0, sizeof(params));
+	t38_set_default_parameters(&params);
+	params.request_response = AST_T38_REQUEST_NEGOTIATE;
+	params.max_ifp = ast_udptl_get_far_max_ifp(line->udptl);
+
+	res = sl_do_ast_channel_action(line, &line->owner, t38_control_action, &params);
+
+	if (!res)
+		line->t38state = T38_STATE_NEGOTIATING;
+	else {
+		ast_udptl_destroy(line->udptl);
+		line->udptl = NULL;	
+	}
+
+	return res;
+}
+
+//-------------------------------------------------------------------------
+// Handles indication from MSP side
+int
+mspd_t38_request_mode_change_voip (mspd_line_t  *line)
+{
+	struct ast_control_t38_parameters params;
+	int res = -1;
+
+	if ((line->t38state != T38_STATE_NEGOTIATED && line->t38state != T38_STATE_NEGOTIATING) || !line->owner)
+		return -1;
+
+	memset(&params, 0, sizeof(params));
+	params.request_response = AST_T38_REQUEST_TERMINATE;
+	res = sl_do_ast_channel_action(line, &line->owner, t38_control_action, &params);
+
+	return res;
+}
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/codecs/lpc10/analys.c asterisk-1.8.2.3.new/codecs/lpc10/analys.c
--- asterisk-1.8.2.3/codecs/lpc10/analys.c	2006-10-14 00:15:44.000000000 +0530
+++ asterisk-1.8.2.3.new/codecs/lpc10/analys.c	2011-01-31 22:44:53.000000000 +0530
@@ -1,6 +1,9 @@
 /*
 
-$Log$
+$Log: analys.c,v $
+Revision 1.1.1.1  2011/01/31 17:14:53  andrey.arsirii
+
+
 Revision 1.16  2004/06/26 03:50:14  markster
 Merge source cleanups (bug #1911)
 
@@ -87,7 +90,10 @@
 
 /* 	ANALYS Version 55 */
 
-/* $Log$
+/* $Log: analys.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:53  andrey.arsirii
+/*
+/*
  * Revision 1.16  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
@@ -259,7 +265,10 @@
 	    *, integer *, integer *, struct lpc10_encoder_state *);
     real phi[100]	/* was [10][10] */, psi[10];
 
-/* $Log$
+/* $Log: analys.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:53  andrey.arsirii
+/*
+/*
  * Revision 1.16  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
@@ -299,7 +308,10 @@
 /*   LPC Configuration parameters: */
 /* Frame size, Prediction order, Pitch period */
 /*       Arguments to ANALYS */
-/* $Log$
+/* $Log: analys.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:53  andrey.arsirii
+/*
+/*
  * Revision 1.16  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/codecs/lpc10/bsynz.c asterisk-1.8.2.3.new/codecs/lpc10/bsynz.c
--- asterisk-1.8.2.3/codecs/lpc10/bsynz.c	2006-10-14 00:15:44.000000000 +0530
+++ asterisk-1.8.2.3.new/codecs/lpc10/bsynz.c	2011-01-31 22:44:55.000000000 +0530
@@ -1,6 +1,9 @@
 /*
 
-$Log$
+$Log: bsynz.c,v $
+Revision 1.1.1.1  2011/01/31 17:14:55  andrey.arsirii
+
+
 Revision 1.15  2004/06/26 03:50:14  markster
 Merge source cleanups (bug #1911)
 
@@ -53,7 +56,10 @@
 
 /* 	BSYNZ Version 54 */
 
-/* $Log$
+/* $Log: bsynz.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:55  andrey.arsirii
+/*
+/*
  * Revision 1.15  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
@@ -155,7 +161,10 @@
     real xy, sum, ssq;
     real lpi0, hpi0;
 
-/* $Log$
+/* $Log: bsynz.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:55  andrey.arsirii
+/*
+/*
  * Revision 1.15  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
@@ -192,7 +201,10 @@
 /*   LPC Configuration parameters: */
 /* Frame size, Prediction order, Pitch period */
 /*       Arguments */
-/* $Log$
+/* $Log: bsynz.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:55  andrey.arsirii
+/*
+/*
  * Revision 1.15  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/codecs/lpc10/chanwr.c asterisk-1.8.2.3.new/codecs/lpc10/chanwr.c
--- asterisk-1.8.2.3/codecs/lpc10/chanwr.c	2008-10-30 22:19:02.000000000 +0530
+++ asterisk-1.8.2.3.new/codecs/lpc10/chanwr.c	2011-01-31 22:44:50.000000000 +0530
@@ -1,6 +1,9 @@
 /*
 
-$Log$
+$Log: chanwr.c,v $
+Revision 1.1.1.1  2011/01/31 17:14:50  andrey.arsirii
+
+
 Revision 1.15  2004/06/26 03:50:14  markster
 Merge source cleanups (bug #1911)
 
@@ -36,7 +39,10 @@
 
 /* 	CHANL Version 49 */
 
-/* $Log$
+/* $Log: chanwr.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:50  andrey.arsirii
+/*
+/*
  * Revision 1.15  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/codecs/lpc10/dcbias.c asterisk-1.8.2.3.new/codecs/lpc10/dcbias.c
--- asterisk-1.8.2.3/codecs/lpc10/dcbias.c	2006-10-14 00:15:44.000000000 +0530
+++ asterisk-1.8.2.3.new/codecs/lpc10/dcbias.c	2011-01-31 22:44:50.000000000 +0530
@@ -1,6 +1,9 @@
 /*
 
-$Log$
+$Log: dcbias.c,v $
+Revision 1.1.1.1  2011/01/31 17:14:50  andrey.arsirii
+
+
 Revision 1.15  2004/06/26 03:50:14  markster
 Merge source cleanups (bug #1911)
 
@@ -34,7 +37,10 @@
 
 /* 	DCBIAS Version 50 */
 
-/* $Log$
+/* $Log: dcbias.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:50  andrey.arsirii
+/*
+/*
  * Revision 1.15  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/codecs/lpc10/decode.c asterisk-1.8.2.3.new/codecs/lpc10/decode.c
--- asterisk-1.8.2.3/codecs/lpc10/decode.c	2006-10-14 00:15:44.000000000 +0530
+++ asterisk-1.8.2.3.new/codecs/lpc10/decode.c	2011-01-31 22:44:56.000000000 +0530
@@ -1,6 +1,9 @@
 /*
 
-$Log$
+$Log: decode.c,v $
+Revision 1.1.1.1  2011/01/31 17:14:56  andrey.arsirii
+
+
 Revision 1.16  2004/06/26 03:50:14  markster
 Merge source cleanups (bug #1911)
 
@@ -61,7 +64,10 @@
 
 /* 	DECODE Version 54 */
 
-/* $Log$
+/* $Log: decode.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:56  andrey.arsirii
+/*
+/*
  * Revision 1.16  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
@@ -205,7 +211,10 @@
     extern integer median_(integer *, integer *, integer *);
     integer ishift, errcnt, lsb;
 
-/* $Log$
+/* $Log: decode.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:56  andrey.arsirii
+/*
+/*
  * Revision 1.16  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
@@ -245,7 +254,10 @@
 /*   LPC Configuration parameters: */
 /* Frame size, Prediction order, Pitch period */
 /*       Arguments */
-/* $Log$
+/* $Log: decode.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:56  andrey.arsirii
+/*
+/*
  * Revision 1.16  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/codecs/lpc10/deemp.c asterisk-1.8.2.3.new/codecs/lpc10/deemp.c
--- asterisk-1.8.2.3/codecs/lpc10/deemp.c	2006-10-14 00:15:44.000000000 +0530
+++ asterisk-1.8.2.3.new/codecs/lpc10/deemp.c	2011-01-31 22:44:52.000000000 +0530
@@ -1,6 +1,9 @@
 /*
 
-$Log$
+$Log: deemp.c,v $
+Revision 1.1.1.1  2011/01/31 17:14:52  andrey.arsirii
+
+
 Revision 1.15  2004/06/26 03:50:14  markster
 Merge source cleanups (bug #1911)
 
@@ -42,7 +45,10 @@
 
 /* 	DEEMP Version 48 */
 
-/* $Log$
+/* $Log: deemp.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:52  andrey.arsirii
+/*
+/*
  * Revision 1.15  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/codecs/lpc10/difmag.c asterisk-1.8.2.3.new/codecs/lpc10/difmag.c
--- asterisk-1.8.2.3/codecs/lpc10/difmag.c	2006-10-14 00:15:44.000000000 +0530
+++ asterisk-1.8.2.3.new/codecs/lpc10/difmag.c	2011-01-31 22:44:56.000000000 +0530
@@ -1,6 +1,9 @@
 /*
 
-$Log$
+$Log: difmag.c,v $
+Revision 1.1.1.1  2011/01/31 17:14:56  andrey.arsirii
+
+
 Revision 1.15  2004/06/26 03:50:14  markster
 Merge source cleanups (bug #1911)
 
@@ -34,7 +37,10 @@
 
 /* 	DIFMAG Version 49 */
 
-/* $Log$
+/* $Log: difmag.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:56  andrey.arsirii
+/*
+/*
  * Revision 1.15  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/codecs/lpc10/dyptrk.c asterisk-1.8.2.3.new/codecs/lpc10/dyptrk.c
--- asterisk-1.8.2.3/codecs/lpc10/dyptrk.c	2006-10-14 00:15:44.000000000 +0530
+++ asterisk-1.8.2.3.new/codecs/lpc10/dyptrk.c	2011-01-31 22:44:52.000000000 +0530
@@ -1,6 +1,9 @@
 /*
 
-$Log$
+$Log: dyptrk.c,v $
+Revision 1.1.1.1  2011/01/31 17:14:52  andrey.arsirii
+
+
 Revision 1.15  2004/06/26 03:50:14  markster
 Merge source cleanups (bug #1911)
 
@@ -52,7 +55,10 @@
 
 /* 	DYPTRK Version 52 */
 
-/* $Log$
+/* $Log: dyptrk.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:52  andrey.arsirii
+/*
+/*
  * Revision 1.15  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
@@ -147,7 +153,10 @@
     real alpha, minsc, maxsc;
 
 /*       Arguments */
-/* $Log$
+/* $Log: dyptrk.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:52  andrey.arsirii
+/*
+/*
  * Revision 1.15  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/codecs/lpc10/encode.c asterisk-1.8.2.3.new/codecs/lpc10/encode.c
--- asterisk-1.8.2.3/codecs/lpc10/encode.c	2006-10-14 00:15:44.000000000 +0530
+++ asterisk-1.8.2.3.new/codecs/lpc10/encode.c	2011-01-31 22:44:50.000000000 +0530
@@ -1,6 +1,9 @@
 /*
 
-$Log$
+$Log: encode.c,v $
+Revision 1.1.1.1  2011/01/31 17:14:50  andrey.arsirii
+
+
 Revision 1.15  2004/06/26 03:50:14  markster
 Merge source cleanups (bug #1911)
 
@@ -48,7 +51,10 @@
 
 /* 	ENCODE Version 54 */
 
-/* $Log$
+/* $Log: encode.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:50  andrey.arsirii
+/*
+/*
  * Revision 1.15  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
@@ -139,7 +145,10 @@
     /* Local variables */
     integer idel, nbit, i__, j, i2, i3, mrk;
 
-/* $Log$
+/* $Log: encode.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:50  andrey.arsirii
+/*
+/*
  * Revision 1.15  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
@@ -168,7 +177,10 @@
 /*   LPC Configuration parameters: */
 /* Frame size, Prediction order, Pitch period */
 /*       Arguments */
-/* $Log$
+/* $Log: encode.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:50  andrey.arsirii
+/*
+/*
  * Revision 1.15  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/codecs/lpc10/energy.c asterisk-1.8.2.3.new/codecs/lpc10/energy.c
--- asterisk-1.8.2.3/codecs/lpc10/energy.c	2006-10-14 00:15:44.000000000 +0530
+++ asterisk-1.8.2.3.new/codecs/lpc10/energy.c	2011-01-31 22:44:56.000000000 +0530
@@ -1,6 +1,9 @@
 /*
 
-$Log$
+$Log: energy.c,v $
+Revision 1.1.1.1  2011/01/31 17:14:56  andrey.arsirii
+
+
 Revision 1.15  2004/06/26 03:50:14  markster
 Merge source cleanups (bug #1911)
 
@@ -34,7 +37,10 @@
 
 /* 	ENERGY Version 50 */
 
-/* $Log$
+/* $Log: energy.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:56  andrey.arsirii
+/*
+/*
  * Revision 1.15  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/codecs/lpc10/f2c.h asterisk-1.8.2.3.new/codecs/lpc10/f2c.h
--- asterisk-1.8.2.3/codecs/lpc10/f2c.h	2006-02-15 00:44:15.000000000 +0530
+++ asterisk-1.8.2.3.new/codecs/lpc10/f2c.h	2011-01-31 22:44:52.000000000 +0530
@@ -1,6 +1,9 @@
 /*
 
-$Log$
+$Log: f2c.h,v $
+Revision 1.1.1.1  2011/01/31 17:14:52  andrey.arsirii
+
+
 Revision 1.15  2004/06/26 03:50:14  markster
 Merge source cleanups (bug #1911)
 
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/codecs/lpc10/f2clib.c asterisk-1.8.2.3.new/codecs/lpc10/f2clib.c
--- asterisk-1.8.2.3/codecs/lpc10/f2clib.c	2006-02-15 00:44:15.000000000 +0530
+++ asterisk-1.8.2.3.new/codecs/lpc10/f2clib.c	2011-01-31 22:44:55.000000000 +0530
@@ -1,6 +1,9 @@
 /*
 
-$Log$
+$Log: f2clib.c,v $
+Revision 1.1.1.1  2011/01/31 17:14:55  andrey.arsirii
+
+
 Revision 1.14  2003/02/12 13:59:15  matteo
 mer feb 12 14:56:57 CET 2003
 
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/codecs/lpc10/ham84.c asterisk-1.8.2.3.new/codecs/lpc10/ham84.c
--- asterisk-1.8.2.3/codecs/lpc10/ham84.c	2006-10-14 00:15:44.000000000 +0530
+++ asterisk-1.8.2.3.new/codecs/lpc10/ham84.c	2011-01-31 22:44:55.000000000 +0530
@@ -1,6 +1,9 @@
 /*
 
-$Log$
+$Log: ham84.c,v $
+Revision 1.1.1.1  2011/01/31 17:14:55  andrey.arsirii
+
+
 Revision 1.15  2004/06/26 03:50:14  markster
 Merge source cleanups (bug #1911)
 
@@ -34,7 +37,10 @@
 
 /* 	HAM84 Version 45G */
 
-/* $Log$
+/* $Log: ham84.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:55  andrey.arsirii
+/*
+/*
  * Revision 1.15  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/codecs/lpc10/hp100.c asterisk-1.8.2.3.new/codecs/lpc10/hp100.c
--- asterisk-1.8.2.3/codecs/lpc10/hp100.c	2006-10-14 00:15:44.000000000 +0530
+++ asterisk-1.8.2.3.new/codecs/lpc10/hp100.c	2011-01-31 22:44:55.000000000 +0530
@@ -1,6 +1,9 @@
 /*
 
-$Log$
+$Log: hp100.c,v $
+Revision 1.1.1.1  2011/01/31 17:14:55  andrey.arsirii
+
+
 Revision 1.15  2004/06/26 03:50:14  markster
 Merge source cleanups (bug #1911)
 
@@ -44,7 +47,10 @@
 
 /*      HP100 Version 55 */
 
-/* $Log$
+/* $Log: hp100.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:55  andrey.arsirii
+/*
+/*
  * Revision 1.15  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/codecs/lpc10/invert.c asterisk-1.8.2.3.new/codecs/lpc10/invert.c
--- asterisk-1.8.2.3/codecs/lpc10/invert.c	2006-10-14 00:15:44.000000000 +0530
+++ asterisk-1.8.2.3.new/codecs/lpc10/invert.c	2011-01-31 22:44:52.000000000 +0530
@@ -1,6 +1,9 @@
 /*
 
-$Log$
+$Log: invert.c,v $
+Revision 1.1.1.1  2011/01/31 17:14:52  andrey.arsirii
+
+
 Revision 1.15  2004/06/26 03:50:14  markster
 Merge source cleanups (bug #1911)
 
@@ -34,7 +37,10 @@
 
 /* 	INVERT Version 45G */
 
-/* $Log$
+/* $Log: invert.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:52  andrey.arsirii
+/*
+/*
  * Revision 1.15  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
@@ -102,7 +108,10 @@
     real v[100]	/* was [10][10] */;
 
 /*       Arguments */
-/* $Log$
+/* $Log: invert.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:52  andrey.arsirii
+/*
+/*
  * Revision 1.15  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/codecs/lpc10/irc2pc.c asterisk-1.8.2.3.new/codecs/lpc10/irc2pc.c
--- asterisk-1.8.2.3/codecs/lpc10/irc2pc.c	2006-10-14 00:15:44.000000000 +0530
+++ asterisk-1.8.2.3.new/codecs/lpc10/irc2pc.c	2011-01-31 22:44:56.000000000 +0530
@@ -1,6 +1,9 @@
 /*
 
-$Log$
+$Log: irc2pc.c,v $
+Revision 1.1.1.1  2011/01/31 17:14:56  andrey.arsirii
+
+
 Revision 1.15  2004/06/26 03:50:14  markster
 Merge source cleanups (bug #1911)
 
@@ -34,7 +37,10 @@
 
 /* 	IRC2PC Version 48 */
 
-/* $Log$
+/* $Log: irc2pc.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:56  andrey.arsirii
+/*
+/*
  * Revision 1.15  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
@@ -93,7 +99,10 @@
     integer i__, j;
 
 /* 	Arguments */
-/* $Log$
+/* $Log: irc2pc.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:56  andrey.arsirii
+/*
+/*
  * Revision 1.15  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/codecs/lpc10/ivfilt.c asterisk-1.8.2.3.new/codecs/lpc10/ivfilt.c
--- asterisk-1.8.2.3/codecs/lpc10/ivfilt.c	2006-10-14 00:15:44.000000000 +0530
+++ asterisk-1.8.2.3.new/codecs/lpc10/ivfilt.c	2011-01-31 22:44:51.000000000 +0530
@@ -1,6 +1,9 @@
 /*
 
-$Log$
+$Log: ivfilt.c,v $
+Revision 1.1.1.1  2011/01/31 17:14:51  andrey.arsirii
+
+
 Revision 1.16  2004/06/26 03:50:14  markster
 Merge source cleanups (bug #1911)
 
@@ -37,7 +40,10 @@
 
 /* 	IVFILT Version 48 */
 
-/* $Log$
+/* $Log: ivfilt.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:51  andrey.arsirii
+/*
+/*
  * Revision 1.16  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/codecs/lpc10/lpc10.h asterisk-1.8.2.3.new/codecs/lpc10/lpc10.h
--- asterisk-1.8.2.3/codecs/lpc10/lpc10.h	2006-06-10 04:43:52.000000000 +0530
+++ asterisk-1.8.2.3.new/codecs/lpc10/lpc10.h	2011-01-31 22:44:49.000000000 +0530
@@ -1,6 +1,9 @@
 /*
 
-$Log$
+$Log: lpc10.h,v $
+Revision 1.1.1.1  2011/01/31 17:14:49  andrey.arsirii
+
+
 Revision 1.18  2004/08/31 13:32:11  markster
 Merge NetBSD and Courtesty tone with modifications (bug #2329)
 
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/codecs/lpc10/lpcdec.c asterisk-1.8.2.3.new/codecs/lpc10/lpcdec.c
--- asterisk-1.8.2.3/codecs/lpc10/lpcdec.c	2006-10-14 00:15:44.000000000 +0530
+++ asterisk-1.8.2.3.new/codecs/lpc10/lpcdec.c	2011-01-31 22:44:51.000000000 +0530
@@ -1,6 +1,9 @@
 /*
 
-$Log$
+$Log: lpcdec.c,v $
+Revision 1.1.1.1  2011/01/31 17:14:51  andrey.arsirii
+
+
 Revision 1.15  2004/06/26 03:50:14  markster
 Merge source cleanups (bug #1911)
 
@@ -63,7 +66,10 @@
 
 /* ***************************************************************** */
 
-/* $Log$
+/* $Log: lpcdec.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:51  andrey.arsirii
+/*
+/*
  * Revision 1.15  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
@@ -124,7 +130,10 @@
     integer irc[10], len;
     real rms;
 
-/* $Log$
+/* $Log: lpcdec.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:51  andrey.arsirii
+/*
+/*
  * Revision 1.15  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
@@ -164,7 +173,10 @@
 /*   LPC Configuration parameters: */
 /* Frame size, Prediction order, Pitch period */
 /*       Arguments */
-/* $Log$
+/* $Log: lpcdec.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:51  andrey.arsirii
+/*
+/*
  * Revision 1.15  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/codecs/lpc10/lpcenc.c asterisk-1.8.2.3.new/codecs/lpc10/lpcenc.c
--- asterisk-1.8.2.3/codecs/lpc10/lpcenc.c	2006-10-14 00:15:44.000000000 +0530
+++ asterisk-1.8.2.3.new/codecs/lpc10/lpcenc.c	2011-01-31 22:44:55.000000000 +0530
@@ -1,6 +1,9 @@
 /*
 
-$Log$
+$Log: lpcenc.c,v $
+Revision 1.1.1.1  2011/01/31 17:14:55  andrey.arsirii
+
+
 Revision 1.15  2004/06/26 03:50:14  markster
 Merge source cleanups (bug #1911)
 
@@ -55,7 +58,10 @@
 
 /* ***************************************************************** */
 
-/* $Log$
+/* $Log: lpcenc.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:55  andrey.arsirii
+/*
+/*
  * Revision 1.15  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
@@ -120,7 +126,10 @@
     real rms;
 
 /*       Arguments */
-/* $Log$
+/* $Log: lpcenc.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:55  andrey.arsirii
+/*
+/*
  * Revision 1.15  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/codecs/lpc10/lpcini.c asterisk-1.8.2.3.new/codecs/lpc10/lpcini.c
--- asterisk-1.8.2.3/codecs/lpc10/lpcini.c	2008-10-15 22:11:54.000000000 +0530
+++ asterisk-1.8.2.3.new/codecs/lpc10/lpcini.c	2011-01-31 22:44:53.000000000 +0530
@@ -1,6 +1,9 @@
 /*
 
-$Log$
+$Log: lpcini.c,v $
+Revision 1.1.1.1  2011/01/31 17:14:53  andrey.arsirii
+
+
 Revision 1.18  2003/10/21 18:08:11  markster
 Fix include order
 
@@ -55,7 +58,10 @@
 
 /* ***************************************************************** */
 
-/* $Log$
+/* $Log: lpcini.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:53  andrey.arsirii
+/*
+/*
  * Revision 1.18  2003/10/21 18:08:11  markster
  * Fix include order
  *
@@ -93,7 +99,10 @@
 /* Subroutine */ int lpcini_(void)
 {
 
-/* $Log$
+/* $Log: lpcini.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:53  andrey.arsirii
+/*
+/*
  * Revision 1.18  2003/10/21 18:08:11  markster
  * Fix include order
  *
@@ -131,7 +140,10 @@
 
 /*   LPC Configuration parameters: */
 /* Frame size, Prediction order, Pitch period */
-/* $Log$
+/* $Log: lpcini.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:53  andrey.arsirii
+/*
+/*
  * Revision 1.18  2003/10/21 18:08:11  markster
  * Fix include order
  *
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/codecs/lpc10/lpfilt.c asterisk-1.8.2.3.new/codecs/lpc10/lpfilt.c
--- asterisk-1.8.2.3/codecs/lpc10/lpfilt.c	2006-10-14 00:15:44.000000000 +0530
+++ asterisk-1.8.2.3.new/codecs/lpc10/lpfilt.c	2011-01-31 22:44:56.000000000 +0530
@@ -1,6 +1,9 @@
 /*
 
-$Log$
+$Log: lpfilt.c,v $
+Revision 1.1.1.1  2011/01/31 17:14:56  andrey.arsirii
+
+
 Revision 1.15  2004/06/26 03:50:14  markster
 Merge source cleanups (bug #1911)
 
@@ -34,7 +37,10 @@
 
 /* 	LPFILT Version 55 */
 
-/* $Log$
+/* $Log: lpfilt.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:56  andrey.arsirii
+/*
+/*
  * Revision 1.15  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/codecs/lpc10/median.c asterisk-1.8.2.3.new/codecs/lpc10/median.c
--- asterisk-1.8.2.3/codecs/lpc10/median.c	2006-10-14 00:15:44.000000000 +0530
+++ asterisk-1.8.2.3.new/codecs/lpc10/median.c	2011-01-31 22:44:55.000000000 +0530
@@ -1,6 +1,9 @@
 /*
 
-$Log$
+$Log: median.c,v $
+Revision 1.1.1.1  2011/01/31 17:14:55  andrey.arsirii
+
+
 Revision 1.15  2004/06/26 03:50:14  markster
 Merge source cleanups (bug #1911)
 
@@ -34,7 +37,10 @@
 
 /* 	MEDIAN Version 45G */
 
-/* $Log$
+/* $Log: median.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:55  andrey.arsirii
+/*
+/*
  * Revision 1.15  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/codecs/lpc10/mload.c asterisk-1.8.2.3.new/codecs/lpc10/mload.c
--- asterisk-1.8.2.3/codecs/lpc10/mload.c	2006-10-14 00:15:44.000000000 +0530
+++ asterisk-1.8.2.3.new/codecs/lpc10/mload.c	2011-01-31 22:44:54.000000000 +0530
@@ -1,6 +1,9 @@
 /*
 
-$Log$
+$Log: mload.c,v $
+Revision 1.1.1.1  2011/01/31 17:14:54  andrey.arsirii
+
+
 Revision 1.15  2004/06/26 03:50:14  markster
 Merge source cleanups (bug #1911)
 
@@ -34,7 +37,10 @@
 
 /* 	MLOAD Version 48 */
 
-/* $Log$
+/* $Log: mload.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:54  andrey.arsirii
+/*
+/*
  * Revision 1.15  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/codecs/lpc10/onset.c asterisk-1.8.2.3.new/codecs/lpc10/onset.c
--- asterisk-1.8.2.3/codecs/lpc10/onset.c	2006-10-14 00:15:44.000000000 +0530
+++ asterisk-1.8.2.3.new/codecs/lpc10/onset.c	2011-01-31 22:44:55.000000000 +0530
@@ -1,6 +1,9 @@
 /*
 
-$Log$
+$Log: onset.c,v $
+Revision 1.1.1.1  2011/01/31 17:14:55  andrey.arsirii
+
+
 Revision 1.15  2004/06/26 03:50:14  markster
 Merge source cleanups (bug #1911)
 
@@ -46,7 +49,10 @@
 
 /* 	ONSET Version 49 */
 
-/* $Log$
+/* $Log: onset.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:55  andrey.arsirii
+/*
+/*
  * Revision 1.15  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
@@ -154,7 +160,10 @@
     real *fpc;
 
 /*       Arguments */
-/* $Log$
+/* $Log: onset.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:55  andrey.arsirii
+/*
+/*
  * Revision 1.15  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/codecs/lpc10/pitsyn.c asterisk-1.8.2.3.new/codecs/lpc10/pitsyn.c
--- asterisk-1.8.2.3/codecs/lpc10/pitsyn.c	2009-07-30 21:37:05.000000000 +0530
+++ asterisk-1.8.2.3.new/codecs/lpc10/pitsyn.c	2011-01-31 22:44:55.000000000 +0530
@@ -1,6 +1,9 @@
 /*
 
-$Log$
+$Log: pitsyn.c,v $
+Revision 1.1.1.1  2011/01/31 17:14:55  andrey.arsirii
+
+
 Revision 1.16  2004/06/26 03:50:14  markster
 Merge source cleanups (bug #1911)
 
@@ -45,7 +48,10 @@
 
 /* 	PITSYN Version 53 */
 
-/* $Log$
+/* $Log: pitsyn.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:55  andrey.arsirii
+/*
+/*
  * Revision 1.16  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
@@ -160,7 +166,10 @@
     real xxy;
 
 /*       Arguments */
-/* $Log$
+/* $Log: pitsyn.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:55  andrey.arsirii
+/*
+/*
  * Revision 1.16  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/codecs/lpc10/placea.c asterisk-1.8.2.3.new/codecs/lpc10/placea.c
--- asterisk-1.8.2.3/codecs/lpc10/placea.c	2006-10-14 00:15:44.000000000 +0530
+++ asterisk-1.8.2.3.new/codecs/lpc10/placea.c	2011-01-31 22:44:51.000000000 +0530
@@ -1,6 +1,9 @@
 /*
 
-$Log$
+$Log: placea.c,v $
+Revision 1.1.1.1  2011/01/31 17:14:51  andrey.arsirii
+
+
 Revision 1.16  2004/06/26 03:50:14  markster
 Merge source cleanups (bug #1911)
 
@@ -40,7 +43,10 @@
 
 /* 	PLACEA Version 48 */
 
-/* $Log$
+/* $Log: placea.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:51  andrey.arsirii
+/*
+/*
  * Revision 1.16  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/codecs/lpc10/placev.c asterisk-1.8.2.3.new/codecs/lpc10/placev.c
--- asterisk-1.8.2.3/codecs/lpc10/placev.c	2006-10-14 00:15:44.000000000 +0530
+++ asterisk-1.8.2.3.new/codecs/lpc10/placev.c	2011-01-31 22:44:56.000000000 +0530
@@ -1,6 +1,9 @@
 /*
 
-$Log$
+$Log: placev.c,v $
+Revision 1.1.1.1  2011/01/31 17:14:56  andrey.arsirii
+
+
 Revision 1.15  2004/06/26 03:50:14  markster
 Merge source cleanups (bug #1911)
 
@@ -37,7 +40,10 @@
 
 /* 	PLACEV Version 48 */
 
-/* $Log$
+/* $Log: placev.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:56  andrey.arsirii
+/*
+/*
  * Revision 1.15  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/codecs/lpc10/preemp.c asterisk-1.8.2.3.new/codecs/lpc10/preemp.c
--- asterisk-1.8.2.3/codecs/lpc10/preemp.c	2006-10-14 00:15:44.000000000 +0530
+++ asterisk-1.8.2.3.new/codecs/lpc10/preemp.c	2011-01-31 22:44:52.000000000 +0530
@@ -1,6 +1,9 @@
 /*
 
-$Log$
+$Log: preemp.c,v $
+Revision 1.1.1.1  2011/01/31 17:14:52  andrey.arsirii
+
+
 Revision 1.15  2004/06/26 03:50:14  markster
 Merge source cleanups (bug #1911)
 
@@ -34,7 +37,10 @@
 
 /* 	PREEMP Version 55 */
 
-/* $Log$
+/* $Log: preemp.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:52  andrey.arsirii
+/*
+/*
  * Revision 1.15  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/codecs/lpc10/prepro.c asterisk-1.8.2.3.new/codecs/lpc10/prepro.c
--- asterisk-1.8.2.3/codecs/lpc10/prepro.c	2006-10-14 00:15:44.000000000 +0530
+++ asterisk-1.8.2.3.new/codecs/lpc10/prepro.c	2011-01-31 22:44:56.000000000 +0530
@@ -1,6 +1,9 @@
 /*
 
-$Log$
+$Log: prepro.c,v $
+Revision 1.1.1.1  2011/01/31 17:14:56  andrey.arsirii
+
+
 Revision 1.15  2004/06/26 03:50:14  markster
 Merge source cleanups (bug #1911)
 
@@ -48,7 +51,10 @@
 
 /* 	PREPRO Version 48 */
 
-/* $Log$
+/* $Log: prepro.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:56  andrey.arsirii
+/*
+/*
  * Revision 1.15  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/codecs/lpc10/random.c asterisk-1.8.2.3.new/codecs/lpc10/random.c
--- asterisk-1.8.2.3/codecs/lpc10/random.c	2006-10-14 00:15:44.000000000 +0530
+++ asterisk-1.8.2.3.new/codecs/lpc10/random.c	2011-01-31 22:44:56.000000000 +0530
@@ -1,6 +1,9 @@
 /*
 
-$Log$
+$Log: random.c,v $
+Revision 1.1.1.1  2011/01/31 17:14:56  andrey.arsirii
+
+
 Revision 1.15  2004/06/26 03:50:14  markster
 Merge source cleanups (bug #1911)
 
@@ -42,7 +45,10 @@
 
 /* 	RANDOM Version 49 */
 
-/* $Log$
+/* $Log: random.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:56  andrey.arsirii
+/*
+/*
  * Revision 1.15  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/codecs/lpc10/rcchk.c asterisk-1.8.2.3.new/codecs/lpc10/rcchk.c
--- asterisk-1.8.2.3/codecs/lpc10/rcchk.c	2006-10-14 00:15:44.000000000 +0530
+++ asterisk-1.8.2.3.new/codecs/lpc10/rcchk.c	2011-01-31 22:44:54.000000000 +0530
@@ -1,6 +1,9 @@
 /*
 
-$Log$
+$Log: rcchk.c,v $
+Revision 1.1.1.1  2011/01/31 17:14:54  andrey.arsirii
+
+
 Revision 1.15  2004/06/26 03:50:14  markster
 Merge source cleanups (bug #1911)
 
@@ -34,7 +37,10 @@
 
 /* 	RCCHK Version 45G */
 
-/* $Log$
+/* $Log: rcchk.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:54  andrey.arsirii
+/*
+/*
  * Revision 1.15  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/codecs/lpc10/synths.c asterisk-1.8.2.3.new/codecs/lpc10/synths.c
--- asterisk-1.8.2.3/codecs/lpc10/synths.c	2006-10-14 00:15:44.000000000 +0530
+++ asterisk-1.8.2.3.new/codecs/lpc10/synths.c	2011-01-31 22:44:50.000000000 +0530
@@ -1,6 +1,9 @@
 /*
 
-$Log$
+$Log: synths.c,v $
+Revision 1.1.1.1  2011/01/31 17:14:50  andrey.arsirii
+
+
 Revision 1.16  2004/06/26 03:50:14  markster
 Merge source cleanups (bug #1911)
 
@@ -66,7 +69,10 @@
 
 /* 	SYNTHS Version 54 */
 
-/* $Log$
+/* $Log: synths.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:50  andrey.arsirii
+/*
+/*
  * Revision 1.16  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
@@ -192,7 +198,10 @@
 	    integer *, real *, struct lpc10_decoder_state *);
     real rci[160]	/* was [10][16] */;
 
-/* $Log$
+/* $Log: synths.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:50  andrey.arsirii
+/*
+/*
  * Revision 1.16  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
@@ -232,7 +241,10 @@
 /*   LPC Configuration parameters: */
 /* Frame size, Prediction order, Pitch period */
 /*       Arguments */
-/* $Log$
+/* $Log: synths.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:50  andrey.arsirii
+/*
+/*
  * Revision 1.16  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/codecs/lpc10/tbdm.c asterisk-1.8.2.3.new/codecs/lpc10/tbdm.c
--- asterisk-1.8.2.3/codecs/lpc10/tbdm.c	2006-10-14 00:15:44.000000000 +0530
+++ asterisk-1.8.2.3.new/codecs/lpc10/tbdm.c	2011-01-31 22:44:49.000000000 +0530
@@ -1,6 +1,9 @@
 /*
 
-$Log$
+$Log: tbdm.c,v $
+Revision 1.1.1.1  2011/01/31 17:14:49  andrey.arsirii
+
+
 Revision 1.15  2004/06/26 03:50:14  markster
 Merge source cleanups (bug #1911)
 
@@ -35,7 +38,10 @@
 
 /* 	TBDM Version 49 */
 
-/* $Log$
+/* $Log: tbdm.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:49  andrey.arsirii
+/*
+/*
  * Revision 1.15  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/codecs/lpc10/voicin.c asterisk-1.8.2.3.new/codecs/lpc10/voicin.c
--- asterisk-1.8.2.3/codecs/lpc10/voicin.c	2006-10-14 00:15:44.000000000 +0530
+++ asterisk-1.8.2.3.new/codecs/lpc10/voicin.c	2011-01-31 22:44:54.000000000 +0530
@@ -1,6 +1,9 @@
 /*
 
-$Log$
+$Log: voicin.c,v $
+Revision 1.1.1.1  2011/01/31 17:14:54  andrey.arsirii
+
+
 Revision 1.16  2004/06/26 03:50:14  markster
 Merge source cleanups (bug #1911)
 
@@ -56,7 +59,10 @@
 
 /* 	VOICIN Version 52 */
 
-/* $Log$
+/* $Log: voicin.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:54  andrey.arsirii
+/*
+/*
  * Revision 1.16  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
@@ -307,7 +313,10 @@
 
 /* 	Global Variables: */
 /*       Arguments */
-/* $Log$
+/* $Log: voicin.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:54  andrey.arsirii
+/*
+/*
  * Revision 1.16  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/codecs/lpc10/vparms.c asterisk-1.8.2.3.new/codecs/lpc10/vparms.c
--- asterisk-1.8.2.3/codecs/lpc10/vparms.c	2006-10-14 00:15:44.000000000 +0530
+++ asterisk-1.8.2.3.new/codecs/lpc10/vparms.c	2011-01-31 22:44:51.000000000 +0530
@@ -1,6 +1,9 @@
 /*
 
-$Log$
+$Log: vparms.c,v $
+Revision 1.1.1.1  2011/01/31 17:14:51  andrey.arsirii
+
+
 Revision 1.15  2004/06/26 03:50:14  markster
 Merge source cleanups (bug #1911)
 
@@ -38,7 +41,10 @@
 
 /* 	VPARMS Version 50 */
 
-/* $Log$
+/* $Log: vparms.c,v $
+/* Revision 1.1.1.1  2011/01/31 17:14:51  andrey.arsirii
+/*
+/*
  * Revision 1.15  2004/06/26 03:50:14  markster
  * Merge source cleanups (bug #1911)
  *
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/codecs/.moduleinfo asterisk-1.8.2.3.new/codecs/.moduleinfo
--- asterisk-1.8.2.3/codecs/.moduleinfo	2011-01-27 02:48:33.000000000 +0530
+++ asterisk-1.8.2.3.new/codecs/.moduleinfo	2011-11-29 19:35:14.000000000 +0530
@@ -1,10 +1,10 @@
 <category name="MENUSELECT_CODECS" displayname="Codec Translators" remove_on_change="codecs/modules.link">
+<member name="codec_a_mu" displayname="A-law and Mulaw direct Coder/Decoder" remove_on_change="codecs/codec_a_mu.o codecs/codec_a_mu.so">
+</member>
 <member name="codec_adpcm" displayname="Adaptive Differential PCM Coder/Decoder" remove_on_change="codecs/codec_adpcm.o codecs/codec_adpcm.so">
 </member>
 <member name="codec_alaw" displayname="A-law Coder/Decoder" remove_on_change="codecs/codec_alaw.o codecs/codec_alaw.so">
 </member>
-<member name="codec_a_mu" displayname="A-law and Mulaw direct Coder/Decoder" remove_on_change="codecs/codec_a_mu.o codecs/codec_a_mu.so">
-</member>
 <member name="codec_dahdi" displayname="Generic DAHDI Transcoder Codec Translator" remove_on_change="codecs/codec_dahdi.o codecs/codec_dahdi.so">
 	<depend>dahdi</depend>
 </member>
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/include/asterisk/frame.h asterisk-1.8.2.3.new/include/asterisk/frame.h
--- asterisk-1.8.2.3/include/asterisk/frame.h	2010-12-01 22:31:56.000000000 +0530
+++ asterisk-1.8.2.3.new/include/asterisk/frame.h	2011-09-16 17:26:00.000000000 +0530
@@ -261,7 +261,7 @@
 /*! iLBC Free Compression */
 #define AST_FORMAT_ILBC       (1ULL << 10)
 /*! ADPCM (G.726, 32kbps, RFC3551 codeword packing) */
-#define AST_FORMAT_G726       (1ULL << 11)
+#define AST_FORMAT_G726_32    (1ULL << 11)
 /*! G.722 */
 #define AST_FORMAT_G722       (1ULL << 12)
 /*! G.722.1 (also known as Siren7, 32kbps assumed) */
@@ -298,6 +298,17 @@
 #define AST_FORMAT_G719	      (1ULL << 32)
 /*! SpeeX Wideband (16kHz) Free Compression */
 #define AST_FORMAT_SPEEX16    (1ULL << 33)
+#define AST_FORMAT_ILBC_1     (1ULL << 34)
+/*! G726 codec set */
+#define AST_FORMAT_G726_16    (1ULL << 35)
+#define AST_FORMAT_G726_40    (1ULL << 36)
+#define AST_FORMAT_G726_24    (1ULL << 37)
+#define AST_FORMAT_G726       (AST_FORMAT_G726_32)
+/*! AMR Narrow band */
+#define AST_FORMAT_AMR        (1ULL << 38)
+/*! AMR-WB Wide/Narrow band (G.722.1) */
+#define AST_FORMAT_AMR_WB     (1ULL << 39)
+
 /*! Raw mu-law data (G.711) */
 #define AST_FORMAT_TESTLAW    (1ULL << 47)
 /*! Reserved bit - do not use */
@@ -333,6 +344,7 @@
 	AST_CONTROL_READ_ACTION = 27, /*!< Tell ast_read to take a specific action */
 	AST_CONTROL_AOC = 28,           /*!< Advice of Charge with encoded generic AOC payload */
 	AST_CONTROL_END_OF_Q = 29,		/*!< Indicate that this position was the end of the channel queue for a softhangup. */
+	AST_CONTROL_MSPD_CHANNEL_SWITCH_MODE = 30, /*! <Indicate MSPD channel module to switch LSP to VoIP or vice versa */
 };
 
 enum ast_frame_read_action {
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/include/asterisk/logger.h asterisk-1.8.2.3.new/include/asterisk/logger.h
--- asterisk-1.8.2.3/include/asterisk/logger.h	2010-06-08 20:08:18.000000000 +0530
+++ asterisk-1.8.2.3.new/include/asterisk/logger.h	2011-02-23 18:20:12.000000000 +0530
@@ -42,6 +42,9 @@
 #define VERBOSE_PREFIX_2 "  == "
 #define VERBOSE_PREFIX_3 "    -- "
 #define VERBOSE_PREFIX_4 "       > "
+#define VERBOSE_PREFIX_5 "       * "
+#define VERBOSE_PREFIX_6 "       >> "
+#define VERBOSE_PREFIX_7 "       ** "
 
 /*! \brief Used for sending a log message
 	This is the standard logger function.  Probably the only way you will invoke it would be something like this:
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/include/asterisk/mspd/channel.h asterisk-1.8.2.3.new/include/asterisk/mspd/channel.h
--- asterisk-1.8.2.3/include/asterisk/mspd/channel.h	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/include/asterisk/mspd/channel.h	2014-05-07 14:49:35.000000000 +0530
@@ -0,0 +1,121 @@
+/*
+ * Mindspeed Comcerto - Channel module for line handling.
+ *
+ *  Copyright (C) 2004 - 2011 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef _MSPD_CHANNEL_H_
+#define _MSPD_CHANNEL_H_
+
+#include <asterisk/mspd/device.h>
+#include <asterisk/mspd/queue.h>
+#include <asterisk/mspd/common.h>
+#include <asterisk/cli.h>
+#include <asterisk/udptl.h>
+
+// the type of a channel
+typedef enum mspd_channel_type {
+    MCT_VOIP = 1,
+    MCT_FOIP,
+    MCT_PART_TDM,
+    MCT_PART_RTP,
+    MCT_VOIPOSHM,
+} mspd_channel_type_t;
+
+typedef enum mspd_tone {
+    DC_TONE_OFF,
+    DC_TONE_BUSY,
+    DC_TONE_DIAL,
+    DC_TONE_ANSWER,
+    DC_TONE_INDI,
+    DC_TONE_HOLD,
+} mspd_tone_t;
+
+struct t38_profile {                                                                                                                                                                                                                                                                   
+    struct ast_control_t38_parameters ast;
+    int max_datagram;
+};
+
+typedef struct mspd_channel mspd_channel_t;
+typedef void (*mspd_channel_event_callback_t) (mspd_channel_t *chan, const vapi_queue_element_t *item);
+typedef void (*mspd_channel_destructor_t) (mspd_channel_t *chan);
+
+mspd_channel_t * mspd_channel_create(mspd_device_t *dev, 
+				     mspd_channel_type_t type, 
+				     format_t ast_format,
+				     Boolean vad,
+				     int sizeof_pvt,
+				     mspd_channel_event_callback_t event_callback,
+				     mspd_channel_destructor_t destructor);
+void* mspd_channel_get_pvt(mspd_channel_t *chan);
+void mspd_channel_set_pvt(mspd_channel_t *channel, void* pvt);
+const char *mspd_channel_type2text(mspd_channel_type_t type);
+void mspd_channel_destroy(mspd_channel_t *channel);
+int mspd_channel_set_coding_defaults (mspd_channel_t *channel);
+int mspd_channel_set_ip_header(mspd_channel_t *channel,
+                               struct ast_sockaddr const *src,
+                               struct ast_sockaddr const *dst);
+int mspd_channel_send_ud_cmd (const mspd_channel_t *channel,
+                              U16 func_code,
+                              Boolean enable);
+int mspd_channel_set_dtmfpar (mspd_channel_t *channel);
+int mspd_channel_set_tonectrl (mspd_channel_t *channel);
+int mspd_channel_start_conf_tx (mspd_channel_t *channel);
+int mspd_channel_start_tx (mspd_channel_t *channel);
+int mspd_channel_stop_tx (mspd_channel_t *channel);
+int mspd_channel_enable_foip (mspd_channel_t *channel);
+int mspd_channel_enable (mspd_channel_t *channel, format_t ast_format_id);
+int mspd_channel_disable(mspd_channel_t *channel);
+int mspd_channel_set_rtp_peer (mspd_channel_t *channel,
+            		       struct ast_rtp_instance *intern_rtp,
+            		       struct ast_rtp_instance *rtp,
+            		       format_t prefered_codec);
+int mspd_channel_play_dtmftone (mspd_channel_t *channel, char digit);
+int mspd_channel_set_tone (mspd_channel_t *channel, mspd_tone_t tone);
+mspd_tone_t mspd_channel_get_tone (const mspd_channel_t *channel);
+int mspd_channel_mute_participant (mspd_channel_t *channel, Boolean do_mute);
+int mspd_channel_hold_participant (mspd_channel_t *channel, Boolean do_hold);
+int mspd_channel_set_toneopt (mspd_channel_t *channel);
+int mspd_channel_payload_manager (mspd_channel_t *channel);
+format_t mspd_channel_get_format(const mspd_channel_t *channel);
+const char * mspd_channel_get_name(const mspd_channel_t *channel);
+U16 mspd_channel_get_id(const mspd_channel_t *channel);
+int mspd_channel_put_event(mspd_channel_t* channel, queue_item_t item);
+mspd_channel_t *mspd_channel_find_locked(CONNID id);
+int mspd_channel_lock(mspd_channel_t *channel);
+void mspd_channel_unlock(mspd_channel_t *channel);
+mspd_device_t *mspd_channel_get_device(mspd_channel_t *channel);
+mspd_channel_type_t mspd_channel_get_type(mspd_channel_t *channel);
+void mspd_channel_set_type(mspd_channel_t *channel, mspd_channel_type_t type);
+int mspd_channel_set_faxsplopt (mspd_channel_t * channel);
+Boolean mspd_channel_cid_gen_in_progress(const mspd_channel_t *channel);
+Boolean mspd_channel_get_passthru_mode(const mspd_channel_t *channel);
+int mspd_channel_configure_rsp_part (mspd_channel_t *channel);
+int mspd_channel_send_caller_id (mspd_channel_t *channel);
+int mspd_channel_prepare_callerid_msg (mspd_channel_t *channel,
+                                       struct ast_channel *ast,
+                                       Boolean is_onhook);
+int mspd_channel_echocan_manager (const mspd_channel_t *channel, const mspd_echocan_t *echocan);
+int mspd_channel_switch_to_voip(mspd_channel_t *channel, BandMode wideband, U16 base_timeslot);
+int mspd_channel_switch_to_lsp_part(mspd_channel_t *channel, BandMode wideband, U16 base_timeslot, U16 conf_id);
+int mspd_channel_switch_to_voip_and_configure (mspd_channel_t *channel, 
+					       BandMode wideband, 
+					       U16 base_timeslot, 
+					       const mspd_echocan_t* echocan, 
+					       struct ast_rtp_instance *rtp);
+int mspd_channel_switch_to_foip_and_configure (mspd_channel_t *channel, struct t38_profile *profile, struct ast_udptl *udptl);
+int mspd_channel_configure_voip (mspd_channel_t *channel, const mspd_echocan_t *echocan);
+int mspd_channel_configure_lsp_part (mspd_channel_t *channel, const mspd_echocan_t *echocan);
+int mspd_channel_bwe_manager (mspd_channel_t *channel, BandMode tdm_band, BandMode mixer_band, mspd_bwe_t *bwe, Boolean apply);
+char *mspd_channel_cli_send_cmd (struct ast_cli_entry *e, int cmd, struct ast_cli_args *a);
+mspd_channel_t *mspd_channel_find_by_name_locked(const char* name);
+int mspd_channel_switch_to_passthru_mode (mspd_channel_t *channel);
+int mspd_channel_set_passthru_autoswitch (mspd_channel_t *channel);
+
+#endif
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/include/asterisk/mspd/cmmlib.h asterisk-1.8.2.3.new/include/asterisk/mspd/cmmlib.h
--- asterisk-1.8.2.3/include/asterisk/mspd/cmmlib.h	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/include/asterisk/mspd/cmmlib.h	2012-02-17 21:59:26.000000000 +0530
@@ -0,0 +1,39 @@
+#ifndef _MSPD_CMMLIB_H
+#define _MSPD_CMMLIB_H
+
+#include <netinet/in.h>
+#include <libcmm.h>
+
+////// =====================================================
+////// MSPD CMM RTP CUT-THROUGH library
+////// =====================================================
+
+#define PROTO_RTP_UDP                    17
+
+#define CMM_FPP_RTP_CUT_THROUGH          3
+
+#define OK                               0
+#define ERR_FPP_SOCKET_OPEN              1
+#define ERR_FPP_SOCKET_UPDATE            2
+#define ERR_FPP_SOCKET_CLOSE             3
+#define ERR_FPP_SESSION_OPEN             4
+#define ERR_FPP_SESSION_CONTROL          5
+#define ERR_FPP_SESSION_CLOSE            6
+#define ERR_CHANNEL_NOT_SUPPORTED        10
+#define ERR_BAD_RTP                      20
+#define ERR_FPP_SOCKET_NOT_OPENED        30
+#define ERR_FPP_SOCKET_BAD               31
+
+int ast_cmm_fpp_create_socket (int sock_type, struct sockaddr_in *us);
+int ast_cmm_fpp_update_socket (int sock_id, struct sockaddr_in *peer);
+void ast_cmm_fpp_close_socket (int sock_id);
+
+int ast_cmm_fpp_create_rtp_session (int sockA_id, int sockB_id);
+void ast_cmm_fpp_close_rtp_session (int rtp_call_id);
+
+int ast_cmm_send_check_cmd (cmm_handle_t *cmm_handle, cmm_command_t *cmm_cmd);
+
+
+////// =====================================================
+
+#endif
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/include/asterisk/mspd/common.h asterisk-1.8.2.3.new/include/asterisk/mspd/common.h
--- asterisk-1.8.2.3/include/asterisk/mspd/common.h	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/include/asterisk/mspd/common.h	2011-12-26 21:48:05.000000000 +0530
@@ -0,0 +1,142 @@
+#ifndef MSPD_COMMON_H
+#define MSPD_COMMON_H
+
+#include <vapi/vapi.h> 
+
+#include "asterisk/rtp_engine.h"
+
+#define MSPD_CONFIG_FILE "mspd.conf"
+
+#define EC_TYPE_STD  0
+#define EC_TYPE_DFEC 1
+
+#define BWE_TO_TDM      0
+#define BWE_TO_PACKET   1
+#define BWE_NO_ENCHANCEMENT 2
+
+typedef enum {
+    StdEC = EC_TYPE_STD,
+    DFEC = EC_TYPE_DFEC
+} ECType;
+
+// AMR speed rate table.
+enum bitrates_codec_amr {
+    amr4_75 = 0,    // 000b = 4.75 kbit/s
+    amr5_15 = 1,    // 001b = 5.15 kbit/s
+    amr5_90 = 2,    // 010b = 5.90 kbit/s
+    amr6_70 = 3,    // 011b = 6.70 kbit/s
+    amr7_40 = 4,    // 100b = 7.40 kbit/s
+    amr7_95 = 5,    // 101b = 7.95 kbit/s
+    amr10_2 = 6,    // 110b = 10.2 kbit/s
+    amr12_2 = 7     // 111b = 12.2 kbit/s(default)
+};
+
+// AMR-WB (G.722.2) speed rate table.
+enum bitrates_codec_amr_wb {
+    amrwb6_60  = 0,  // 0000b = 6.60 kbit/s
+    amrwb8_85  = 1,  // 0001b = 8.85 kbit/s
+    amrwb12_65 = 2,  // 0010b = 12.65 kbit/s
+    amrwb14_25 = 3,  // 0011b = 14.25 kbit/s
+    amrwb15_85 = 4,  // 0100b = 15.85 kbit/s
+    amrwb18_25 = 5,  // 0101b = 18.25 kbit/s
+    amrwb19_85 = 6,  // 0110b = 19.85 kbit/s
+    amrwb23_05 = 7,  // 0111b = 23.05 kbit/s
+    amrwb23_85 = 8   // 1000b = 23.85 kbit/s(default)
+};
+
+typedef enum {
+    Narrow,
+    Wide,
+    NoBand
+} BandMode;
+
+typedef struct mspd_dfectune {
+    S16                 ec_tx_in_scf_frc;      //0
+    S16                 ec_tx_in_scf_int;      //1
+    S16                 ec_tx_flt_coef;        //2
+    S16                 ec_tx_det_thr_le;      //3
+    S16                 ec_tx_out_scf_frc;     //4
+    S16                 ec_tx_out_scf_int;     //5
+    S16                 ec_rx_in_scf_frc;      //6
+    S16                 ec_rx_in_scf_int;      //7
+    S16                 ec_rx_flt_coef;        //8
+    S16                 ec_rx_det_thr;         //9
+    S16                 ec_rx_out_scf_frc;     //10
+    S16                 ec_rx_out_scf_int;     //11
+    S16                 ec_minerl;             //12
+    U16                 ec_db_hng_reset;       //13
+    S16                 ec_db_adj;             //14
+    U16                 ec_nl_hng;             //15
+    U16                 ec_nl_hng_se;          //16
+    U16                 ec_nl_inc;             //17
+    U16                 ec_nl_inc_se;          //18
+    S16                 ec_flt_res_sme_nl;     //19
+    S16                 ec_flt_cng_sme_nl;     //20
+    S16                 ec_tx_out_thr_dbt_nl;  //21
+    S16                 ec_tx_out_thr_min_nl;  //22
+    S16                 ec_tx_out_pscf_nl;     //23
+    S16                 ec_tx_c3_nl;           //24
+    S16                 ec_tx_c4_nl;           //25
+    S16                 ec_tx_nos_scf_nl;      //26
+    S16                 ec_tx_scf_max_nl;      //27
+    S16                 ec_tx_out_pwr_adj_nl;  //28
+    U16                 ec_tx_out_thr_del_nl;  //29
+    S16                 ec_nlp_off_inc;        //30
+    U16                 ec_flt_chk_rst1;       //31
+    S16                 ec_flt_rin_min;        //32
+    S16                 ec_flt_thr1;           //33
+    S16                 ec_flt_scf1;           //34
+    S16                 ec_flt_scf2;           //35
+    S16                 ec_flt_epc3;           //36
+    S16                 ec_flt_scf3;           //37
+    S16                 ec_flt_thr4;           //38
+    S16                 ec_flt_thr2;           //39
+    U16                 ec_flt_cnt3;           //40
+    S16                 ec_flt_scf4;           //41
+    S16                 ec_flt_scf5;           //42
+    S16                 ec_flt_nos_scf_min;    //43
+    S16                 ec_dat_rx_scf_min_st;  //44
+    S16                 ec_dat_rese_lev;       //45
+    S16                 ec_dat_rese_dt_lev;    //46
+    S16                 ec_dat_rx_lev;         //47
+    S16                 ec_dat_tx_lev;         //48
+    S16                 ec_tx_det_thr_se;      //49
+    S16                 ec_tx_out_thr_min_nl2; //50
+    S16                 ec_tx_out_min_tx_nl2;  //51
+    U16                 ec_tx_out_inc_nl2;     //52
+    U16                 ec_tx_out_cnt_rst_nl2; //53
+    S16                 ec_dat_rx_mxl;         //54
+    S16                 ec_flt_rxm_sme_nl;     //55
+    S16                 ec_dat_rx_scf_min_dt;  //56
+    S16                 ec_tx_acom_nl;         //57
+    S16                 ec_tx_rlim_nl;         //58
+    S16                 ec_max_noise;          //59
+} mspd_dfectune_t;
+
+// global echocan setting across all phones by default
+typedef struct mspd_echocan {
+    U16                 echocan_ctrl;
+    U16                 enh_echocan_ctrl;
+    U16                 dualfilterechocan;
+    U16                 dfec_ctrl;
+    U16                 dfectune_default;
+    mspd_dfectune_t     dfectune_params;
+} mspd_echocan_t;
+
+// global bandwidth extension setting across all phones by default
+typedef struct mspd_bwe {
+    Boolean             is_bwe_enabled;
+    Boolean             bwe_master;
+    U8                  bwe_direction;
+    U8                  bwe_high_band;
+    U8                  bwe_low_band;
+} mspd_bwe_t;
+
+void mspd_info_about_rtp(struct ast_rtp_instance *rtp);
+
+#define save_strdup(p, v) ast_do_save_strdup((p), (v), __func__, __LINE__) 
+int ast_do_save_strdup  (char **p, const char *v, char const *func, int line);
+
+int ast_parse_mac    (uint8_t * mac, struct ast_variable *v);
+
+#endif
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/include/asterisk/mspd/conference.h asterisk-1.8.2.3.new/include/asterisk/mspd/conference.h
--- asterisk-1.8.2.3/include/asterisk/mspd/conference.h	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/include/asterisk/mspd/conference.h	2011-09-28 21:57:43.000000000 +0530
@@ -0,0 +1,22 @@
+#ifndef _MSPD_CONFERENCE_H_
+#define _MSPD_CONFERENCE_H_
+
+#include <asterisk/mspd/channel.h>
+#include <asterisk/mspd/common.h>
+
+typedef struct mspd_conference mspd_conference_t;
+
+mspd_conference_t * mspd_conference_create (mspd_device_t *dev, BandMode conf_mode);
+void mspd_conference_destroy (mspd_conference_t *conference);
+mspd_channel_t *mspd_conference_create_rtp_participant(mspd_conference_t           	*conference,
+                                    		       format_t                    	ast_format,
+                                    		       struct ast_rtp_instance     	*rtp);
+const char *mspd_conference_get_name(const mspd_conference_t *conference);
+U16 mspd_conference_get_participants_count(const mspd_conference_t *conference);
+mspd_device_t *mspd_conference_get_device(mspd_conference_t *conference);
+U16 mspd_conference_get_id(const mspd_conference_t *conference);
+Boolean mspd_conference_get_mixer(const mspd_conference_t *conference);
+void mspd_conference_inc_participants(mspd_conference_t *conf);
+void mspd_conference_dec_participants(mspd_conference_t *conf);
+
+#endif
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/include/asterisk/mspd/defaults.h asterisk-1.8.2.3.new/include/asterisk/mspd/defaults.h
--- asterisk-1.8.2.3/include/asterisk/mspd/defaults.h	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/include/asterisk/mspd/defaults.h	2013-03-01 13:43:02.000000000 +0530
@@ -0,0 +1,577 @@
+/*
+ * Mindspeed Comcerto - Channel module for line handling.
+ *
+ *  Copyright (C) 2004 - 2011 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef _MSPD_DEFAULTS_H_
+#define _MSPD_DEFAULTS_H_
+
+// ===============================================================================================
+//  MSPD Channel module default values */
+
+const static U8 DEVICE_CONTROL_MAC [6] = {0x00,0x11,0x22,0x33,0x44,0x55}; // MSP  MAC comes from MSPD.conf
+const static U8 HOST_CONTROL_MAC   [6] = {0x00,0xAA,0xBB,0xCC,0xDD,0xEE}; // VED1 ETH1 comes from MSPD.conf
+const static U8 DEVICE_HARD_MAC    [6] = {0xFF,0xEE,0xDD,0xCC,0xBB,0xAA}; // not used in Master mode
+const static U8 HOST_CONTROL_INTERFACE [] = "eth1";
+
+#define DEVICE_ID   DEV_TYPE_M83XXX                                 // Can be any value
+
+// maximum values for configuration items (can be increased if necessary)
+#define MSPD_MAX_DEVICES        (1)
+#define MSPD_MAX_BUSES          (4)
+#define MSPD_MAX_PHONES         (8)
+#define MSPD_MAX_CHANNELS       (24)
+
+// =============================================================================
+//  MSPD Channel module config file default values */
+
+#define DEF_GLOBAL_IP_ADDR            "169.254.0.1"
+#define DEF_DEVICE_IP_ADDR            "169.254.0.2"
+#define DEF_UD_SRC_PORT               30000
+#define DEF_UD_DST_PORT               DEF_UD_SRC_PORT
+#define DEF_UD_IP_ADDR                DEF_DEVICE_IP_ADDR
+#define DEF_PICKUP_GROUP              "1"
+#define DEF_CALL_GROUP                "1"
+#define DEF_INTER_DIGIT_TIMEOUT       1300
+#define DEF_DIAL_TIMEOUT              8000
+#define DEF_FXO_CALL_DELAY            1000
+
+#define DEF_DEVICE_NAME               "msp"
+#define DEF_DEVICE_SRC_MAC_ADDR       "00:AA:BB:CC:DD:EE"
+#define DEF_DEVICE_DST_MAC_ADDR       "00:AA:BB:CC:DD:EE"
+#define DEF_CONTEXT                   "default"
+
+#define DEF_ANALOG_PHONE_NAME         "analog"
+
+#define DEF_DSP_ACP                   0
+#define DEF_VAD                       0
+#define DEF_UD_ENABLE                 0
+
+// =============================================================================
+// Echocan defaults
+#define DEF_ECHOCAN_CTRL              0x9001
+#define DEF_ENH_ECHOCAN_CTRL          0x9001
+#define DEF_DFEC_CTRL                 0x8007
+#define DEF_DFEC_TUNE_CONFIG          "Default"
+
+// =============================================================================
+//  TDM bus defaults
+#define DEF_TDM_TX_ORDER                    1
+#define DEF_TDM_RX_POLARITY                 0
+#define DEF_TDM_TX_POLARITY                 0
+#define DEF_TDM_RX_CLOCK_MODE               0
+#define DEF_TDM_TX_CLOCK_MODE               0
+#define DEF_TDM_RX_CLOCK_EDGE               0
+#define DEF_TDM_TX_CLOCK_EDGE               1
+#define DEF_TDM_FRAME_EDGE                  1
+#define DEF_TDM_NUMBER_OF_TS                32
+#define DEF_TDM_INVERTED_FRAME_SIGNAL       0
+#define DEF_TDM_BIT_ORDER_RECEIVE           1
+#define DEF_NUM_TDM_CLK_CYCLES_DELAY_TX     0
+#define DEF_NUM_TDM_CLK_CYCLES_DELAY_RX     0
+
+#define DEF_TDMBUS_NAME                     "SLIC"
+#define DEF_BUS_NUMBER_OF_LINES             5
+#define DEF_BUS_ID                          0
+#define DEF_BUS_IS_TRUNK                    0
+
+
+/* =============================================================================
+ *  VoIP channel voice-options (with/without packet generation enabled) */
+
+// line-side(!) default coding format for 8-bit PCM samples over a TDM slot
+// (influences SUPVSR_SET_PCM_LAW and VOIP_VCEOPT)
+// false -> mu-law
+// true  -> A-law
+#define MSPD_PCM_DEFAULT_IS_ALAW    (0)
+
+#if MSPD_PCM_DEFAULT_IS_ALAW
+//#define DEF_ALLOWED_CODECS    "alaw,ulaw,g723,g722,g729,iLBC,iLBC_1,g726_32,g726_40,g726_16,g726_24,amr,amr_wb"
+#define DEF_ALLOWED_CODECS	"alaw,ulaw"
+#else
+//#define DEF_ALLOWED_CODECS    "ulaw,alaw,g723,g722,g729,iLBC,iLBC_1,g726_32,g726_40,g726_16,g726_24,amr,amr_wb"
+#define DEF_ALLOWED_CODECS	"ulaw,alaw"
+#endif
+
+// G.711 codec with default law
+#define MSPD_DEFAULT_G711 \
+    (MSPD_PCM_DEFAULT_IS_ALAW ? AST_FORMAT_ALAW : AST_FORMAT_ULAW)
+
+// default codec used by MSPD channel (has to be understood by Asterisk)
+#define MSPD_DEFAULT_CODEC      MSPD_DEFAULT_G711
+
+// This *must* match the actual encoding used by the 'other' side on the
+// TDM-bus, i.e. a SLIC has to be configured to use the correct law, the country
+// determines if ISDN uses A-law or -law, ...
+#define PCM_CODING                (MSPD_PCM_DEFAULT_IS_ALAW ? 0x0000 : 0x0001)
+
+// note, that Asterisk's chan_sip doesn't support silence suppression at all!
+#define MSPD_VOICE_OPTIONS_TX_ENABLED ( \
+    0x1400 |                            \
+    0x0000 |                            \
+    0x0020 |                            \
+    0x0010 |                            \
+    0x0000 |                            \
+    0x0000 |                            \
+    0x0000 |                            \
+    PCM_CODING                          \
+)
+#define MSPD_VOICE_OPTIONS_TX_DISABLED  \
+    (MSPD_VOICE_OPTIONS_TX_ENABLED |    \
+     0x0008)             \
+
+// =============================================================================
+//  FAX Defines
+#define FAX_STATE_IDLE                     0x00
+#define FAX_STATE_NO_SIG                   0x01
+#define FAX_STATE_CNG_RCVD_FRM_PCM         0x02
+#define FAX_STATE_CNG_SNT_TO_PCM           0x03
+#define FAX_STATE_CED_RCVD_FRM_PCM         0x04
+#define FAX_STATE_CED_SNT_TO_PCM           0x05
+#define FAX_STATE_V21_CH2_DEMOD            0x06
+#define FAX_STATE_V21_CH2_REMOD            0x07
+#define FAX_STATE_V27_TER_2400_DEMOD       0x08
+#define FAX_STATE_V27_TER_2400_REMOD       0x09
+#define FAX_STATE_V27_TER_4800_DEMOD       0x0A
+#define FAX_STATE_V27_TER_4800_REMOD       0x0B
+#define FAX_STATE_V29_7200_DEMOD           0x0C
+#define FAX_STATE_V29_7200_REMOD           0x0D
+#define FAX_STATE_V29_9600_DEMOD           0x0E
+#define FAX_STATE_V29_9600_REMOD           0x0F
+#define FAX_STATE_V17_7200_SH_TRN_DEMOD    0x10
+#define FAX_STATE_V17_7200_SH_TRN_REMOD    0x11
+#define FAX_STATE_V17_7200_LNG_TRN_DEMOD   0x12
+#define FAX_STATE_V17_7200_LNG_TRN_REMOD   0x13
+#define FAX_STATE_V17_9600_SH_TRN_DEMOD    0x14
+#define FAX_STATE_V17_9600_SH_TRN_REMOD    0x15
+#define FAX_STATE_V17_9600_LNG_TRN_DEMOD   0x16
+#define FAX_STATE_V17_9600_LNG_TRN_REMOD   0x17
+#define FAX_STATE_V17_12000_SH_TRN_DEMOD   0x18
+#define FAX_STATE_V17_12000_SH_TRN_REMOD   0x19
+#define FAX_STATE_V17_12000_LNG_TRN_DEMOD  0x1A
+#define FAX_STATE_V17_12000_LNG_TRN_REMOD  0x1B
+#define FAX_STATE_V17_14400_SH_TRN_DEMOD   0x1C
+#define FAX_STATE_V17_14400_SH_TRN_REMOD   0x1D
+#define FAX_STATE_V17_14400_LNG_TRN_DEMOD  0x1E
+#define FAX_STATE_V17_14400_LNG_TRN_REMOD  0x1F
+
+//T.30 Message Facsimile Control Field (FCF)
+#define FAX_CTRL_STATE_00 0x00
+#define FAX_CTRL_STATE_DIS 0x01
+#define FAX_CTRL_STATE_CSI 0x02
+#define FAX_CTRL_STATE_NSF 0x04
+#define FAX_CTRL_STATE_CFR 0x21
+#define FAX_CTRL_STATE_FTT 0x22
+#define FAX_CTRL_STATE_MCF 0x31
+#define FAX_CTRL_STATE_RTN 0x32
+#define FAX_CTRL_STATE_RTP 0x33
+#define FAX_CTRL_STATE_DCN_1 0x5F
+#define FAX_CTRL_STATE_DCN_2 0xDF
+#define FAX_CTRL_STATE_7E 0x7E
+#define FAX_CTRL_STATE_7F 0x7F
+#define FAX_CTRL_STATE_DCS 0xC1
+#define FAX_CTRL_STATE_TSI 0xC2
+#define FAX_CTRL_STATE_EOM 0xF1
+#define FAX_CTRL_STATE_MPS 0xF2
+#define FAX_CTRL_STATE_EOP 0xF4
+
+// =============================================================================
+//  DFECTUNE Defines
+#define DEF_EC_TX_IN_SCF_FRC          0
+#define DEF_EC_TX_IN_SCF_INT          1
+#define DEF_EC_TX_FLT_COEF            8192
+#define DEF_EC_TX_DET_THR_LE          323
+#define DEF_EC_TX_OUT_SCF_FRC         0
+#define DEF_EC_TX_OUT_SCF_INT         1
+#define DEF_EC_RX_IN_SCF_FRC          0
+#define DEF_EC_RX_IN_SCF_INT          1
+#define DEF_EC_RX_FLT_COEF            8192
+#define DEF_EC_RX_DET_THR             363
+#define DEF_EC_RX_OUT_SCF_FRC         0
+#define DEF_EC_RX_OUT_SCF_INT         1
+#define DEF_EC_MINERL                 20675
+#define DEF_EC_DB_HNG_RESET           80
+#define DEF_EC_DB_ADJ                -20675
+#define DEF_EC_NL_HNG                 400
+#define DEF_EC_NL_HNG_SE              1600
+#define DEF_EC_NL_INC                 80
+#define DEF_EC_NL_INC_SE              320
+#define DEF_EC_FLT_RES_SME_NL         184
+#define DEF_EC_FLT_CNG_SME_NL         16384
+#define DEF_EC_TX_OUT_THR_DBT_NL      1463
+#define DEF_EC_TX_OUT_THR_MIN_NL      1463
+#define DEF_EC_TX_OUT_PSCF_NL        -4096
+#define DEF_EC_TX_C3_NL               24576
+#define DEF_EC_TX_C4_NL               8192
+#define DEF_EC_TX_NOS_SCF_NL          1843
+#define DEF_EC_TX_SCF_MAX_NL          3677
+#define DEF_EC_TX_OUT_PWR_ADJ_NL     -32767
+#define DEF_EC_TX_OUT_THR_DEL_NL      3
+#define DEF_EC_NLP_OFF_INC            82
+#define DEF_EC_FLT_CHK_RST1           160
+#define DEF_EC_FLT_RIN_MIN            407
+#define DEF_EC_FLT_THR1               261
+#define DEF_EC_FLT_SCF1              -32767
+#define DEF_EC_FLT_SCF2              -16384
+#define DEF_EC_FLT_EPC3               6538
+#define DEF_EC_FLT_SCF3              -16384
+#define DEF_EC_FLT_THR4               1843
+#define DEF_EC_FLT_THR2               1638
+#define DEF_EC_FLT_CNT3               3
+#define DEF_EC_FLT_SCF4              -26029
+#define DEF_EC_FLT_SCF5              -11626
+#define DEF_EC_FLT_NOS_SCF_MIN        8192
+#define DEF_EC_DAT_RX_SCF_MIN_ST      16384
+#define DEF_EC_DAT_RESE_LEV           130
+#define DEF_EC_DAT_RESE_DT_LEV        130
+#define DEF_EC_DAT_RX_LEV             2043
+#define DEF_EC_DAT_TX_LEV             324
+#define DEF_EC_TX_DET_THR_SE          115
+#define DEF_EC_TX_OUT_THR_MIN_NL2     1463
+#define DEF_EC_TX_OUT_MIN_TX_NL2      16384
+#define DEF_EC_TX_OUT_INC_NL2         2400
+#define DEF_EC_TX_OUT_CNT_RST_NL2     4800
+#define DEF_EC_DAT_RX_MXL             7241
+#define DEF_EC_FLT_RXM_SME_NL         9116
+#define DEF_EC_DAT_RX_SCF_MIN_DT      16384
+#define DEF_EC_TX_ACOM_NL             0
+#define DEF_EC_TX_RLIM_NL             0
+#define DEF_EC_MAX_NOISE              13312
+
+#define SINGNED_16BIT_MIN         -32768
+#define SINGNED_16BIT_MAX         32767
+#define SINGNED_16BIT_NEG_MAX     -1
+#define SINGNED_16BIT_NEG_MIN     SINGNED_16BIT_MIN
+#define SINGNED_16BIT_POS_MAX     SINGNED_16BIT_MAX
+#define SINGNED_16BIT_POS_MIN     0
+
+#define UNSINGNED_16BIT_MIN       0
+#define UNSINGNED_16BIT_MAX       65535
+#define UNSINGNED_15BIT_MIN       0
+#define UNSINGNED_15BIT_MAX       32767
+
+#define EC_TX_IN_SCF_FRC           0
+#define EC_TX_IN_SCF_FRC_MIN       SINGNED_16BIT_MIN
+#define EC_TX_IN_SCF_FRC_MAX       SINGNED_16BIT_MAX
+
+#define EC_TX_IN_SCF_INT           1
+#define EC_TX_IN_SCF_INT_MIN       SINGNED_16BIT_MIN
+#define EC_TX_IN_SCF_INT_MAX       SINGNED_16BIT_MAX
+
+#define EC_TX_FLT_COEF             2
+#define EC_TX_FLT_COEF_MIN         SINGNED_16BIT_MIN
+#define EC_TX_FLT_COEF_MAX         SINGNED_16BIT_MAX
+
+#define EC_TX_DET_THR_LE           3
+#define EC_TX_DET_THR_LE_MIN       SINGNED_16BIT_POS_MIN
+#define EC_TX_DET_THR_LE_MAX       SINGNED_16BIT_POS_MAX
+
+#define EC_TX_OUT_SCF_FRC          4
+#define EC_TX_OUT_SCF_FRC_MIN      SINGNED_16BIT_MIN
+#define EC_TX_OUT_SCF_FRC_MAX      SINGNED_16BIT_MAX
+
+#define EC_TX_OUT_SCF_INT          5
+#define EC_TX_OUT_SCF_INT_MIN      SINGNED_16BIT_MIN
+#define EC_TX_OUT_SCF_INT_MAX      SINGNED_16BIT_MAX
+
+#define EC_RX_IN_SCF_FRC           6
+#define EC_RX_IN_SCF_FRC_MIN       SINGNED_16BIT_MIN
+#define EC_RX_IN_SCF_FRC_MAX       SINGNED_16BIT_MAX
+
+#define EC_RX_IN_SCF_INT           7
+#define EC_RX_IN_SCF_INT_MIN       SINGNED_16BIT_MIN
+#define EC_RX_IN_SCF_INT_MAX       SINGNED_16BIT_MAX
+
+#define EC_RX_FLT_COEF             8
+#define EC_RX_FLT_COEF_MIN         SINGNED_16BIT_MIN
+#define EC_RX_FLT_COEF_MAX         SINGNED_16BIT_MAX
+
+#define EC_RX_DET_THR              9
+#define EC_RX_DET_THR_MIN          SINGNED_16BIT_POS_MIN
+#define EC_RX_DET_THR_MAX          SINGNED_16BIT_POS_MAX
+
+#define EC_RX_OUT_SCF_FRC          10
+#define EC_RX_OUT_SCF_FRC_MIN      SINGNED_16BIT_MIN
+#define EC_RX_OUT_SCF_FRC_MAX      SINGNED_16BIT_MAX
+
+#define EC_RX_OUT_SCF_INT          11
+#define EC_RX_OUT_SCF_INT_MIN      SINGNED_16BIT_MIN
+#define EC_RX_OUT_SCF_INT_MAX      SINGNED_16BIT_MAX
+
+#define EC_MINERL                  12
+#define EC_MINERL_MIN              SINGNED_16BIT_POS_MIN
+#define EC_MINERL_MAX              SINGNED_16BIT_POS_MAX
+
+#define EC_DB_HNG_RESET            13
+#define EC_DB_HNG_RESET_MIN        UNSINGNED_16BIT_MIN
+#define EC_DB_HNG_RESET_MAX        UNSINGNED_16BIT_MAX
+
+#define EC_DB_ADJ                  14
+#define EC_DB_ADJ_MIN              SINGNED_16BIT_NEG_MIN
+#define EC_DB_ADJ_MAX              SINGNED_16BIT_NEG_MAX
+
+#define EC_NL_HNG                  15
+#define EC_NL_HNG_MIN              UNSINGNED_16BIT_MIN
+#define EC_NL_HNG_MAX              UNSINGNED_16BIT_MAX
+
+#define EC_NL_HNG_SE               16
+#define EC_NL_HNG_SE_MIN           UNSINGNED_16BIT_MIN
+#define EC_NL_HNG_SE_MAX           UNSINGNED_16BIT_MAX
+
+#define EC_NL_INC                  17
+#define EC_NL_INC_MIN              UNSINGNED_16BIT_MIN
+#define EC_NL_INC_MAX              UNSINGNED_16BIT_MAX
+
+#define EC_NL_INC_SE               18
+#define EC_NL_INC_SE_MIN           UNSINGNED_16BIT_MIN
+#define EC_NL_INC_SE_MAX           UNSINGNED_16BIT_MAX
+
+#define EC_FLT_RES_SME_NL          19
+#define EC_FLT_RES_SME_NL_MIN      SINGNED_16BIT_POS_MIN
+#define EC_FLT_RES_SME_NL_MAX      SINGNED_16BIT_POS_MAX
+
+#define EC_FLT_CNG_SME_NL          20
+#define EC_FLT_CNG_SME_NL_MIN      SINGNED_16BIT_POS_MIN
+#define EC_FLT_CNG_SME_NL_MAX      SINGNED_16BIT_POS_MAX
+
+#define EC_TX_OUT_THR_DBT_NL       21
+#define EC_TX_OUT_THR_DBT_NL_MIN   SINGNED_16BIT_POS_MIN
+#define EC_TX_OUT_THR_DBT_NL_MAX   SINGNED_16BIT_POS_MAX
+
+#define EC_TX_OUT_THR_MIN_NL       22
+#define EC_TX_OUT_THR_MIN_NL_MIN   SINGNED_16BIT_POS_MIN
+#define EC_TX_OUT_THR_MIN_NL_MAX   SINGNED_16BIT_POS_MAX
+
+#define EC_TX_OUT_PSCF_NL          23
+#define EC_TX_OUT_PSCF_NL_MIN      SINGNED_16BIT_NEG_MIN
+#define EC_TX_OUT_PSCF_NL_MAX      SINGNED_16BIT_NEG_MAX
+
+#define EC_TX_C3_NL                24
+#define EC_TX_C3_NL_MIN            SINGNED_16BIT_POS_MIN
+#define EC_TX_C3_NL_MAX            SINGNED_16BIT_POS_MAX
+
+#define EC_TX_C4_NL                25
+#define EC_TX_C4_NL_MIN            SINGNED_16BIT_POS_MIN
+#define EC_TX_C4_NL_MAX            SINGNED_16BIT_POS_MAX
+
+#define EC_TX_NOS_SCF_NL           26
+#define EC_TX_NOS_SCF_NL_MIN       SINGNED_16BIT_POS_MIN
+#define EC_TX_NOS_SCF_NL_MAX       SINGNED_16BIT_POS_MAX
+
+#define EC_TX_SCF_MAX_NL           27
+#define EC_TX_SCF_MAX_NL_MIN       SINGNED_16BIT_POS_MIN
+#define EC_TX_SCF_MAX_NL_MAX       SINGNED_16BIT_POS_MAX
+
+#define EC_TX_OUT_PWR_ADJ_NL       28
+#define EC_TX_OUT_PWR_ADJ_NL_MIN   SINGNED_16BIT_NEG_MIN
+#define EC_TX_OUT_PWR_ADJ_NL_MAX   SINGNED_16BIT_NEG_MAX
+
+#define EC_TX_OUT_THR_DEL_NL       29
+#define EC_TX_OUT_THR_DEL_NL_MIN   UNSINGNED_16BIT_MIN
+#define EC_TX_OUT_THR_DEL_NL_MAX   UNSINGNED_16BIT_MAX
+
+#define EC_NLP_OFF_INC             30
+#define EC_NLP_OFF_INC_MIN         SINGNED_16BIT_POS_MIN
+#define EC_NLP_OFF_INC_MAX         SINGNED_16BIT_POS_MAX
+
+#define EC_FLT_CHK_RST1            31
+#define EC_FLT_CHK_RST1_MIN        UNSINGNED_16BIT_MIN + 1
+#define EC_FLT_CHK_RST1_MAX        UNSINGNED_16BIT_MAX
+
+#define EC_FLT_RIN_MIN             32
+#define EC_FLT_RIN_MIN_MIN         SINGNED_16BIT_POS_MIN
+#define EC_FLT_RIN_MIN_MAX         SINGNED_16BIT_POS_MAX
+
+#define EC_FLT_THR1                33
+#define EC_FLT_THR1_MIN            SINGNED_16BIT_POS_MIN
+#define EC_FLT_THR1_MAX            SINGNED_16BIT_POS_MAX
+
+#define EC_FLT_SCF1                34
+#define EC_FLT_SCF1_MIN            SINGNED_16BIT_NEG_MIN
+#define EC_FLT_SCF1_MAX            SINGNED_16BIT_NEG_MAX
+
+#define EC_FLT_SCF2                35
+#define EC_FLT_SCF2_MIN            SINGNED_16BIT_NEG_MIN
+#define EC_FLT_SCF2_MAX            SINGNED_16BIT_NEG_MAX
+
+#define EC_FLT_EPC3                36
+#define EC_FLT_EPC3_MIN            SINGNED_16BIT_POS_MIN
+#define EC_FLT_EPC3_MAX            SINGNED_16BIT_POS_MAX
+
+#define EC_FLT_SCF3                37
+#define EC_FLT_SCF3_MIN            SINGNED_16BIT_NEG_MIN
+#define EC_FLT_SCF3_MAX            SINGNED_16BIT_NEG_MAX
+
+#define EC_FLT_THR4                38
+#define EC_FLT_THR4_MIN            SINGNED_16BIT_POS_MIN
+#define EC_FLT_THR4_MAX            SINGNED_16BIT_POS_MAX
+
+#define EC_FLT_THR2                39
+#define EC_FLT_THR2_MIN            SINGNED_16BIT_POS_MIN
+#define EC_FLT_THR2_MAX            SINGNED_16BIT_POS_MAX
+
+#define EC_FLT_CNT3                40
+#define EC_FLT_CNT3_MIN            UNSINGNED_16BIT_MIN + 1
+#define EC_FLT_CNT3_MAX            UNSINGNED_16BIT_MAX
+
+#define EC_FLT_SCF4                41
+#define EC_FLT_SCF4_MIN            SINGNED_16BIT_NEG_MIN
+#define EC_FLT_SCF4_MAX            SINGNED_16BIT_NEG_MAX
+
+#define EC_FLT_SCF5                42
+#define EC_FLT_SCF5_MIN            SINGNED_16BIT_NEG_MIN
+#define EC_FLT_SCF5_MAX            SINGNED_16BIT_NEG_MAX
+
+#define EC_FLT_NOS_SCF_MIN         43
+#define EC_FLT_NOS_SCF_MIN_MIN     SINGNED_16BIT_POS_MIN
+#define EC_FLT_NOS_SCF_MIN_MAX     SINGNED_16BIT_POS_MAX
+
+#define EC_DAT_RX_SCF_MIN_ST       44
+#define EC_DAT_RX_SCF_MIN_ST_MIN   SINGNED_16BIT_POS_MIN
+#define EC_DAT_RX_SCF_MIN_ST_MAX   SINGNED_16BIT_POS_MAX
+
+#define EC_DAT_RESE_LEV            45
+#define EC_DAT_RESE_LEV_MIN        SINGNED_16BIT_POS_MIN
+#define EC_DAT_RESE_LEV_MAX        SINGNED_16BIT_POS_MAX
+
+#define EC_DAT_RESE_DT_LEV         46
+#define EC_DAT_RESE_DT_LEV_MIN     SINGNED_16BIT_POS_MIN
+#define EC_DAT_RESE_DT_LEV_MAX     SINGNED_16BIT_POS_MAX
+
+#define EC_DAT_RX_LEV              47
+#define EC_DAT_RX_LEV_MIN          SINGNED_16BIT_POS_MIN
+#define EC_DAT_RX_LEV_MAX          SINGNED_16BIT_POS_MAX
+
+#define EC_DAT_TX_LEV              48
+#define EC_DAT_TX_LEV_MIN          SINGNED_16BIT_POS_MIN
+#define EC_DAT_TX_LEV_MAX          SINGNED_16BIT_POS_MAX
+
+#define EC_TX_DET_THR_SE           49
+#define EC_TX_DET_THR_SE_MIN       SINGNED_16BIT_POS_MIN
+#define EC_TX_DET_THR_SE_MAX       SINGNED_16BIT_POS_MAX
+
+#define EC_TX_OUT_THR_MIN_NL2      50
+#define EC_TX_OUT_THR_MIN_NL2_MIN  SINGNED_16BIT_POS_MIN
+#define EC_TX_OUT_THR_MIN_NL2_MAX  SINGNED_16BIT_POS_MAX
+
+#define EC_TX_OUT_MIN_TX_NL2       51
+#define EC_TX_OUT_MIN_TX_NL2_MIN   SINGNED_16BIT_POS_MIN
+#define EC_TX_OUT_MIN_TX_NL2_MAX   SINGNED_16BIT_POS_MAX
+
+#define EC_TX_OUT_INC_NL2          52
+#define EC_TX_OUT_INC_NL2_MIN      UNSINGNED_16BIT_MIN
+#define EC_TX_OUT_INC_NL2_MAX      UNSINGNED_16BIT_MAX
+
+#define EC_TX_OUT_CNT_RST_NL2      53
+#define EC_TX_OUT_CNT_RST_NL2_MIN  UNSINGNED_16BIT_MIN
+#define EC_TX_OUT_CNT_RST_NL2_MAX  UNSINGNED_16BIT_MAX
+
+#define EC_DAT_RX_MXL              54
+#define EC_DAT_RX_MXL_MIN          SINGNED_16BIT_POS_MIN
+#define EC_DAT_RX_MXL_MAX          SINGNED_16BIT_POS_MAX
+
+#define EC_FLT_RXM_SME_NL          55
+#define EC_FLT_RXM_SME_NL_MIN      SINGNED_16BIT_POS_MIN
+#define EC_FLT_RXM_SME_NL_MAX      SINGNED_16BIT_POS_MAX
+
+#define EC_DAT_RX_SCF_MIN_DT       56
+#define EC_DAT_RX_SCF_MIN_DT_MIN   SINGNED_16BIT_POS_MIN
+#define EC_DAT_RX_SCF_MIN_DT_MAX   SINGNED_16BIT_POS_MAX
+
+#define EC_TX_ACOM_NL              57
+#define EC_TX_ACOM_NL_MIN          SINGNED_16BIT_POS_MIN
+#define EC_TX_ACOM_NL_MAX          SINGNED_16BIT_POS_MAX
+
+#define EC_TX_RLIM_NL              58
+#define EC_TX_RLIM_NL_MIN          SINGNED_16BIT_POS_MIN
+#define EC_TX_RLIM_NL_MAX          SINGNED_16BIT_POS_MAX
+
+#define EC_MAX_NOISE               59
+#define EC_MAX_NOISE_MIN           SINGNED_16BIT_POS_MIN
+#define EC_MAX_NOISE_MAX           SINGNED_16BIT_POS_MAX
+
+#define MAX_DFECTUNE_PARAM         60
+
+#define SPU_ECHOCAN_CTRL                 0x0001
+#define SPU_VOICE_SIL_DET_IND            0x0002
+#define SPU_CALLERID_DET_ENA             0x0004
+#define SPU_IP_INTF_TONE_DET             0x0040
+#define SPU_DUALFILTER_ECHOCAN           0x1000
+
+#define DEF_BWE_HIGH_BAND             4
+#define DEF_BWE_LOW_BAND              5
+#define BWE_HIGH_BAND_MAX             10
+#define BWE_LOW_BAND_MAX              10
+
+// ===============================================================================================
+// Const static array containing dtmf frequencies
+
+//const mspd_dtmf_freq_t dtmf_tones[16] =
+//{
+//    {0x03AD,0x0538},  /*0*/
+//    {0x02B9,0x04B9},  /*1*/
+//    {0x02B9,0x0538},  /*2*/
+//    {0x02B9,0x05C5},  /*3*/
+//    {0x0302,0x04B9},  /*4*/
+//    {0x0302,0x0538},  /*5*/
+//    {0x0302,0x05C5},  /*6*/
+//    {0x0354,0x04B9},  /*7*/
+//    {0x0354,0x0538},  /*8*/
+//    {0x0354,0x05C5},  /*9*/
+//    {0x02B9,0x0661},  /*A*/
+//    {0x0302,0x0661},  /*B*/
+//    {0x0354,0x0661},  /*C*/
+//    {0x03AD,0x0661},  /*D*/
+//    {0x03AD,0x04B9},  /***/
+//    {0x03AD,0x05C5}   /*#*/
+//};
+
+// ===============================================================================================
+// Codec defines
+
+#define MSPD_MAX_BUF    20
+
+// Raw mu-law data (G.711 64 kbps)          => AST_FORMAT_ULAW      PT = 0
+// ADPCM (G.726, 32kbps)                    => AST_FORMAT_G726      PT = 2
+// G.723.1 compression (6.3 kbps)           => AST_FORMAT_G723_1    PT = 4
+// Raw A-law data (G.711 64 kbps)           => AST_FORMAT_ALAW      PT = 8
+// ADPCM(G.722, 64 kbps)                    => AST_FORMAT_G722      PT = 9
+// G.729A audio (8 kbps)                    => AST_FORMAT_G729A     PT = 18 = 0x12
+// iLBC Free Compression 15.20kbps          => AST_FORMAT_ILBC_1    PT = 29 = 0x1D
+// iLBC Free Compression 13.33kbps          => AST_FORMAT_ILBC      PT = 30 = 0x1E
+// Adaptive Multi Rate (AMR, G.722.1)       => AST_FORMAT_AMR       PT = 39 = 0x27
+// AMR WideBand (AMR-WB, G.722.2)           => AST_FORMAT_AMR_WB    PT = 64 = 0x40
+// ADPCM (G.726, 40 kbps)                   => AST_FORMAT_G726_40   PT = 90 = 0x5A
+// ADPCM (G.726, 16 kbps)                   => AST_FORMAT_G726_16   PT = 91 = 0x5B
+// ADPCM (G.726, 24 kbps)                   => AST_FORMAT_G726_24   PT = 92 = 0x5C
+
+/* all codecs supported by MSPD channel */
+#define AST_FORMAT_G726_SET         (AST_FORMAT_G726_32 \
+                                    |AST_FORMAT_G726_40 \
+                                    |AST_FORMAT_G726_16 \
+                                    |AST_FORMAT_G726_24)
+
+#define WIDE_BAND_CODECS            (AST_FORMAT_G722    \
+                                    |AST_FORMAT_AMR_WB)
+
+#define MSPD_SUPPORTED_CODECS       (AST_FORMAT_ULAW     \
+                                    |AST_FORMAT_ALAW     \
+                                    |AST_FORMAT_G723_1   \
+                                    |AST_FORMAT_G729A    \
+                                    |AST_FORMAT_ILBC     \
+                                    |AST_FORMAT_ILBC_1   \
+                                    |AST_FORMAT_G726_SET \
+                                    |AST_FORMAT_AMR      \
+                                    |WIDE_BAND_CODECS)
+
+#define MSPD_DEFAULT_PREFS          "ulaw,alaw,g723,g722,g729,iLBC,iLBC_1,g726_32,g726_40,g726_16,g726_24,amr,amr_wb"
+
+#endif // _MSPD_DEFAULTS_H_
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/include/asterisk/mspd/device.h asterisk-1.8.2.3.new/include/asterisk/mspd/device.h
--- asterisk-1.8.2.3/include/asterisk/mspd/device.h	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/include/asterisk/mspd/device.h	2011-05-19 18:29:32.000000000 +0530
@@ -0,0 +1,35 @@
+/*
+ * Mindspeed Comcerto - Channel module for line handling.
+ *
+ *  Copyright (C) 2004 - 2011 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef _MSPD_DEVICE_H_
+#define _MSPD_DEVICE_H_
+
+#include <asterisk/config.h>
+
+typedef struct mspd_device mspd_device_t;
+
+void mspd_device_cleanup(void);
+mspd_device_t* mspd_device_find(const char *name);
+const char* mspd_device_get_name(const mspd_device_t *dev);
+U16 mspd_device_get_channel_tag(mspd_device_t *dev);
+int mspd_device_send_ud_cmd (const mspd_device_t *dev, U16 func_code, Boolean enable);
+U16 mspd_device_get_channel_id(mspd_device_t *dev);
+U32 mspd_device_get_id(const mspd_device_t *dev);
+const struct ast_sockaddr* mspd_device_get_ipaddr(const mspd_device_t *dev);
+U16 mspd_device_get_conference_id(mspd_device_t *dev);
+mspd_device_t* mspd_device_find_by_index(unsigned index);
+int mspd_device_send_redirection_cmd(const struct ast_sockaddr* ud_dest_ipaddr, U16* enable_error);
+int mspd_device_set_spu_features_control(mspd_device_t *dev);
+int mspd_device_set_next_channel_on_acp (mspd_device_t *dev);
+int mspd_device_config(struct ast_config *cfg, char *cat);
+
+#endif
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/include/asterisk/mspd/global.h asterisk-1.8.2.3.new/include/asterisk/mspd/global.h
--- asterisk-1.8.2.3/include/asterisk/mspd/global.h	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/include/asterisk/mspd/global.h	2011-12-26 21:48:05.000000000 +0530
@@ -0,0 +1,40 @@
+/*
+ * Mindspeed Comcerto - Channel module for line handling.
+ *
+ *  Copyright (C) 2004 - 2011 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef _MSPD_GLOBAL_H_
+#define _MSPD_GLOBAL_H_
+
+#include "asterisk.h"
+#include "asterisk/config.h"
+
+#include <asterisk/mspd/common.h>
+
+typedef enum mspd_fax_mode {
+    MSPD_FAXMODE_AUTO,
+    MSPD_FAXMODE_T38,
+    MSPD_FAXMODE_PASSTHRU,
+} mspd_fax_mode_t;
+
+const struct ast_sockaddr* mspd_global_get_ipaddr(void);
+ECType mspd_global_get_ec_type(void);
+int mspd_global_config (struct ast_config *cfg, char *cat);
+void mspd_global_set_ec_type(ECType t);
+U8 mspd_global_get_bitrate_amr(void);
+U8 mspd_global_get_bitrate_amr_wb(void);
+mspd_fax_mode_t mspd_global_get_fax_mode(void);
+Boolean mspd_global_get_wideband(void);
+Boolean mspd_global_get_ntt_callerid(void);
+Boolean mspd_global_is_rtp_ct_mode(void);
+mspd_bwe_t *mspd_global_get_rsp_bwe(void);
+char* mspd_global_fax_mode_to_string(mspd_fax_mode_t type);
+
+#endif
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/include/asterisk/mspd/macro.h asterisk-1.8.2.3.new/include/asterisk/mspd/macro.h
--- asterisk-1.8.2.3/include/asterisk/mspd/macro.h	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/include/asterisk/mspd/macro.h	2014-05-07 14:49:35.000000000 +0530
@@ -0,0 +1,238 @@
+/*
+ * Mindspeed Comcerto - Channel module for line handling.
+ *
+ *  Copyright (C) 2004 - 2011 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef _MSPD_MACRO_H_
+#define _MSPD_MACRO_H_
+
+#include "asterisk/mspd/utils.h"
+
+#define	mspd_chan_name	"MSPD"
+// ===============================================================================================
+// Formats for  log & verbose messages
+
+#define MSPD_FMT                "%s|%s: "
+#define MSPD_WHERE              (mspd_chan_name), __func__
+
+#ifdef MSPD_CONFERENCE
+#define MSPD_CONF_FMT			"MSPD_CONF|%s: "
+#define MSPD_CONF_WHERE			 __func__
+#endif
+
+// ===============================================================================================
+// macros to simplify channel-type checks (determine if a channel has a certain feature)
+
+#define MSPD_HAS_TDM(t) ((t) == MCT_VOIP     || (t) == MCT_VOIPOSHM || (t) == MCT_PART_TDM || (t) == MCT_FOIP)
+#define MSPD_HAS_RTP(t) ((t) == MCT_VOIP     || (t) == MCT_VOIPOSHM || (t) == MCT_PART_RTP || (t) == MCT_FOIP)
+#define MSPD_IS_PART(t) ((t) == MCT_PART_RTP || (t) == MCT_PART_TDM)
+
+// ===============================================================================================
+// RTP macros
+
+#define MSPD_INFO_ABOUT_RTP(rtp) {                        \
+        struct ast_sockaddr us, peer;                     \
+        ast_rtp_instance_get_local_address(rtp, &us);     \
+        ast_rtp_instance_get_remote_address(rtp, &peer);  \
+        ast_verbose("*** RTP: us=%s, peer=%s ***\n",      \
+                    ast_sockaddr_stringify (&us),         \
+                    ast_sockaddr_stringify (&peer));      \
+}
+
+#define mspd_print_ud_info(ud_info){                                      \
+    if (ud_info){                                                         \
+    ast_verbose("\t : --- Global Unified Diagnostics Info ---\n"          \
+                "\t : Src-Port:%d\tDest-Port:%d\tDest-Ip:%s\n"            \
+                "\t : TDM-Tx:%d\tTDM-Rx:%d\n"                             \
+                "\t : PKT-Tx:%d\tPKT-Rx:%d\n"                             \
+                "\t : SPU-In:%d\tSPU-Out:%d\n"                            \
+                "\t : Report-Cmds:%d\n\n"                                 \
+                "\t : --- Supervisor Unified Diagnostics Enable:%s ---\n",\
+                ud_info->ud_src_portno,ud_info->ud_dest_portno,           \
+                ast_sockaddr_stringify_addr(&(ud_info->ud_dest_ipaddr)),  \
+                ud_info->ud_enable_tdm_tx,ud_info->ud_enable_tdm_rx,      \
+                ud_info->ud_enable_pkt_tx,ud_info->ud_enable_pkt_rx,      \
+                ud_info->ud_enable_spu_in,ud_info->ud_enable_spu_out,     \
+                ud_info->ud_enable_report_cmd,                            \
+                ud_info->ud_enable_supvsr ? "yes" : "no");}               \
+}
+
+// -----------------------------------------------------------------------------------------------
+// This macros can be used in the beginning/end of fucncions
+// to indicate where we are.
+// Additionally it is placed TO MSPG_LOG macroses group
+// to help in case of wrong format/parameter set usage
+// which causes segmentation failed.
+// To enable it perform from CLI "set verbose 12".
+#define MSPD_LOCATE() (\
+{\
+    if (option_verbose >= 12)\
+        printf("[%s|%s:%d]\n", __FILE__ , __func__, __LINE__);\
+})
+
+// VERBOSE_PREFIX_n defined in options.h
+// To enable debug mode perform from CLI "set debug 1".
+// To enable verbosity messages perform from CLI "set verbose 1" or higher.
+// Only messages allowed by verbosity level will be displayed.
+#define MSPD_LOG(_level, _message_fmt, args...) (\
+{\
+    mspd_print_time(); \
+    MSPD_LOCATE(); \
+    if (option_debug) {\
+        ast_log(LOG_NOTICE, _message_fmt, ##args); \
+    }\
+    else {\
+        if (option_verbose >= _level) {\
+                ast_verbose(VERBOSE_PREFIX_##_level MSPD_FMT _message_fmt, \
+                            MSPD_WHERE, ##args); \
+        }\
+    }\
+})
+
+#define MSPD_WARN(_level, _message_fmt, args...) (\
+{\
+    mspd_print_time(); \
+    MSPD_LOCATE(); \
+    if (option_verbose >= _level) \
+        ast_log(LOG_WARNING, MSPD_FMT _message_fmt, MSPD_WHERE, ##args); \
+})
+
+#define MSPD_ERR(_message_fmt, args...) (\
+{\
+    mspd_print_time(); \
+    MSPD_LOCATE(); \
+    ast_log(LOG_ERROR, MSPD_FMT _message_fmt, MSPD_WHERE, ##args); \
+})
+
+
+#define MSPD_DBG(_message_fmt, args...) (\
+{\
+    mspd_print_time(); \
+    MSPD_LOCATE(); \
+    ast_log(LOG_DEBUG, MSPD_FMT _message_fmt, MSPD_WHERE, ##args); \
+})
+
+#define VAPI_REPORT(_vstatus, _message) (\
+{\
+    mspd_print_time(); \
+    MSPD_LOCATE(); \
+    char vapi_check_buf [256]; \
+    if (_vstatus == SUCCESS) {\
+        if (option_debug) {\
+            ast_log(LOG_NOTICE, "--== %s [%s] ==--\n", _message, \
+                    term_color(vapi_check_buf, "OK", COLOR_GREEN, 0, sizeof (vapi_check_buf))); \
+        }\
+        else {\
+            if (option_verbose) \
+                ast_verbose(VERBOSE_PREFIX_4 MSPD_FMT"--== %s [%s] ==--\n", \
+                            MSPD_WHERE, _message,\
+                            term_color(vapi_check_buf, "OK", COLOR_GREEN, 0, sizeof (vapi_check_buf))); \
+        }\
+    }\
+    else {\
+        ast_log(LOG_ERROR, "--== %s [%s]: %d ==--\n", _message, \
+                term_color(vapi_check_buf, "FAIL", COLOR_RED, 0, sizeof (vapi_check_buf)), \
+                _vstatus); \
+    }\
+})
+
+#define VAPI_REPORT_ACT(_vstatus, _message, fail_action) (\
+{\
+    mspd_print_time(); \
+    MSPD_LOCATE(); \
+    char vapi_check_buf [256]; \
+    if (_vstatus == SUCCESS) {\
+        if (option_debug) \
+            ast_log(LOG_NOTICE, "--== %s [%s] ==--\n", _message, \
+                    term_color(vapi_check_buf, "OK", COLOR_GREEN, 0, sizeof (vapi_check_buf))); \
+        else {\
+            if (option_verbose) \
+                ast_verbose(VERBOSE_PREFIX_4 MSPD_FMT"--== %s [%s] ==--\n", \
+                            MSPD_WHERE, _message,\
+                            term_color(vapi_check_buf, "OK", COLOR_GREEN, 0, sizeof (vapi_check_buf))); \
+        }\
+    }\
+    else {\
+        ast_log(LOG_ERROR, "--== %s [%s]: %d ==--\n", _message, \
+                term_color(vapi_check_buf, "FAIL", COLOR_RED, 0, sizeof (vapi_check_buf)), \
+                _vstatus); \
+        fail_action; \
+    }\
+})
+
+// format for messages in Asterisk entry point functions to give vital info
+#define AEP_FMT                "(%s|%s,%s:%u|%s): "
+#define AEP_VAL(ast, line) \
+        ((ast) ? (ast)->name                         : "**no-ast**"),   \
+        ((ast) ? ast_state2str((ast)->_state)       : "**no-ast**"),   \
+        ((line) ? (line)->bus->name                  : "**no-line**"),  \
+        ((line) ? (line)->timeslot                   : ~0U),            \
+        ((line) ? sl_state2text((line)->state)      : "**no-line**")
+
+/* Commented for Aseterisk 1.8
+
+    // waiting on condition variable with/without thread debugging
+#ifdef DEBUG_THREADS
+  #define ast_cond_wait(cond, lock) \
+                pthread_cond_wait((cond), &(lock)->mutex)
+  #define ast_cond_timedwait(cond, lock, abstime) \
+                pthread_cond_timedwait((cond), &(lock)->mutex, (abstime))
+#else // !DEBUG_THREADS
+  #define ast_cond_wait(cond, lock) \
+                pthread_cond_wait((cond), (lock))
+  #define ast_cond_timedwait(cond, lock, abstime) \
+                pthread_cond_timedwait((cond), (lock), (abstime))
+#endif // DEBUG_THREADS
+    */
+
+    // macros to simplify lock mutex/check/log code
+#define MSPD_LOCK(lock, fail_action) do { \
+        int const mspd_lock_rc = ast_mutex_lock(&(lock)); \
+        if (mspd_lock_rc) { \
+        ast_log(LOG_ERROR, MSPD_FMT"(): failed to lock mutex '%s' at line %d: %s\n", \
+                MSPD_WHERE, #lock, __LINE__, strerror(mspd_lock_rc)); \
+        fail_action; \
+        } \
+    } while (0)
+
+#define MSPD_UNLOCK(lock) do { \
+        int const mspd_unlock_rc = ast_mutex_unlock(&(lock)); \
+        if (mspd_unlock_rc) { \
+        ast_log(LOG_ERROR, MSPD_FMT"(): failed to unlock mutex '" #lock "' at line %d: %s\n", \
+                MSPD_WHERE, __LINE__, strerror(mspd_unlock_rc)); \
+        } \
+    } while (0)
+
+    // macro to have a asprintf() that plays nicely with astmm
+#define mspd_asprintf(fmt, args...) ({ \
+        char _tmp_buf[128]; \
+        snprintf(_tmp_buf, sizeof(_tmp_buf), (fmt) , ##args); \
+        strdup(_tmp_buf); \
+    })
+
+
+// Log a MSP message (macro because of MSPD_WHERE)
+#define log_mspd_msg(loglevel, tag, name, msg) \
+({ \
+    char buf[2048]; \
+    mspd_fifo2str(buf, sizeof(buf), ((uint8_t*)(msg)->pusFifo)[0], (msg)->pusFifo); \
+    if (loglevel == __LOG_VERBOSE) \
+    ast_verbose(VERBOSE_PREFIX_5 MSPD_FMT"[%s] <%s:%u> i=%u%s\n", \
+                MSPD_WHERE, (tag), (name), (msg)->sMailbox.usParam2, \
+                ((uint8_t*)(msg)->pusFifo)[1], buf); \
+    else \
+        ast_log(loglevel, __FILE__, __LINE__, __func__, MSPD_FMT"[%s] <%s:%u> i=%u%s\n", \
+                MSPD_WHERE, (tag), (name), (msg)->sMailbox.usParam2, \
+                ((uint8_t*)(msg)->pusFifo)[1], buf); \
+})
+
+
+#endif
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/include/asterisk/mspd/mspd.h asterisk-1.8.2.3.new/include/asterisk/mspd/mspd.h
--- asterisk-1.8.2.3/include/asterisk/mspd/mspd.h	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/include/asterisk/mspd/mspd.h	2011-04-29 19:02:30.000000000 +0530
@@ -0,0 +1,19 @@
+/*
+ * Mindspeed Comcerto - Channel module for line handling.
+ *
+ *  Copyright (C) 2004,2005 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef _MSPD_H_
+#define _MSPD_H_
+
+int mspd_init(void);
+void mspd_cleanup(void);
+
+#endif
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/include/asterisk/mspd/queue.h asterisk-1.8.2.3.new/include/asterisk/mspd/queue.h
--- asterisk-1.8.2.3/include/asterisk/mspd/queue.h	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/include/asterisk/mspd/queue.h	2011-11-23 21:19:35.000000000 +0530
@@ -0,0 +1,82 @@
+        /*
+ * Mindspeed Comcerto Channel module.
+ *
+ *  Copyright (C) 2004 - 2011 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef _MSPD_QUEUE_H_
+#define _MSPD_QUEUE_H_
+
+// ===============================================================================================
+// Includes
+
+//#include <stdint.h>
+#include <vapi/vapi.h>
+
+#include "asterisk.h"
+#include "asterisk/lock.h"
+
+// ===============================================================================================
+// Global data
+
+// queue elements, the actual information that is passed between producer and consumer (is
+// dynamically allocated, pointer in ringbuffer points to it)
+// - MSP-channel indications
+
+typedef struct TEMPO_EVENT_DESC tempo_queue_element_t;
+typedef struct VAPI_EVENT_DESC {
+    SToneDetectEventParams event;
+    uint16_t	uPassthruMode;
+    int         usFnCode;
+} vapi_queue_element_t;
+
+// queue-items (i.e. data stored in queue ringbuffer)
+typedef union queue_item {
+    tempo_queue_element_t   *tempo;
+    vapi_queue_element_t    *vItem;
+} queue_item_t;
+
+// the queue that connects the producer and the consumer
+typedef struct queue {
+    size_t                  queue_size;
+    queue_item_t           *last;
+    volatile queue_item_t  *head;
+    volatile queue_item_t  *tail;
+    ast_mutex_t             mutex;
+    volatile unsigned int   n_items;
+    ast_cond_t              is_not_empty;
+    queue_item_t            buf[];
+} queue_t;
+
+// ===============================================================================================
+// Defines
+
+// item to tell consumer thread that it is OK to start
+#define QUEUE_START_ITEM        ((queue_item_t) {.vItem = (void*)2})
+
+// item to stop consumer thread
+#define QUEUE_STOP_ITEM         ((queue_item_t) {.vItem = (void*)1})
+
+
+// ===============================================================================================
+// Proto
+queue_t *    mspd_queue_create    (size_t queue_size);
+void         mspd_queue_destroy   (queue_t *queue);
+int          mspd_queue_start     (queue_t *queue);
+void         mspd_queue_stop      (queue_t *queue);
+int          mspd_queue_put       (queue_t *queue, queue_item_t item);
+// used by consumers
+queue_item_t mspd_queue_get       (queue_t *queue);
+
+// this is needed because gcc complaints about missing prototypes
+inline tempo_queue_element_t * mspd_queue_get_tempo (queue_t *queue);
+inline vapi_queue_element_t *  mspd_queue_get_vItem (queue_t *queue);
+
+#endif // _MSPD_QUEUE_H_
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/include/asterisk/mspd/rtp.h asterisk-1.8.2.3.new/include/asterisk/mspd/rtp.h
--- asterisk-1.8.2.3/include/asterisk/mspd/rtp.h	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/include/asterisk/mspd/rtp.h	2011-08-05 19:40:55.000000000 +0530
@@ -0,0 +1,24 @@
+/*
+ * Mindspeed Comcerto Channel module.
+ *
+ *  Copyright (C) 2004 - 2011 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef MSPD_RTP_H
+#define MSPD_RTP_H
+
+#include "asterisk.h"
+#include "asterisk/rtp_engine.h"
+
+#include "asterisk/mspd/device.h"
+
+struct ast_rtp_instance * mspd_rtp_allocate_new (mspd_device_t *dev);
+
+#endif
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/include/asterisk/mspd/utils.h asterisk-1.8.2.3.new/include/asterisk/mspd/utils.h
--- asterisk-1.8.2.3/include/asterisk/mspd/utils.h	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/include/asterisk/mspd/utils.h	2011-10-25 19:59:48.000000000 +0530
@@ -0,0 +1,142 @@
+/*
+ * Mindspeed Comcerto - Channel module for line handling.
+ *
+ *  Copyright (C) 2004,2005 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef _MSPD_UTILS_H_
+#define _MSPD_UTILS_H_
+
+// ===============================================================================================
+// Includes
+
+#include <stdint.h>
+#include <stdarg.h>
+#include <assert.h>
+
+#include <vapi/vapi.h>
+#include <vapi/comcerto-api-defs.h> 
+
+// ===============================================================================================
+// Defines
+
+// special values for mspd_make_msg()
+#define DC_EOM                  (-1)
+#define DC_OVERRIDE_N_PARAMS    (-2)
+
+#define FX_EOM                  (-1)
+#define FX_OVERRIDE_SIZE        (-2)
+#define MAX_FIFO_SIZE           (256)
+
+// ================================================================================================
+// Local types
+
+typedef struct {
+    U16 func_code;
+    U16 cmd_class_type;
+    U16 n_params;
+} command_map_t;
+
+typedef struct {
+    U16         code;
+    char const *text;
+} code2text_t;
+
+typedef struct timeval mspd_timer;      // Synonim for internal purposes
+
+typedef struct {                         // To be used as a return value
+    U32 sec;
+    S16 msec;
+} mspd_time;
+
+// ================================================================================================
+// Defines
+
+// Definitions in old map format
+#define CMD_CHAN_CONF               CMD_CLASS_CONF_CHANNEL  << 8 | CMD_TYPE_CONF_CHANGE
+#define CMD_DEV_CONF                CMD_CLASS_CONF_DEVICE   << 8 | CMD_TYPE_CONF_CHANGE
+
+#define CMD_ENABLE_DIAG_CONF        CMD_CLASS_OPEN_DIAG     << 8 | CMD_TYPE_DIAG_MON_LIVE_CTRL
+#define CMD_OPEN_DIAG               CMD_CLASS_OPEN_DIAG     << 8 | CMD_TYPE_DIAG_CONFIG
+
+#define FC_DESTROY_ALL_CHANNEL                  0x0017
+
+#define CMD_TYPE_SET_TSA                        0x0036
+
+#define PORT_SELECT                             0x0700
+#define NIF_SELECT                              0x0701
+#define NIF_DEFAULT_DEST                        0x0702
+#define PKT_DEFAULT_DEST                        0x0703
+#define PKT_RULE_CONFIG                         0x0706
+#define PKT_MODIFY_CONFIG                       0X0709
+
+#define VOIP_ECGAIN                             0x8008
+#define BWE_SET                                 0x8140
+
+// CRM 20.4.1 TONEDET Enhancements
+#define VOIP_TONEDET_TONE_EARLY_CAS_DET         0x70
+#define VOIP_TONEDET_TONE_CAS_DET               0x71
+
+// NetEngine PORT Definitions                                                      // portId   Description     Notes
+#define NIF_PORT_NULL                           0x00      //  00         NullPort             To drop packets when used as destination
+#define NIF_PORT_MAC0                           0x01      //  01         Ethernet MAC 0  Used when MSP drives EMAC0
+#define NIF_PORT_MAC1                           0x02      //  02         Ethernet MAC 1  Used when MSP drives EMAC1
+#define NIF_PORT_TDM                            0x05      //  05         TDM                  Used to support VoIP protocol stack
+#define NIF_PORT_VED                            0x11
+#define NIF_PORT_FPP                            0x16
+
+// Protocol Identification
+#define Protocol_IPv4 3
+// Others 0
+// Ethernet 1
+// PPP 2
+// IPV4 3
+// IPV6 4
+// CSM_ENCAPS 5
+// ARP 6
+// VLAN 7
+// VCID 8
+// UDP 9
+// TCP 10
+// ICMP 11
+
+// ===============================================================================================
+// Prototypes
+
+command_map_t const *
+                get_command_map_entry (uint16_t func_code);
+
+char const *    code2text (uint code, code2text_t const *table, size_t nelements);
+char *          cmdclass2text (uint16_t cmd);
+char *          cmdtype2text (uint16_t cmd);
+
+char const *    mspd_lookup_msg_id (uint code);
+char const *    mspd_lookup_error_code (uint code);
+void            mspd_fifo2str(char *buf, int n, uint fifo_size, uint16_t *fifo);
+
+int       mspd_make_msg (SMsg  *msg,
+                             uint    channel_id,
+                             uint    func_code,
+                             int     *argv);
+
+void            sl_print_busdetails (void);
+void            sl_print_phonedetails (void);
+void            sl_print_echocandetails (void);
+
+// Time functions
+mspd_time       mspd_get_time_ms (void);
+void            mspd_print_time(void);
+
+#ifdef DEBUG
+#define MSPD_ASSERT(x) assert(x)
+#else
+#define MSPD_ASSERT(x) (if(!(x)) MSPD_ERR("Assertion failed: #x");
+#endif
+
+#endif
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/include/asterisk/rtp_engine.h asterisk-1.8.2.3.new/include/asterisk/rtp_engine.h
--- asterisk-1.8.2.3/include/asterisk/rtp_engine.h	2010-11-03 23:35:14.000000000 +0530
+++ asterisk-1.8.2.3.new/include/asterisk/rtp_engine.h	2011-06-24 16:59:33.000000000 +0530
@@ -313,7 +313,7 @@
 	/*! Module this RTP engine came from, used for reference counting */
 	struct ast_module *mod;
 	/*! Callback for setting up a new RTP instance */
-	int (*new)(struct ast_rtp_instance *instance, struct sched_context *sched, struct ast_sockaddr *sa, void *data);
+	int (*new)(struct ast_rtp_instance *instance, struct sched_context *sched, struct ast_sockaddr *sa, void *data, int is_msp_socket);
 	/*! Callback for destroying an RTP instance */
 	int (*destroy)(struct ast_rtp_instance *instance);
 	/*! Callback for writing out a frame */
@@ -373,6 +373,7 @@
 	void (*stun_request)(struct ast_rtp_instance *instance, struct ast_sockaddr *suggestion, const char *username);
 	/*! Callback to get the transcodeable formats supported */
 	int (*available_formats)(struct ast_rtp_instance *instance, format_t to_endpoint, format_t to_asterisk);
+	int (*get_fpp_socket)(struct ast_rtp_instance *instance);
 	/*! Linked list information */
 	AST_RWLIST_ENTRY(ast_rtp_engine) entry;
 };
@@ -543,7 +544,7 @@
  */
 struct ast_rtp_instance *ast_rtp_instance_new(const char *engine_name,
                 struct sched_context *sched, const struct ast_sockaddr *sa,
-                void *data);
+                void *data, int is_msp_socket);
 
 /*!
  * \brief Destroy an RTP instance
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/main/asterisk.c asterisk-1.8.2.3.new/main/asterisk.c
--- asterisk-1.8.2.3/main/asterisk.c	2010-11-29 12:58:44.000000000 +0530
+++ asterisk-1.8.2.3.new/main/asterisk.c	2011-05-11 18:35:46.000000000 +0530
@@ -143,6 +143,7 @@
 #include "asterisk/ccss.h"
 #include "asterisk/test.h"
 #include "asterisk/aoc.h"
+#include "asterisk/mspd/mspd.h"
 
 #include "../defaults.h"
 
@@ -3800,6 +3801,11 @@
 		exit(1);
 	}
 
+	if (mspd_init()) {
+		printf("%s", term_quit());
+		exit(1);
+	}
+
 	if ((moduleresult = load_modules(0))) {		/* Load modules */
 		printf("%s", term_quit());
 		exit(moduleresult == -2 ? 2 : 1);
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/main/asterisk.exports.in asterisk-1.8.2.3.new/main/asterisk.exports.in
--- asterisk-1.8.2.3/main/asterisk.exports.in	2010-09-24 09:12:37.000000000 +0530
+++ asterisk-1.8.2.3.new/main/asterisk.exports.in	2011-05-11 18:35:46.000000000 +0530
@@ -1,5 +1,6 @@
 {
 	global:
+		LINKER_SYMBOL_PREFIXmspd_*;
 		LINKER_SYMBOL_PREFIXast_*;
 		LINKER_SYMBOL_PREFIX_ast_*;
 		LINKER_SYMBOL_PREFIX__ast_*;
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/main/bridging.c asterisk-1.8.2.3.new/main/bridging.c
--- asterisk-1.8.2.3/main/bridging.c	2010-06-02 19:02:22.000000000 +0530
+++ asterisk-1.8.2.3.new/main/bridging.c	2012-01-04 15:44:18.000000000 +0530
@@ -725,14 +725,17 @@
 
 	ao2_unlock(bridge_channel->bridge);
 
+	// Backport from trunk: protecting bridge_channel before reading the state
+	ast_mutex_lock(&bridge_channel->lock);
 	/* Wait for data to either come from the channel or us to be signalled */
 	if (!bridge_channel->suspended) {
-		ast_debug(1, "Going into a multithreaded waitfor for bridge channel %p of bridge %p\n", bridge_channel, bridge_channel->bridge);
+		ast_mutex_unlock(&bridge_channel->lock);
+		ast_debug(10, "Going into a multithreaded waitfor for bridge channel %p of bridge %p\n", bridge_channel, bridge_channel->bridge);
 		chan = ast_waitfor_nandfds(&bridge_channel->chan, 1, fds, nfds, NULL, &outfd, &ms);
 	} else {
-		ast_mutex_lock(&bridge_channel->lock);
-		ast_debug(1, "Going into a multithreaded signal wait for bridge channel %p of bridge %p\n", bridge_channel, bridge_channel->bridge);
+		ast_debug(10, "Going into a multithreaded signal wait for bridge channel %p of bridge %p\n", bridge_channel, bridge_channel->bridge);
 		ast_cond_wait(&bridge_channel->cond, &bridge_channel->lock);
+		ast_debug(10, "GOT signal on channel %p of bridge %p\n", bridge_channel, bridge_channel->bridge);
 		ast_mutex_unlock(&bridge_channel->lock);
 	}
 
@@ -763,9 +766,12 @@
 /*! \brief Internal function that suspends a channel from a bridge */
 static void bridge_channel_suspend(struct ast_bridge *bridge, struct ast_bridge_channel *bridge_channel)
 {
+	// Backport from trunk: protecting bridge_channel before setting a new value
+	ast_mutex_lock(&bridge_channel->lock);
 	bridge_channel->suspended = 1;
 
 	bridge_array_remove(bridge, bridge_channel->chan);
+	ast_mutex_unlock(&bridge_channel->lock);
 
 	if (bridge->technology->suspend) {
 		bridge->technology->suspend(bridge, bridge_channel);
@@ -777,9 +783,14 @@
 /*! \brief Internal function that unsuspends a channel from a bridge */
 static void bridge_channel_unsuspend(struct ast_bridge *bridge, struct ast_bridge_channel *bridge_channel)
 {
+	// Backport from trunk: protecting bridge_channel before setting a new value
+	ast_mutex_lock(&bridge_channel->lock);
 	bridge_channel->suspended =0;
 
 	bridge_array_add(bridge, bridge_channel->chan);
+	// Backport from trunk: sending a signal to wake up a waiting thread
+	ast_cond_signal(&bridge_channel->cond);
+	ast_mutex_unlock(&bridge_channel->lock);
 
 	if (bridge->technology->unsuspend) {
 		bridge->technology->unsuspend(bridge, bridge_channel);
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/main/channel.c asterisk-1.8.2.3.new/main/channel.c
--- asterisk-1.8.2.3/main/channel.c	2010-12-08 04:29:30.000000000 +0530
+++ asterisk-1.8.2.3.new/main/channel.c	2013-10-23 20:25:27.000000000 +0530
@@ -68,6 +68,8 @@
 #include "asterisk/stringfields.h"
 #include "asterisk/global_datastores.h"
 #include "asterisk/data.h"
+#include "asterisk/rtp_engine.h"
+#include "asterisk/mspd/cmmlib.h"
 
 #ifdef HAVE_EPOLL
 #include <sys/epoll.h>
@@ -1010,7 +1012,10 @@
 		AST_FORMAT_SLINEAR16,
 		AST_FORMAT_SLINEAR,
 		/*! G.726 is standard ADPCM, in RFC3551 packing order */
-		AST_FORMAT_G726,
+		AST_FORMAT_G726_32,
+		AST_FORMAT_G726_16,
+		AST_FORMAT_G726_24,
+		AST_FORMAT_G726_40,
 		/*! G.726 is standard ADPCM, in AAL2 packing order */
 		AST_FORMAT_G726_AAL2,
 		/*! ADPCM has great sound quality and is still pretty easy to translate */
@@ -1020,6 +1025,7 @@
 		AST_FORMAT_GSM,
 		/*! iLBC is not too bad */
 		AST_FORMAT_ILBC,
+		AST_FORMAT_ILBC_1,
 		/*! Speex is free, but computationally more expensive than GSM */
 		AST_FORMAT_SPEEX16,
 		AST_FORMAT_SPEEX,
@@ -1030,6 +1036,8 @@
 		AST_FORMAT_G729A,
 		/*! Down to G.723.1 which is proprietary but at least designed for voice */
 		AST_FORMAT_G723_1,
+		AST_FORMAT_AMR,
+		AST_FORMAT_AMR_WB,
 	};
 	char buf[512];
 
@@ -5635,11 +5643,16 @@
 	/* Set up translation from the chan to the peer */
 	rc = ast_channel_make_compatible_helper(chan, peer);
 
-	if (rc < 0)
-		return rc;
+	/* Even if chan hasn't made compatible to peer,
+	 * peer still can make itself compatible to chan.
+	 * Need to try it. For example if chan = SIP and peer = MSPD,
+	 * SIP CM might be not able to become compatible to MSPD (absense of needed code in SIP CM),
+	 * but MSPD CM can do it (switch MSP to needed codec).
+	 * This is explicitly needed for FPT.
+	 */
 
 	/* Set up translation from the peer to the chan */
-	rc = ast_channel_make_compatible_helper(peer, chan);
+	rc &= ast_channel_make_compatible_helper(peer, chan);
 
 	return rc;
 }
@@ -6755,6 +6768,45 @@
 		config->nexteventts = ast_tvadd(ast_tvnow(), ast_samp2tv(config->feature_timer, 1000));
 	}
 
+	ast_verb(5, "ast_generic_bridge RTPCT\n");
+	struct ast_rtp_instance *instance0 = NULL;
+	struct ast_rtp_instance *instance1 = NULL;
+	struct ast_rtp_glue     *glue0     = NULL;
+	struct ast_rtp_glue     *glue1     = NULL;
+	struct ast_rtp_engine   *engine0   = NULL;
+	struct ast_rtp_engine   *engine1   = NULL;
+	int sock0_id = 0;
+	int sock1_id = 0;
+	int rtp_session_id = 0;;
+
+	/* Grab glue that binds each channel to something using the RTP engine */
+	if ((glue0 = ast_rtp_instance_get_glue(c0->tech->type)) &&
+		(glue1 = ast_rtp_instance_get_glue(c1->tech->type)))
+	{
+		glue0->get_rtp_info(c0, &instance0);
+		glue1->get_rtp_info(c1, &instance1);
+	}
+
+	if (instance0 && instance1) {
+		engine0 = ast_rtp_instance_get_engine (instance0);
+		engine1 = ast_rtp_instance_get_engine (instance1);
+	}
+
+	if (engine0 && engine1 &&
+		engine0->get_fpp_socket &&
+		engine1->get_fpp_socket)
+	{
+		sock0_id = engine0->get_fpp_socket(instance0);
+		sock1_id = engine1->get_fpp_socket(instance1);
+		if (sock0_id > 0 && sock1_id > 0) {
+			rtp_session_id = ast_cmm_fpp_create_rtp_session(sock0_id, sock1_id);
+			if (rtp_session_id > 0)
+				ast_verb(5, "RTP cut-through enabled\n");
+			else
+				ast_log(LOG_ERROR, "Setting RTP cut-through failed (err=%d)\n", rc);
+		}
+	}
+
 	for (;;) {
 		struct ast_channel *who, *other;
 
Binary files asterisk-1.8.2.3/main/.channel.c.swp and asterisk-1.8.2.3.new/main/.channel.c.swp differ
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/main/frame.c asterisk-1.8.2.3.new/main/frame.c
--- asterisk-1.8.2.3/main/frame.c	2010-06-17 22:53:43.000000000 +0530
+++ asterisk-1.8.2.3.new/main/frame.c	2011-06-24 21:09:52.000000000 +0530
@@ -122,6 +122,12 @@
 	{ AST_FORMAT_SIREN14, "siren14", 32000, "ITU G.722.1 Annex C, (Siren14, licensed from Polycom)", 120, 20, 80, 20, 20 },	/*!< Binary commercial distribution */
 	{ AST_FORMAT_TESTLAW, "testlaw", 8000, "G.711 test-law", 80, 10, 150, 10, 20 },                        /*!< codec_ulaw.c */
 	{ AST_FORMAT_G719, "g719", 48000, "ITU G.719", 160, 20, 80, 20, 20 },
+	{ AST_FORMAT_ILBC_1, "ilbc_1", 8000, "iLBC", 38, 30, 30, 30, 30 },
+	{ AST_FORMAT_G726_16, "g726_16", 8000, "G.726 16kbps", 20, 10, 300, 10, 20 },
+	{ AST_FORMAT_G726_24, "g726_24", 8000, "G.726 24kbps", 30, 10, 300, 10, 20 },
+	{ AST_FORMAT_G726_40, "g726_40", 8000, "G.726 40kbps", 50, 10, 300, 10, 20 },
+	{ AST_FORMAT_AMR, "amr", 8000, "GSM AMR", 33, 20, 80, 20, 20 }, 					/*! MSPD GSM AMR Narrow band codec*/
+	{ AST_FORMAT_AMR_WB, "amr_wb", 16000, "AMR-WB", 61, 20, 80, 20, 20 },					/*! MSPD AMR-WB (G.722.2) Wide/Narrow band codec*/
 };
 
 struct ast_frame ast_null_frame = { AST_FRAME_NULL, };
@@ -1461,6 +1467,7 @@
 		samples = 240 * (f->datalen / 50);
 		break;
 	case AST_FORMAT_GSM:
+	case AST_FORMAT_AMR:
 		samples = 160 * (f->datalen / 33);
 		break;
 	case AST_FORMAT_G729A:
@@ -1478,11 +1485,15 @@
 	case AST_FORMAT_ULAW:
 	case AST_FORMAT_ALAW:
 	case AST_FORMAT_TESTLAW:
+	case AST_FORMAT_AMR_WB:
 		samples = f->datalen;
 		break;
 	case AST_FORMAT_G722:
 	case AST_FORMAT_ADPCM:
-	case AST_FORMAT_G726:
+	case AST_FORMAT_G726_16:
+	case AST_FORMAT_G726_24:
+	case AST_FORMAT_G726_32:
+	case AST_FORMAT_G726_40:
 	case AST_FORMAT_G726_AAL2:
 		samples = f->datalen * 2;
 		break;
@@ -1498,6 +1509,9 @@
 		/* 48,000 samples per second at 64kbps is 8,000 bytes per second */
 		samples = (int) f->datalen * ((float) 48000 / 8000);
 		break;
+	case AST_FORMAT_ILBC_1: 
+		samples = 160 * (f->datalen / 38); 
+		break; 
 	default:
 		ast_log(LOG_WARNING, "Unable to calculate samples for format %s\n", ast_getformatname_multiple(tmp, sizeof(tmp), f->subclass.codec));
 	}
@@ -1516,7 +1530,11 @@
 	case AST_FORMAT_ILBC:
 		len = (samples / 240) * 50;
 		break;
+	case AST_FORMAT_ILBC_1: 
+		len = (samples / 160) * 38; 
+		break; 
 	case AST_FORMAT_GSM:
+	case AST_FORMAT_AMR:
 		len = (samples / 160) * 33;
 		break;
 	case AST_FORMAT_G729A:
@@ -1529,11 +1547,15 @@
 	case AST_FORMAT_ULAW:
 	case AST_FORMAT_ALAW:
 	case AST_FORMAT_TESTLAW:
+	case AST_FORMAT_AMR_WB:
 		len = samples;
 		break;
 	case AST_FORMAT_G722:
 	case AST_FORMAT_ADPCM:
-	case AST_FORMAT_G726:
+	case AST_FORMAT_G726_16:
+	case AST_FORMAT_G726_24:
+	case AST_FORMAT_G726_32:
+	case AST_FORMAT_G726_40:
 	case AST_FORMAT_G726_AAL2:
 		len = samples / 2;
 		break;
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/main/Makefile asterisk-1.8.2.3.new/main/Makefile
--- asterisk-1.8.2.3/main/Makefile	2010-08-02 20:11:46.000000000 +0530
+++ asterisk-1.8.2.3.new/main/Makefile	2011-08-05 19:40:55.000000000 +0530
@@ -22,6 +22,10 @@
 OBJSFILTER=fskmodem_int.o fskmodem_float.o cygload.o buildinfo.o
 OBJS=$(filter-out $(OBJSFILTER),$(SRC:.c=.o))
 
+MSPD_SRC=mspd/cmmlib.c mspd/common.c mspd/device.c mspd/utils.c mspd/mspd.c mspd/queue.c mspd/channel.c mspd/global.c mspd/conference.c mspd/rtp.c
+MSPD_OBJS=$(filter-out $(OBJSFILTER),$(MSPD_SRC:.c=.o))
+$(MSPD_OBJS): _ASTCFLAGS+=-Werror -DAST_MODULE=\"mspd\"
+
 # we need to link in the objects statically, not as a library, because
 # otherwise modules will not have them available if none of the static
 # objects use it.
@@ -33,6 +37,7 @@
 AST_LIBS += $(OPENSSL_LIB)
 AST_LIBS += $(BKTR_LIB)
 AST_LIBS += $(LIBXML2_LIB) 
+AST_LIBS += -lcmm -lvapi -lgtlcommon -lgtlcsme
 
 ifneq ($(findstring $(OSARCH), linux-gnu uclinux linux-uclibc linux-gnueabi ),)
   ifneq ($(findstring LOADABLE_MODULES,$(MENUSELECT_CFLAGS)),)
@@ -173,13 +178,13 @@
 
 $(OBJS): _ASTCFLAGS+=-DAST_MODULE=\"core\"
 
-$(MAIN_TGT): $(OBJS) editline/libedit.a db1-ast/libdb1.a $(AST_EMBED_LDSCRIPTS)
+$(MAIN_TGT): $(OBJS) editline/libedit.a db1-ast/libdb1.a $(AST_EMBED_LDSCRIPTS) $(MSPD_OBJS)
 	@$(CC) -c -o buildinfo.o $(_ASTCFLAGS) buildinfo.c $(ASTCFLAGS)
-	$(ECHO_PREFIX) echo "   [LD] $(OBJS) editline/libedit.a db1-ast/libdb1.a $(AST_EMBED_LDSCRIPTS) -> $@"
+	$(ECHO_PREFIX) echo "   [LD] $(OBJS) editline/libedit.a db1-ast/libdb1.a $(AST_EMBED_LDSCRIPTS) $(MSPD_OBJS) -> $@"
 ifneq ($(findstring chan_h323,$(MENUSELECT_CHANNELS)),)
-	$(CMD_PREFIX) $(CC) $(STATIC_BUILD) -o $@ $(ASTLINK) $(AST_EMBED_LDFLAGS) $(_ASTLDFLAGS) $(ASTLDFLAGS) $(OBJS) editline/libedit.a db1-ast/libdb1.a $(AST_EMBED_LDSCRIPTS) buildinfo.o $(AST_LIBS) $(AST_EMBED_LIBS) $(GMIMELDFLAGS)
+	$(CMD_PREFIX) $(CC) $(STATIC_BUILD) -o $@ $(ASTLINK) $(AST_EMBED_LDFLAGS) $(_ASTLDFLAGS) $(ASTLDFLAGS) $(OBJS) editline/libedit.a db1-ast/libdb1.a $(AST_EMBED_LDSCRIPTS) buildinfo.o $(AST_LIBS) $(AST_EMBED_LIBS) $(GMIMELDFLAGS) $(MSPD_OBJS)
 else
-	$(CMD_PREFIX) $(CXX) $(STATIC_BUILD) -o $@ $(ASTLINK) $(AST_EMBED_LDFLAGS) $(_ASTLDFLAGS) $(ASTLDFLAGS) $(H323LDFLAGS) $(OBJS) editline/libedit.a db1-ast/libdb1.a $(AST_EMBED_LDSCRIPTS) buildinfo.o $(AST_LIBS) $(AST_EMBED_LIBS) $(H323LDLIBS) $(GMIMELDFLAGS)
+	$(CMD_PREFIX) $(CXX) $(STATIC_BUILD) -o $@ $(ASTLINK) $(AST_EMBED_LDFLAGS) $(_ASTLDFLAGS) $(ASTLDFLAGS) $(H323LDFLAGS) $(OBJS) editline/libedit.a db1-ast/libdb1.a $(AST_EMBED_LDSCRIPTS) buildinfo.o $(AST_LIBS) $(AST_EMBED_LIBS) $(H323LDLIBS) $(GMIMELDFLAGS) $(MSPD_OBJS)
 endif
 
 ifeq ($(GNU_LD),1)
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/main/mspd/channel.c asterisk-1.8.2.3.new/main/mspd/channel.c
--- asterisk-1.8.2.3/main/mspd/channel.c	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/main/mspd/channel.c	2014-05-07 14:49:36.000000000 +0530
@@ -0,0 +1,2655 @@
+#include "asterisk.h"
+
+#include <vapi/vapi.h> 
+#include <vapi/comcerto-api-defs.h> 
+#include <vapi/gtl.h>
+
+#include "asterisk/lock.h"
+#include "asterisk/utils.h"
+#include "asterisk/rtp_engine.h" 
+#include "asterisk/lock.h" 
+#include "asterisk/logger.h" 
+#include "asterisk/pbx.h" 
+#include "asterisk/options.h" 
+#include "asterisk/features.h" 
+#include "asterisk/term.h" 
+#include "asterisk/sched.h" 
+#include "asterisk/mspd/macro.h"
+#include "asterisk/mspd/common.h"
+#include "asterisk/mspd/defaults.h"
+#include "asterisk/mspd/utils.h"
+#include "asterisk/mspd/device.h"
+#include "asterisk/mspd/channel.h"
+#include "asterisk/mspd/queue.h"
+#include "asterisk/mspd/global.h"
+#include "asterisk/linkedlists.h"
+
+#define MSPD_CID_MSG_MAX_LENGTH 256
+#define INDICATION_QUEUE_SIZE       (32)
+
+#define TONECTRL_DTMF         0x01 
+#define TONECTRL_FPT          0x02 
+#define TONECTRL_MTP          0x04 
+#define TONECTRL_CNG          0x10 
+
+#define CID_MSG_MAX_LENGTH          256 
+#define CID_PARAM_TYPE_PHONENUM     0x02 
+#define CID_PARAM_TYPE_PHONENAME    0x07 
+#define CID_MOD_TYPE_BELL           0x00 
+#define CID_MOD_TYPE_V23            0x01 
+#define CID_MSG_TYPE_MDMF           0x80 
+#define CID_MSG_TYPE_SDMF           0x40 
+#define CID_MOD_TYPE                CID_MOD_TYPE_BELL 
+#define CID_MSG_TYPE                CID_MSG_TYPE_MDMF 
+#define CID_MSG_TYPE_OFFHOOK        CID_MSG_TYPE_MDMF 
+
+#define SUPERVISOR_CHANNEL_ID 0xFFFF
+
+#define MSP_DTMFOPT_RTP_SILENCE (1 << 7) /* DTMF samples are replaced with silence */
+#define MSP_DTMFOPT_NO_DTMF_TDM (0 << 0) /* Disable DTMF in voice coding */
+#define MSP_DTMFOPT_NO_DTMF_RTP (0 << 1) /* Disable DTMF in RTP coding */
+
+static char const              mspd_supvsr_name[] = "supvsr";
+
+// a device channel (VoIP channel or rtp|tdm conference participant)
+struct mspd_channel {
+    char                		*name;
+    mspd_device_t       		*dev;
+    mspd_channel_type_t 		type;
+    U16                 		id;
+    queue_t             		*queue;
+    pthread_t           		consumer;
+    U16                 		tag;
+    ast_mutex_t         		lock;
+    ast_cond_t         			msg_is_done_cond;
+    void				*pvt;	/* this is private structure, can be used by channel user as wanted */
+
+    char                		cid_buf[MSPD_CID_MSG_MAX_LENGTH];
+    SCallerIdInfo            		cid_msg;
+    Boolean             		cid_gen_in_progress;
+    Boolean				vad;
+
+    Boolean             		passthru_mode;
+    mspd_tone_t				tone;
+    format_t            		format; /* The last configured format */
+    U32                 		ssrc;
+    mspd_channel_event_callback_t	event_callback;
+    mspd_channel_destructor_t		destructor;
+
+    AST_LIST_ENTRY(mspd_channel) 	list;
+};
+
+static AST_LIST_HEAD_STATIC(channels, mspd_channel);
+
+Boolean mspd_channel_get_passthru_mode(const mspd_channel_t *channel)
+{
+    return channel->passthru_mode;
+}
+
+mspd_channel_type_t mspd_channel_get_type(mspd_channel_t *channel)
+{
+    return channel->type;
+}
+
+void mspd_channel_set_type(mspd_channel_t *channel, mspd_channel_type_t type)
+{
+    channel->type = type;
+    free(channel->name);
+    channel->name = mspd_asprintf("<%s:%u,%s,%x>",
+                                mspd_device_get_name(channel->dev),
+                                channel->id,
+                                mspd_channel_type2text(channel->type),
+                                channel->tag);
+}
+
+mspd_device_t *mspd_channel_get_device(mspd_channel_t *channel)
+{
+    return channel->dev;
+}
+
+format_t mspd_channel_get_format(const mspd_channel_t *channel)
+{
+    return channel->format;
+}
+
+void *mspd_channel_get_pvt(mspd_channel_t *channel)
+{
+    return channel->pvt;
+}
+
+const char * mspd_channel_get_name(const mspd_channel_t *channel)
+{
+    return channel->name;
+}
+
+U16 mspd_channel_get_id(const mspd_channel_t *channel)
+{
+    return channel->id;
+}
+
+// -----------------------------------------------------------------------------------------------
+const char *
+mspd_channel_type2text(mspd_channel_type_t type)
+{
+    switch (type) {
+        case MCT_VOIP:          return "VoIP";
+        case MCT_FOIP:          return "FoIP";
+        case MCT_PART_TDM:      return "Part-TDM";
+        case MCT_PART_RTP:      return "Part-RTP";
+	case MCT_VOIPOSHM:	return "VoIPoSHM";
+    }
+    return "**UNKNOWN_CHAN_TYPE**";
+}
+
+// -----------------------------------------------------------------------------------------------
+// consumer thread function
+static void *
+channel_thread(void *data)
+{
+    mspd_channel_t * const  channel = data;
+    queue_t *        const  queue   = channel->queue;
+    vapi_queue_element_t *  Item    = NULL;
+
+    if (pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL)) {
+        MSPD_ERR("(%s): unable to disable DC Consumer thread cancelability, shutting down\n",
+                channel->name);
+        if (Item && Item != QUEUE_START_ITEM.vItem && Item != QUEUE_STOP_ITEM.vItem)
+            free(Item);
+
+        while ((Item = mspd_queue_get_vItem(queue)) != QUEUE_STOP_ITEM.vItem)
+            if (Item && Item != QUEUE_START_ITEM.vItem) {
+                free(Item);
+                Item = NULL;
+            }
+        goto stop_thread;
+    }
+
+    MSPD_LOG(1, "Starting DC Consumer\n");
+
+    while ((Item = mspd_queue_get_vItem(queue)) != QUEUE_START_ITEM.vItem) {
+        if (Item == QUEUE_STOP_ITEM.vItem)
+            goto stop_thread;
+        if (Item)
+            free(Item);
+    }
+
+    MSPD_LOG(2, "DC consumer thread: consuming on channel %s started\n",
+            channel->name);
+
+    for (Item = NULL;;) {
+        if (Item)
+            free(Item);
+
+        Item = mspd_queue_get_vItem(queue);
+        if (Item == QUEUE_STOP_ITEM.vItem)
+            break;
+
+        if (!Item || Item == QUEUE_START_ITEM.vItem) {
+            MSPD_ERR("(%s): got Item %s from queue\n",
+                    channel->name, Item ? "QUEUE_START_ITEM" : "NULL");
+            continue;
+        }
+
+	switch (Item->usFnCode) {
+        case FC_CND_DONE:
+            MSPD_DBG("Received CND_DONE... signalling on ch 0x%#x:%d\n",
+                    (U32) channel, channel->id);
+            channel->cid_gen_in_progress = False;
+    	    break;
+
+	case FC_PASSTHRU_AUTOSWITCH_IND:
+	    MSPD_LOG(1, "%s: VOIP_PASSTHRU_AUTOSWITCH_IND (%d) received\n", 
+                         channel->name, Item->uPassthruMode); 
+   
+	    ast_mutex_lock(&channel->lock);
+	    if ((Item->uPassthruMode & 0x7) == PASSTHRU_AUTOSWITCH_IND_SWITCH_TYPE_ST_PT)
+		channel->passthru_mode = True; 
+	    else if ((Item->uPassthruMode & 0x7) == PASSTHRU_AUTOSWITCH_IND_SWITCH_TYPE_ST_VOICE)
+		channel->passthru_mode = False; 
+	    ast_mutex_unlock(&channel->lock); 
+	    break; 
+
+	default:
+	    break;
+	}
+
+	channel->event_callback(channel, Item);
+    }
+
+stop_thread:
+    MSPD_LOG(1, "DC consumer thread: consuming on channel %s stopped\n",
+            channel->name);
+    return NULL;
+}
+
+// -----------------------------------------------------------------------------------------------
+// Deletes a channel object
+static void
+channel_destructor (void *obj)
+{
+    mspd_channel_t *channel = (mspd_channel_t *)obj;
+
+    MSPD_LOG(3, "(%s)\n", channel->name);
+
+    AST_LIST_LOCK(&channels);
+    AST_LIST_REMOVE(&channels, channel, list);
+    AST_LIST_UNLOCK(&channels);
+
+    mspd_channel_disable(channel);
+
+    if(channel->destructor)
+        channel->destructor(channel);
+
+    if (channel->pvt)
+        free(channel->pvt);
+
+    if (channel->consumer != AST_PTHREADT_NULL) {
+        mspd_queue_stop(channel->queue);
+        pthread_join(channel->consumer, NULL);
+        channel->consumer = AST_PTHREADT_NULL;
+    }
+
+    if (channel->queue)
+        mspd_queue_destroy(channel->queue);
+
+    if (channel->name)
+        free(channel->name);
+
+    ast_cond_destroy(&channel->msg_is_done_cond);
+    ast_mutex_destroy(&channel->lock);
+}
+
+// -----------------------------------------------------------------------------------------------
+// create a new channel structure (but don't send message to create channel in device)
+mspd_channel_t *
+mspd_channel_create (mspd_device_t 			*dev, 
+		     mspd_channel_type_t 		type,
+		     format_t				ast_format,
+		     Boolean				vad,
+		     int				sizeof_pvt,
+		     mspd_channel_event_callback_t	event_callback, /* will be invoked on any new event */
+		     mspd_channel_destructor_t      	destructor 	/* will be invoked when channel will be destructed */
+		    )
+{
+    mspd_channel_t *channel;
+
+    if (type != MCT_VOIP &&
+		type != MCT_VOIPOSHM &&
+        type != MCT_PART_RTP &&
+        type != MCT_PART_TDM)
+    {
+        MSPD_ERR("(%s,%s): invalid channel type %u\n",
+                mspd_device_get_name(dev), mspd_channel_type2text(type), type);
+        return NULL;
+    }
+
+    // Allocated memory will be zeroed
+    if (!(channel = ao2_alloc(sizeof(*channel), channel_destructor))) {
+        MSPD_ERR("(%s,%s): out of memory\n",
+                mspd_device_get_name(dev), mspd_channel_type2text(type));
+        return NULL;
+    }
+
+    ast_cond_init(&channel->msg_is_done_cond, NULL);
+    ast_mutex_init(&channel->lock);
+
+    channel->dev = dev;
+    channel->type = type;
+    channel->ssrc = rand();
+    channel->format = ast_format;
+    channel->vad = vad;
+    channel->id = mspd_device_get_channel_id(dev);
+    channel->consumer = AST_PTHREADT_NULL;
+    channel->tag = mspd_device_get_channel_tag(dev);
+    channel->name = mspd_asprintf("<%s:%u,%s,%x>",
+                                mspd_device_get_name(dev),
+                                channel->id,
+                                mspd_channel_type2text(type),
+                                channel->tag);
+
+    MSPD_LOG(5, "Channel: type=%s, name=%s\n", mspd_channel_type2text(type), channel->name);
+
+    channel->event_callback = event_callback;
+    channel->destructor = destructor;
+
+    if (event_callback) {
+	/* event handler is defined, start event handling thread */
+        channel->queue = mspd_queue_create(INDICATION_QUEUE_SIZE);
+	if (!channel->queue) {
+    	    MSPD_ERR("(%s,%s): out of memory while allocating queue\n",
+        	    mspd_device_get_name(dev), mspd_channel_type2text(type));
+    	    goto bail_out;
+	}
+
+	if (mspd_queue_start(channel->queue)) {
+    	    MSPD_ERR("(%s): starting queue has failed\n", channel->name);
+    	    goto bail_out;
+	}
+
+	// TODO: Check if Super Visor consumer is needed
+	if (ast_pthread_create(&channel->consumer, NULL, channel_thread, channel) < 0) {
+    	    channel->consumer = AST_PTHREADT_NULL;
+    	    MSPD_ERR("(%s,%s): failed to start indication-handler thread\n",
+        	    mspd_device_get_name(dev), mspd_channel_type2text(type));
+    	    goto bail_out;
+	}
+    }
+
+    channel->pvt = malloc(sizeof_pvt);
+    if(!channel->pvt)
+	goto bail_out;
+    memset(channel->pvt, 0, sizeof_pvt);
+
+    AST_LIST_LOCK(&channels);
+    AST_LIST_INSERT_TAIL(&channels, channel, list);
+    AST_LIST_UNLOCK(&channels);
+
+    return channel;
+
+bail_out:
+    mspd_channel_destroy(channel);
+    return NULL;
+}
+
+
+void
+mspd_channel_destroy (mspd_channel_t *channel)
+{
+    // If delta becomes 0, channel_destructor() will be called;
+    // allocated memory for the pointer will be zeroed and freed by internal_ao2_ref().
+    ao2_ref(channel, -1);
+}
+
+// --------------------------------------------------------------------------------------------
+// Sends Enable/Disable traces command to MSP.
+// this function will be called only when ud_enable is set globally
+int
+mspd_channel_send_ud_cmd (const mspd_channel_t *channel,
+            		  U16 func_code,
+            		  Boolean enable)
+{
+    VSTATUS status  = 1;
+    void *message   = NULL;
+    U32 resp_len    = MAX_FIFO_SIZE;
+    U8  dev_resp     [MAX_FIFO_SIZE];
+    char colored_buf [80];
+
+    message = VAPI_AllocateMessage(MAX_FIFO_SIZE);
+    if (!message) {
+        MSPD_ERR("VAPI_AllocateMessage has failed\n");
+        return -1;
+    }
+
+    status = VAPI_SetMessage(message,
+                CMD_CLASS_OPEN_DIAG,
+                CMD_TYPE_DIAG_MON_LIVE_CTRL,
+                func_code,
+                1,
+                enable);
+        if (status)
+            VAPI_REPORT_ACT (status, "Setting UD command", goto msg_err);
+
+    status = VAPI_SendConnectionMessage(channel->id,
+                (SMsg *)message, NULL,
+                dev_resp, &resp_len);
+
+    if(status) {
+        term_color(colored_buf, "FAILED", COLOR_RED, 0, sizeof (colored_buf));
+
+        MSPD_ERR("%s UD option %-18s (0x%04X) for channel %s %s (0x%x)\n",
+                enable ? "Enabling" : "Disabling",
+                mspd_lookup_msg_id(func_code), func_code,
+                channel->name, colored_buf, status);
+        goto msg_err;
+    }
+    term_color(colored_buf, enable ? "enabled" : "disabled",
+            COLOR_GREEN, 0, sizeof (colored_buf));
+    MSPD_LOG(4, "UD option %-18s (0x%04X) for channel=%s [%s]\n",
+            mspd_lookup_msg_id(func_code), func_code,
+            channel->name, colored_buf);
+msg_err:
+    VAPI_FreeMessage(message);
+
+    return status;
+}
+
+// -----------------------------------------------------------------------------------------------
+// set channel's IP-header for outgoing packets (FC_SET_IP_HDR_CHANNEL, FC=0x9000)
+int
+mspd_channel_set_ip_header (mspd_channel_t *channel,
+                	    struct ast_sockaddr const *src,
+                	    struct ast_sockaddr const *dst)
+{
+    char srcstr[80];
+    char dststr[80];
+    strncpy(srcstr, ast_sockaddr_stringify (src), sizeof(srcstr));
+    strncpy(dststr, ast_sockaddr_stringify (dst), sizeof(dststr));
+
+    MSPD_LOG(3, "Setting IP parameters for channel %s: src=%s, dst=%s\n",
+            channel->name,
+            srcstr,
+            dststr);
+
+    if (ast_sockaddr_cmp_addr(src, mspd_device_get_ipaddr(channel->dev))) {
+        MSPD_ERR("(%s): can't set ip-header: source address (%s) != device address (%s)\n",
+                channel->name,
+                ast_sockaddr_stringify (src),
+                ast_sockaddr_stringify (mspd_device_get_ipaddr(channel->dev)));
+        return 1;
+    }
+
+    VSTATUS     status = 1;
+    SIpParams   ip_params;
+
+    // VAPI does not support IPv6. Should we request development?
+    ip_params.uiDestIpAddr = htonl(ast_sockaddr_ipv4(dst));
+    ip_params.usDestUdpPort = htons(ast_sockaddr_port(dst));
+    ip_params.uiSrcIpAddr = htonl(ast_sockaddr_ipv4(src));
+    ip_params.usSrcUdpPort = htons(ast_sockaddr_port(src));
+    ip_params.ucIPServiceId = 0;
+
+    status = VAPI_SetConnIpParams(channel->id, &ip_params, NULL);
+    VAPI_REPORT (status, "VAPI_SetConnIpParams");
+
+    return status;
+}
+
+// -----------------------------------------------------------------------------------------------
+// send messages to set coding parameters and stop packet generation of channel
+int
+mspd_channel_set_coding_defaults (mspd_channel_t *channel)
+{
+    VSTATUS status  = 1;
+    void *message   = NULL;
+    U32 resp_len    = MAX_FIFO_SIZE;
+    U8  dev_resp     [MAX_FIFO_SIZE];
+
+    // VCEOPT (0x8001) parameters
+    int param1 = 0x0000;
+    int param2 = 0x4000 |                               // Param2 [14]    - UDPTL Packet Detection in VoIP Mode (e.g. T.38 Fax Detection)
+                 mspd_global_get_bitrate_amr() << 10;     // Param2 [12:10] - AMR speed rate table
+    int param5 = 0x0001 |                               // Param5 [0]     - Packet Loss Concealment (PLC) Configuration
+                 mspd_global_get_bitrate_amr_wb() << 5;   // Param5 [8:5]   - AMR_WB (G.722.2) speed rate table
+
+    if (!MSPD_HAS_RTP(channel->type)) {
+        MSPD_ERR("(%s): channel has invalid type %s\n",
+                channel->name, mspd_channel_type2text(channel->type));
+        return 1;
+    }
+
+    param1 = MSPD_VOICE_OPTIONS_TX_DISABLED;
+    if (channel->vad)
+        param1 |= 0x0040;                               // Param1 [7:6]   - Voice Activity Detector (VAD) configuration
+
+    MSPD_LOG(3, "Setting defaults for channel %s: Packet generation disabled, VAD=%d: (0x%x)\n",
+        channel->name, channel->vad, param1);
+
+    message = VAPI_AllocateMessage(MAX_FIFO_SIZE);
+    if (!message) {
+        MSPD_ERR("VAPI_AllocateMessage has failed\n");
+        return -1;
+    }
+
+    /* Mindspeed VOIP_VCEOPT (0x8001) command configuration:
+    Param1:
+    [15:8]  Voice Packetization Interval (sets the period of time in ms spanned by each packet)
+    [7:6]   VAD configuration: 0 = VAD Disabled (default)
+    [5]     Decoder adaptive post filter configuration: 1 = Enable (default)
+    [4]     G.723.1 coding rate: 1 = High rate (6.3 kbps) (default)
+    [3]     Packet generation disable: 0 = Enable packet generation (default)
+    [2]     G.723.1 Decoder DC removal filter disable: 0 = Enable DC removal (default)
+    [1]     Silence handling to PCM interface: 0 = Generate comfort noise to PCM during silence (default)
+    [0]     PCM coding standard. Sets the PSTN coding standard used on the line side: 1 = u-law coding (default)
+
+    Param2:
+    [15]    Packet Reception Disable: 0 = Enables Packet Reception (default).
+    [14]    UDPTL Packet Detection in VoIP Mode (for example, T.38 Fax Detection): 0 - Disabled (default).
+    [13]    G.726 Sample Re-order: 1 <96> IETF bit packing (default)
+    [12:10] AMR speed rate table: 111b = 12.2 (default)
+    [9]     G.722 swap mode selection. The possible values are: 0 = ITU endianess (default)
+    [8]     Reserved (Set to zero)
+    [7]     Reserved (Set to zero)
+    [6]     Reserved (Set to zero)
+    [5:4]   Redundancy of RTP data: 0 = Disable Redundancy (default)
+    [3:2]   Reserved (Set to zero)
+    [1:0]   Reserved (Set to zero)
+
+    Param3:
+    [15:0]  VAD_TUNE, see CRM; Option 4: Least bandwidth saving; but highest quality
+
+    Param4:
+    [15:8]  G.711 Appendix 2 LPC model order for Encoder: 0x00 - Selects PT13 (default)
+    [7:0]   CNG maximum model order for Decoder: 0x00 - Selects PT13 (default)
+
+    Param5:
+    [15:10] Reserved (set to zero)
+    [9]     CRC for AMR_WB (G.722.2) Payload: 0 - Do not add CRC to AMR (default)
+    [8-5]   AMR_WB (G.722.2) speed rate table
+    [4]     Reserved
+    [3]     Reserved
+    [2]     CRC for AMR Payload: 0 = Do not add CRC to AMR byte aligned payload (default)
+    [1]     Bits per Sample Selection: 0 = 8-bit PCM samples (default)
+    [0]     Packet Loss Concealment (PLC) Configuration: 1 = PLC enabled (default)
+    */
+
+    status = VAPI_SetMessage(message,
+                CMD_CLASS_CONF_CHANNEL,
+                CMD_TYPE_CONF_CHANGE,
+                    FC_VOIP_VCEOPT,
+                        5,
+                        param1,
+                        param2,
+                        0x0004,
+                        0x0000,
+                        param5);
+    if (status)
+        VAPI_REPORT_ACT (status, "Setting VOIP_VCEOPT", goto msg_err);
+
+    status = VAPI_SendConnectionMessage(channel->id,
+                (SMsg *)message, NULL,
+                dev_resp, &resp_len);
+    VAPI_REPORT_ACT (status, "Sending VOIP_VCEOPT", goto msg_err);
+
+msg_err:
+    VAPI_FreeMessage(message);
+
+    return status;
+}
+
+// -----------------------------------------------------------------------------------------------
+static int
+set_dtmfmode (mspd_channel_t *channel)
+{
+    MSPD_LOG(5, "Setting DTMF mode for channel %s\n",
+            channel->name);
+
+    VSTATUS status  = 1;
+    void *message   = NULL;
+    U32 resp_len    = MAX_FIFO_SIZE;
+    U8  dev_resp     [MAX_FIFO_SIZE];
+
+    message = VAPI_AllocateMessage(MAX_FIFO_SIZE);
+    if (!message) {
+        MSPD_ERR("VAPI_AllocateMessage has failed\n");
+        return -1;
+    }
+
+    status = VAPI_SetMessage(message,
+                CMD_CLASS_CONF_CHANNEL,
+                CMD_TYPE_CONF_CHANGE,
+                    FC_VOIP_DTMFOPT,
+                        1, 
+			MSP_DTMFOPT_RTP_SILENCE | MSP_DTMFOPT_NO_DTMF_TDM | MSP_DTMFOPT_NO_DTMF_RTP);
+
+    /* We have disabled inband DTMF, because we invoke TONEGEN (as part of send_digit technology API).
+     * We need to use TONEGEN to handle SIP->FXS calls where SIP INFO DTMF method is used by SIP party.
+     * Therefore we need to transform it to TONEGEN.
+     * And we can't keep both inband + TONEDET methods of DTMF delivery for MSP because for FXS->FXS call 
+     * indications of both types will be sent to bridged FXS port and this will cause collisions.
+     *
+     * According to CRM:
+     * "DTMF in RTP, and out of channel relay via TONEDET/TONEGEN should not be used simultaneously, as the
+     * internal operation of DTMF in RTP is to generate TONEGEN requests. If the host also sends TONEGEN requests
+     * for the same digits, the sequence will probably be corrupted (e.g. digits duplicated)."
+     *
+     * A side effect of this could be following SIP->FXS call:
+     * If SIP party uses inband + SIP INFO DTMF methods simultaneously and Asterisk is configured to dtmfmode=info, 
+     * We will map SIP INFO to TONEGEN (via send_digit API), but inband will be passed as is.
+     * This will cause undefined behavior on accepting side (for example FXO port) according to CRM statement above.
+     * On the other hand if we disable TONEGEN, we wouldn't be able to handle case with SIP->FXS call with just SIP INFO indications.
+     *
+     * So with this implementation we map inbound stream to MSP following way.
+     *
+     * For SIP->FXS calls. MSP has inband DTMF removal from incoming RTP stream disabled. MSPD CM handles send_digit API from Asterisk core.
+     * SIP->Asterisk                             dtmfmode (sip.conf)      Asterisk->MSP               DTMF on TDM
+     * -----------------------------------------------------------------------------------------------------------
+     * inband ULAW/ALAW + INFO                   info                     inband + TONEGEN            + (double propagation is possible)
+     * inband ULAW/ALAW + INFO                   inband                   TONEGEN            	      +
+     * inband ULAW/ALAW + INFO                   rfc2833                  inband                      +
+     * inband ULAW/ALAW                          inband 		  TONEGEN                     +
+     * inband complex codec                      inband			  inband                      -
+     * inband complex codec + INFO               info			  TONEGEN                     +
+     * inband complex codec + INFO               inband			  inband	              -
+     * INFO                		         info			  TONEGEN                     +
+     * RFC2833				         rfc2833		  TONEGEN                     +
+     * INFO + RFC2833                	         info			  TONEGEN                     +
+     * INFO + RFC2833                	         rfc2833		  TONEGEN                     +
+     * inband ULAW/ALAW + RFC2833                rfc2833		  TONEGEN                     +
+     * inband ULAW/ALAW + RFC2833 (SDP)          auto			  TONEGEN		      +
+     * inband ULAW/ALAW (SDP) + RFC2833          auto			  TONEGEN		      +
+     * inband complex codec (SDP) + RFC2833      auto			  inband		      +
+
+     *
+     *
+     * For FXS->FXS calls: 
+     * MSP->Asterisk             Asterisk->MSP
+     * ---------------------------------------------------------------------------------------
+     * TONEDET                   TONEGEN
+     *
+     *
+     * For FXS->SIP calls: 
+     * MSP->Asterisk                             dtmfmode (sip.conf)      Asterisk->SIP
+     * ---------------------------------------------------------------------------------------
+     * TONEDET                   		 info                     SIP INFO
+     * TONEDET                                   rfc2833                  RFC2833
+     * TONEDET                                   inband 		  inband
+     */
+
+    if (status)
+            VAPI_REPORT_ACT (status, "Setting VOIP_DTMFOPT", goto msg_err);
+
+    status = VAPI_SendConnectionMessage(channel->id,
+                (SMsg *)message, NULL,
+                dev_resp, &resp_len);
+    VAPI_REPORT_ACT (status, "Sending VOIP_DTMFOPT", goto msg_err);
+
+msg_err:
+    VAPI_FreeMessage(message);
+
+    return status;
+}
+
+// -----------------------------------------------------------------------------------------------
+int
+mspd_channel_set_dtmfpar (mspd_channel_t *channel)
+{
+    MSPD_LOG(5, "Setting DTMF params for channel %s\n", channel->name);
+
+    VSTATUS status  = 1;
+    void *message   = NULL;
+    U32 resp_len    = MAX_FIFO_SIZE;
+    U8  dev_resp     [MAX_FIFO_SIZE];
+
+    message = VAPI_AllocateMessage(MAX_FIFO_SIZE);
+    if (!message) {
+        MSPD_ERR("VAPI_AllocateMessage has failed\n");
+        return -1;
+    }
+
+    status = VAPI_SetMessage(message,
+                CMD_CLASS_CONF_CHANNEL,
+                CMD_TYPE_CONF_CHANGE,
+                    FC_VOIP_DTMFDPAR,
+                        3,
+                        30,
+                        35,
+                        20);
+
+    if (status)
+            VAPI_REPORT_ACT (status, "Setting VOIP_DTMFDPAR", goto msg_err);
+
+    status = VAPI_SendConnectionMessage(channel->id,
+                (SMsg *)message, NULL,
+                dev_resp, &resp_len);
+    VAPI_REPORT_ACT (status, "Sending VOIP_DTMFDPAR", goto msg_err);
+
+msg_err:
+    VAPI_FreeMessage(message);
+
+    return status;
+}
+
+//-----------------------------------------------------------------------------------------------
+//send messages to set the tonectrl parameter of the channel
+int
+mspd_channel_set_tonectrl (mspd_channel_t *channel)
+{
+    MSPD_LOG(5, "Setting tone control for %s\n", channel->name);
+
+    VSTATUS status  = 1;
+    void *message   = NULL;
+    U32 resp_len    = MAX_FIFO_SIZE;
+    U8  dev_resp     [MAX_FIFO_SIZE];
+
+    message = VAPI_AllocateMessage(MAX_FIFO_SIZE);
+    if (!message) {
+        MSPD_ERR("VAPI_AllocateMessage has failed\n");
+        return -1;
+    }
+
+    /* VoIP_TONECTRL: Tone Indication Control (0x805B), see CRM 14.5.31
+
+    Parameter 1 - Tone Feature Group Enable Bits
+    [15:9]  Reserved
+    [8]     V.32ext Auto-EC Off. -- 0: Disabled. (default)
+    [7]     Disable Notch filter control for 2002 Hz tone
+    [6]     Call Progress Tone Indication
+    [5]     Answer Tone (2100 Hz) Notch Filter Control -- 0 = enabled for all codecs (excepts G.711) (default)
+    [4]     Fax Calling Tone (CNG 1100 Hz) Detector Control
+    [3]     V.8bis Cre (2002 Hz and 1375 Hz) tone detector control.
+    [2]     Modem Passthrough Affected Tone Detection Indication (for example, ANS, ANS/, Voice and Silence)
+    [1]     Fax Affected Tone Detection Indication (for example, V.21 Flag Detector)
+    [0]     DTMF Detection Indication
+    */
+
+    status = VAPI_SetMessage(message,
+                CMD_CLASS_CONF_CHANNEL,
+                CMD_TYPE_CONF_CHANGE,
+                    FC_VOIP_TONECTRL,
+                        1, TONECTRL_DTMF | TONECTRL_FPT | TONECTRL_MTP | TONECTRL_CNG);
+    if (status)
+        VAPI_REPORT_ACT (status, "Setting VOIP_TONECTRL", goto msg_err);
+
+    status = VAPI_SendConnectionMessage(channel->id,
+                (SMsg *)message, NULL,
+                dev_resp, &resp_len);
+    VAPI_REPORT_ACT (status, "Sending VOIP_TONECTRL", goto msg_err);
+
+msg_err:
+    VAPI_FreeMessage(message);
+
+    return status;
+}
+
+// -----------------------------------------------------------------------------------------------
+// send message to start packet generation and set various coding parameters of channel
+int
+mspd_channel_start_conf_tx (mspd_channel_t *channel)
+{
+    if (!MSPD_HAS_RTP(channel->type)) {
+        MSPD_ERR("(%s): channel has invalid type %s\n",
+                channel->name, mspd_channel_type2text(channel->type));
+        return 1;
+    }
+
+    MSPD_LOG(3, "Enabling packet generation for channel %s (0x%x)\n",
+            channel->name, MSPD_VOICE_OPTIONS_TX_ENABLED);
+
+    VSTATUS status  = 1;
+    void *message   = NULL;
+    U32 resp_len    = MAX_FIFO_SIZE;
+    U8  dev_resp     [MAX_FIFO_SIZE];
+
+    message = VAPI_AllocateMessage(MAX_FIFO_SIZE);
+    if (!message) {
+        MSPD_ERR("VAPI_AllocateMessage has failed\n");
+        return -1;
+    }
+
+    status = VAPI_SetMessage(message,
+                CMD_CLASS_CONF_CHANNEL,
+                CMD_TYPE_CONF_CHANGE,
+                    FC_VOIP_VCEOPT,
+                        1, MSPD_VOICE_OPTIONS_TX_ENABLED);
+    if (status)
+        VAPI_REPORT_ACT (status, "Setting VOIP_VCEOPT", goto msg_err);
+
+    status = VAPI_SendConnectionMessage(channel->id,
+                (SMsg *)message, NULL,
+                dev_resp, &resp_len);
+    VAPI_REPORT_ACT (status, "Sending VOIP_VCEOPT", goto msg_err);
+
+msg_err:
+    VAPI_FreeMessage(message);
+
+    return status;
+}
+
+// -----------------------------------------------------------------------------------------------
+// send message to start packet generation and set various coding parameters of channel
+int
+mspd_channel_start_tx (mspd_channel_t *channel)
+{
+    int param1 = MSPD_VOICE_OPTIONS_TX_ENABLED;
+
+    if (!MSPD_HAS_RTP(channel->type)) {
+        MSPD_ERR("(%s): channel has invalid type %s\n",
+                channel->name, mspd_channel_type2text(channel->type));
+        return 1;
+    }
+    if (channel->vad)
+        param1 |= 0x0040;
+
+    MSPD_LOG(3, "Enabling packet generation for channel %s, VAD=%d (0x%x)\n",
+            channel->name, channel->vad, param1);
+
+    VSTATUS status  = 1;
+    void *message   = NULL;
+    U32 resp_len    = MAX_FIFO_SIZE;
+    U8  dev_resp     [MAX_FIFO_SIZE];
+
+    message = VAPI_AllocateMessage(MAX_FIFO_SIZE);
+    if (!message) {
+        MSPD_ERR("VAPI_AllocateMessage has failed\n");
+        return -1;
+    }
+
+    status = VAPI_SetMessage(message,
+                CMD_CLASS_CONF_CHANNEL,
+                CMD_TYPE_CONF_CHANGE,
+                    FC_VOIP_VCEOPT,
+                        1, param1);
+    if (status)
+        VAPI_REPORT_ACT (status, "Setting VOIP_VCEOPT", goto msg_err);
+
+    status = VAPI_SendConnectionMessage(channel->id,
+                (SMsg *)message, NULL,
+                dev_resp, &resp_len);
+    VAPI_REPORT_ACT (status, "Sending VOIP_VCEOPT", goto msg_err);
+
+msg_err:
+    VAPI_FreeMessage(message);
+
+    return status;
+}
+
+// -----------------------------------------------------------------------------------------------
+// send message to stop packet generation and set various coding parameters of channel
+int
+mspd_channel_stop_tx (mspd_channel_t *channel)
+{
+    if (!MSPD_HAS_RTP(channel->type)) {
+        MSPD_ERR("(%s): channel has invalid type %s\n",
+                channel->name, mspd_channel_type2text(channel->type));
+        return 1;
+    }
+
+    MSPD_LOG(3, "Disabling packet generation for channel %s (0x%x)\n",
+            channel->name, MSPD_VOICE_OPTIONS_TX_DISABLED);
+
+    VSTATUS status  = 1;
+    void *message   = NULL;
+    U32 resp_len    = MAX_FIFO_SIZE;
+    U8  dev_resp     [MAX_FIFO_SIZE];
+
+    message = VAPI_AllocateMessage(MAX_FIFO_SIZE);
+    if (!message) {
+        MSPD_ERR("VAPI_AllocateMessage has failed\n");
+        return -1;
+    }
+
+    status = VAPI_SetMessage(message,
+                CMD_CLASS_CONF_CHANNEL,
+                CMD_TYPE_CONF_CHANGE,
+                    FC_VOIP_VCEOPT,
+                        1, MSPD_VOICE_OPTIONS_TX_DISABLED);
+    if (status)
+        VAPI_REPORT_ACT (status, "Setting VOIP_VCEOPT", goto msg_err);
+
+    status = VAPI_SendConnectionMessage(channel->id,
+                (SMsg *)message, NULL,
+                dev_resp, &resp_len);
+    VAPI_REPORT_ACT (status, "Sending VOIP_VCEOPT", goto msg_err);
+
+msg_err:
+    VAPI_FreeMessage(message);
+
+    return status;
+}
+
+// ------------------------------------------------------------------------------
+// send message to enable fax-processing on channel
+int
+mspd_channel_enable_foip (mspd_channel_t *channel)
+{
+    if (channel->type != MCT_FOIP) {
+        MSPD_ERR("(%s): channel has invalid type %s\n",
+                channel->name, mspd_channel_type2text(channel->type));
+        return 1;
+    }
+
+    MSPD_LOG(3,"Enabling UDPTL mode for %s\n", channel->name);
+
+    VSTATUS status  = 1;
+    void *message   = NULL;
+    U32 resp_len    = MAX_FIFO_SIZE;
+    U8  dev_resp     [MAX_FIFO_SIZE];
+
+    message = VAPI_AllocateMessage(MAX_FIFO_SIZE);
+    if (!message) {
+        MSPD_ERR("VAPI_AllocateMessage has failed\n");
+        return -1;
+    }
+
+    status = VAPI_SetMessage(message,
+                CMD_CLASS_CONF_CHANNEL,
+                CMD_TYPE_CONF_CHANGE,
+                    FC_VOIP_VOPENA,
+                        1, VOIP_VOPENA_MODE_ENABLE_UDPTL);
+    if (status)
+        VAPI_REPORT_ACT (status, "Setting VOIP_VOPENA", goto msg_err);
+
+    status = VAPI_SendConnectionMessage(channel->id,
+                (SMsg *)message, NULL,
+                dev_resp, &resp_len);
+    VAPI_REPORT_ACT (status, "Sending VOIP_VOPENA", goto msg_err);
+
+msg_err:
+    VAPI_FreeMessage(message);
+
+    return status;
+}
+
+// -----------------------------------------------------------------------------------------------
+// send message to enable voice processing on channel (and set codec to use)
+int
+mspd_channel_enable (mspd_channel_t *channel, format_t ast_format_id)
+{
+    S8 payload_type = -1;
+
+    MSPD_LOG(3, "Enabling channel %s in format %s\n", channel->name, ast_getformatname(ast_format_id));
+
+    while (payload_type < 0) {
+        switch (ast_format_id) {
+            case AST_FORMAT_ULAW:       payload_type = 0x00;    break;
+            case AST_FORMAT_GSM:        payload_type = 0x03;    break;
+            case AST_FORMAT_G723_1:     payload_type = 0x04;    break;
+            case AST_FORMAT_ALAW:       payload_type = 0x08;    break;
+            case AST_FORMAT_G722:       payload_type = 0x09;    break;
+            case AST_FORMAT_G729A:      payload_type = 0x12;    break;
+            case AST_FORMAT_ILBC_1:     payload_type = 0x1D;    break;
+            case AST_FORMAT_ILBC:       payload_type = 0x1E;    break;
+            case AST_FORMAT_G726_16:    payload_type = 0x5B;    break;
+	    case AST_FORMAT_G726_24:    payload_type = 0x5C;    break;
+	    case AST_FORMAT_G726_32:    payload_type = 0x02;    break;
+	    case AST_FORMAT_G726_40:    payload_type = 0x5A;    break;
+	    case AST_FORMAT_AMR:        payload_type = 0x27;    break;
+	    case AST_FORMAT_AMR_WB:     payload_type = 0x40;    break;
+            default:
+                if (ast_format_id == MSPD_DEFAULT_CODEC) {
+                    MSPD_ERR("(%s): default format (%s) is unsupported!?\n",
+                            channel->name, ast_getformatname(ast_format_id));
+                    return 1;
+                }
+                MSPD_WARN(3, "(%s): got unsupported format %s, resetting to %s\n",
+                        channel->name, ast_getformatname(ast_format_id),
+                        ast_getformatname(MSPD_DEFAULT_CODEC));
+                ast_format_id = MSPD_DEFAULT_CODEC;
+        }
+    } // while (payload_type < 0)
+
+    MSPD_LOG(3, "(%s,%s) Payload type: 0x%x\n",
+            channel->name, ast_getformatname(ast_format_id), payload_type);
+
+    VSTATUS status  = 1;
+    void *message   = NULL;
+    U32 resp_len    = MAX_FIFO_SIZE;
+    U8  dev_resp     [MAX_FIFO_SIZE];
+
+    message = VAPI_AllocateMessage(MAX_FIFO_SIZE);
+    if (!message) {
+        MSPD_ERR("VAPI_AllocateMessage has failed\n");
+        return -1;
+    }
+
+    channel->format = ast_format_id;
+    status = VAPI_SetMessage(message,
+                CMD_CLASS_CONF_CHANNEL,
+                CMD_TYPE_CONF_CHANGE,
+                    FC_VOIP_VOPENA,
+                        7,
+                        VOIP_VOPENA_MODE_ENABLE_RTP,
+                        ((U16)payload_type << 8) | 0x80,
+                        0x0000,
+                        0x0000,
+                        0x0000,
+                        channel->ssrc >> 16,
+                        channel->ssrc);
+    if (status)
+        VAPI_REPORT_ACT (status, "Setting VOIP_VOPENA", goto msg_err);
+
+    status = VAPI_SendConnectionMessage(channel->id,
+                (SMsg *)message, NULL,
+                dev_resp, &resp_len);
+    VAPI_REPORT_ACT (status, "Sending voice enable", goto msg_err);
+
+    if (!status)
+	/* Sending VOPENA switches MSP to voice mode from FPT */
+	channel->passthru_mode = False;
+
+msg_err:
+    VAPI_FreeMessage(message);
+
+    return status;
+}
+
+// ----------------------------------------------------------------------------------------------
+// send message to channel to disable voice processing
+int
+mspd_channel_disable(mspd_channel_t *channel)
+{
+    if (!MSPD_HAS_RTP(channel->type) &&
+        !MSPD_HAS_TDM(channel->type))
+    {
+        MSPD_ERR("(%s): channel has invalid type %s\n",
+                channel->name, mspd_channel_type2text(channel->type));
+        return 1;
+    }
+    MSPD_LOG(3, "Disabling channel %s\n", channel->name);
+
+    VSTATUS status  = 1;
+    void *message   = NULL;
+    U32 resp_len    = MAX_FIFO_SIZE;
+    U8  dev_resp     [MAX_FIFO_SIZE];
+
+    message = VAPI_AllocateMessage(MAX_FIFO_SIZE);
+    if (!message) {
+        MSPD_ERR("VAPI_AllocateMessage has failed\n");
+        return -1;
+    }
+
+    status = VAPI_SetMessage(message,
+                CMD_CLASS_CONF_CHANNEL,
+                CMD_TYPE_CONF_CHANGE,
+                    FC_VOIP_VOPENA,
+                        1,
+                        0x0000);
+    if (status)
+        VAPI_REPORT_ACT (status, "Setting VOIP_VOPENA", goto msg_err);
+
+    status = VAPI_SendConnectionMessage(channel->id,
+                (SMsg *)message, NULL,
+                dev_resp, &resp_len);
+    VAPI_REPORT_ACT (status, "Sending voice disable", goto msg_err);
+
+msg_err:
+    VAPI_FreeMessage(message);
+
+    return status;
+}
+
+// -----------------------------------------------------------------------------------------------
+// disable tones or enable specific tone to PCM for channel
+int
+mspd_channel_set_tone (mspd_channel_t *channel, mspd_tone_t tone)
+{
+    char const *tone_name = NULL;
+    int vTone = 0;
+    VSTATUS status  = 1;
+
+    switch (tone) {
+        case DC_TONE_OFF:                                tone_name = "OFF";      break;
+        case DC_TONE_BUSY:      vTone = eBUSYTONE;       tone_name = "BUSY";     break;
+        case DC_TONE_DIAL:      vTone = eDIALTONE;       tone_name = "DIAL";     break;
+        case DC_TONE_ANSWER:    vTone = eRINGBACKTONE;   tone_name = "ANSWER";   break;
+        // Parameters of eCUSTOM tones are defined in dc_setup_signalling_tones ()
+        case DC_TONE_INDI:      vTone = eCUSTOM_1;       tone_name = "INDICATION"; break;
+        case DC_TONE_HOLD:      vTone = eCUSTOM_2;       tone_name = "HOLD_TONE";  break;
+        default:
+            MSPD_ERR("(%s): invalid tone %u\n", channel->name, tone);
+            return 1;
+    }
+
+    MSPD_LOG(3, "(%s): set tone %s\n", channel->name, tone_name);
+
+    if (!MSPD_HAS_TDM(channel->type)) {
+        MSPD_ERR("(%s): channel has invalid type %s\n",
+                channel->name, mspd_channel_type2text(channel->type));
+        return 1;
+    }
+
+    SPlayToneOpt pstPlayToneOpt = {1,1,0,0}; // Mixing voice with tone while ToneON and ToneOFF
+
+    if (vTone)
+        status = VAPI_PlayTone(channel->id, vTone, eDirToTDM, &pstPlayToneOpt, 0, NULL);
+    else
+        status = VAPI_StopTone(channel->id, 0, 0, NULL);
+
+    VAPI_REPORT_ACT (status, "VOIP_TONEGEN", return 1);
+
+    channel->tone = tone;
+
+    return 0;
+}
+
+mspd_tone_t
+mspd_channel_get_tone (const mspd_channel_t *channel)
+{
+    return channel->tone;
+}
+
+// -----------------------------------------------------------------------------------------------
+int
+mspd_channel_play_dtmftone (mspd_channel_t *channel, char digit)
+{
+    int vTone = 0xFF;
+    VSTATUS status  = 1;
+
+    MSPD_LOG(5, "(%s): play DTMF tone %c\n", channel->name, digit);
+
+    switch (digit) {
+        case '1': vTone = eDTMFTONE_1;      break;
+        case '2': vTone = eDTMFTONE_2;      break;
+        case '3': vTone = eDTMFTONE_3;      break;
+        case '4': vTone = eDTMFTONE_4;      break;
+        case '5': vTone = eDTMFTONE_5;      break;
+        case '6': vTone = eDTMFTONE_6;      break;
+        case '7': vTone = eDTMFTONE_7;      break;
+        case '8': vTone = eDTMFTONE_8;      break;
+        case '9': vTone = eDTMFTONE_9;      break;
+        case '0': vTone = eDTMFTONE_0;      break;
+        case 'A': vTone = eDTMFTONE_A;      break;
+        case 'B': vTone = eDTMFTONE_B;      break;
+        case 'C': vTone = eDTMFTONE_C;      break;
+        case 'D': vTone = eDTMFTONE_D;      break;
+        case '*': vTone = eDTMFTONE_STAR;   break;
+        case '#': vTone = eDTMFTONE_HASH;   break;
+        default:
+            return 1;
+    }
+
+    status = VAPI_PlayTone(channel->id, vTone, eDirToTDM, NULL, 0, NULL);
+    VAPI_REPORT_ACT (status, "Play tone", return 1);
+
+    return 0;
+}
+
+// -----------------------------------------------------------------------------------------------
+// set new rtp peer (and/or codec) of channel (rtp-bridge & meetme)
+int
+mspd_channel_set_rtp_peer (mspd_channel_t *channel,
+                struct ast_rtp_instance *intern_rtp,
+                struct ast_rtp_instance *rtp,
+                format_t prefered_codec)
+{
+    if (!MSPD_HAS_RTP(channel->type)) {
+        MSPD_ERR("(%s): channel has invalid type\n", channel->name);
+        return 1;
+    }
+
+    if (!intern_rtp) {
+        MSPD_ERR("(%s): intern-rtp is missing\n", channel->name);
+        return 1;
+    }
+
+    if (option_verbose > 2) {
+        struct ast_sockaddr own_peer, own_us;
+        ast_rtp_instance_get_local_address(intern_rtp, &own_us);
+        ast_rtp_instance_get_remote_address(intern_rtp, &own_peer);
+        MSPD_LOG(3, "(%s): current: %s -> %s\n",
+                    channel->name,
+                    ast_sockaddr_stringify (&own_us),
+                    ast_sockaddr_stringify (&own_peer));
+    }
+
+    if (rtp) {
+        struct ast_sockaddr src_ip, dst_ip;
+        ast_rtp_instance_get_remote_address(intern_rtp, &src_ip);
+        ast_rtp_instance_get_remote_address(rtp, &dst_ip);
+
+        //if (dst_ip.sin_addr.s_addr == mspd_global.ipaddr ||
+        //    dst_ip.sin_addr.s_addr == channel->dev->ipaddr)
+        if (ast_sockaddr_cmp_addr(&dst_ip, mspd_global_get_ipaddr()) ||
+            ast_sockaddr_cmp_addr(&dst_ip, mspd_device_get_ipaddr(channel->dev)))
+        {
+            MSPD_ERR("(%s): invalid RTP %s -> %s\n",
+                    channel->name,
+                    ast_sockaddr_stringify (&src_ip),
+                    ast_sockaddr_stringify (&dst_ip));
+            return 1;
+        }
+
+        return -1;
+    }
+    else { // !rtp
+        if ((channel->type == MCT_VOIP) || (channel->type == MCT_VOIPOSHM)){
+
+            struct ast_sockaddr src, dst;
+            ast_rtp_instance_get_remote_address(rtp, &src);
+            ast_rtp_instance_get_local_address(rtp, &dst);
+
+            MSPD_DBG("rtp was NULL, using intern_rtp\n");
+            MSPD_INFO_ABOUT_RTP(intern_rtp);
+
+            if (mspd_channel_disable(channel))                                return 1;
+            if (mspd_channel_set_ip_header(channel, &src, &dst))              return 1;
+            if (mspd_channel_enable(channel, prefered_codec))                 return 1;
+        }
+        else {
+            if (mspd_channel_disable(channel))                                return 1;
+        }
+    }
+    return 0;
+}
+
+// -----------------------------------------------------------------------------------------------
+// mute or unmute the participant of a conference
+int
+mspd_channel_mute_participant (mspd_channel_t *channel, Boolean do_mute)
+{
+    MSPD_LOG(3, "%s %s\n", do_mute ? "Mute" : "Unmute", channel->name);
+
+    if (!MSPD_IS_PART(channel->type)) {
+        MSPD_ERR("(%s,%d): channel has invalid type\n", channel->name, do_mute);
+        return 1;
+    }
+    VSTATUS status =
+        VAPI_MuteParticipant(channel->id, do_mute, NULL);
+
+    if (do_mute)
+        VAPI_REPORT(status, "CONF_MUTE_PARTICIPANT: Mute");
+    else
+        VAPI_REPORT(status, "CONF_MUTE_PARTICIPANT: Unmute");
+
+    return status;
+}
+
+// -----------------------------------------------------------------------------------------------
+// hold or unhold the participant of a conference
+int
+mspd_channel_hold_participant (mspd_channel_t *channel, Boolean do_hold)
+{
+    MSPD_LOG(3, "%s %s\n", do_hold ? "Hold" : "Unhold", channel->name);
+
+    if (!MSPD_IS_PART(channel->type)) {
+        MSPD_ERR("(%s,%d): channel has invalid type\n", channel->name, do_hold);
+        return 1;
+    }
+    VSTATUS status =
+        VAPI_PutParticipantOnHold(channel->id, do_hold ? eSIMPLEHOLD : eUNHOLD, 0, NULL);
+
+    if (do_hold)
+        VAPI_REPORT(status, "CONF_PUT_PARTICIPANT_ON_HOLD: eSIMPLEHOLD");
+    else
+        VAPI_REPORT(status, "CONF_PUT_PARTICIPANT_ON_HOLD: eUNHOLD");
+
+    return status;
+}
+
+
+// -----------------------------------------------------------------------------------------------
+int
+mspd_channel_payload_manager (mspd_channel_t *channel)
+{
+    MSPD_LOG(3, "%s: Setting payload type\n", channel->name);
+
+    VSTATUS status  = 1;
+    void *message   = NULL;
+    U32 resp_len    = MAX_FIFO_SIZE;
+    U8  dev_resp     [MAX_FIFO_SIZE];
+
+    message = VAPI_AllocateMessage(MAX_FIFO_SIZE);
+    if (!message) {
+        MSPD_ERR("VAPI_AllocateMessage has failed\n");
+        return -1;
+    }
+
+    status = VAPI_SetMessage(message,
+                CMD_CLASS_CONF_CHANNEL,
+                CMD_TYPE_CONF_CHANGE,
+                    FC_VOIP_PTMNG,
+                        26,
+                        0x600D, // (01) Redundant scheme for DTMF (default 0xFF)    (00) Generic Confort Noise (default 0x0D)
+                        0x6261, // (03) Internet Fax Protocol (default 0xFF)        (02) RFC2833 DTMF (default 0xFF)
+                        0x0800, // (05) G.711 A-law PCM (default 0x08)              (04) G.711 u-law PCM (default 0x00)
+                        0x0F04, // (07) G.728 (default 0x0F)                        (06) G.723.1 (default 0x04)
+                        0x0212, // (09) G.726-32 (default 0x02)                     (08) G.729a (default 0x12)
+                        0x03FF, // (11) GSM_FR (default 0x02)                       (10) G.727 (default 0x12)
+                        0xFFFF, // (13) Pass through u-law (default 0xFF)           (12) Clear Channel (default 0xFF)
+                        0x5BFF, // (15) G.726-16 (default 0xFF)                     (14) Pass through A-law (default 0xFF)
+                        0x5A5C, // (17) G.726-40 (default 0xFF)                     (16) G.726-24 (default 0xFF)
+                        0x27FF, // (19) GSM_AMR (default 0xFF)                      (18) GSM_EFR (default 0xFF)
+                        0x0DFF, // (21) CNF SEC (default 0xFF)                      (21) EVRC (default 0xFF)
+                        0xFFFF, // (23) QCELP-13K (default 0xFF)                    (22) SMV (default 0xFF)
+                        0xFFFF, // (25) CRBT-ADPCM (default 0xFF)                   (24) QCELP-8K (default 0xFF)
+                        0xFFFF, // (27) FEC (default 0xFF)                          (26) G.729eg (default 0xFF)
+                        0x1E1D, // (29) ILBC-13.33k (default 0xFF)                  (28) ILBC-15.20k (default 0xFF)
+                        0xFFFF, // (31) GSM_AMR_BWE (default 0xFF)                  (30) RFC2833 Event (default 0xFF)
+                        0xFFFF, // (33) RFC2833 Tone (default 0xFF)                 (32) EVRC-B (default 0xFF)
+                        0xFF40, // (35) G729_MSPD (default 0xFF)                    (34) AMR_WB (G722.2) (default 0xFF)
+                        0xFFFF, // (37) GSM_HR (default 0xFF)                       (36) CESoPSN (default 0xFF)
+                        0xFFFF, // (39) CSD_BS30T_32k (default 0xFF)                (38) CSD_BS30T_64k (default 0xFF)
+                        0xFFFF, // (41) CSD_BS30T_28k8 (default 0xFF)               (40) CSD_BS30T_33k6 (default 0xFF)
+                        0xFFFF, // (43) CSD_BS20T_28k8 (default 0xFF)               (42) CSD_BS20T_57k6 (default 0xFF)
+                        0xFFFF, // (45) G729.1 (default 0xFF)                       (44) CSD_BS20T_14k4 (default 0xFF)
+                        0xFFFF, // (47) CCISoIP (default 0xFF)                      (46) AMR_WB (G722.2) Byte-aligned (default 0xFF)
+                        0xFF09, // (49) reserved (default 0xFF)                     (48) G.722 (default 0xFF)
+                        0xFFFF);// (51) reserved (default 0xFF),                    (50) CSD_BS20T_9k6 (default 0xFF));
+
+    if (status)
+        VAPI_REPORT_ACT (status, "Setting VOIP_PTMNG", goto msg_err);
+
+
+    status = VAPI_SendConnectionMessage(channel->id,
+                (SMsg *)message, NULL,
+                dev_resp, &resp_len);
+    VAPI_REPORT_ACT (status, "Sending VOIP_PTMNG", goto msg_err);
+
+msg_err:
+    VAPI_FreeMessage(message);
+
+    return status;
+}
+
+
+// -----------------------------------------------------------------------------------------------
+int
+mspd_channel_set_toneopt (mspd_channel_t *channel)
+{
+    if (mspd_global_get_fax_mode() != MSPD_FAXMODE_PASSTHRU)
+            return 0;
+
+    MSPD_LOG(3, "%s: Setting tone options\n", channel->name);
+
+    VSTATUS status  = 1;
+    void *message   = NULL;
+    U32 resp_len    = MAX_FIFO_SIZE;
+    U8  dev_resp     [MAX_FIFO_SIZE];
+
+    message = VAPI_AllocateMessage(MAX_FIFO_SIZE);
+    if (!message) {
+        MSPD_ERR("VAPI_AllocateMessage has failed\n");
+        return -1;
+    }
+
+
+    status = VAPI_SetMessage(message,
+                CMD_CLASS_CONF_CHANNEL,
+                CMD_TYPE_CONF_CHANGE,
+                    FC_VOIP_TONEOPT,
+                        1,
+                        0x000F);
+    if (status)
+        VAPI_REPORT_ACT (status, "Setting VOIP_TONEOPT", goto msg_err);
+
+
+    status = VAPI_SendConnectionMessage(channel->id,
+                (SMsg *)message, NULL,
+                dev_resp, &resp_len);
+    VAPI_REPORT_ACT (status, "Sending VOIP_TONEOPT", goto msg_err);
+
+msg_err:
+    VAPI_FreeMessage(message);
+
+    return status;
+}
+
+int
+mspd_channel_put_event(mspd_channel_t* channel, queue_item_t item)
+{
+    if (channel->queue->n_items >= channel->queue->queue_size) {
+        MSPD_ERR("(%s): channel-queue is full -> dropping indication\n", channel->name);
+        goto bail_out;
+    }
+
+    if (mspd_queue_put(channel->queue, item)) {
+        MSPD_ERR("(%s): queue-add has failed -> dropping indication\n", channel->name);
+        goto bail_out;
+    }
+    return 0;
+
+bail_out:
+    free(item.vItem);
+    return 1;
+
+}
+
+mspd_channel_t *mspd_channel_find_locked(CONNID id)
+{
+    mspd_channel_t *channel = NULL;
+
+    AST_LIST_LOCK(&channels);
+    AST_LIST_TRAVERSE(&channels, channel, list) {
+        if (channel->id == id)
+            break;
+    }
+    AST_LIST_UNLOCK(&channels);
+
+    if(channel)
+	ast_mutex_lock(&channel->lock);
+
+    return channel;
+}
+
+mspd_channel_t *
+mspd_channel_find_by_name_locked(const char* name)
+{
+    mspd_channel_t *channel = NULL;
+
+    AST_LIST_LOCK(&channels);
+    AST_LIST_TRAVERSE(&channels, channel, list) {
+        if (!strcmp(channel->name, name))
+            break;
+    }
+    AST_LIST_UNLOCK(&channels);
+
+    if(channel)
+	ast_mutex_lock(&channel->lock);
+
+    return channel;
+}
+int mspd_channel_lock(mspd_channel_t *channel)
+{
+    return ast_mutex_lock(&channel->lock);
+}
+
+void 
+mspd_channel_unlock(mspd_channel_t *channel)
+{
+    ast_mutex_unlock(&channel->lock);
+}
+
+// -----------------------------------------------------------------------------------------------
+int
+mspd_channel_set_passthru_autoswitch (mspd_channel_t *channel)
+{
+    MSPD_LOG(3, "%s: Activating Passthru autoswitch\n", channel->name);
+
+    VSTATUS status  = 1;
+    void *message   = NULL;
+    U32 resp_len    = MAX_FIFO_SIZE;
+    U8  dev_resp     [MAX_FIFO_SIZE];
+
+    message = VAPI_AllocateMessage(MAX_FIFO_SIZE);
+    if (!message) {
+        MSPD_ERR("VAPI_AllocateMessage has failed\n");
+        return -1;
+    }
+
+
+    status = VAPI_SetMessage(message,
+                CMD_CLASS_CONF_CHANNEL,
+                CMD_TYPE_CONF_CHANGE,
+                    FC_SET_PASSTHRU_AUTOSWITCH,
+                        1,
+                        0x0239);
+    if (status)
+        VAPI_REPORT_ACT (status, "Setting SET_PASSTHRU_AUTOSWITCH", goto msg_err);
+
+
+    status = VAPI_SendConnectionMessage(channel->id,
+                (SMsg *)message, NULL,
+                dev_resp, &resp_len);
+    VAPI_REPORT_ACT (status, "Sending SET_PASSTHRU_AUTOSWITCH", goto msg_err);
+
+msg_err:
+    VAPI_FreeMessage(message);
+
+    return status;
+}
+
+// -----------------------------------------------------------------------------------------------
+int
+mspd_channel_switch_to_passthru_mode (mspd_channel_t *channel)
+{
+    MSPD_LOG(3, "%s: Activating Passthru mode\n", channel->name);
+
+    VSTATUS status  = 1;
+    void *message   = NULL;
+    U32 resp_len    = MAX_FIFO_SIZE;
+    U8  dev_resp     [MAX_FIFO_SIZE];
+
+    message = VAPI_AllocateMessage(MAX_FIFO_SIZE);
+    if (!message) {
+        MSPD_ERR("VAPI_AllocateMessage has failed\n");
+        return -1;
+    }
+
+
+    status = VAPI_SetMessage(message,
+                CMD_CLASS_CONF_CHANNEL,
+                CMD_TYPE_CONF_CHANGE,
+                    FC_SET_PASSTHRU_AUTOSWITCH,
+                        1,
+                        0x023d); /* force switch to Pass Through mode */
+    if (status)
+        VAPI_REPORT_ACT (status, "Setting SET_PASSTHRU_AUTOSWITCH", goto msg_err);
+
+
+    status = VAPI_SendConnectionMessage(channel->id,
+                (SMsg *)message, NULL,
+                dev_resp, &resp_len);
+    VAPI_REPORT_ACT (status, "Sending SET_PASSTHRU_AUTOSWITCH", goto msg_err);
+
+    channel->passthru_mode = True;
+
+msg_err:
+    VAPI_FreeMessage(message);
+
+    return status;
+}
+
+// -----------------------------------------------------------------------------------------------
+int
+mspd_channel_set_faxsplopt (mspd_channel_t * channel)
+{
+    MSPD_LOG(3, "%s: Sending FAX special options\n", channel->name);
+
+    VSTATUS status  = 1;
+    void *message   = NULL;
+    U32 resp_len    = MAX_FIFO_SIZE;
+    U8  dev_resp     [MAX_FIFO_SIZE];
+
+    message = VAPI_AllocateMessage(MAX_FIFO_SIZE);
+    if (!message) {
+        MSPD_ERR("VAPI_AllocateMessage has failed\n");
+        return -1;
+    }
+
+    status = VAPI_SetMessage(message,
+                CMD_CLASS_CONF_CHANNEL,
+                CMD_TYPE_CONF_CHANGE,
+                    FC_FOIP_FAXSPLOPT,
+                        1,
+                        0x0070);
+    if (status)
+        VAPI_REPORT_ACT (status, "Setting FOIP_FAXSPLOPT", goto msg_err);
+
+
+    status = VAPI_SendConnectionMessage(channel->id,
+                (SMsg *)message, NULL,
+                dev_resp, &resp_len);
+    VAPI_REPORT_ACT (status, "Sending FOIP_FAXSPLOPT", goto msg_err);
+
+msg_err:
+    VAPI_FreeMessage(message);
+
+    return status;
+}
+
+Boolean 
+mspd_channel_cid_gen_in_progress(const mspd_channel_t *channel)
+{
+    return channel->cid_gen_in_progress;
+}
+
+// -----------------------------------------------------------------------------------------------
+int
+mspd_channel_send_caller_id (mspd_channel_t *channel)
+{
+    channel->cid_gen_in_progress = True;
+
+    VSTATUS status =
+        VAPI_PlayCid(channel->id, &channel->cid_msg, NULL);
+    VAPI_REPORT_ACT (status, "VAPI_StartCallerId", return status);
+
+    MSPD_LOG(3, "Sent %s CID cmd on Channel(%s:%d)\n",
+            channel->cid_msg.bIsOnHook ? "OnHook" : "OffHook",
+            channel->name, channel->id);
+
+    return 0;
+}
+
+// -----------------------------------------------------------------------------------------------
+// Caller id information
+int
+mspd_channel_prepare_callerid_msg (mspd_channel_t *channel,
+				   struct ast_channel *ast, 
+				   Boolean is_onhook)
+{
+    char *CID_buf = channel->cid_buf;
+    SCallerIdInfo *CID_msg = &channel->cid_msg;
+    U8 cid_msg_type;
+    U16 indx = 0;
+
+    if(mspd_global_get_ntt_callerid())
+	cid_msg_type = CID_MSG_TYPE_SDMF;
+    else
+	cid_msg_type = CID_MSG_TYPE_MDMF;
+            
+    char *CID_name = ast->connected.id.name.str   ? ast->connected.id.name.str   : "NoName";
+    char *CID_num  = ast->connected.id.number.str ? ast->connected.id.number.str : "NoNum";
+
+    MSPD_LOG(3,"%s Caller ID information: mode=%s name=%s, number=%s\n",
+            is_onhook ? "OnHook" : "OffHook",
+            mspd_global_get_ntt_callerid() ? "NTT" : "Bell",
+            CID_name, CID_num);
+            
+    // --== Filling in the CID message ==--
+    CID_buf[indx++] = cid_msg_type;
+    if (!mspd_global_get_ntt_callerid()) {
+        CID_buf[indx++] = CID_PARAM_TYPE_PHONENUM;
+        CID_buf[indx++] = strlen(CID_num);
+                
+        //Error checking for CID number
+        if ((indx + CID_buf[indx-1]) < CID_MSG_MAX_LENGTH) {
+            strcpy(&CID_buf[indx], CID_num);
+            indx += CID_buf[indx-1];
+        }
+        else {
+            MSPD_ERR("Error:Caller ID information length "
+                    "exceeds the buffer limit[%d]\n",
+                    CID_MSG_MAX_LENGTH);
+            return -1;
+        }
+    }
+
+    if ((indx + CID_buf[indx-1]) < CID_MSG_MAX_LENGTH)
+    {
+        CID_buf[indx++] = CID_PARAM_TYPE_PHONENAME;
+        CID_buf[indx++] = strlen(CID_name);
+        strcpy(&CID_buf[indx], CID_name);
+        indx += CID_buf[indx-1];
+
+        CID_msg->MsgLen = indx;
+        CID_msg->pucMsgStr = (unsigned char*)CID_buf;
+        CID_msg->bIsOnHook = (Boolean) is_onhook;
+        CID_msg->ucModulType = CID_MOD_TYPE_BELL;
+    }
+    else {
+        MSPD_ERR(" Caller ID information length "
+                "exceeds the buffer limit[%d]\n",
+                CID_MSG_MAX_LENGTH);
+        return -1;
+    }
+    MSPD_DBG("--- Preparing CallerID finished ---\n");
+    return 0;
+}
+
+//-----------------------------------------------------------------------------------------------
+//send messages to set the enhanced echo cancellation parameter of the channel
+static int
+set_enh_echocan (const mspd_channel_t *channel, const mspd_echocan_t *echocan)
+{
+    MSPD_LOG(3, "(%s) enhanced_echocan=0x%x \n",
+            mspd_channel_get_name(channel), echocan->enh_echocan_ctrl);
+
+    VSTATUS status  = 1;
+    void *message   = NULL;
+    U32 resp_len    = MAX_FIFO_SIZE;
+    U8  dev_resp     [MAX_FIFO_SIZE];
+
+    message = VAPI_AllocateMessage(MAX_FIFO_SIZE);
+    if (!message) {
+        MSPD_ERR("VAPI_AllocateMessage has failed\n");
+        return -1;
+    }
+
+
+    status = VAPI_SetMessage(message,
+                CMD_CLASS_CONF_CHANNEL,
+                CMD_TYPE_CONF_CHANGE,
+                    FC_EC_CONTROL,
+                        1, echocan->enh_echocan_ctrl);
+    if (status)
+        VAPI_REPORT_ACT (status, "Setting EC_CONTROL", goto msg_err);
+
+
+    status = VAPI_SendConnectionMessage(mspd_channel_get_id(channel),
+                (SMsg *)message, NULL,
+                dev_resp, &resp_len);
+    VAPI_REPORT_ACT (status, "Sending EC_CONTROL", goto msg_err);
+
+msg_err:
+    VAPI_FreeMessage(message);
+
+    return status;
+}
+
+//-----------------------------------------------------------------------------------------------
+//send messages to set the echo cancellation parameter of the channel
+static int
+set_echocan (const mspd_channel_t *channel, const mspd_echocan_t *echocan)
+{
+	MSPD_LOG(3, "(%s) echocan=0x%x\n",
+            mspd_channel_get_name(channel), echocan->echocan_ctrl);
+
+        VSTATUS status  = 1;
+        void *message   = NULL;
+        U32 resp_len    = MAX_FIFO_SIZE;
+        U8  dev_resp     [MAX_FIFO_SIZE];
+
+        message = VAPI_AllocateMessage(MAX_FIFO_SIZE);
+        if (!message) {
+            MSPD_ERR("VAPI_AllocateMessage has failed\n");
+            return -1;
+        }
+
+        status = VAPI_SetMessage(message,
+                    CMD_CLASS_CONF_CHANNEL,
+                    CMD_TYPE_CONF_CHANGE,
+                        FC_VOIP_ECHOCAN,
+                            1, echocan->echocan_ctrl);
+        if (status)
+            VAPI_REPORT_ACT (status, "Setting VOIP_ECHOCAN", goto msg_err);
+
+
+        status = VAPI_SendConnectionMessage(mspd_channel_get_id(channel),
+                    (SMsg *)message, NULL,
+                    dev_resp, &resp_len);
+        VAPI_REPORT_ACT (status, "Sending VOIP_ECHOCAN", goto msg_err);
+
+msg_err:
+        VAPI_FreeMessage(message);
+
+        return status;
+}
+
+//-----------------------------------------------------------------------------------------------
+//send messages to set the dual filter echo cancellation parameter of the channel
+static int
+set_dualfilter_echocan (const mspd_channel_t *channel, const mspd_echocan_t *echocan)
+{
+    MSPD_LOG(3, "(%s) dualfilter_echocan=0x%x \n",
+            mspd_channel_get_name(channel), echocan->dfec_ctrl);
+
+    VSTATUS status  = 1;
+    void *message   = NULL;
+    U32 resp_len    = MAX_FIFO_SIZE;
+    U8  dev_resp     [MAX_FIFO_SIZE];
+
+    message = VAPI_AllocateMessage(MAX_FIFO_SIZE);
+    if (!message) {
+        MSPD_ERR("VAPI_AllocateMessage has failed\n");
+        return -1;
+    }
+
+    status = VAPI_SetMessage(message,
+                CMD_CLASS_CONF_CHANNEL,
+                CMD_TYPE_CONF_CHANGE,
+                    FC_VOIP_DFECAN,
+                        1, echocan->dfec_ctrl);
+    if (status)
+        VAPI_REPORT_ACT (status, "Setting VOIP_DFECAN", goto msg_err);
+
+
+    status = VAPI_SendConnectionMessage(mspd_channel_get_id(channel),
+                (SMsg *)message, NULL,
+                dev_resp, &resp_len);
+    VAPI_REPORT_ACT (status, "Sending VOIP_DFECAN", goto msg_err);
+
+msg_err:
+    VAPI_FreeMessage(message);
+
+    return status;
+}
+
+//------------------------------------------------------------------------------
+//send messages to set the dual filter echocan tuning parameters
+static int
+set_dualfilter_tune (const mspd_channel_t *channel, const mspd_echocan_t *echocan)
+{
+    const mspd_dfectune_t *dfectune_params = &echocan->dfectune_params;
+
+    MSPD_LOG(3, "(%s) dfectune called \n", mspd_channel_get_name(channel));
+
+    VSTATUS status  = 1;
+    void *message   = NULL;
+    U32 resp_len    = MAX_FIFO_SIZE;
+    U8  dev_resp     [MAX_FIFO_SIZE];
+
+    message = VAPI_AllocateMessage(MAX_FIFO_SIZE);
+    if (!message) {
+        MSPD_ERR("VAPI_AllocateMessage has failed\n");
+        return -1;
+    }
+    if (echocan->dfectune_default) {
+        MSPD_LOG(3, "(%s) dfectune default values are passed to MSP \n", mspd_channel_get_name(channel));
+        status = VAPI_SetMessage(message,
+                 CMD_CLASS_CONF_CHANNEL,
+                 CMD_TYPE_CONF_CHANGE,
+                    FC_VOIP_DFECTUNE,
+                        1,
+                        0x0001);
+    }
+    else {
+        MSPD_LOG(3, "(%s) dfectune configured values are passed to MSP \n", mspd_channel_get_name(channel));
+        status = VAPI_SetMessage(message,
+                 CMD_CLASS_CONF_CHANNEL,
+                 CMD_TYPE_CONF_CHANGE,
+                 FC_VOIP_DFECTUNE,
+                 2 * MAX_DFECTUNE_PARAM + 1,
+                 0x0000, // CONT (Control options) Bits [15:1] Reserved
+                        // Bit 0: Reset all parameters to their defaults.
+                        // 0 = No
+                        // 1 = Yes.
+                        //                              [INDEX] PARAMETER NAME     [DEFAULT           DESCRIPTION
+                        //                                                          DECIMAL]
+               EC_TX_IN_SCF_FRC,
+               dfectune_params->ec_tx_in_scf_frc,     //    0    EC_TX_IN_SCF_FRC          0  Tx input signal digital gain (fractional part)
+               EC_TX_IN_SCF_INT,
+               dfectune_params->ec_tx_in_scf_int,     //    1    EC_TX_IN_SCF_INT          1  Tx input signal digital gain (integer part)
+               EC_TX_FLT_COEF,
+               dfectune_params->ec_tx_flt_coef,       //    2    EC_TX_FLT_COEF         8192  Tx energy filter coeffcient
+               EC_TX_DET_THR_LE,
+               dfectune_params->ec_tx_det_thr_le,     //    3    EC_TX_DET_THR_LE        323  Tx detection threshold for large echoes
+               EC_TX_OUT_SCF_FRC,
+               dfectune_params->ec_tx_out_scf_frc,    //    4    EC_TX_OUT_SCF_FRC         0  Tx output signal digital gain (fractional part)
+
+               EC_TX_OUT_SCF_INT,
+               dfectune_params->ec_tx_out_scf_int,    //    5    EC_TX_OUT_SCF_INT         1  Tx output signal digital gain (integer part)
+               EC_RX_IN_SCF_FRC,
+               dfectune_params->ec_rx_in_scf_frc,     //    6    EC_RX_IN_SCF_FRC          0  Rx input signal digital gain (fractional part)
+               EC_RX_IN_SCF_INT,
+               dfectune_params->ec_rx_in_scf_int,     //    7    EC_RX_IN_SCF_INT          1  Rx input signal digital gain (integer part)
+               EC_RX_FLT_COEF,
+               dfectune_params->ec_rx_flt_coef,       //    8    EC_RX_FLT_COEF         8192  Rx energy filter coefficient
+               EC_RX_DET_THR,
+               dfectune_params->ec_rx_det_thr,        //    9    EC_RX_DET_THR           363  Rx input detection threshold
+
+               EC_RX_OUT_SCF_FRC,
+               dfectune_params->ec_rx_out_scf_frc,    //  10    EC_RX_OUT_SCF_FRC         0  Rx output signal digital gain (fractional part)
+               EC_RX_OUT_SCF_INT,
+               dfectune_params->ec_rx_out_scf_int,    //  11    EC_RX_OUT_SCF_INT         1  Rx output signal digital gain (integer part)
+               EC_MINERL,
+               dfectune_params->ec_minerl,            //  12    EC_MINERL             20675  Overall effective minimum ERL
+               EC_DB_HNG_RESET,
+               dfectune_params->ec_db_hng_reset,      //  13    EC_DB_HNG_RESET          80  Double-talk hangover counter reset
+               EC_DB_ADJ,
+               dfectune_params->ec_db_adj,            //  14    EC_DB_ADJ            -20675  Minimum ERL adjustment SCF
+
+               EC_NL_HNG,
+               dfectune_params->ec_nl_hng,            //  15    EC_NL_HNG               400  NLP hangover counter reset
+               EC_NL_HNG_SE,
+               dfectune_params->ec_nl_hng_se,         //  16    EC_NL_HNG_SE           1600  NLP hangover counter reset for small echoes
+               EC_NL_INC,
+               dfectune_params->ec_nl_inc,            //  17    EC_NL_INC                80  NLP hangover counter increment
+               EC_NL_INC_SE,
+               dfectune_params->ec_nl_inc_se,         //  18    EC_NL_INC_SE            320  NLP hangover counter increment for small echoes
+               EC_FLT_RES_SME_NL,
+               dfectune_params->ec_flt_res_sme_nl,    //  19    EC_FLT_RES_SME_NL       184  NLP small/large residual echo threshold
+
+               EC_FLT_CNG_SME_NL,
+               dfectune_params->ec_flt_cng_sme_nl,    //  20    EC_FLT_CNG_SME_NL     16384  NLP small/large residual echo noise SCF
+               EC_TX_OUT_THR_DBT_NL,
+               dfectune_params->ec_tx_out_thr_dbt_nl, //  21    EC_TX_OUT_THR_DBT_NL   1463  NLP Rx peak SCF maximum
+               EC_TX_OUT_THR_MIN_NL,
+               dfectune_params->ec_tx_out_thr_min_nl, //  22    EC_TX_OUT_THR_MIN_NL   1463  NLP Rx peak SCF minimum
+               EC_TX_OUT_PSCF_NL,
+               dfectune_params->ec_tx_out_pscf_nl,    //  23    EC_TX_OUT_PSCF_NL     -4096  NLP adaptive/fixed comparison SCF
+               EC_TX_C3_NL,
+               dfectune_params->ec_tx_c3_nl,          //  24    EC_TX_C3_NL           24576  NLP Rx peak SCF update (output) SCF
+
+               EC_TX_C4_NL,
+               dfectune_params->ec_tx_c4_nl,          //  25    EC_TX_C4_NL            8192  NLP Rx peak SCF update (input) SCF
+               EC_TX_NOS_SCF_NL,
+               dfectune_params->ec_tx_nos_scf_nl,     //  26    EC_TX_NOS_SCF_NL       1843  NLP attenuation noise SCF
+               EC_TX_SCF_MAX_NL,
+               dfectune_params->ec_tx_scf_max_nl,     //  27    EC_TX_SCF_MAX_NL       3677  NLP attenuation SCF maximum
+               EC_TX_OUT_PWR_ADJ_NL,
+               dfectune_params->ec_tx_out_pwr_adj_nl, //  28    EC_TX_OUT_PWR_ADJ_NL -32767  NLP residual echo adjustment SCF
+               EC_TX_OUT_THR_DEL_NL,
+               dfectune_params->ec_tx_out_thr_del_nl, //  29    EC_TX_OUT_THR_DEL_NL      3  NLP computation delay
+
+               EC_NLP_OFF_INC,
+               dfectune_params->ec_nlp_off_inc,       //  30    EC_NLP_OFF_INC           82  NLP on to off delay SCF update
+               EC_FLT_CHK_RST1,
+               dfectune_params->ec_flt_chk_rst1,      //  31    EC_FLT_CHK_RST1         160  Filter evaluation Rx interval
+               EC_FLT_RIN_MIN,
+               dfectune_params->ec_flt_rin_min,       //  32    EC_FLT_RIN_MIN          407  Filter evaluation minimum Rx level
+               EC_FLT_THR1,
+               dfectune_params->ec_flt_thr1,          //  33    EC_FLT_THR1             261  Threshold required to update fixed filter
+               EC_FLT_SCF1,
+               dfectune_params->ec_flt_scf1,          //  34    EC_FLT_SCF1          -32767  Comparison SCF for fixed filter update
+
+               EC_FLT_SCF2,
+               dfectune_params->ec_flt_scf2,          //  35    EC_FLT_SCF2          -16384  Echo path change comparison SCF
+               EC_FLT_EPC3,
+               dfectune_params->ec_flt_epc3,          //  36    EC_FLT_EPC3            6538  Maximum error for echo path change
+               EC_FLT_SCF3,
+               dfectune_params->ec_flt_scf3,          //  37    EC_FLT_SCF3          -16384  Adaptive filter reset comparison SCF
+               EC_FLT_THR4,
+               dfectune_params->ec_flt_thr4,          //  38    EC_FLT_THR4            1843  Always use adaptive filter threshold
+               EC_FLT_THR2,
+               dfectune_params->ec_flt_thr2,          //  39    EC_FLT_THR2            1638  Always use fixed filter threshold
+
+               EC_FLT_CNT3,
+               dfectune_params->ec_flt_cnt3,          //  40    EC_FLT_CNT3               3  Update fixed filter counter reset
+               EC_FLT_SCF4,
+               dfectune_params->ec_flt_scf4,          //  41    EC_FLT_SCF4          -26029  Comparison SCF for fixed filter update
+               EC_FLT_SCF5,
+               dfectune_params->ec_flt_scf5,          //  42    EC_FLT_SCF5          -11626  Comparison SCF for fixed filter update
+               EC_FLT_NOS_SCF_MIN,
+               dfectune_params->ec_flt_nos_scf_min,   //  43    EC_FLT_NOS_SCF_MIN     8192  Filt Coef Update Noise Gain Adjust Min
+               EC_DAT_RX_SCF_MIN_ST,
+               dfectune_params->ec_dat_rx_scf_min_st, //  44    EC_DAT_RX_SCF_MIN_ST  16384  Dynamic attenuation SCF min (single-talk)
+
+               EC_DAT_RESE_LEV,
+               dfectune_params->ec_dat_rese_lev,      //  45    EC_DAT_RESE_LEV         130  Dynamic attenuation echo level (single-talk)
+               EC_DAT_RESE_DT_LEV,
+               dfectune_params->ec_dat_rese_dt_lev,   //  46    EC_DAT_RESE_DT_LEV      130  Dynamic attenuation echo level (double-talk)
+               EC_DAT_RX_LEV,
+               dfectune_params->ec_dat_rx_lev,        //  47    EC_DAT_RX_LEV          2043  Dynamic attenuation minimum Rx level
+               EC_DAT_TX_LEV,
+               dfectune_params->ec_dat_tx_lev,        //  48    EC_DAT_TX_LEV           324  Dynamic attenuation minimum Tx level
+               EC_TX_DET_THR_SE,
+               dfectune_params->ec_tx_det_thr_se,     //  49    EC_TX_DET_THR_SE        115  Tx detection threshold for small echoes
+
+               EC_TX_OUT_THR_MIN_NL2,
+               dfectune_params->ec_tx_out_thr_min_nl2, //  50    EC_TX_OUT_THR_MIN_NL2  1463  NLP more stringent Rx peak SCF minimum
+               EC_TX_OUT_MIN_TX_NL2,
+               dfectune_params->ec_tx_out_min_tx_nl2,  //  51    EC_TX_OUT_MIN_TX_NL2  16384  NLP less stringent near-end talker threshold SCF
+               EC_TX_OUT_INC_NL2,
+               dfectune_params->ec_tx_out_inc_nl2,     //  52    EC_TX_OUT_INC_NL2      2400  NLP secondary hangover counter increment
+               EC_TX_OUT_CNT_RST_NL2,
+               dfectune_params->ec_tx_out_cnt_rst_nl2, //  53    EC_TX_OUT_CNT_RST_NL2  4800  NLP secondary hangover counter reset
+               EC_DAT_RX_MXL,
+               dfectune_params->ec_dat_rx_mxl,         //  54    EC_DAT_RX_MXL          7241  Dynamic attenuation max Rx output level
+
+               EC_FLT_RXM_SME_NL,
+               dfectune_params->ec_flt_rxm_sme_nl,     //  55    EC_FLT_RXM_SME_NL      9116  NLP max Rx output level for small echo values
+               EC_DAT_RX_SCF_MIN_DT,
+               dfectune_params->ec_dat_rx_scf_min_dt,  //  56    EC_DAT_RX_SCF_MIN_DT  16384  Dynamic attenuation SCF min (double-talk)
+               EC_TX_ACOM_NL,
+               dfectune_params->ec_tx_acom_nl,         //  57    EC_TX_ACOM_NL             0  NLP attenuation required ACOM
+               EC_TX_RLIM_NL,
+               dfectune_params->ec_tx_rlim_nl,         //  58    EC_TX_RLIM_NL             0  NLP attenuation minimum peak echo level
+               EC_MAX_NOISE,
+               dfectune_params->ec_max_noise);         //  59    EC_MAX_NOISE          13312  Maximum allowable Tx background noise level
+    }
+
+    if (status)
+        VAPI_REPORT_ACT (status, "Setting VOIP_DFECTUNE", goto msg_err);
+
+
+    status = VAPI_SendConnectionMessage(mspd_channel_get_id(channel),
+                (SMsg *)message, NULL,
+                dev_resp, &resp_len);
+    VAPI_REPORT_ACT (status, "Sending VOIP_DFECTUNE", goto msg_err);
+
+msg_err:
+    VAPI_FreeMessage(message);
+
+    return status;
+}
+
+//------------------------------------------------------------------------------
+//Echocan configured on a channel based on the global configuration
+int
+mspd_channel_echocan_manager (const mspd_channel_t *channel, const mspd_echocan_t *echocan)
+{
+    if (mspd_global_get_ec_type() == EC_TYPE_STD) {
+        if (set_enh_echocan(channel, echocan))                  return 1;
+        if (set_echocan(channel, echocan))                      return 1;
+        return 0;
+    }
+    if (mspd_global_get_ec_type() == EC_TYPE_DFEC) {
+        if (set_dualfilter_echocan(channel, echocan))           return 1;
+        if (set_dualfilter_tune(channel, echocan))              return 1;
+        return 0;
+    }
+    return -1;
+}
+
+// -----------------------------------------------------------------------------------------------
+// Helper function to set timeslots, while changing MSPD channel from LSP to VOIP mode
+static void
+mspd_channel_prepare_switch_to_voip (BandMode wideband, U16 base_timeslot, U16 *params, U8 *params_count)
+{
+    if (wideband) {
+        *params_count = 5;
+        params[0] = 4;
+        params[1] = base_timeslot;
+        params[2] = base_timeslot + 1;
+        params[3] = base_timeslot + 16;
+        params[4] = base_timeslot + 16 + 1;
+    }
+    else {
+        *params_count = 2;
+        params[0] = 1;
+        params[1] = base_timeslot;
+    }
+}
+
+// -----------------------------------------------------------------------------------------------
+//  Helper function to set timeslots and conf ID, while changing MSPD channel from VOIP to LSP mode
+static void
+mspd_channel_prepare_switch_to_lsp_part (BandMode wideband, U16 base_timeslot, U16 conf_id, U16 *params, U8 *params_count)
+{
+    if (wideband) {
+        *params_count = 6;
+        params[0] = conf_id;
+        params[1] = 4;
+        params[2] = base_timeslot;
+        params[3] = base_timeslot + 1;
+        params[4] = base_timeslot + 16;
+        params[5] = base_timeslot + 16 + 1;
+    }
+    else {
+        *params_count = 3;
+        params[0] = conf_id;
+        params[1] = 1;
+        params[2] = base_timeslot;
+    }
+}
+
+// -----------------------------------------------------------------------------------------------
+int
+mspd_channel_switch_to_voip(mspd_channel_t *chan, BandMode wideband, U16 timeslot)
+{
+    VSTATUS vstatus = 0xFF;
+    U16 params [5] = {0};
+    U8  params_count = 0;
+    SChangeConnInfo ChangeConn;
+
+    ChangeConn.eConnType = eVOIP;
+    ChangeConn.ePartType = eNOTPART;
+    ChangeConn.eConnMode = wideband ? eWideBand : eNarrowBand;
+    ChangeConn.eChangeOpMode = eOpModeNone;
+
+    mspd_channel_prepare_switch_to_voip (wideband, timeslot, params, &params_count);
+    vstatus = VAPI_ChangeConnectionType (mspd_channel_get_id(chan), &ChangeConn, params_count, params, NULL);
+    if (vstatus) {
+        MSPD_ERR("%s: VAPI_ChangeConnectionType from %s to VoIP  FAILED\n",
+            mspd_channel_get_name(chan), mspd_channel_type2text(mspd_channel_get_type(chan)));
+        return vstatus;
+    }
+
+    MSPD_LOG(3, "%s: VAPI_ChangeConnectionType from %s to VoIP done\n",
+        mspd_channel_get_name(chan), mspd_channel_type2text(mspd_channel_get_type(chan)));
+
+    mspd_channel_set_type(chan, MCT_VOIP);
+
+    return vstatus;
+}
+
+
+// -----------------------------------------------------------------------------------------------
+int
+mspd_channel_switch_to_lsp_part(mspd_channel_t *chan, BandMode wideband, U16 timeslot, U16 conf_id)
+{
+    VSTATUS vstatus = 0xFF;
+    U16 params [6] = {0};
+    U8  params_count = 0;
+    SChangeConnInfo ChangeConn;
+
+    ChangeConn.eConnType = 0;
+    ChangeConn.eConnMode = wideband ? eWideBand : eNarrowBand;
+    ChangeConn.ePartType = wideband ? eLSPWB : eLSP;
+    ChangeConn.eChangeOpMode = eOpModeNone;
+
+    mspd_channel_prepare_switch_to_lsp_part (wideband, timeslot, conf_id,
+                                            params, &params_count);
+    vstatus = VAPI_ChangeConnectionType (mspd_channel_get_id(chan), &ChangeConn, params_count, params, NULL);
+    if (vstatus) {
+        MSPD_ERR("%s: VAPI_ChangeConnectionType from %s to LSP part FAILED\n",
+            mspd_channel_get_name(chan), mspd_channel_type2text(mspd_channel_get_type(chan)));
+        return vstatus;
+    }
+
+    MSPD_LOG(3, "%s: VAPI_ChangeConnectionType from %s to LSP part done\n",
+            mspd_channel_get_name(chan), mspd_channel_type2text(mspd_channel_get_type(chan)));
+
+    mspd_channel_set_type(chan, MCT_PART_TDM);
+
+    return vstatus;
+}
+
+static int
+set_max_datagram (mspd_channel_t *channel, unsigned max_datagram)
+{
+    VSTATUS status  = 1;
+    void *message   = NULL;
+    U32 resp_len    = MAX_FIFO_SIZE;
+    U8  dev_resp     [MAX_FIFO_SIZE];
+
+    message = VAPI_AllocateMessage(MAX_FIFO_SIZE);
+    if (!message) {
+        MSPD_ERR("VAPI_AllocateMessage has failed\n");
+        return -1;
+    }
+
+    status = VAPI_SetMessage(message,
+                CMD_CLASS_CONF_CHANNEL,
+                CMD_TYPE_CONF_CHANGE,
+                    FC_FOIP_SET_DATAGRAM,
+                        1, max_datagram);
+
+    if (status)
+            VAPI_REPORT_ACT (status, "Setting FOIP_SET_DATAGRAM", goto msg_err);
+
+    status = VAPI_SendConnectionMessage(channel->id,
+                (SMsg *)message, NULL,
+                dev_resp, &resp_len);
+    VAPI_REPORT_ACT (status, "Sending FOIP_SET_DATAGRAM", goto msg_err);
+
+msg_err:
+    VAPI_FreeMessage(message);
+
+    return status;
+}
+
+static int
+set_fillbit_removal (mspd_channel_t *channel, unsigned fillbit_removal)
+{
+    VSTATUS status  = 1;
+    void *message   = NULL;
+    U32 resp_len    = MAX_FIFO_SIZE;
+    U8  dev_resp     [MAX_FIFO_SIZE];
+
+    message = VAPI_AllocateMessage(MAX_FIFO_SIZE);
+    if (!message) {
+        MSPD_ERR("VAPI_AllocateMessage has failed\n");
+        return -1;
+    }
+
+    status = VAPI_SetMessage(message,
+                CMD_CLASS_CONF_CHANNEL,
+                CMD_TYPE_CONF_CHANGE,
+                    FC_FOIP_FILLBIT_CTRL,
+                        1, fillbit_removal);
+
+    if (status)
+            VAPI_REPORT_ACT (status, "Setting FOIP_FILLBIT_CTRL", goto msg_err);
+
+    status = VAPI_SendConnectionMessage(channel->id,
+                (SMsg *)message, NULL,
+                dev_resp, &resp_len);
+    VAPI_REPORT_ACT (status, "Sending FOIP_FILLBIT_CTRL", goto msg_err);
+
+msg_err:
+    VAPI_FreeMessage(message);
+
+    return status;
+}
+
+//-------------------------------------------------------------------------
+//This function switches the channel from voip-mode to foip-mode
+int
+mspd_channel_switch_to_foip_and_configure (mspd_channel_t  *channel, 
+					   struct t38_profile *profile, 
+					   struct ast_udptl *udptl)
+{
+    VSTATUS vstatus = 0xFF;
+    SFaxConfigOpts faxOpts;
+    struct ast_sockaddr src, dst;
+
+    memset(&faxOpts, 0, sizeof(faxOpts));
+
+    if (channel->type == MCT_FOIP) {
+        MSPD_LOG(3, "%s:  Already (%s) mode\n",
+            channel->name, mspd_channel_type2text(channel->type));
+        return 0;
+    }
+
+    MSPD_LOG(3, "%s: Switching to FOIP mode\n", channel->name);
+
+    if (mspd_channel_disable(channel))
+        MSPD_ERR("%s: Error in dc_disable\n", channel->name) ;
+
+    mspd_channel_set_type(channel, MCT_FOIP);
+
+//-------------------------------------------------------
+    faxOpts.bUseExistingOpts = 0;                   // Use existing options. True -- Will not modify FAXOPT & FAXLVL settings
+
+    faxOpts.stFaxOpts.ucT38PktLossConcealment = 1;  // 0 = No T.38 packet loss concealment (default)
+    faxOpts.stFaxOpts.ucECMDisable = 0;             // 0 = Allow ECM faxes in T.38 (default)
+    faxOpts.stFaxOpts.ucFaxDataRedundancyCnt = 0;   // 0..3; Default- 0
+    faxOpts.stFaxOpts.ucT30RedundancyCnt = 0;       // 0..7; Default- 3
+    faxOpts.stFaxOpts.ucFaxConnSpeedLimit = 0;      // 0 = No speed limit (default), 6 = 14400 bps limit
+    faxOpts.stFaxOpts.ucErrRcvyMethod = 0;          // 0 = Redundancy (default), 1 = FEC
+    if(profile->ast.rate_management == AST_T38_RATE_MANAGEMENT_TRANSFERRED_TCF)
+	faxOpts.stFaxOpts.ucTCFProcedure = 0;
+    else if(profile->ast.rate_management == AST_T38_RATE_MANAGEMENT_LOCAL_TCF)
+	faxOpts.stFaxOpts.ucTCFProcedure = 1;
+    else {
+	MSPD_ERR("Unsupported rate management mode '%d' requested\n", profile->ast.rate_management);
+	return -1;
+    }
+    faxOpts.stFaxOpts.ucNumFEC = 0;                 // Number of FEC packets to send in UDPTL Range 0 (default) to 3
+    faxOpts.stFaxOpts.usParam2 = 0x0100;            // Parameter 2 of fax options
+
+    faxOpts.ucFaxTxLevel = 0x0A;                    //< 0 - 15, in -1dBm steps; Default - 0x0A;
+
+    faxOpts.bEnableFaxAutoSwitch = 0;               // Enable VAPI to automatically switch to FOIP mode
+    faxOpts.usSwitchoverEventMask = 0;              // Bit map to identify events on which switchover is to be performed, the masks are defined in EFaxSwitchEvents */
+
+    vstatus = VAPI_SwitchToT38(channel->id, &faxOpts, NULL);
+    VAPI_REPORT_ACT (vstatus, "VAPI_SwitchToT38", goto ERR_SWITCH);
+
+    ast_udptl_get_peer(udptl, &src);
+    ast_udptl_get_us(udptl, &dst);
+    if (mspd_channel_set_ip_header(channel, &src, &dst))
+        MSPD_ERR("%s: Error in mspd_channel_set_ip_header\n", channel->name);
+
+    if(set_max_datagram(channel, profile->max_datagram)) {
+        MSPD_ERR("%s: Error setting max datagram to %d\n", channel->name, profile->max_datagram);
+	goto ERR_CONFIGURE;
+    } else
+        MSPD_LOG(3, "%s: Set max datagram to %d\n", channel->name, profile->max_datagram);
+
+    if(set_fillbit_removal(channel, profile->ast.fill_bit_removal)) {
+        MSPD_ERR("%s: Error setting fillbit removal to %d\n", channel->name, profile->ast.fill_bit_removal);
+	goto ERR_CONFIGURE;
+    } else
+        MSPD_LOG(3, "%s: Set fillbit removal to %d\n", channel->name, profile->ast.fill_bit_removal);
+
+    if (mspd_channel_set_faxsplopt(channel))
+	goto ERR_CONFIGURE;
+
+    if (mspd_channel_enable_foip(channel))
+	goto ERR_CONFIGURE;
+
+    MSPD_LOG(3, "%s: Switched to FoIP mode\n", channel->name);
+
+    return 0;
+
+ERR_CONFIGURE:
+    /* TODO: implement switch back to voice mode.
+     * For this a re-factoring should be done to allow
+     * switch back to voice mode without supplying wideband and timeslot.
+     * mspd_channel_t should hold these parameters inside
+     */
+
+ERR_SWITCH:
+    mspd_channel_set_type(channel, MCT_VOIP);
+    return -1; // error
+}
+
+//-------------------------------------------------------------------------
+//This function switches the channel from foip-mode to voip-mode
+int
+mspd_channel_switch_to_voip_and_configure (mspd_channel_t *channel, 
+					   BandMode wideband, 
+					   U16 timeslot, 
+					   const mspd_echocan_t* echocan, 
+					   struct ast_rtp_instance *rtp)
+{
+    struct ast_sockaddr src, dst;
+
+    if (channel->type == MCT_VOIP) {
+        MSPD_LOG(3, "%s: Already (%s) mode\n",
+            channel->name, mspd_channel_type2text(channel->type));
+        return 0;
+    }
+
+    MSPD_LOG(3, "%s: Switching to VOIP mode\n", channel->name);
+
+    if (mspd_channel_disable(channel))
+        MSPD_ERR("%s: Error in mspd_channel_disable\n", channel->name) ;
+
+    if(mspd_channel_switch_to_voip(channel, wideband, timeslot)) {
+        MSPD_ERR("%s: Error while switching to VoIP mode\n", channel->name);
+        goto bail_out;
+    }
+
+    if (mspd_channel_set_coding_defaults(channel))
+	goto bail_out;
+
+    if (rtp) {
+        ast_rtp_instance_get_remote_address(rtp, &src);
+        ast_rtp_instance_get_local_address(rtp, &dst);
+        if (mspd_channel_set_ip_header(channel, &src, &dst))
+            MSPD_ERR("%s: Error in mspd_channel_set_ip_header\n", channel->name);
+    }
+
+    if (mspd_channel_configure_voip(channel, echocan)) {
+        MSPD_ERR("%s: Error in mspd_channel_configure_voip\n", channel->name);
+        goto bail_out;
+    }
+
+    MSPD_LOG(3, "%s: Switched to VoIP mode\n", channel->name);
+
+    return 0;
+
+bail_out:
+    mspd_channel_set_type(channel, MCT_FOIP);
+    return 1; // error
+}
+
+// -----------------------------------------------------------------------------------------------
+static int
+get_bwe_direction (mspd_channel_t *channel, BandMode tdm_mode, BandMode mixer_mode)
+{
+    /// For VoIP:
+    //                 1)  NB TDM   ---> BWE To Packet ---> WB Codec
+    //                 2) WB TDM   <---   BWE To TDM  <---  NB Codec
+    //
+    /// For LSP:
+    //                 1) NB TDM   ---> BWE To Packet ---> WB Mixer
+    //                 2) WB TDM   <---   BWE To TDM  <---  NB Mixer
+    //
+    /// For RSP:
+    //                 1) NB Mixer ---> BWE To Packet ---> RSP WB Codec
+    //                 2) WB Mixer <---  BWE To TDM   <--- RSP NB Codec
+
+    mspd_channel_type_t type    = mspd_channel_get_type(channel);
+    format_t            format  = mspd_channel_get_format(channel);
+
+    switch (type) {
+        case MCT_VOIP:
+		case MCT_VOIPOSHM:
+            if (tdm_mode == Wide) {
+                if (!(format & WIDE_BAND_CODECS)) return BWE_TO_TDM;
+                else return BWE_NO_ENCHANCEMENT;
+            }
+            else {
+                if (format & WIDE_BAND_CODECS)    return BWE_TO_PACKET;
+                else return BWE_NO_ENCHANCEMENT;
+            }
+            break;
+        case MCT_PART_TDM:
+            if (tdm_mode == Wide) {
+                if (mixer_mode == Narrow)         return BWE_TO_TDM;
+                else return BWE_NO_ENCHANCEMENT;
+            }
+            else {
+                if (mixer_mode == Wide)           return BWE_TO_PACKET;
+                else return BWE_NO_ENCHANCEMENT;
+            }
+            break;
+        case MCT_PART_RTP:
+            if (mixer_mode == Wide) {
+                if (!(format & WIDE_BAND_CODECS)) return BWE_TO_TDM;
+                else return BWE_NO_ENCHANCEMENT;
+            }
+            else {
+                if (format & WIDE_BAND_CODECS)    return BWE_TO_PACKET;
+                else return BWE_NO_ENCHANCEMENT;
+            }
+            break;
+        default:
+            return BWE_NO_ENCHANCEMENT;
+    }
+}
+
+// -----------------------------------------------------------------------------------------------
+static int
+set_bwe_enable (mspd_channel_t *channel, mspd_bwe_t *bwe, Boolean bwe_enable)
+{
+    VSTATUS status  = 1;
+    void *message   = NULL;
+    U32 resp_len    = MAX_FIFO_SIZE;
+    U8  dev_resp     [MAX_FIFO_SIZE];
+
+    Boolean bwe_init        = bwe_enable;
+    Boolean bwe_dir         = bwe->bwe_direction;
+    U8      bwe_high        = bwe->bwe_high_band;
+    U8      bwe_low         = bwe->bwe_low_band;
+
+    MSPD_LOG(3, "%s: %s BWE = {dir=%d, high=%d, low=%d}\n",
+        mspd_channel_get_name(channel),
+        bwe_enable ? "Enabling" : "Disabling",
+        bwe_dir, bwe_high, bwe_low);
+
+    U16 bwe_ctrl_1 = bwe_enable << 15 |
+                     bwe_init   << 14 |
+                     bwe_dir    << 13 |
+                     bwe_high   <<  4 |
+                     bwe_low;
+    U16 bwe_ctrl_2 = 0;                 // Reserved for BWE Tune
+
+    message = VAPI_AllocateMessage(MAX_FIFO_SIZE);
+    if (!message) {
+        MSPD_ERR("VAPI_AllocateMessage has failed\n");
+        return -1;
+    }
+
+    status = VAPI_SetMessage(message,
+                CMD_CLASS_CONF_CHANNEL,
+                CMD_TYPE_CONF_CHANGE,
+                    BWE_SET,
+                        2,
+                        bwe_ctrl_1,
+                        bwe_ctrl_2);
+    if (status) {
+        if (bwe_enable)
+            VAPI_REPORT_ACT (status, "Setting BWE SET", return status);
+        else
+            VAPI_REPORT_ACT (status, "Setting BWE CLEAR", return status);
+    }
+
+    status = VAPI_SendConnectionMessage(mspd_channel_get_id(channel),
+                (SMsg *)message, NULL,
+                dev_resp, &resp_len);
+
+    if (bwe_enable)
+        VAPI_REPORT(status, "Sending BWE SET");
+    else
+        VAPI_REPORT(status, "Sending BWE CLEAR");
+
+    VAPI_FreeMessage(message);
+
+    return status;
+}
+
+
+// -----------------------------------------------------------------------------------------------
+int
+mspd_channel_bwe_manager(mspd_channel_t *channel, BandMode tdm_band, BandMode mixer_band, mspd_bwe_t *bwe, Boolean apply)
+{
+    bwe->bwe_direction = get_bwe_direction (channel, tdm_band, mixer_band);
+    if (bwe->bwe_direction == BWE_NO_ENCHANCEMENT)
+        return 0;     // exit without error
+
+    if (bwe->bwe_master) {
+        if (apply) {
+            if (set_bwe_enable(channel, bwe, True))
+                return 1;
+
+            bwe->is_bwe_enabled = True;
+        }
+    }
+    else {
+        if (bwe->is_bwe_enabled) {
+            if (set_bwe_enable(channel, bwe, False))
+                return 1;
+
+            bwe->is_bwe_enabled = False;
+        }
+    }
+
+    return 0;
+}
+
+// -----------------------------------------------------------------------------------------------
+int
+mspd_channel_configure_rsp_part (mspd_channel_t *channel)
+{
+    if (set_dtmfmode(channel))
+        return 1;
+    if (mspd_channel_set_coding_defaults(channel))
+        return 1;
+    if (mspd_channel_payload_manager(channel))
+        return 1;
+    if (mspd_channel_enable(channel, channel->format))
+	return 1;
+
+    return 0;
+}
+
+// -----------------------------------------------------------------------------------------------
+int
+mspd_channel_configure_voip (mspd_channel_t *channel, const mspd_echocan_t *echocan)
+{
+    if (mspd_channel_set_tonectrl(channel))
+        return 1;
+    if (mspd_channel_set_toneopt(channel))
+        return 1;
+    if (set_dtmfmode(channel))
+        return 1;
+    if (mspd_channel_set_coding_defaults(channel))
+        return 1;
+    if (mspd_channel_echocan_manager(channel, echocan))
+         return 1;
+    if (mspd_channel_payload_manager(channel))
+        return 1;
+    if (mspd_channel_enable(channel, channel->format))
+        return 1;
+
+    return 0;
+}
+
+// -----------------------------------------------------------------------------------------------
+static int
+mspd_channel_enable_lsp(mspd_channel_t *channel)
+{
+    MSPD_LOG(5, "Setting LSP Voice Channel Mode for channel %s\n", mspd_channel_get_name(channel));
+
+    VSTATUS status  = 1;
+    void *message   = NULL;
+    U32 resp_len    = MAX_FIFO_SIZE;
+    U8  dev_resp     [MAX_FIFO_SIZE];
+
+    message = VAPI_AllocateMessage(MAX_FIFO_SIZE);
+    if (!message) {
+        MSPD_ERR("VAPI_AllocateMessage has failed\n");
+        return -1;
+    }
+
+    status = VAPI_SetMessage(message,
+                CMD_CLASS_CONF_CHANNEL,
+                CMD_TYPE_CONF_CHANGE,
+                    FC_VOIP_VOPENA,
+                        1,
+                        VOIP_VOPENA_MODE_ENABLE_LSP);
+
+    if (status)
+            VAPI_REPORT_ACT (status, "Setting VOIP_VOPENA", goto msg_err);
+
+    status = VAPI_SendConnectionMessage(mspd_channel_get_id(channel),
+                (SMsg *)message, NULL,
+                dev_resp, &resp_len);
+    VAPI_REPORT_ACT (status, "Sending VOIP_VOPENA", goto msg_err);
+
+msg_err:
+    VAPI_FreeMessage(message);
+
+    return status;
+}
+
+// -----------------------------------------------------------------------------------------------
+int
+mspd_channel_configure_lsp_part (mspd_channel_t *channel, const mspd_echocan_t *echocan)
+{
+    if (mspd_channel_set_tonectrl(channel))
+        return 1;
+    if (mspd_channel_set_toneopt(channel))
+        return 1;
+    if (set_dtmfmode(channel))
+        return 1;
+    if (mspd_channel_echocan_manager(channel, echocan))
+        return 1;
+    if (mspd_channel_enable_lsp(channel))
+        return 1;
+
+    return 0;
+}
+
+// -----------------------------------------------------------------------------------------------
+static char *
+cli_send_cmd_channel (struct ast_cli_entry *e,
+                      int cmd,
+                      struct ast_cli_args *a,
+                      const mspd_channel_t *channel,
+                      const mspd_device_t *dev)
+{
+    int i;
+    const int FUNC_IDX = 5;
+    uint dummy, func_code;
+    int* argv;
+    void *va_idx;
+    U8 fifo_bytes [MAX_FIFO_SIZE] = {0};
+    SMsg msg = {.pusFifo = (U16 *) fifo_bytes};
+
+    U8 OutBuff[0xFF] = {0};
+    U32 OutBuffLen = 0xFF;
+    VSTATUS vstatus = 0xFF;
+    char color_message [256] = {0};
+
+    argv = (int *) malloc((2 * (1 + a->argc - FUNC_IDX)) * sizeof(uint));
+    if (!argv)
+        return CLI_FAILURE;
+    va_idx = argv;
+
+    //4th-parameter of argv list contains "csm-cmd-code"
+    func_code = strtoul(a->argv[4], NULL, 0);
+
+    //overwrite # of params setting done by command_map array
+    dummy = DC_OVERRIDE_N_PARAMS;
+    memcpy((void *)va_idx, &dummy, sizeof(uint));
+    va_idx += sizeof(uint);
+
+    //5th-parameter of argv list (no of args) contains "no of params"
+    dummy = a->argc - FUNC_IDX;
+    memcpy((void *)va_idx, &dummy, sizeof(uint));
+    va_idx += sizeof(uint);
+    for (i = 0; i < a->argc-FUNC_IDX; i++) {
+        dummy = i + 4;
+        memcpy((void *)va_idx, &dummy, sizeof(uint));
+        va_idx += sizeof(uint);
+
+        dummy = strtoul(a->argv[i+FUNC_IDX], NULL, 0);
+        memcpy((void *)va_idx, &dummy, sizeof(uint));
+        va_idx += sizeof(uint);
+    }
+    dummy = DC_EOM;
+    memcpy((void *)va_idx, &dummy, sizeof(uint));
+
+    ast_cli(a->fd, "Sending function code 0x%x to %s %s\n",
+            func_code, channel ? "channel" : "device", channel ? mspd_channel_get_name(channel) : mspd_device_get_name(dev));
+
+    int const rc = mspd_make_msg(&msg, channel ? mspd_channel_get_id(channel) : SUPERVISOR_CHANNEL_ID, func_code, argv);
+    if (rc) {
+        MSPD_ERR("(%s): making CSM message has failed\n", channel ? mspd_channel_get_name(channel) : mspd_device_get_name(dev));
+        free(argv);
+        return CLI_FAILURE;
+    }
+
+    if (dev)
+        vstatus = VAPI_PassThru(mspd_device_get_id(dev), CMD_LEVEL_DEVICE,
+                                &msg, NULL, OutBuff, &OutBuffLen);
+    else
+        vstatus = VAPI_PassThru(mspd_channel_get_id(channel), CMD_LEVEL_CONN,
+                                &msg, NULL, OutBuff, &OutBuffLen);
+    sprintf(color_message, "VAPI %s (0x%04X)", mspd_lookup_msg_id(msg.pusFifo[2]), msg.pusFifo[2]);
+    VAPI_REPORT(vstatus, color_message);
+
+    free(argv);
+    return CLI_SUCCESS;
+}
+
+// -----------------------------------------------------------------------------------------------
+// Support routine for 'mspd send cmd' CLI commands
+static char *
+complete_mspdch (const char *line, const char *word, int pos, int state)
+{
+    int which = 0;
+    char *c = NULL;
+    int wordlen = strlen(word);
+    mspd_channel_t *channel = NULL;
+
+    if (pos != 3) {
+        return NULL;
+    }
+
+    if (!strncasecmp(word, mspd_supvsr_name, wordlen) && ++which > state) {
+        c = strdup(mspd_supvsr_name);
+        return c;
+    }
+
+    AST_LIST_LOCK(&channels);
+    AST_LIST_TRAVERSE(&channels, channel, list) {
+	if(!strncasecmp(word, channel->name, wordlen)) {
+            if (++which > state) {
+                c = strdup(channel->name);
+                break;
+            }
+	}
+    }
+    AST_LIST_UNLOCK(&channels);
+
+    return c;
+}
+
+// -----------------------------------------------------------------------------------------------
+char *
+mspd_channel_cli_send_cmd (struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
+{
+    mspd_channel_t *channel = NULL;
+    mspd_device_t *dev = NULL;
+    char* res;
+
+    switch (cmd) {
+    case CLI_INIT:
+        e->command = "mspd send cmd";
+        e->usage   = "Usage: mspd send cmd <channel> <cmd> [args]\n"
+                     "       Sends a user command to the MSP";
+        return NULL;
+    case CLI_GENERATE:
+        return complete_mspdch(a->line, a->word, a->pos, a->n);
+    }
+
+    if (a->argc < 5)
+        return CLI_SHOWUSAGE;
+
+    channel = mspd_channel_find_by_name_locked(a->argv[3]);
+
+    if (!strncasecmp(mspd_supvsr_name, a->argv[3], strnlen(a->argv[3], sizeof(mspd_supvsr_name)))) {
+        // right now, only send to first device
+        dev = mspd_device_find_by_index(0);
+    }
+
+    if (!channel && !dev) {
+        ast_cli(a->fd, "Channel/device not found: %s.\n", a->argv[3]);
+        res = CLI_FAILURE;
+	goto END;
+    }
+
+    res = cli_send_cmd_channel (e, cmd, a, channel, dev);
+
+END:
+    if (channel)
+        mspd_channel_unlock(channel);
+    return res;
+}
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/main/mspd/cmmlib.c asterisk-1.8.2.3.new/main/mspd/cmmlib.c
--- asterisk-1.8.2.3/main/mspd/cmmlib.c	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/main/mspd/cmmlib.c	2013-10-23 20:25:28.000000000 +0530
@@ -0,0 +1,236 @@
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <netinet/in.h>
+
+#include "asterisk.h"
+#include "asterisk/logger.h"
+#include "asterisk/mspd/cmmlib.h"
+
+#include <libcmm.h>
+#include <cmmd.h>
+#include <fpp.h>
+
+static int cmm_send_check_cmd (cmm_handle_t *cmm_handle, cmm_command_t *cmm_cmd)
+{
+	cmm_response_t          cmm_res;
+	int ret = 0;
+
+	memset(&cmm_res, 0 , sizeof(cmm_res));
+
+	// 1 CMD
+	if (cmm_send(cmm_handle, cmm_cmd, 0) != 0) {
+		ast_log(LOG_ERROR, "-----> CMM cmd 0x%x sending error = '%s' (%d) <-----\n",
+ 				cmm_cmd->func, strerror(errno), errno);
+		return errno;
+	}
+	else
+		ast_log(LOG_DEBUG, "CMM cmd 0x%x sent [ok]\n", cmm_cmd->func);
+
+	// 2 RECV
+	if ((ret = cmm_recv(cmm_handle, &cmm_res, 0)) < 0) {
+		ast_log(LOG_ERROR, "-----> CMM recv getting error = %d, errno = '%s' (%d) <-----\n",
+				ret, strerror(errno), errno);
+		return errno;
+	}
+	//else
+		//ast_log(LOG_DEBUG, "CMM recv for cmd 0x%x [ok]\n", cmm_cmd->func);
+
+	// 3 RESULT
+	if(cmm_res.rc != 0) {
+		ast_log(LOG_ERROR, "-----> CMM ret 0x%x [err]  <-----\n", cmm_res.rc);
+		return cmm_res.rc;
+	}
+	//else
+		//ast_log(LOG_DEBUG, "CMM ret [ok]\n");
+
+	return 0;
+}
+
+/* 
+Notes: 
+- FPP has some private sockets for internal use purpose, which should not 
+be used by external application such as asterisk. so the first socekt ID should be
+taken beyond the fpp private range.
+- To minimze change in cmm headers files for mindspeed's asterisk need the end of 
+private socket is re-defined here, but this value is indeed defined in cmm:module_socket.h
+ */
+#define FPP_SOCK_ID_PRIVATE_END 255
+
+int ast_cmm_fpp_create_socket (int sock_type, struct sockaddr_in *us)
+{
+	cmm_command_t           cmm_cmd;
+	cmmd_socket_open_cmd_t *cmm_sock;
+	cmm_handle_t           *cmm_handle;
+	int rc;
+
+	cmm_handle = cmm_open();
+	if (!cmm_handle) {
+		ast_log(LOG_ERROR, "--- Error openning CMM ---\n");
+		return -1;
+	}
+
+	static int sock_id = FPP_SOCK_ID_PRIVATE_END;
+	sock_id++;
+
+	memset(&cmm_cmd, 0 , sizeof(cmm_cmd));
+
+	cmm_cmd.func = CMMD_CMD_SOCKET_OPEN;
+	cmm_cmd.length = sizeof(cmmd_socket_open_cmd_t);
+
+	cmm_sock = (cmmd_socket_open_cmd_t*)&cmm_cmd.buf;
+	cmm_sock->id = sock_id;
+	cmm_sock->type = sock_type; // CMMD_SOCKET_TYPE_MSP  or  CMMD_SOCKET_TYPE_LANWAN;
+	///cmm_sock->mode = 0;        //SOCKET_UNCONNECTED;
+
+	// IP addresses and UDP ports are swapped
+	cmm_sock->family = AF_INET;
+	memset(&cmm_sock->saddr, 0, sizeof(cmm_sock->saddr)); // IPv4 address
+	cmm_sock->daddr[0] = us->sin_addr.s_addr;
+	cmm_sock->sport = 0;
+	cmm_sock->dport = us->sin_port;
+	cmm_sock->proto = PROTO_RTP_UDP;
+
+	cmm_sock->queue = 0;
+	cmm_sock->dscp = 0;
+	///cmm_sock->fwmark = 0;
+
+	rc = cmm_send_check_cmd(cmm_handle, &cmm_cmd);
+	cmm_close (cmm_handle);
+
+	if (rc)
+		return -rc;  /// Error happened
+	else
+		return sock_id;
+}
+
+int ast_cmm_fpp_update_socket (int sock_id, struct sockaddr_in *peer)
+{
+	cmm_command_t             cmm_cmd;
+	cmmd_socket_update_cmd_t *cmm_sock_update;
+	cmm_handle_t             *cmm_handle;
+	int rc;
+
+	cmm_handle = cmm_open();
+	if (!cmm_handle) {
+		ast_log(LOG_ERROR, "--- Error openning CMM ---\n");
+		return -1;
+	}
+
+	memset(&cmm_cmd, 0 , sizeof(cmm_cmd));
+
+	cmm_cmd.func = CMMD_CMD_SOCKET_UPDATE;
+	cmm_cmd.length = sizeof(cmmd_socket_update_cmd_t);
+	cmm_sock_update = (cmmd_socket_update_cmd_t*) &cmm_cmd.buf;
+
+	cmm_sock_update->id = sock_id;
+	cmm_sock_update->family = AF_INET;
+	cmm_sock_update->saddr[0] = peer->sin_addr.s_addr;
+	cmm_sock_update->sport = peer->sin_port;
+	cmm_sock_update->queue = 0xff;
+
+	rc = cmm_send_check_cmd(cmm_handle, &cmm_cmd);
+	cmm_close (cmm_handle);
+
+	return -rc;
+}
+
+void ast_cmm_fpp_close_socket (int sock_id)
+{
+	cmm_command_t            cmm_cmd;
+	cmmd_socket_close_cmd_t *cmm_sock_close;
+	cmm_handle_t            *cmm_handle;
+
+	cmm_handle = cmm_open();
+	if (!cmm_handle) {
+		ast_log(LOG_ERROR, "--- Error openning CMM ---\n");
+		return;
+	}
+
+	memset(&cmm_cmd, 0 , sizeof(cmm_cmd));
+
+	cmm_cmd.func = CMMD_CMD_SOCKET_CLOSE;
+	cmm_cmd.length = sizeof(cmmd_socket_close_cmd_t);
+	cmm_sock_close = (cmmd_socket_close_cmd_t*)&cmm_cmd.buf;
+
+	cmm_sock_close->id = sock_id;
+
+	cmm_send_check_cmd(cmm_handle, &cmm_cmd);
+	cmm_close (cmm_handle);
+}
+
+int ast_cmm_fpp_create_rtp_session (int sockA_id, int sockB_id)
+{
+	cmm_command_t           cmm_cmd;
+	fpp_rtp_open_cmd_t     *rtp_open;
+	fpp_rtp_ctrl_cmd_t     *rtp_ctrl;
+	cmm_handle_t           *cmm_handle;
+	int rc;
+
+	cmm_handle = cmm_open();
+	if (!cmm_handle) {
+		ast_log(LOG_ERROR, "--- Error openning CMM ---\n");
+		return -1;
+	}
+
+	static int rtp_session_id = 0;
+	rtp_session_id++;
+
+	memset(&cmm_cmd, 0 , sizeof(cmm_cmd));
+
+	cmm_cmd.func = FPP_CMD_RTP_OPEN;
+	cmm_cmd.length = sizeof(fpp_rtp_open_cmd_t);
+	rtp_open = (fpp_rtp_open_cmd_t*)&cmm_cmd.buf;
+	rtp_open->call_id = rtp_session_id;
+	rtp_open->socket_a = sockA_id;
+	rtp_open->socket_b = sockB_id;
+
+	rc = cmm_send_check_cmd(cmm_handle, &cmm_cmd);
+	if (rc) {
+	cmm_close (cmm_handle);
+		return -rc;  /// Error happened
+	}
+
+	memset(&cmm_cmd, 0 , sizeof(cmm_cmd));
+
+	cmm_cmd.func = FPP_CMD_RTP_CONTROL;
+	cmm_cmd.length = sizeof(fpp_rtp_ctrl_cmd_t);
+	rtp_ctrl = (fpp_rtp_ctrl_cmd_t*)&cmm_cmd.buf;
+	rtp_ctrl->call_id = rtp_session_id;
+	rtp_ctrl->control_dir = CMM_FPP_RTP_CUT_THROUGH;
+
+	rc = cmm_send_check_cmd(cmm_handle, &cmm_cmd);
+
+	cmm_close (cmm_handle);
+
+	if (rc)
+		return -rc;  /// Error happened
+
+	return rtp_session_id;
+}
+
+void ast_cmm_fpp_close_rtp_session (int rtp_call_id)
+{
+	cmm_command_t           cmm_cmd;
+	fpp_rtp_close_cmd_t    *rtp_close;
+	cmm_handle_t           *cmm_handle;
+
+	cmm_handle = cmm_open();
+	if (!cmm_handle) {
+		ast_log(LOG_ERROR, "--- Error openning CMM ---\n");
+		return;
+	}
+
+	memset(&cmm_cmd, 0 , sizeof(cmm_cmd));
+
+	cmm_cmd.func = FPP_CMD_RTP_CLOSE;
+	cmm_cmd.length = sizeof(fpp_rtp_close_cmd_t);
+	rtp_close = (fpp_rtp_close_cmd_t*)&cmm_cmd.buf;
+	rtp_close->call_id = rtp_call_id;
+
+	cmm_send_check_cmd(cmm_handle, &cmm_cmd);
+	cmm_close (cmm_handle);
+}
+
+////// =====================================================
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/main/mspd/common.c asterisk-1.8.2.3.new/main/mspd/common.c
--- asterisk-1.8.2.3/main/mspd/common.c	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/main/mspd/common.c	2011-05-20 20:02:57.000000000 +0530
@@ -0,0 +1,59 @@
+#include "asterisk.h"
+#include "asterisk/mspd/common.h"
+#include "asterisk/logger.h"
+#include "asterisk/config.h"
+#include "asterisk/network.h"
+#include "asterisk/mspd/macro.h"
+
+void 
+mspd_info_about_rtp(struct ast_rtp_instance *rtp)
+{
+	struct ast_sockaddr own_peer,own_us;
+	ast_rtp_instance_get_local_address(rtp, &own_us);
+	ast_rtp_instance_get_remote_address(rtp, &own_peer);
+	ast_verbose(VERBOSE_PREFIX_3"(%s):\n^^^^^^^^^^^^^^^^^^^^^^^^^^^ \n%s:%d"
+		    "******** Information about %p src=%s:%u, dst=%s:%u********\n"
+		    "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n",
+		    "DEBUGGING",__FILE__,__LINE__, rtp, ast_inet_ntoa(((struct sockaddr_in*)&own_us.ss)->sin_addr),
+		    ntohs(((struct sockaddr_in*)&own_us.ss)->sin_port), ast_inet_ntoa(((struct sockaddr_in*)&own_peer.ss)->sin_addr),
+		    ntohs(((struct sockaddr_in*)&own_peer.ss)->sin_port));
+}
+
+// -----------------------------------------------------------------------------------------------
+int
+ast_do_save_strdup (char **p, const char *v, char const *func, int line)
+{
+    if (*p)
+        free (*p);
+    *p = ast_strdup (v);
+    if (!(*p)) {
+        MSPD_ERR("Out of memory duplicting string \"%s\" @ %s():%d\n", v, func, line);
+        return 1;
+    }
+    return 0;
+}
+
+// -----------------------------------------------------------------------------------------------
+int
+ast_parse_mac (uint8_t * mac, struct ast_variable *v)
+{
+    uint s[6];
+    uint i;
+    int rc =
+    sscanf (v->value, "%x:%x:%x:%x:%x:%x", &s[0], &s[1], &s[2], &s[3], &s[4],
+        &s[5]);
+    if (rc != 6) {
+        MSPD_ERR("%s=%s is invalid\n", v->name, v->value);
+        return 1;
+    }
+    for (i = 0; i < 6; ++i) {
+        if (s[i] > 255) {
+            MSPD_ERR("%s=%s is invalid\n", v->name, v->value);
+            return 1;
+        }
+    }
+    for (i = 0; i < 6; ++i)
+        mac[i] = s[i];
+
+    return 0;
+}
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/main/mspd/conference.c asterisk-1.8.2.3.new/main/mspd/conference.c
--- asterisk-1.8.2.3/main/mspd/conference.c	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/main/mspd/conference.c	2012-02-22 16:45:31.000000000 +0530
@@ -0,0 +1,314 @@
+/*
+ * Mindspeed Comcerto Channel module.
+ *
+ *  Copyright (C) 2004 - 2011 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+// ===============================================================================================
+// Includes
+
+#include "asterisk.h"
+
+//ASTERISK_FILE_VERSION(__FILE__, "$Revision: 1.14 $")
+
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <pthread.h>
+#include <signal.h>
+#include <time.h>
+#include <errno.h>
+
+#include <vapi/vapi.h>
+#include <vapi/comcerto-api-defs.h>
+
+#include "asterisk/mspd/common.h"
+#include "asterisk/mspd/defaults.h"
+#include "asterisk/mspd/macro.h"
+#include "asterisk/mspd/utils.h"
+#include "asterisk/mspd/device.h"
+#include "asterisk/mspd/conference.h"
+#include "asterisk/mspd/global.h"
+
+#include "asterisk/utils.h"
+#include "asterisk/rtp_engine.h"
+#include "asterisk/lock.h"
+#include "asterisk/logger.h"
+#include "asterisk/pbx.h"
+#include "asterisk/options.h"
+#include "asterisk/features.h"
+#include "asterisk/term.h"
+#include "asterisk/sched.h"
+
+// a device conference
+struct mspd_conference {
+    char                *name;
+    mspd_device_t       *dev;
+    ast_mutex_t         lock;
+    U16                 id;
+    BandMode            mixer;
+    U16                 n_participants;
+};
+
+static uint nconfs = 0;
+
+U16 mspd_conference_get_participants_count(const mspd_conference_t *conference)
+{
+    return conference->n_participants;
+}
+
+const char *mspd_conference_get_name(const mspd_conference_t *conference)
+{
+    return conference->name;
+}
+
+U16 mspd_conference_get_id(const mspd_conference_t *conference)
+{
+    return conference->id;
+}
+
+Boolean mspd_conference_get_mixer(const mspd_conference_t *conference)
+{
+    return conference->mixer;
+}
+
+mspd_device_t *mspd_conference_get_device(mspd_conference_t *conference)
+{
+    return conference->dev;
+}
+
+// -----------------------------------------------------------------------------------------------
+// create a conference (object and in device)
+mspd_conference_t *
+mspd_conference_create (mspd_device_t *dev, BandMode conf_mode)
+{
+    mspd_conference_t *conference;
+    VSTATUS vstatus= 0xFF;
+
+    MSPD_LOG(1, "Creating conference with %s band mixer\n", (conf_mode) ? "Wide" : "Narrow");
+
+    conference = malloc(sizeof(*conference));
+    if (!conference) {
+        MSPD_ERR("(%s): out of memory\n", mspd_device_get_name(dev));
+        return NULL;
+    }
+
+    memset(conference, 0, sizeof(*conference));
+    conference->dev = dev;
+    conference->mixer = conf_mode;
+    ast_mutex_init(&conference->lock);
+    conference->id = mspd_device_get_conference_id(dev);
+
+    SConfParams pstConfParams = {0,0};  //Boolean bTranscoding;	1-Enable, 0-Disable
+                                        //Boolean bBlockDTMF; 1-Enable, 0-Disable */
+    pstConfParams.bMixerType = conf_mode;  // Type of Conference Mixer: 0 = Narrowband (default), 1 = Wideband
+
+    SConfDTSParams pstConfDTSParams;
+    pstConfDTSParams.bDTSOnOff = 0;        //  Dominant talkers enabled (default Off)
+    pstConfDTSParams.usAttackConst = 100;  //  Attack constant (ms)
+    pstConfDTSParams.usNTH1 = 10;          //  Noise Threshold 1 (eights of dB)
+    pstConfDTSParams.usNTH2 = 10;          //  Noise Threshold 2 (eights of dB)
+    pstConfDTSParams.usHoldConst = 100;    // Hold constant (ms)
+    pstConfDTSParams.usN1 = 16;            // Number of participant for group 1
+    pstConfDTSParams.usG1 = 10;            // Attenuation for group 1 (tenths of dB)
+    pstConfDTSParams.usN2 = 16;            // Number of participant for group 2
+    pstConfDTSParams.usG2 = 10;            // Attenuation for group 2 (tenths of dB)
+    pstConfDTSParams.usN3 = 16;            // Number of participant for group 3
+    pstConfDTSParams.usG3 = 10;            // Attenuation for group 3 (tenths of dB)
+
+    Boolean bIsEnhancedConf = 0;
+
+    vstatus = VAPI_CreateConference (mspd_device_get_id(dev), conference->id, &pstConfParams,
+                                    bIsEnhancedConf, &pstConfDTSParams, NULL);
+
+    VAPI_REPORT_ACT (vstatus, "VAPI_CreateConference", goto bail_out);
+
+    conference->name = mspd_asprintf("MSPD_Conf:%u", conference->id);
+    MSPD_LOG(3, "Conference %s created (total %u confs)\n", conference->name, ++nconfs);
+
+    return conference;
+
+bail_out:
+    MSPD_ERR("(%s): free conference\n", mspd_device_get_name(dev));
+    MSPD_UNLOCK(conference->lock);
+    free(conference);
+    MSPD_ERR("(%s): free conference\n", mspd_device_get_name(dev));
+    return NULL;
+}
+
+// -----------------------------------------------------------------------------------------------
+// destroy a conference (as object and in device)
+void
+mspd_conference_destroy (mspd_conference_t *conference)
+{
+    char *conf_name = NULL;
+    VSTATUS vstatus = 0xFF;
+
+    MSPD_LOG(1, "Destroying conference %s\n", conference->name);
+
+    if (conference->n_participants > 0) {
+        MSPD_ERR("(%s): Conference has still %u participant%s\n",
+                conference->name, conference->n_participants,
+                conference->n_participants > 1 ? "s" : "");
+        return;
+    }
+
+    if (conference->id < 0xffffU) {
+        vstatus = VAPI_DestroyConference (conference->id, NULL);
+        VAPI_REPORT (vstatus, "VAPI_DestroyConference");
+
+        conference->id = 0xffffU;
+    }
+
+    MSPD_LOCK(conference->lock, /*ignore*/);
+    if (conference->name) {
+        conf_name = strdup(conference->name);
+        free(conference->name);
+        conference->name = NULL;
+    }
+    MSPD_UNLOCK(conference->lock);
+    ast_mutex_destroy(&conference->lock);
+
+    free(conference);
+
+    MSPD_LOG(3, "Conference %s destroyed (total %u confs)\n", conf_name ? conf_name : "no_name", --nconfs);
+
+    free(conf_name);
+}
+
+static void
+conference_destructor(mspd_channel_t *channel)
+{
+    VSTATUS vstatus = 0xFF;
+
+    mspd_conference_t **pvt = (mspd_conference_t**) mspd_channel_get_pvt(channel);
+    mspd_conference_t *conference = *pvt;
+    --conference->n_participants;
+
+    vstatus = VAPI_DestroyParticipant(mspd_channel_get_id(channel), NULL);
+    VAPI_REPORT (vstatus, "CONF_DESTROY_PARTICIPANT");
+}
+
+// -----------------------------------------------------------------------------------------------
+// create a new channel (as object and in device)
+mspd_channel_t *
+mspd_conference_create_rtp_participant(mspd_conference_t           	*conference,
+                                       format_t                    	ast_format,
+                                       struct ast_rtp_instance     	*rtp)
+{
+    char    color_buf [256]= {0};
+    VSTATUS vstatus = 0xFF;
+    U16 timeslots[4] = {0, 0, 0, 0};
+    BandMode conf_mode = ast_format & WIDE_BAND_CODECS ? Wide : Narrow;
+
+    if (!rtp || !conference)
+    {
+        MSPD_ERR("(%s, %s, %p, %p): invalid arguments, "
+                "can't create channel\n",
+                mspd_channel_type2text(MCT_PART_RTP), ast_getformatname(ast_format), rtp, conference);
+        return NULL;
+    }
+
+    struct ast_sockaddr src, dst;
+    ast_rtp_instance_get_remote_address(rtp, &src);
+    ast_rtp_instance_get_local_address(rtp, &dst);
+
+    if (ast_sockaddr_cmp_addr(&src, mspd_device_get_ipaddr(conference->dev)) ||
+        ast_sockaddr_cmp_addr(&dst, mspd_global_get_ipaddr()))
+    {
+        MSPD_ERR("(%s, %s): invalid RTP %s -> %s, "
+                "can't create channel\n",
+                mspd_channel_type2text(MCT_PART_RTP),
+                ast_getformatname(ast_format),
+                ast_sockaddr_stringify (&src),
+                ast_sockaddr_stringify (&dst));
+        return NULL;
+    }
+
+    if (option_verbose > 1) {
+        char buf[256];
+        int n = 0;
+        if (ast_format) {
+            char cbuf[256];
+            ast_getformatname_multiple(cbuf, sizeof(cbuf), ast_format),
+            n += snprintf(buf + n, sizeof(buf) - n, ", %s", cbuf);
+        }
+
+        n += snprintf(buf + n, sizeof(buf) - n, ", %s->%s",
+             ast_sockaddr_stringify (&src),
+             ast_sockaddr_stringify (&dst));
+
+        n += snprintf(buf + n, sizeof(buf) - n, ", %s conf-id:0x%x",
+             conference->name, conference->id);
+
+        MSPD_LOG(2, "Creating (%s%s)\n", mspd_channel_type2text(MCT_PART_RTP), buf);
+    }
+
+    ///--- --== Allocating Channel resources ==-- ---///
+    mspd_channel_t * const channel = mspd_channel_create(conference->dev,
+                                                         MCT_PART_RTP,
+                                                         ast_format,
+							 0,
+							 sizeof(mspd_conference_t*),
+							 NULL,
+							 conference_destructor);
+
+    if (!channel) {
+        MSPD_ERR("(%s,%s): allocating new channel has failed\n",
+                mspd_device_get_name(conference->dev), mspd_channel_type2text(MCT_PART_RTP));
+        return NULL;
+    }
+
+    mspd_conference_t **pvt = mspd_channel_get_pvt(channel);
+    *pvt = conference;
+    ++conference->n_participants;
+
+    //----------------------------------------------------------------------------------------
+    MSPD_LOG(1, "%s: RTP, %s, DevID=%d, ConfName=%s, ConfID=%d\n",
+            term_color(color_buf, "CONF_CREATE_PARTICIPANT (0x9312)",
+            COLOR_BRGREEN, 0, sizeof (color_buf)), (conf_mode == Wide) ? "Wideband" : "Narrowband",
+            mspd_device_get_id(conference->dev), conference->name, conference->id);
+
+    vstatus = VAPI_AllocateParticipant (conference->id, mspd_channel_get_id(channel),
+                                        (conf_mode == Wide) ? eRSPWB : eRSP,
+                                        (conf_mode == Wide) ? 4 : 1, 
+					timeslots,   // not used internally
+                                        NULL, NULL);
+    VAPI_REPORT_ACT (vstatus, "RSP CONF_CREATE_PARTICIPANT (0x9312)", goto send_failed);
+
+    if (mspd_channel_set_ip_header(channel, &src, &dst))
+	    goto send_failed;
+    if (mspd_channel_bwe_manager(channel,
+        NoBand,  // not used internally
+        mspd_conference_get_mixer(conference),
+        mspd_global_get_rsp_bwe(),
+        True))
+	    goto send_failed;
+    if (mspd_channel_configure_rsp_part(channel))
+	    goto send_failed;
+    if (mspd_channel_start_conf_tx(channel))
+	    goto send_failed;
+
+    return channel;
+
+send_failed:
+    MSPD_ERR("(%s): Channel configuration has failed\n", mspd_channel_get_name(channel));
+    mspd_channel_destroy(channel);
+    return NULL;
+}
+
+void mspd_conference_inc_participants(mspd_conference_t *conf)
+{
+    ++conf->n_participants;
+}
+
+void mspd_conference_dec_participants(mspd_conference_t *conf)
+{
+    --conf->n_participants;
+}
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/main/mspd/device.c asterisk-1.8.2.3.new/main/mspd/device.c
--- asterisk-1.8.2.3/main/mspd/device.c	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/main/mspd/device.c	2013-02-26 14:20:07.000000000 +0530
@@ -0,0 +1,1133 @@
+#include "asterisk.h"
+
+#include <vapi/vapi.h> 
+#include <vapi/comcerto-api-defs.h> 
+#include <vapi/gtl.h>
+
+#include "asterisk/lock.h"
+#include "asterisk/utils.h"
+#include "asterisk/rtp_engine.h" 
+#include "asterisk/lock.h" 
+#include "asterisk/logger.h" 
+#include "asterisk/pbx.h" 
+#include "asterisk/options.h" 
+#include "asterisk/features.h" 
+#include "asterisk/term.h" 
+#include "asterisk/sched.h" 
+#include "asterisk/mspd/macro.h"
+#include "asterisk/mspd/common.h"
+#include "asterisk/mspd/defaults.h"
+#include "asterisk/mspd/utils.h"
+#include "asterisk/mspd/device.h"
+#include "asterisk/mspd/global.h"
+#include "asterisk/mspd/queue.h"
+#include "asterisk/mspd/channel.h"
+
+#define MSPD_MAX_DEVICES	(1)
+
+// a MSP (Media Stream Processor) device
+struct mspd_device {
+    char                *name;
+    U32                 device_id;
+
+    struct ast_sockaddr ipaddr;
+    U8                  mac_src[6];
+    U8                  mac_dst[6];
+
+    ast_mutex_t         lock;
+    U16                 channel_tag;
+    U16			channel_id;
+    U16			conference_id;
+
+    STdmBusParams       tdm_params;
+};
+
+static mspd_device_t devices[MSPD_MAX_DEVICES];
+static unsigned int n_devices = 0;
+
+// -----------------------------------------------------------------------------------------------
+static int
+handle_indication_vapi (SUndefinedEventParams *event)
+{
+    //SUndefinedEventParams *undef_event = (SUndefinedEventParams *)event;
+    //U32 connection = event->ID.ConId;
+
+    if (option_verbose > 8)
+        MSPD_LOG(1, "--- event->usFnCode = 0x%04X ---\n", event->usFnCode);
+
+    // Event Detection Indication
+    // will be supported as event type in next VAPI releases
+    if (event->usFnCode == FC_VOIP_EVENTDET)
+        return 0;
+
+    // PASSTHRU_AUTOSWITCH_IND
+    // indicates the host of an automatic switch made by the device
+    if (event->usFnCode == FC_PASSTHRU_AUTOSWITCH_IND) {
+
+        queue_item_t    item;
+        mspd_channel_t *channel = NULL;
+
+        MSPD_LOG(5, "Connection %u: PASSTHRU_AUTOSWITCH INDICATION (0x%04X) detected\n",
+                    (U32) event->ID.ConId,
+                    FC_PASSTHRU_AUTOSWITCH_IND);
+
+        item.vItem = calloc(sizeof(*item.vItem), 1);
+        if (!item.vItem) {
+            MSPD_ERR("(%u): out of memory for VAPI queue-element\n", event->ID.ConId);
+            return 1;
+        }
+
+        item.vItem->usFnCode              = FC_PASSTHRU_AUTOSWITCH_IND;
+        item.vItem->event.ConId           = event->ID.ConId;
+        item.vItem->uPassthruMode         = event->ausParams[1];
+
+	channel = mspd_channel_find_locked(event->ID.ConId);
+	if(!channel)
+	    return -1;
+
+        if(mspd_channel_put_event(channel,item)) {
+	    mspd_channel_unlock(channel);
+            return -1;
+	}
+
+	mspd_channel_unlock(channel);
+        return 0;
+    }
+
+    if (event->usFnCode == FC_FAXSTATE) {
+
+        queue_item_t    item;
+        mspd_channel_t *channel = NULL;
+
+        item.vItem = malloc(sizeof(*item.vItem));
+        if (!item.vItem) {
+            MSPD_ERR("(%u): out of memory for VAPI queue-element\n", event->ID.ConId);
+            return 1;
+        }
+
+        item.vItem->usFnCode              = FC_FAXSTATE;
+        item.vItem->event.ConId           = event->ID.ConId;
+        item.vItem->event.usDetectedTone  = event->ausParams[1];
+        item.vItem->event.usPpowerLevel   = 0;
+        item.vItem->event.uTimestamp      = 0;
+
+        channel = mspd_channel_find_locked(event->ID.ConId);
+	if(!channel)
+	    return -1;
+
+        if(mspd_channel_put_event(channel, item)) {
+	    mspd_channel_unlock(channel);
+            return -1;
+	}
+
+	mspd_channel_unlock(channel);
+        return 0;
+    }
+
+    if (option_verbose > 9){
+        if (event->ucLevel)
+            MSPD_LOG(5, "--- Undefined Device level event gotten ---\n");
+        else
+            MSPD_LOG(5, "--- Undefined Channel level event gotten ---\n");
+
+        MSPD_LOG(5, "--- Len=%u Index=%u CmdClass=0x%02x CmdType=0x%02x "
+                "FnCode=0x%04x ParamCnt=0x%04x ---\n",
+                event->ucLength,
+                event->ucIndex,
+                event->ucCmdClass,
+                event->ucCmdType,
+                event->usFnCode,
+                event->usNoOfParams);
+
+        int param_cnt=0;
+        for (param_cnt = 0; param_cnt < event->usNoOfParams; param_cnt++)
+            MSPD_LOG(5, " --- Param%u = [0x%04x] \n",
+                    param_cnt, event->ausParams[param_cnt]);
+    }
+
+    return 0;
+}
+
+// -----------------------------------------------------------------------------------------------
+// send indication to consumer
+static int
+handle_tone_vapi (SToneDetectEventParams *tone_detected)
+{
+    U32 connection = tone_detected->ConId;
+
+    queue_item_t    item;
+    mspd_channel_t *channel = NULL;
+
+    MSPD_LOG(5, "Connection %u: Tone 0x%x detected\n",
+                (U32) tone_detected->ConId,
+                (U32) tone_detected->usDetectedTone);
+
+    item.vItem = malloc(sizeof(*item.vItem));
+    if (!item.vItem) {
+        MSPD_ERR("(%u): out of memory for VAPI queue-element\n", connection);
+        return 1;
+    }
+
+    item.vItem->usFnCode              = FC_VOIP_TONEDET;
+    item.vItem->event.ConId           = tone_detected->ConId;
+    item.vItem->event.usDetectedTone  = tone_detected->usDetectedTone;
+    item.vItem->event.usPpowerLevel   = tone_detected->usPpowerLevel;
+    item.vItem->event.uTimestamp      = tone_detected->uTimestamp;
+
+    channel = mspd_channel_find_locked(tone_detected->ConId);
+    if(!channel)
+	return -1;
+
+    if(mspd_channel_put_event(channel, item)) {
+        mspd_channel_unlock(channel);
+        return -1;
+    }
+
+    mspd_channel_unlock(channel);
+    return 0;
+}
+
+// -----------------------------------------------------------------------------------------------
+static char const *
+eVAPI2text(EEventCode type)
+{
+    switch (type) {
+        case eVAPI_SPI_EVENT:                           return "eVAPI_SPI_EVENT";
+        case eVAPI_TONE_DETECT_EVENT:                   return "eVAPI_TONE_DETECT_EVENT";
+        case eVAPI_TONE_GEN_CMPLT_EVENT:                return "eVAPI_TONE_GEN_CMPLT_EVENT";
+        case eVAPI_PT_CHANGE_EVENT:                     return "eVAPI_PT_CHANGE_EVENT";
+        case eVAPI_SSRC_CHANGE_EVENT:                   return "eVAPI_SSRC_CHANGE_EVENT";
+        case eVAPI_SSRC_VIOLATION_EVENT:                return "eVAPI_SSRC_VIOLATION_EVENT";
+        case eVAPI_NTE_TRANSMIT_COMPLETE_EVENT:         return "eVAPI_NTE_TRANSMIT_COMPLETE_EVENT";
+        case eVAPI_NTE_RECVD_EVENT:                     return "eVAPI_NTE_RECVD_EVENT";
+        case eVAPI_CALLER_ID_CMPLT_EVENT:               return "eVAPI_CALLER_ID_CMPLT_EVENT";
+        case eVAPI_G711_CONCURRENT_DECODER_EVENT:       return "eVAPI_G711_CONCURRENT_DECODER_EVENT";
+        case eVAPI_PASSTHRU_CONCURRENT_DECODER_EVENT:   return "eVAPI_PASSTHRU_CONCURRENT_DECODER_EVENT";
+        case eVAPI_DECODER_EVENT:                       return "eVAPI_DECODER_EVENT";
+        case eVAPI_CALLER_ID_DETECTED_EVENT:            return "eVAPI_CALLER_ID_DETECTED_EVENT";
+        case eVAPI_REMOTE_DETECT_EVENT:                 return "eVAPI_REMOTE_DETECT_EVENT";
+        case eVAPI_FAX_SWITCH_CMPLT_EVENT:              return "eVAPI_FAX_SWITCH_CMPLT_EVENT";
+        case eVAPI_ALERT_IND:                           return "eVAPI_ALERT_IND";
+        case eVAPI_IMSOTDM_H245_EVENT:                  return "eVAPI_IMSOTDM_H245_EVENT";
+        case eVAPI_SYNCDAT_EVENT:                       return "eVAPI_SYNCDAT_EVENT";
+        case eVAPI_SYNCEOF_EVENT:                       return "eVAPI_SYNCEOF_EVENT";
+        case eVAPI_IPTONE_DETECT_EVENT:                 return "eVAPI_IPTONE_DETECT_EVENT";
+        case eVAPI_UNDEFINED_EVENT:                     return "eVAPI_UNDEFINED_EVENT";
+    }
+    return "**UNKNOWN VAPI EVENT**";
+}
+
+static void
+vapi_callback (EEventCode eEventCode, void *pvData)
+{
+    char buf [256];
+    term_color(buf, eVAPI2text(eEventCode), COLOR_YELLOW, 0, sizeof (buf));
+
+    SToneDetectEventParams *tone_detected;
+    SToneGenCmpltEventParams *gen_complete;
+
+    switch (eEventCode)
+    {
+        case eVAPI_SPI_EVENT:                           // Event SPI like On-hook/Off-Hook
+            MSPD_LOG(5, "=== %s ===\n", buf);
+        break;
+
+        case eVAPI_TONE_DETECT_EVENT:                   // Event for tone detection (like for DTMF)
+        {
+                tone_detected = (SToneDetectEventParams *)pvData;
+                MSPD_LOG(5, "=== %s ConnID=%d===\n", buf, tone_detected->ConId);
+
+                if(handle_tone_vapi(tone_detected))
+                    MSPD_LOG(5, "--- Some tone is not handled ---\n");
+            break;
+        }
+
+        case eVAPI_TONE_GEN_CMPLT_EVENT:                // Event Tone Generation completed
+        {
+            gen_complete = (SToneGenCmpltEventParams *)pvData;;
+            /**< 0x00  Normal termination \n
+                            0x01: Timestamp has already passed limit value \n
+                            0x02: Timestamp has not yet reached start value \n
+                            0x03: Termination due to TONEOFF command \n
+                            0x04: Termination due to null TONEGEN command \n
+                            0x05: Termination of active tone by new tone generate request \n
+                            0x06: Cancellation of waiting tone by new tone generate request \n
+                            0x07: Termination of protected tone (sent after 50ms off time) \n
+                            0x08: Protected buffer full  tone dropped \n
+                            0x09: Stop tone received for buffered unprotected tone  \n
+                            tone dropped \n
+                            0x0A: Unprotected tone dropped during protected sequence \n
+                            0x0B: Protected tone delay more than 5 seconds  tone dropped */
+
+            MSPD_LOG(5, "=== %s Status=%d ConnId=%d===\n",
+                    buf, gen_complete->usToneTerminateCause, gen_complete->ConId);
+            break;
+        }
+
+        case eVAPI_PT_CHANGE_EVENT:                     // Event Payload type change
+            if (option_verbose > 9)
+                MSPD_LOG(5, "=== %s ===\n", buf);
+        break;
+
+        case eVAPI_UNDEFINED_EVENT:                     // Events, not suported by VAPI
+            if (option_verbose > 8)
+            MSPD_LOG(5, "=== %s ===\n", buf);
+
+            if(handle_indication_vapi ((SUndefinedEventParams *) pvData))
+                MSPD_LOG(5, "--- Some event is not handled ---\n");
+        break;
+
+        default:
+            MSPD_LOG(5, "=== %s ===\n", buf);
+    }
+}
+
+// -----------------------------------------------------------------------------------------------
+// This function re-organizes tones for use in signalling systems, i.e. DC_TONE_DIAL, DC_TONE_BUSY
+static int
+setup_signalling_tones (void)
+{
+    /* === VAPI defaults ===
+    Tone             Repeat     freq1,  amp1,   freq2,  amp2    ontime, offtime; freq3, amp3, ...
+    eNULLTONE         1,        0,      0,      0,      0,      0,      0
+    eCONGESTIONTONE   0xFF,     480,    100,    620,    100,    250,    250
+    eWARNINGTONE      1,        440,    100,    0,      0,      1500,   8000,   440, 100, 0, 0, 500, 8000
+    eWAITINGTONE      1,        440,    100,    0,      0,      300,    10000
+    eCONFIRMATIONTONE 0         350,    170,    440,    170,    100,    100,    350, 170, 440, 170, 100, 100, 350, 170, 440, 170, 100, 100
+    eDIALTONE         0xFF,     350,    100,    440,    100,    0,      0
+    eBUSYTONE         0xFF,     480,    100,    620,    100,    500,    500
+    eRINGBACKTONE     0xFF,     440,    100,    480,    100,    1000,   3000
+    eSPECIALTONE      1,        950,    100,    0,      0,      330,    0,      1400, 100, 0, 0, 330, 0, 1800, 100, 0, 0, 330, 0
+    eSASTONE          0         440,    212,    0,      0,      300,    300
+    */
+
+    /* === Previous Asterisk defines ===
+    DC_TONE_DIAL:     0xFF,     350,    176,    440,    176
+    DC_TONE_BUSY:     0xFF,     440,    176,    500,    750
+    DC_TONE_ANSWER:   0xFF,     440,    176,    488,    176,    2000,   4008
+    DC_TONE_INDI:     0xFF30,   250,    176,    750,    176,    200,    1200
+    DC_TONE_HOLD:     0xFF,     550,    176,    840,    176,    500,    2200
+    */
+
+    // TODO: Adjust signalling tones according to ITU-T E.180/Q.35
+    // "Technical characteristics of tones for the telephone service"
+
+    VSTATUS status = 1;
+    VSTATUS acc = 0;
+
+    // DC_TONE_DIAL
+    status = VAPI_SetTone(eDIALTONE, eDualTone,
+                            0xFF,
+                            6,
+                            350, 176, 440, 176, 0, 0);
+    if (status) {
+        MSPD_ERR ("Can not re-define eDIALTONE\n");
+        acc += status;
+    }
+
+    // DC_TONE_BUSY
+    status = VAPI_SetTone(eBUSYTONE, eDualTone,
+                            0xFF,
+                            6,
+                            440, 176, 0, 0, 500, 750);
+    if (status) {
+        MSPD_ERR ("Can not re-define eBUSYTONE\n");
+        acc += status;
+    }
+
+    // DC_TONE_ANSWER
+    status = VAPI_SetTone(eRINGBACKTONE, eDualTone,
+                            0xFF,
+                            6,
+                            440, 176, 488, 176, 2000, 4000);
+    if (status) {
+        MSPD_ERR ("Can not re-define eRINGBACKTONE\n");
+        acc += status;
+    }
+
+    // DC_TONE_INDI
+    status = VAPI_SetTone(eCUSTOM_1, eDualTone,
+                            0xFF,
+                            6,
+                            250, 350, 750, 350, 200, 1200);
+    if (status) {
+        MSPD_ERR ("Can not re-define eCUSTOM_1\n");
+        acc += status;
+    }
+
+    // DC_TONE_HOLD
+    status = VAPI_SetTone(eCUSTOM_2, eDualTone,
+                            0xFF,
+                            6,
+                            1000, 350, 1600, 350, 200, 2300);
+    if (status) {
+        MSPD_ERR ("Can not re-define eCUSTOM_2\n");
+        acc += status;
+    }
+
+    return acc;
+}
+
+// -----------------------------------------------------------------------------------------------
+int
+mspd_device_set_spu_features_control (mspd_device_t *dev)
+{
+
+    VSTATUS status  = 1;
+    void *message   = NULL;
+    U32 resp_len    = MAX_FIFO_SIZE;
+    U8  dev_resp     [MAX_FIFO_SIZE];
+    U16 spu_config;
+
+    if(!dev) {
+        MSPD_ERR("No device to send a command");
+        return -1;
+    }
+
+    message = VAPI_AllocateMessage(MAX_FIFO_SIZE);
+    if (!message) {
+        MSPD_ERR("VAPI_AllocateMessage has failed\n");
+        return -1;
+    }
+
+    if(mspd_global_get_ec_type() == EC_TYPE_STD)
+        spu_config  = (SPU_IP_INTF_TONE_DET|SPU_CALLERID_DET_ENA|
+                            SPU_VOICE_SIL_DET_IND|SPU_ECHOCAN_CTRL);
+    else
+        spu_config = (SPU_DUALFILTER_ECHOCAN|SPU_IP_INTF_TONE_DET|
+                            SPU_CALLERID_DET_ENA|SPU_VOICE_SIL_DET_IND);
+
+    MSPD_LOG(3, "%s: Setting SPU features [0x%04x]\n", dev->name, spu_config);
+
+    status = VAPI_SetMessage(message,
+                CMD_CLASS_CONF_DEVICE,
+                CMD_TYPE_CONF_CHANGE,
+                    FC_SPU_FEATURES_CONTROL,
+                        1, spu_config);
+
+    if (status)
+        VAPI_REPORT_ACT (status, "Setting SPU_FEATURES_CONTROL", goto msg_err);
+
+
+    status = VAPI_SendDeviceMessage(dev->device_id,
+                (SMsg *)message, NULL,
+                dev_resp, &resp_len);
+    VAPI_REPORT_ACT (status, "Setting SPU features", goto msg_err);
+
+msg_err:
+    VAPI_FreeMessage(message);
+
+    return status;
+}
+
+// -----------------------------------------------------------------------------------------------
+
+static int
+mspd_device_set_pcm_law(mspd_device_t *dev);
+static int
+mspd_device_set_pcm_law(mspd_device_t *dev)
+{
+    VSTATUS status  = 1;
+    void *message   = NULL;
+    U32 resp_len    = MAX_FIFO_SIZE;
+    U8  dev_resp     [MAX_FIFO_SIZE];
+    U16 v = MSPD_PCM_DEFAULT_IS_ALAW ? 1 : 0;
+
+    if (!dev) {
+        MSPD_ERR("No device to send a command");
+        return -1;
+    }
+    message = VAPI_AllocateMessage(MAX_FIFO_SIZE);
+    if (!message) {
+        MSPD_ERR("VAPI_AllocateMessage has failed\n");
+        return -1;
+    }
+    MSPD_LOG(3, "%s: Setting PCM law [0x%04x]\n", dev->name, v);
+    status = VAPI_SetMessage(message, CMD_CLASS_CONF_DEVICE, CMD_TYPE_CONF_CHANGE,
+			     FC_SUPVSR_SET_PCM_LAW, 1, v);
+    if (!status) {
+	status = VAPI_SendDeviceMessage(dev->device_id, (SMsg *)message, NULL,
+					dev_resp, &resp_len);
+	// command only succeeds if no channel have been created yet, but it
+	// could be that asterisk is restarted, so we have to ignore this
+	// specific error
+	if (status == -79)
+	    status = 0;
+    }
+    VAPI_REPORT_ACT (status, "Setting PCM law", goto msg_err);
+
+msg_err:
+    VAPI_FreeMessage(message);
+
+    return status;
+}
+
+// ----------------------------------------------------------------------------------------------
+// send message to the device to select MSP network interface
+static int
+set_packet_destination(mspd_device_t *dev, U8 port_id, U16 data_msb, U16 data_lsb)
+{
+    MSPD_LOG(1, "Selecting MSP network interface %s (%d), msb=%d, lsb=%d\n",
+                "to_do_print_NIF", port_id, data_msb, data_lsb);
+
+    VSTATUS status  = 1;
+    void *message   = NULL;
+    U32 resp_len    = MAX_FIFO_SIZE;
+    U8  dev_resp     [MAX_FIFO_SIZE];
+
+    message = VAPI_AllocateMessage(MAX_FIFO_SIZE);
+    if (!message) {
+        MSPD_ERR("VAPI_AllocateMessage has failed\n");
+        return -1;
+    }
+
+    // NIF_DEFAULT_DEST(0x0703)
+    // portId   Description     Notes
+    //  22      FPP_PORT        rtp0 interface port
+    status = VAPI_SetMessage(message,
+              CMD_CLASS_CONF_DEVICE,
+              CMD_TYPE_CONF_CHANGE,
+                  PKT_DEFAULT_DEST,
+                      4,
+                      Protocol_IPv4,
+                      port_id,
+                      data_msb,
+                      data_lsb);
+
+    if (status)
+        VAPI_REPORT_ACT (status, "Setting NIF_DEFAULT_DEST", goto msg_err);
+
+    status = VAPI_SendDeviceMessage(dev->device_id,
+                (SMsg *)message, NULL,
+                dev_resp, &resp_len);
+    VAPI_REPORT (status, "Setting NIF_DEFAULT_DEST");
+
+msg_err:
+    VAPI_FreeMessage(message);
+
+    return status;
+}
+
+// ----------------------------------------------------------------------------------------------
+// send message to the device to select MSP network interface
+static int
+set_network_interface(mspd_device_t *dev, U8 port_id, U16 data_msb, U16 data_lsb)
+{
+    MSPD_LOG(1, "Selecting MSP network interface %s (%d), msb=%d, lsb=%d\n",
+                "to_do_print_NIF", port_id, data_msb, data_lsb);
+
+    VSTATUS status  = 1;
+    void *message   = NULL;
+    U32 resp_len    = MAX_FIFO_SIZE;
+    U8  dev_resp     [MAX_FIFO_SIZE];
+
+    message = VAPI_AllocateMessage(MAX_FIFO_SIZE);
+    if (!message) {
+        MSPD_ERR("VAPI_AllocateMessage has failed\n");
+        return -1;
+    }
+
+    status = VAPI_SetMessage(message,
+                CMD_CLASS_CONF_DEVICE,
+                CMD_TYPE_CONF_CHANGE,
+                    NIF_SELECT,
+                        3,
+                        port_id,
+                        data_msb,
+                        data_lsb);
+    if (status)
+        VAPI_REPORT_ACT (status, "Setting NIF_SELECT", goto msg_err);
+
+    status = VAPI_SendDeviceMessage(dev->device_id,
+                (SMsg *)message, NULL,
+                dev_resp, &resp_len);
+    VAPI_REPORT (status, "Setting NIF_SELECT");
+
+msg_err:
+    VAPI_FreeMessage(message);
+
+    return status;
+}
+
+// -----------------------------------------------------------------------------------------------
+// initialize network parameters
+static int 
+init_network_params (mspd_device_t *dev)
+{
+    VSTATUS     status = 1;
+    SIpAddrInfo ip_info;
+
+    status = set_network_interface  (dev, NIF_PORT_VED, 0, 0);
+    VAPI_REPORT_ACT (status, "Setting default network interface", return status);
+    status = set_packet_destination (dev, NIF_PORT_NULL, 0, 0);
+    VAPI_REPORT_ACT (status, "Setting default packet destination", return status);
+
+    status = VAPI_SetEthMac(dev->device_id, CMD_LEVEL_DEVICE, (U8 *)dev->mac_dst, (U8 *)dev->mac_src, NULL);
+    VAPI_REPORT_ACT (status, "VAPI_SetEthMac", return status);
+
+    ip_info.ucNumOfSrcIpAddr = 1;
+    ip_info.bIsMultipleMode = 0;
+    ip_info.ucEncapsulation = 2;        // Ethernet Layer
+    ip_info.ucChkSumVerification = 1;   // IP checksum
+    ip_info.auiDevIPAddress[0] = htonl(ast_sockaddr_ipv4(&dev->ipaddr));
+
+    status = VAPI_SetDeviceIPAddr(dev->device_id, &ip_info, NULL);
+    VAPI_REPORT_ACT (status, "VAPI_SetDeviceIPAddr", return status);
+
+    if (mspd_global_is_rtp_ct_mode()) {
+        status = set_network_interface  (dev, NIF_PORT_TDM, 1, 0);
+        VAPI_REPORT_ACT (status, "Setting network interface NIF_PORT_TDM", return status);
+        status = set_packet_destination (dev, NIF_PORT_FPP, 0, 0);
+        VAPI_REPORT_ACT (status, "Setting packet destination NIF_PORT_FPP", return status);
+    }
+
+    return 0;
+}
+
+// -----------------------------------------------------------------------------------------------
+// initialize TDM parameters
+static int 
+init_tdm_bus (mspd_device_t *dev)
+{
+    VSTATUS         status = 1;
+    STdmSetupParams tdm_bus_params;
+
+    memset(&tdm_bus_params, 0, sizeof(tdm_bus_params));
+
+    tdm_bus_params.usMode = 1;      // SINGLE_BUS_MODE
+    tdm_bus_params.usNoOfBus = 1;   // Devices DEV_TYPE_M821XX and DEV_TYPE_M83XXX have single TDM bus
+
+    memcpy (&tdm_bus_params.astTdmBusParam[0], &dev->tdm_params, sizeof(STdmBusParams));
+
+    status = VAPI_SetTDMParams(dev->device_id, &tdm_bus_params, NULL);
+    VAPI_REPORT_ACT (status, "VAPI_SetTDMParams", return status);
+
+    return 0;
+}
+
+// -----------------------------------------------------------------------------------------------
+// release resources etc.
+static void
+cleanup_device (mspd_device_t *dev)
+{
+    VSTATUS status;
+
+    MSPD_LOG(1, "Releasing device %s\n", dev->name);
+
+    MSPD_LOCK(dev->lock, /*ignore*/);
+    /* TODO: revisit this after mspd_channel_t is merged to Asterisk core
+    if (mspd_global.ud_prefs.ud_enable_supvsr)
+        dc_send_disable_ud_cmds_to_msp_device(NULL, dev);
+    */
+
+    if (mspd_global_is_rtp_ct_mode()) {
+	status = set_network_interface (dev, NIF_PORT_VED, 0, 0);
+	VAPI_REPORT(status, "Setting default network interface");
+	status = set_packet_destination (dev, NIF_PORT_NULL, 0, 0);
+	VAPI_REPORT(status, "Setting default packet destination");
+    }
+
+    status = VAPI_CloseDevice(dev->device_id, ePURGE);
+    VAPI_REPORT(status,"VAPI CloseDevice");
+
+    if (dev->name)
+        free(dev->name);
+
+    dev->name = NULL;
+
+    MSPD_UNLOCK(dev->lock);
+    ast_mutex_destroy(&dev->lock);
+}
+
+// -----------------------------------------------------------------------------------------------
+// destroy existing MSP channels/conference/participants (useful if Asterisk was unexpectadly crashed)
+static int
+destroy_all_device_channels(mspd_device_t *dev)
+{
+    VSTATUS status  = 1;
+    void *message   = NULL;
+    U32 resp_len    = MAX_FIFO_SIZE;
+    U8  dev_resp     [MAX_FIFO_SIZE];
+
+    message = VAPI_AllocateMessage(MAX_FIFO_SIZE);
+    if (!message) {
+        MSPD_ERR("VAPI_AllocateMessage has failed\n");
+        return -1;
+    }
+
+    MSPD_DBG("Deleting all MSP channels in device %s\n", dev->name);
+
+    status = VAPI_SetMessage(message,
+                CMD_CLASS_CONF_DEVICE,
+                CMD_TYPE_CONF_CHANGE,
+                    FC_DESTROY_ALL_CHANNEL,
+                        0);
+
+    if (status) {
+        if (option_debug)
+            VAPI_REPORT(status, "Setting FC_DESTROY_ALL_CHANNEL");
+        goto msg_err;
+    }
+
+    status = VAPI_SendDeviceMessage(dev->device_id,
+                (SMsg *)message, NULL,
+                dev_resp, &resp_len);
+
+    if (option_debug)
+        VAPI_REPORT(status, "Destroying all MSP channels");
+
+msg_err:
+    VAPI_FreeMessage(message);
+
+    return status;
+
+}
+
+// -----------------------------------------------------------------------------------------------
+// initialize device
+static int
+init_device (mspd_device_t *dev)
+{
+    MSPD_LOG(1, "Initializing device %s\n", dev->name);
+    MSPD_LOCK(dev->lock, /*ignore*/);
+
+    VSTATUS vstatus = VAPI_OpenDevice(dev->device_id, NULL);
+    VAPI_REPORT_ACT(vstatus,"VAPI OpenDevice", goto bail_out);
+
+    vstatus = VAPI_InitDevice(dev->device_id,
+                VAPI_DEV_OPMODE_DEFAULT,
+                VAPI_DEV_PROF_SPU_FSK_IP_DETECTION,
+                NULL, NULL);
+    VAPI_REPORT_ACT(vstatus,"VAPI InitDevice", goto bail_out);
+
+    MSPD_LOG(2, "Registering callback MSP indication handler\n");
+    VAPI_RegisterEventCallback(dev->device_id, EVENT_LEVEL_GENERIC, vapi_callback);
+    VAPI_REPORT (vstatus, "VAPI dc_producer_vapi registered");
+
+    if (destroy_all_device_channels(dev))
+        MSPD_WARN(5, "MSP Channels were not deleted");
+
+    MSPD_UNLOCK(dev->lock);
+
+    if (init_tdm_bus(dev))                                   goto bail_out_unlocked;
+    if (init_network_params (dev))                           goto bail_out_unlocked;
+    if (mspd_device_set_pcm_law(dev))			     goto bail_out_unlocked;
+    if (mspd_device_set_spu_features_control(dev))           goto bail_out_unlocked;
+    if (setup_signalling_tones())                            goto bail_out_unlocked;
+
+    return 0;
+
+bail_out:
+    MSPD_UNLOCK(dev->lock);
+bail_out_unlocked:
+    cleanup_device(dev);
+    return 1;
+}
+
+// -----------------------------------------------------------------------------------------------
+// Handles [device] configuration
+static int
+config_device (mspd_device_t* dev, struct ast_config *cfg, char *cat)
+{
+    struct ast_variable *v;
+    STdmBusParams   *tdm_params = &dev->tdm_params;
+
+    memset (dev, 0, sizeof (*dev));
+
+    /*default configuration */
+    if (save_strdup (&dev->name, DEF_DEVICE_NAME))
+        return 1;
+
+    ast_parse_arg(DEF_DEVICE_IP_ADDR, PARSE_ADDR, &dev->ipaddr);
+
+    memcpy (dev->mac_src, &HOST_CONTROL_MAC,   6);   // Set default ETH1 MAC address
+    memcpy (dev->mac_dst, &HOST_CONTROL_MAC,   6);
+
+    dev->device_id = DEVICE_ID;
+
+    tdm_params->ucBusId                  = DEF_BUS_ID;
+    tdm_params->ucTxOrder                = DEF_TDM_TX_ORDER;
+    tdm_params->ucRxPolarity             = DEF_TDM_RX_POLARITY;
+    tdm_params->ucTxPolarity             = DEF_TDM_TX_POLARITY;
+    tdm_params->ucRxClkMode              = DEF_TDM_RX_CLOCK_MODE;
+    tdm_params->ucTxClkMode              = DEF_TDM_TX_CLOCK_MODE;
+    tdm_params->ucRxClkEdge              = DEF_TDM_RX_CLOCK_EDGE;
+    tdm_params->ucTxClkEdge              = DEF_TDM_TX_CLOCK_EDGE;
+    tdm_params->ucFrameEdge              = DEF_TDM_FRAME_EDGE;
+    tdm_params->ucInvertedFrmSig         = DEF_TDM_NUMBER_OF_TS;
+    tdm_params->ucInvertedFrmSig         = DEF_TDM_INVERTED_FRAME_SIGNAL;
+    tdm_params->ucBitOrderRcv            = DEF_TDM_BIT_ORDER_RECEIVE;
+    tdm_params->usNumTdmClkCyclesDelayTx = DEF_NUM_TDM_CLK_CYCLES_DELAY_TX;
+    tdm_params->usNumTdmClkCyclesDelayRx = DEF_NUM_TDM_CLK_CYCLES_DELAY_RX;
+
+    MSPD_LOG(2, "Reading device configuration\n");
+
+    if (!mspd_global_get_ipaddr()->len) {
+        MSPD_ERR("Define [global] before [device]\n");
+        return 1;
+    }
+
+    ast_mutex_init (&dev->lock);
+
+    memcpy (dev->mac_src, &HOST_CONTROL_MAC,   6);   // Set default ETH1 MAC address
+    memcpy (dev->mac_dst, &HOST_CONTROL_MAC,   6);
+
+    for (v = ast_variable_browse (cfg, cat); v; v = v->next) {
+        if (!strcasecmp (v->name, "name")) {
+            if (!ast_strlen_zero(v->value))
+                save_strdup (&(dev->name), v->value);
+            else
+                MSPD_WARN(3, "config_device: \"%s\" is empty. Using defaults\n", v->name);
+        }
+        else if (!strcasecmp (v->name, "ipaddr")) {
+            if (ast_parse_arg(v->value, PARSE_ADDR, &dev->ipaddr)) {
+                ast_log(LOG_ERROR, "Invalid address: %s\n", v->value);
+                return 1;
+                }
+        }
+        else if (!strcasecmp (v->name, "srcmac")) {
+            if (ast_parse_mac (dev->mac_src, v))        // Redefine MAC address from config
+                return 1;
+        }
+        else if (!strcasecmp (v->name, "dstmac")) {
+            if (ast_parse_mac (dev->mac_dst, v))
+                return 1;
+        }
+        else if (!strcasecmp (v->name, "tdm_tx_order")) {
+            tdm_params->ucTxOrder = strtoul (v->value, NULL, 0);
+        }
+        else if (!strcasecmp (v->name, "tdm_rx_polarity")) {
+            tdm_params->ucRxPolarity = strtoul (v->value, NULL, 0);
+        }
+        else if (!strcasecmp (v->name, "tdm_tx_polarity")) {
+            tdm_params->ucTxPolarity = strtoul (v->value, NULL, 0);
+        }
+        else if (!strcasecmp (v->name, "tdm_rx_clock_mode")) {
+            tdm_params->ucRxClkMode = strtoul (v->value, NULL, 0);
+        }
+        else if (!strcasecmp (v->name, "tdm_tx_clock_mode")) {
+            tdm_params->ucTxClkMode = strtoul (v->value, NULL, 0);
+        }
+        else if (!strcasecmp (v->name, "tdm_rx_clock_edge")) {
+            tdm_params->ucRxClkEdge = strtoul (v->value, NULL, 0);
+        }
+        else if (!strcasecmp (v->name, "tdm_tx_clock_edge")) {
+            tdm_params->ucTxClkEdge = strtoul (v->value, NULL, 0);
+        }
+        else if (!strcasecmp (v->name, "tdm_frame_edge")) {
+            tdm_params->ucFrameEdge = strtoul (v->value, NULL, 0);
+        }
+        else if (!strcasecmp (v->name, "tdm_number_of_ts")) {
+            tdm_params->usNumOfTS = strtoul (v->value, NULL, 0);
+	}
+        else if (!strcasecmp (v->name, "tdm_inverted_frame_signal")) {
+            tdm_params->ucInvertedFrmSig = strtoul (v->value, NULL, 0);
+        }
+        else if (!strcasecmp (v->name, "tdm_bit_order_rcv")) {
+            tdm_params->ucBitOrderRcv = strtoul (v->value, NULL, 0);
+        }
+        else if (!strcasecmp (v->name, "num_tdm_clk_cycles_delay_tx")) {
+            tdm_params->usNumTdmClkCyclesDelayTx = strtoul (v->value, NULL, 0);
+        }
+        else if (!strcasecmp (v->name, "num_tdm_clk_cycles_delay_rx")) {
+            tdm_params->usNumTdmClkCyclesDelayRx = strtoul (v->value, NULL, 0);
+        }
+        else {
+            MSPD_ERR("Unknown field \"%s\" in [%s]\n", v->name, cat);
+        }
+    }
+
+    if (!dev->name) {
+        MSPD_ERR("Device has no name\n");
+        return 1;
+    }
+
+    if (!dev->ipaddr.len) {
+        MSPD_ERR("Device %s has no IP-address\n", dev->name);
+        return 1;
+    }
+    if (!ast_sockaddr_cmp_addr(&(dev->ipaddr), mspd_global_get_ipaddr())) {
+        MSPD_ERR("Setup is invalid, IP-address of device %s "
+                "is same as global IP-address\n", dev->name);
+        return 1;
+    }
+
+    return 0;
+}
+
+// -----------------------------------------------------------------------------------------------
+// Handles [device] configuration
+int
+mspd_device_config (struct ast_config *cfg, char *cat)
+{
+    mspd_device_t *dev;
+    if(n_devices == MSPD_MAX_DEVICES)
+	MSPD_ERR("Too many devices, limit is %d\n", MSPD_MAX_DEVICES);
+    dev = &devices[n_devices];
+    if(!config_device(dev, cfg, cat) && !init_device(dev)) {
+	n_devices++;
+	return 0;
+    }
+
+    return -1;
+}
+
+void
+mspd_device_cleanup(void)
+{
+    int i;
+    for (i = 0; i < n_devices; i++) {
+        cleanup_device(&devices[i]);
+        n_devices--;
+    }
+}
+
+mspd_device_t*
+mspd_device_find(const char *name)
+{
+    int i;
+    for(i = 0; i < n_devices; i++) {
+	mspd_device_t *dev = &devices[i];
+	if(!strcmp(dev->name, name))
+	    return dev;
+    }
+    return NULL;
+}
+
+const char*
+mspd_device_get_name(const mspd_device_t *dev)
+{
+    return dev->name;
+}
+
+U16 
+mspd_device_get_channel_tag(mspd_device_t *dev)
+{
+    U16 res;
+    MSPD_LOCK(dev->lock, /*ignore*/);
+    res = dev->channel_tag++;
+    MSPD_UNLOCK(dev->lock);
+    return res;
+}
+
+U16
+mspd_device_get_channel_id(mspd_device_t *dev)
+{
+    U16 res;
+    MSPD_LOCK(dev->lock, /*ignore*/);
+    res = dev->channel_id++;
+    MSPD_UNLOCK(dev->lock);
+    return res;
+}
+
+U32
+mspd_device_get_id(const mspd_device_t *dev)
+{
+    return dev->device_id;
+}
+
+const struct ast_sockaddr*
+mspd_device_get_ipaddr(const mspd_device_t *dev)
+{
+    return &dev->ipaddr;
+}
+
+U16
+mspd_device_get_conference_id(mspd_device_t *dev)
+{
+    U16 res;
+    MSPD_LOCK(dev->lock, /*ignore*/);
+    res = dev->conference_id++;
+    MSPD_UNLOCK(dev->lock);
+    return res;
+}
+
+// --------------------------------------------------------------------------------------------
+// Sends Enable/Disable traces command to MSP.
+// this function will be called only when ud_enable is set globally
+int
+mspd_device_send_ud_cmd (const mspd_device_t *dev,
+            	    	     U16 func_code,
+            	    	     Boolean enable)
+{
+    VSTATUS status  = 1;
+    void *message   = NULL;
+    U32 resp_len    = MAX_FIFO_SIZE;
+    U8  dev_resp     [MAX_FIFO_SIZE];
+    char colored_buf [80];
+
+    message = VAPI_AllocateMessage(MAX_FIFO_SIZE);
+    if (!message) {
+        MSPD_ERR("VAPI_AllocateMessage has failed\n");
+        return -1;
+    }
+
+    status = VAPI_SetMessage(message,
+                CMD_CLASS_OPEN_DIAG,
+                CMD_TYPE_DIAG_MON_LIVE_CTRL,
+                func_code,
+                1,
+                enable);
+    if (status)
+        VAPI_REPORT_ACT (status, "Setting UD command", goto msg_err);
+
+    status = VAPI_SendDeviceMessage(dev->device_id,
+            (SMsg *)message, NULL,
+                dev_resp, &resp_len);
+
+    if(status) {
+        term_color(colored_buf, "FAILED", COLOR_RED, 0, sizeof (colored_buf));
+
+        MSPD_ERR("%s UD option %-18s (0x%04X) for device %s %s (0x%x)\n",
+                enable ? "Enabling" : "Disabling",
+                mspd_lookup_msg_id(func_code), func_code,
+                dev->name, colored_buf, status);
+        goto msg_err;
+    }
+    term_color(colored_buf, enable ? "enabled" : "disabled",
+            COLOR_GREEN, 0, sizeof (colored_buf));
+    MSPD_LOG(4, "UD option %-18s (0x%04X) for device=%s [%s]\n",
+            mspd_lookup_msg_id(func_code), func_code,
+            dev->name, colored_buf);
+msg_err:
+    VAPI_FreeMessage(message);
+
+    return status;
+}
+
+/* TODO: remove this interface.
+ * Only lookup by name interface should be left.
+ * Currently this interface is present due to workarounnds in
+ * code that uses it.
+ */
+mspd_device_t*
+mspd_device_find_by_index(unsigned index)
+{
+    return &devices[index];
+}
+
+int
+mspd_device_send_redirection_cmd (const struct ast_sockaddr* ud_dest_ipaddr, U16* enable_error)
+{
+    static int send_redirect_cmd = 0;
+
+    if (send_redirect_cmd) {
+        MSPD_LOG(5, "UD redirection cmd (%d) already enabled\n", send_redirect_cmd);
+        return 0;
+    }
+
+    VSTATUS status  = 1;
+    void *message   = NULL;
+    U32 resp_len    = MAX_FIFO_SIZE;
+    U8  dev_resp     [MAX_FIFO_SIZE];
+
+    mspd_device_t *dev = &devices[0];
+    uint8_t const * const src_mac = dev->mac_src;
+    uint8_t const * const dst_mac = dev->mac_dst;
+
+    message = VAPI_AllocateMessage(MAX_FIFO_SIZE);
+    if (!message) {
+        MSPD_ERR("VAPI_AllocateMessage has failed\n");
+        return -1;
+    }
+
+    status = VAPI_SetMessage(message,
+                       CMD_CLASS_CONF_DEVICE,
+                       CMD_TYPE_CONF_CHANGE,
+                           NIF_SELECT,
+                               3,
+                               0x0011,
+                               0x0000,
+                               0x0000);
+    if (status)
+        VAPI_REPORT_ACT (status, "Setting NIF_SELECT", goto msg_err);
+
+
+    status = VAPI_SendDeviceMessage(dev->device_id,
+               (SMsg *)message, NULL,
+               dev_resp, &resp_len);
+    VAPI_REPORT_ACT (status, "Sending NIF_SELECT", goto msg_err);
+    VAPI_FreeMessage(message);
+
+    message = VAPI_AllocateMessage(MAX_FIFO_SIZE);
+    if (!message) {
+        MSPD_ERR("VAPI_AllocateMessage has failed\n");
+        return -1;
+    }
+    status = VAPI_SetMessage(message,
+                        CMD_CLASS_OPEN_DIAG,
+                        CMD_TYPE_DIAG_CONFIG,
+                            FC_REDIRECT_CSM_UDP,
+                                17,
+                                0x0004,
+                                dst_mac[0] | (dst_mac[1] << 8),
+                                dst_mac[2] | (dst_mac[3] << 8),
+                                dst_mac[4] | (dst_mac[5] << 8),
+                                src_mac[0] | (src_mac[1] << 8),
+                                src_mac[2] | (src_mac[3] << 8),
+                                src_mac[4] | (src_mac[5] << 8),
+                                0x0008,
+                                0x0045,
+                                0x0040,
+                                0x1180,
+                                (ast_sockaddr_ipv4(&(dev->ipaddr)) & 0xffff),
+                                (ast_sockaddr_ipv4(&(dev->ipaddr)) >> 16),
+                                (ast_sockaddr_ipv4(ud_dest_ipaddr) & 0xffff),
+                                (ast_sockaddr_ipv4(ud_dest_ipaddr) >> 16),
+                                0x1000,
+                                0x2000);
+    if (status)
+        VAPI_REPORT_ACT (status, "Setting FC_REDIRECT_CSM_UDP", goto msg_err);
+
+    status = VAPI_SendDeviceMessage(dev->device_id,
+                   (SMsg *)message, NULL,
+                   dev_resp, &resp_len);
+    VAPI_REPORT (status, "UD-redirection CSMEncaps over IP");
+
+    if(status) {
+        *enable_error = 1; // yes acked with error
+        goto msg_err;
+    }
+    send_redirect_cmd++;
+    MSPD_LOG(4, "Unified Diagnostics Redirection Enabled (%d)\n", send_redirect_cmd);
+
+msg_err:
+    VAPI_FreeMessage(message);
+
+    return status;
+}
+
+// -----------------------------------------------------------------------------------------------
+int
+mspd_device_set_next_channel_on_acp (mspd_device_t *dev)
+{
+    VSTATUS status  = 1;
+    void *message   = NULL;
+    U32 resp_len    = MAX_FIFO_SIZE;
+    U8  dev_resp     [MAX_FIFO_SIZE];
+
+    message = VAPI_AllocateMessage(MAX_FIFO_SIZE);
+    if (!message) {
+        MSPD_ERR("VAPI_AllocateMessage has failed\n");
+        return -1;
+    }
+
+    status = VAPI_SetMessage(message,
+                CMD_CLASS_CONF_DEVICE,
+                CMD_TYPE_CONF_CHANGE,
+                    FC_SUPVSR_NEXT_VOIP_CHAN_ON_ACP,
+                        0);
+
+    if (status)
+            VAPI_REPORT_ACT (status, "Setting NEXT_VOIP_CHAN_ON_ACP", goto msg_err);
+
+    status = VAPI_SendDeviceMessage(dev->device_id,
+                (SMsg *)message, NULL,
+                dev_resp, &resp_len);
+    VAPI_REPORT_ACT (status, "Sending NEXT_VOIP_CHAN_ON_ACP", goto msg_err);
+
+msg_err:
+    VAPI_FreeMessage(message);
+
+    return status;
+}
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/main/mspd/global.c asterisk-1.8.2.3.new/main/mspd/global.c
--- asterisk-1.8.2.3/main/mspd/global.c	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/main/mspd/global.c	2011-12-26 21:48:28.000000000 +0530
@@ -0,0 +1,185 @@
+#include "asterisk.h"
+
+#include <vapi/vapi.h> 
+#include <vapi/comcerto-api-defs.h> 
+#include <vapi/gtl.h>
+
+#include "asterisk/lock.h"
+#include "asterisk/utils.h"
+#include "asterisk/rtp_engine.h" 
+#include "asterisk/lock.h" 
+#include "asterisk/logger.h" 
+#include "asterisk/pbx.h" 
+#include "asterisk/options.h" 
+#include "asterisk/features.h" 
+#include "asterisk/term.h" 
+#include "asterisk/sched.h" 
+#include "asterisk/mspd/macro.h"
+#include "asterisk/mspd/common.h"
+#include "asterisk/mspd/defaults.h"
+#include "asterisk/mspd/utils.h"
+#include "asterisk/mspd/global.h"
+
+static struct ast_sockaddr ipaddr;
+static ECType ec_type = EC_TYPE_STD;
+// According to CRM AMR-WB 6.60 is default (param5 = 0x0001)
+static U8 bitrate_amr = amr12_2;
+static U8 bitrate_amr_wb = amrwb23_85;
+static mspd_fax_mode_t fax_mode = MSPD_FAXMODE_AUTO;
+static Boolean wideband = False;
+static Boolean ntt_callerid = False;
+static Boolean rtp_ct_mode = False;
+static mspd_bwe_t rsp_bwe;
+
+const struct ast_sockaddr* mspd_global_get_ipaddr(void)
+{
+    return &ipaddr;
+}
+
+ECType mspd_global_get_ec_type(void)
+{
+    return ec_type;
+}
+
+/* TODO: change code to remove this interface */
+void mspd_global_set_ec_type(ECType t)
+{
+    ec_type = t;
+}
+
+U8 mspd_global_get_bitrate_amr(void)
+{
+    return bitrate_amr;
+}
+
+U8 mspd_global_get_bitrate_amr_wb(void)
+{
+    return bitrate_amr_wb;
+}
+
+mspd_fax_mode_t mspd_global_get_fax_mode(void)
+{
+    return fax_mode;
+}
+
+Boolean mspd_global_get_wideband(void)
+{
+    return wideband;
+}
+
+Boolean mspd_global_is_rtp_ct_mode(void)
+{
+    return rtp_ct_mode;
+}
+
+Boolean mspd_global_get_ntt_callerid(void)
+{
+    return ntt_callerid;
+}
+
+mspd_bwe_t *mspd_global_get_rsp_bwe(void)
+{
+    return &rsp_bwe;
+}
+
+struct fax_mode_desc {
+    mspd_fax_mode_t 	type;
+    char* 		desc;
+} fax_mode_descs[] = {{MSPD_FAXMODE_AUTO, "auto"}, 
+		      {MSPD_FAXMODE_T38, "t38"},
+		      {MSPD_FAXMODE_PASSTHRU, "passthru"}};
+
+char* mspd_global_fax_mode_to_string(mspd_fax_mode_t type)
+{
+	unsigned i;
+	for (i = 0; i < sizeof(fax_mode_descs)/sizeof(struct fax_mode_desc); i++) {
+		if (fax_mode_descs[i].type == type)
+			return fax_mode_descs[i].desc;
+	}
+	MSPD_ASSERT(0); // programming error
+	return NULL;
+}
+
+static mspd_fax_mode_t fax_mode_from_string(const char* desc)
+{
+	unsigned i;
+	for (i = 0; i < sizeof(fax_mode_descs)/sizeof(struct fax_mode_desc); i++) {
+		if (!strcasecmp(fax_mode_descs[i].desc, desc))
+			return fax_mode_descs[i].type;
+	}
+	return -1;
+}
+
+// -----------------------------------------------------------------------------------------------
+// Handles [global] configuration
+int
+mspd_global_config (struct ast_config *cfg, char *cat)
+{
+    ast_parse_arg(DEF_GLOBAL_IP_ADDR, PARSE_ADDR, &ipaddr);
+
+    struct ast_variable *v;
+    for (v = ast_variable_browse (cfg, cat); v; v = v->next) {
+        if (!strcasecmp (v->name, "ipaddr")) {
+            if (ast_parse_arg(v->value, PARSE_ADDR, &ipaddr)) {
+                ast_log(LOG_ERROR, "Invalid address: %s\n", v->value);
+                MSPD_ERR ("ast_sockaddr_parse: parsing error (%s) mask %d, addr %p\n",
+                        v->value, PARSE_ADDR, &ipaddr);
+                return 1;
+            }
+        } else if (!strcasecmp(v->name, "ec_type")) {
+                if(!strcasecmp(v->value, "DFEC"))
+                    ec_type = EC_TYPE_DFEC;
+                else {
+                    if(!strcasecmp(v->value, "EC"))
+                        ec_type = EC_TYPE_STD;
+		}
+        }
+        else if (!strcasecmp(v->name, "bitrate_amr")) {
+            bitrate_amr = strtoul (v->value, NULL, 0);
+        }
+        else if (!strcasecmp(v->name, "bitrate_amr_wb")) {
+            bitrate_amr_wb = strtoul (v->value, NULL, 0);
+        }
+        else if (!strcasecmp(v->name, "fax_mode")) {
+		fax_mode = fax_mode_from_string(v->value);
+		if (fax_mode == -1) {
+            		MSPD_ERR ("Wrong fax mode supplied '%s'\n",
+                	            v->value);
+			fax_mode = MSPD_FAXMODE_AUTO;
+		}
+        }
+        else if (!strcasecmp(v->name, "ntt_callerid")) {
+            ntt_callerid = ast_true(v->value) ? True : False;
+        }
+        else if (!strcasecmp(v->name, "wideband")) {
+            wideband = ast_true(v->value) ? True : False;
+        }
+        else if (!strcasecmp(v->name, "rtpcutthru_mode")) {
+            rtp_ct_mode = ast_true(v->value) ? True : False;
+        }
+        else if(!strcasecmp(v->name, "rsp_bwe_master")) {
+            rsp_bwe.bwe_master = ast_true(v->value) ? True : False;
+        }
+        else if (!strcasecmp (v->name, "rsp_bwe_high_band")) {
+            rsp_bwe.bwe_high_band = strtoul (v->value, NULL, 0);
+        }
+        else if (!strcasecmp (v->name, "rsp_bwe_low_band")) {
+            rsp_bwe.bwe_low_band = strtoul (v->value, NULL, 0);
+        }
+    }
+
+    if (!bitrate_amr ||
+         bitrate_amr > amr12_2)
+         bitrate_amr = amr12_2;
+
+    if (!bitrate_amr_wb ||
+         bitrate_amr_wb > amrwb23_85)
+         bitrate_amr_wb = amrwb23_85;
+
+    if (rsp_bwe.bwe_high_band > BWE_HIGH_BAND_MAX)
+        rsp_bwe.bwe_high_band = BWE_HIGH_BAND_MAX;
+    if (rsp_bwe.bwe_low_band > BWE_LOW_BAND_MAX)
+        rsp_bwe.bwe_low_band = BWE_LOW_BAND_MAX;
+
+    return 0;
+}
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/main/mspd/mspd.c asterisk-1.8.2.3.new/main/mspd/mspd.c
--- asterisk-1.8.2.3/main/mspd/mspd.c	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/main/mspd/mspd.c	2012-02-06 20:03:08.000000000 +0530
@@ -0,0 +1,127 @@
+#include "asterisk.h"
+
+#include <vapi/vapi.h> 
+#include <vapi/comcerto-api-defs.h> 
+#include <vapi/gtl.h>
+
+#include "asterisk/lock.h"
+#include "asterisk/utils.h"
+#include "asterisk/rtp_engine.h" 
+#include "asterisk/lock.h" 
+#include "asterisk/logger.h" 
+#include "asterisk/pbx.h" 
+#include "asterisk/options.h" 
+#include "asterisk/features.h" 
+#include "asterisk/term.h" 
+#include "asterisk/sched.h" 
+#include "asterisk/cli.h"
+#include "asterisk/mspd/macro.h"
+#include "asterisk/mspd/common.h"
+#include "asterisk/mspd/defaults.h"
+#include "asterisk/mspd/utils.h"
+#include "asterisk/mspd/device.h"
+#include "asterisk/mspd/mspd.h"
+#include "asterisk/mspd/global.h"
+#include "asterisk/mspd/channel.h"
+
+// TODO: read from MSPD.conf or VAPI.conf or use internally defined Default conf
+// TODO: return a pointer to a struct
+static void 
+set_vapi_config (SCSMEUsrData *vapi_gtl_dev_conf) 
+{
+    vapi_gtl_dev_conf->pvNext             = NULL;       // Pointer to the next device struct
+    vapi_gtl_dev_conf->usControlInterface = eCSM_ITF;   // Type of Data struct in pvNext
+
+    vapi_gtl_dev_conf->uiDevId   = DEVICE_ID;           // Device Id
+    vapi_gtl_dev_conf->uiVersion = 0;                   // Version Info
+    vapi_gtl_dev_conf->eDevMode  = eMASTER;             // eMASTER or eSLAVE
+    vapi_gtl_dev_conf->ucDevType = DEV_TYPE_M83XXX;     // Both DEV_TYPE_M821XX and DEV_TYPE_M83XXX are compatible
+    vapi_gtl_dev_conf->bUseDefaultMaxChnls = True;      // 1 = device default, 0 = custom
+    vapi_gtl_dev_conf->usMaxChannels = 0;               // Ignored if bUseDefaultMaxChnls = 1
+
+        /*Interface Specific info */
+    memcpy (vapi_gtl_dev_conf->aucDevMac,  &DEVICE_CONTROL_MAC, 6);     // Device MAC Address
+    memcpy (vapi_gtl_dev_conf->aucHostMac, &HOST_CONTROL_MAC,   6);     // Host MAC Address (used in MAAS ASSIGN only for CSME Slave)
+    vapi_gtl_dev_conf->pucEthDevName = (char *)HOST_CONTROL_INTERFACE;  // Interface name on which communication with device is takin place eg ETH0 or ETH1
+    vapi_gtl_dev_conf->ucIsAckReqd   = 1;                               // 1 = ACK is required
+
+    memcpy (vapi_gtl_dev_conf->aucDevHardMac, &DEVICE_HARD_MAC, 6);     // Device preconfigured M823XX MAC Address
+    vapi_gtl_dev_conf->ucEthBootMode = 0;                               // define the ethernet boot mode for slave device (M823XX only)
+                                                                        // 0 : Backward compatible mode (default)
+                                                                        // 1 : Standard mode
+                                                                        // 2 : Alternate mode
+}
+
+static int
+config_load(void)
+{
+    struct ast_config *cfg;
+    char *cat = NULL;
+    int rc = 0;
+
+    struct ast_flags config_flags = { 0 };
+
+    if (!(cfg = ast_config_load (MSPD_CONFIG_FILE, config_flags)) || cfg == CONFIG_STATUS_FILEINVALID) {
+        MSPD_ERR("Unable to load config \"%s\"\n", MSPD_CONFIG_FILE);
+        return -1;
+    } else if (cfg == CONFIG_STATUS_FILEUNCHANGED)
+        return 0;
+
+    MSPD_LOG(2, "Reading the config file %s\n", MSPD_CONFIG_FILE);
+
+    while ((cat = ast_category_browse (cfg, cat))) {
+        if (!strcasecmp (cat, "global"))
+            rc += mspd_global_config(cfg, cat);
+        else if (!strcasecmp (cat, "device"))
+            rc += mspd_device_config(cfg, cat);
+    }
+    ast_config_destroy (cfg);
+
+    return rc;
+}
+
+static struct ast_cli_entry cli_mspd[] = {
+    AST_CLI_DEFINE(mspd_channel_cli_send_cmd,  "Sends a user command to the MSP"),
+};
+
+int
+mspd_init(void)
+{
+    VSTATUS vstatus = 0xFF;
+    SCSMEUsrData vapi_gtl_dev_config;
+
+    set_vapi_config (&vapi_gtl_dev_config);
+    vstatus = VAPI_Init(&vapi_gtl_dev_config);
+    VAPI_REPORT_ACT (vstatus, "VAPI_Init", return -1);
+
+    MSPD_LOG(5, "VAPI version is %s\n", VAPI_GetVersion());
+
+    if(config_load()) {
+        MSPD_ERR("MSP device configuration/initialization failed\n");
+        goto ERR;
+    }
+
+    if(ast_cli_register_multiple(cli_mspd, ARRAY_LEN(cli_mspd))) {
+        MSPD_ERR("Some CLI commands are not registered\n");
+        goto ERR;
+    }
+
+    return 0;
+
+ERR:
+    vstatus = VAPI_Close();
+    VAPI_REPORT(vstatus, "VAPI_Close");
+
+    return -1;
+}
+
+void
+mspd_cleanup(void)
+{
+    VSTATUS vstatus = 0xFF;
+
+    mspd_device_cleanup();
+
+    vstatus = VAPI_Close();
+    VAPI_REPORT(vstatus, "VAPI_Close");
+}
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/main/mspd/queue.c asterisk-1.8.2.3.new/main/mspd/queue.c
--- asterisk-1.8.2.3/main/mspd/queue.c	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/main/mspd/queue.c	2011-05-12 16:51:36.000000000 +0530
@@ -0,0 +1,144 @@
+/*
+ * Mindspeed Comcerto Channel module.
+ *
+ *  Copyright (C) 2004 - 2011 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+ // ===============================================================================================
+// Includes
+
+#include "asterisk.h"
+
+//ASTERISK_FILE_VERSION(__FILE__, "$Revision: 1.2 $")
+
+#include <stdlib.h>
+
+#include "asterisk/mspd/queue.h"
+#include "asterisk/mspd/defaults.h"
+#include "asterisk/mspd/macro.h"
+
+#include "asterisk/lock.h"
+#include <asterisk/logger.h>
+#include <asterisk/options.h>
+
+// ===============================================================================================
+// Local functions
+
+queue_t *
+mspd_queue_create (size_t queue_size)
+{
+   queue_t *q = malloc(sizeof(queue_t) + queue_size * sizeof(queue_item_t));
+    if (!q)
+        return NULL;
+
+    q->queue_size = queue_size;
+    q->last = q->buf + (queue_size - 1);
+    q->n_items = 0;
+    q->head = q->buf;
+    q->tail = q->buf;
+
+    ast_mutex_init(&q->mutex);
+    ast_cond_init(&q->is_not_empty, NULL);
+    memset(q->buf, 0, queue_size * sizeof(queue_item_t));
+    return q;
+}
+
+// -----------------------------------------------------------------------------------------------
+void
+mspd_queue_destroy (queue_t *queue)
+{
+    ast_cond_destroy(&queue->is_not_empty);
+    ast_mutex_destroy(&queue->mutex);
+    free(queue);
+}
+
+// -----------------------------------------------------------------------------------------------
+void
+mspd_queue_stop (queue_t *queue)
+{
+    while (queue->n_items >= queue->queue_size)
+        usleep(100);
+    while (mspd_queue_put(queue, QUEUE_STOP_ITEM))
+    ;
+}
+
+// -----------------------------------------------------------------------------------------------
+// should only be called before any "real" items were put
+int
+mspd_queue_start (queue_t *queue)
+{
+    return (queue->n_items > 0) || mspd_queue_put(queue, QUEUE_START_ITEM);
+}
+
+// -----------------------------------------------------------------------------------------------
+int
+mspd_queue_put (queue_t *queue, queue_item_t item)
+{
+    *queue->tail = item;
+    if (ast_mutex_lock(&queue->mutex)) {
+        MSPD_ERR("%s: unable to obtain lock\n", __func__);
+        return 1;
+    }
+    if (queue->n_items >= queue->queue_size) {
+        ast_mutex_unlock(&queue->mutex);
+        MSPD_ERR("%s: no room in queue\n", __func__);
+        return 1;
+    }
+    ++queue->n_items;
+    //pthread_cond_signal(&queue->is_not_empty);
+    ast_cond_signal(&queue->is_not_empty);
+    ast_mutex_unlock(&queue->mutex);
+    if (queue->tail++ == queue->last)
+        queue->tail = queue->buf;
+    return 0;
+}
+
+// -----------------------------------------------------------------------------------------------
+queue_item_t
+mspd_queue_get (queue_t *queue)
+{
+    queue_item_t item;
+
+    if (ast_mutex_lock(&queue->mutex)) {
+        MSPD_ERR("%s: unable to obtain lock\n", __func__);
+        return (queue_item_t){.vItem = NULL};
+    }
+    while (queue->n_items == 0) {
+        int rc;
+        while ((rc = ast_cond_wait(&queue->is_not_empty, &queue->mutex)) != 0) {
+            if (rc != EINTR) {
+                ast_mutex_unlock(&queue->mutex);
+                MSPD_ERR("%s: cond-wait returned %d\n", __func__, rc);
+                return (queue_item_t){.vItem = NULL};
+            }
+        }
+    }
+    item = *queue->head;
+    --queue->n_items;
+    ast_mutex_unlock(&queue->mutex);
+    if (queue->head++ == queue->last)
+        queue->head = queue->buf;
+    return item;
+}
+
+// -----------------------------------------------------------------------------------------------
+inline tempo_queue_element_t *
+mspd_queue_get_tempo (queue_t *queue)
+{
+    queue_item_t const item = mspd_queue_get(queue);
+    return item.tempo;
+}
+
+// -----------------------------------------------------------------------------------------------
+inline vapi_queue_element_t *
+mspd_queue_get_vItem (queue_t *queue)
+{
+    queue_item_t const item = mspd_queue_get(queue);
+    return item.vItem;
+}
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/main/mspd/rtp.c asterisk-1.8.2.3.new/main/mspd/rtp.c
--- asterisk-1.8.2.3/main/mspd/rtp.c	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/main/mspd/rtp.c	2011-08-12 19:14:28.000000000 +0530
@@ -0,0 +1,78 @@
+/*
+ * Mindspeed Comcerto Channel module.
+ *
+ *  Copyright (C) 2004 - 2011 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+// ===============================================================================================
+// Includes
+
+#include "asterisk.h"
+
+//ASTERISK_FILE_VERSION(__FILE__, "$Revision: 1.2 $")
+
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+
+#include "asterisk/mspd/macro.h"
+#include "asterisk/mspd/global.h"
+#include "asterisk/mspd/device.h"
+#include "asterisk/mspd/rtp.h"
+
+#include "asterisk/rtp_engine.h"
+
+// ===============================================================================================
+// RTP helper
+
+// -----------------------------------------------------------------------------------------------
+// allocate an ast_rtp structure for internal RTP traffic, i.e. Asterisk<-RTP->MSP to
+// record/playback from/to channel
+//
+// the following setup is generated:
+//
+//    rtp.us   = [mspd_global.ipaddr]:[allocated-port]
+//    rtp.peer =        [dev->ipaddr]:[allocated-port - 10000]
+
+struct ast_rtp_instance *
+mspd_rtp_allocate_new (mspd_device_t *dev)
+{
+    struct ast_rtp_instance *instance = NULL;
+    struct ast_sockaddr bindaddr_tmp;
+
+    ast_sockaddr_copy(&bindaddr_tmp, mspd_global_get_ipaddr());
+
+    if (!(instance = ast_rtp_instance_new("asterisk", NULL, &bindaddr_tmp, NULL, 1))) {
+        MSPD_ERR("(%s): failed to allocate RTP instanse\n", mspd_device_get_name(dev));
+        return NULL;
+    }
+    ast_rtp_codecs_payloads_default(ast_rtp_instance_get_codecs(instance), instance);
+    
+    struct ast_sockaddr us, peer;
+    ast_rtp_instance_get_local_address(instance, &us);
+
+    int port = ast_sockaddr_port(&us);
+    port -= 10000;
+
+    ast_sockaddr_copy(&peer, mspd_device_get_ipaddr(dev));
+    ast_sockaddr_set_port (&peer, port);
+    ast_rtp_instance_set_remote_address (instance, &peer);
+
+    ast_rtp_instance_get_remote_address (instance, &peer);
+    ast_rtp_instance_get_local_address(instance, &us);
+
+    if (option_verbose > 2) {
+        ast_verbose("(%s): New RTP allocated: us=%s,", mspd_device_get_name(dev),
+            ast_sockaddr_stringify (&us));
+        ast_verbose("peer=%s\n",
+            ast_sockaddr_stringify (&peer));
+    }
+
+    return instance;
+}
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/main/mspd/utils.c asterisk-1.8.2.3.new/main/mspd/utils.c
--- asterisk-1.8.2.3/main/mspd/utils.c	1970-01-01 05:30:00.000000000 +0530
+++ asterisk-1.8.2.3.new/main/mspd/utils.c	2011-10-24 16:54:46.000000000 +0530
@@ -0,0 +1,1185 @@
+/*
+ * Mindspeed Comcerto Channel module.
+ *
+ *  Copyright (C) 2004 - 2011 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+ // ===============================================================================================
+// Includes
+
+#include "asterisk.h"
+
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+
+#include <vapi/vapi.h>
+#include <vapi/comcerto-api-defs.h>
+
+#include "asterisk/mspd/common.h"
+#include "asterisk/mspd/utils.h"
+#include "asterisk/mspd/macro.h"
+
+#include <asterisk/options.h>
+#include <asterisk/logger.h>
+#include <asterisk/term.h>
+
+
+// -----------------------------------------------------------------------------------------------
+// Function-code, command class & type, default number of parameters
+// ATTENTION! KEEP TABLES SORTED ASCENDING BY FUNC_CODE!
+
+command_map_t const command_map[] = {
+//  { SUPVSR_READY                          ,   0                       ,  -1},
+//  { IRM_AVAILABLE                         ,   CMD_ENABLE_DIAG_CONF    ,   2},
+//  { IRM_SPUCONVTABLE                      ,   0                       ,  -1},
+    { DIAG_REPORTCMD                        ,   CMD_ENABLE_DIAG_CONF    ,   2},
+    { DIAG_TDM_RX                           ,   CMD_ENABLE_DIAG_CONF    ,   1},
+    { DIAG_TDM_TX                           ,   CMD_ENABLE_DIAG_CONF    ,   1},
+    { DIAG_SPU_IOPARAMS                     ,   CMD_ENABLE_DIAG_CONF    ,   1},
+    { DIAG_SPU_INSTREAM                     ,   CMD_ENABLE_DIAG_CONF    ,   1},
+    { DIAG_SPU_OUTSTREAM                    ,   CMD_ENABLE_DIAG_CONF    ,   1},
+    { DIAG_DSP_TASK_IOPARAMS                ,   CMD_ENABLE_DIAG_CONF    ,   1},
+    { DIAG_CSME_MCP_TRACE                   ,   CMD_ENABLE_DIAG_CONF    ,   1},
+    { DIAG_DSP_TOMIXER                      ,   CMD_ENABLE_DIAG_CONF    ,   1},
+    { DIAG_DSP_FROMMIXER                    ,   CMD_ENABLE_DIAG_CONF    ,   1},
+    { DIAG_REPORTALLCMD                     ,   CMD_ENABLE_DIAG_CONF    ,   2},
+    { DIAG_REPORTCMD                        ,   CMD_ENABLE_DIAG_CONF    ,   2},
+    { DIAG_PACKET_RX                        ,   CMD_ENABLE_DIAG_CONF    ,   2},
+    { DIAG_PACKET_TX                        ,   CMD_ENABLE_DIAG_CONF    ,   2},
+    { FC_REDIRECT_CSM                       ,   CMD_OPEN_DIAG           ,   8},
+    { FC_REDIRECT_CSM_UDP                   ,   CMD_OPEN_DIAG           ,  22},
+//  { FC_CNDDETSP                           ,   0                       ,  -1},
+    { FC_DESTROY_ALL_CHANNEL                ,   CMD_DEV_CONF            ,   0},
+    { FC_SUPVSR_CREATE_CHANNEL              ,   CMD_DEV_CONF            ,   2},
+    { FC_SUPVSR_DESTROY_CHANNEL             ,   CMD_DEV_CONF            ,   1},
+    { FC_SPU_FEATURES_CONTROL               ,   CMD_DEV_CONF            ,   1},
+//  { FC_SUPVSR_GET_ARM_CODE_VERSION        ,   0                       ,  -1},
+//  { FC_SUPVSR_GET_SPU_CODE_VERSION        ,   0                       ,  -1},
+//  { FC_SUPVSR_RUN_CHECKSUM                ,   0                       ,  -1},
+    { FC_SUPVSR_GET_DEVICE_TYPE             ,   0                       ,   2},
+//  { SET_TSA                               ,   0                       ,  -1},
+//  { RESET_INDICATION                      ,   0                       ,  -1},
+//  { DIAG_DISCARDED                        ,   0                       ,  -1},
+//  { DIAG_CMD_TRACE                        ,   0                       ,  -1},
+    { FC_SET_ETH_HDR                        ,   CMD_DEV_CONF            ,   8},
+//  { GET_ETH_HDR                           ,   0                       ,  -1},
+//  { SET_RTO                               ,   0                       ,  -1},
+//  { ETH_SERVICE_CONFIG                    ,   0                       ,  -1},
+//  { ARP_SERVICE_CONFIG                    ,   CMD_DEV_CONF            ,   1},
+//  { SPECIALPKT_HANDLING_SERVICE_CONFIG    ,   0                       ,  -1},
+//  { SPECIALPKT_HANDLING_INDICATION_ETH    ,   0                       ,  -1},
+//  { SPECIALPKT_HANDLING_GEN_ETH           ,   0                       ,  -1},
+//  { CSME_MULTI_CMD                        ,   0                       ,  -1},
+//  { SPECIALPKT_HANDLING_INDICATION_IP     ,   0                       ,  -1},
+//  { SPECIALPKT_HANDLING_GEN_IPOAAL5       ,   0                       ,  -1},
+//  { SET_IP_HDR_DEVICE                     ,   0                       ,  -1},
+//  { GET_IP_HDR_DEVICE                     ,   0                       ,  -1},
+    { FC_IP_SERVICE_CONFIG                  ,   CMD_DEV_CONF            ,   1},
+    { FC_IP_ADDRESS                         ,   CMD_DEV_CONF            ,   2},
+//  { ICMP_SERVICE_CONFIG                   ,   0                       ,  -1},
+//  { ICMP_INDICATION                       ,   0                       ,  -1},
+//  { IP_OPTIONS                            ,   0                       ,  -1},
+//  { IP_REDIRECT_OPTIONS_CFG               ,   0                       ,  -1},
+//  { IP_REDIRECT_INIT_SESSION              ,   0                       ,  -1},
+//  { IP_REDIRECT_SET_LAYER3_HDR            ,   0                       ,  -1},
+//  { IP_REDIRECT_SET_LAYER2_HDR            ,   0                       ,  -1},
+//  { IP_REDIRECT_SRCHDRCHG_IND             ,   0                       ,  -1},
+    { FC_TDM_ENABLE_BUS                     ,   CMD_DEV_CONF            ,   1},
+//  { LATENCY_LEVEL                         ,   0                       ,  -1},
+    { FC_SUPVSR_SETUP_TDM_PARAMS            ,   CMD_DEV_CONF            ,   4},
+//  { EXT_CLOCK_STATUS                      ,   0                       ,  -1},
+//  { RUN_VBE                               ,   0                       ,  -1},
+//  { VBE_RESULT                            ,   0                       ,  -1},
+//  { SUPVSR_GET_DEVICE_VERSION             ,   0                       ,  -1},
+//  { SUPVSR_GET_ARM_CLK                    ,   0                       ,  -1},
+//  { SUPVSR_GET_SPU_CLK                    ,   0                       ,  -1},
+    { FC_TDM_SELECT_BUS_MODE                ,   CMD_DEV_CONF            ,   1},
+    { FC_SET_PASSTHRU_AUTOSWITCH            ,   CMD_CHAN_CONF           ,   1},
+    { FC_SUPVSR_SET_PCM_LAW                 ,   CMD_DEV_CONF            ,   1},
+//  { STANDBY_CONFIG                        ,   0                       ,  -1},
+//  { DEVICE_SET_COUNTRY_CODE               ,   0                       ,  -1},
+//  { CP_SET_COUNTRY_CODE_PARAMS            ,   0                       ,  -1},
+//  { SUPVSR_SET_TS_MODE                    ,   0                       ,  -1},
+//  { SET_ALT_HDR_DEVICE                    ,   0                       ,  -1},
+//  { PORT_SELECT                           ,   0                       ,  -1},
+    { NIF_SELECT                            ,   CMD_DEV_CONF            ,   3},
+//  { NIF_DEFAULT_DEST                      ,   0                       ,  -1},
+    { PKT_DEFAULT_DEST                      ,   CMD_DEV_CONF            ,   4},
+    { PKT_RULE_CONFIG                       ,   CMD_DEV_CONF            ,  13},
+//  { DIAG_TDM_RX                           ,   0                       ,  -1},
+//  { DIAG_TDM_TX                           ,   0                       ,  -1},
+//  { IUUP_QUERY_BASICDIAG                  ,   0                       ,  -1},
+    { FC_VOIP_VOPENA                        ,   CMD_CHAN_CONF           ,   1},
+    { FC_VOIP_VCEOPT                        ,   CMD_CHAN_CONF           ,   1},
+    { FC_VOIP_DTMFOPT                       ,   CMD_CHAN_CONF           ,   1},
+    { FC_VOIP_DGAIN                         ,   CMD_CHAN_CONF           ,   2},
+    { FC_VOIP_ECHOCAN                       ,   CMD_CHAN_CONF           ,   1},
+    { FC_FAXOPT                             ,   CMD_CHAN_CONF           ,   2},
+    { FC_FOIP_FAXSPLOPT                     ,   CMD_CHAN_CONF           ,   1},
+//  { FC_IUUPOAAL2_RPPH                     ,   0                       ,  -1},
+    { VOIP_ECGAIN                           ,   CMD_CHAN_CONF           ,   1},
+    { FC_VOIP_TONEGEN                       ,   CMD_CHAN_CONF           ,  16},
+    { FC_VOIP_TONEOPT                       ,   CMD_CHAN_CONF           ,   1},
+//  { VOIP_SSRCFILT                         ,   0                       ,  -1},
+//  { VOIP_RTPSUPP                          ,   0                       ,  -1},
+//  { VOIP_RTCPSTAT                         ,   0                       ,  -1},
+//  { VOIP_TONEDET                          ,   0                       ,  -1},
+//  { VOIP_SSRCCHG                          ,   0                       ,  -1},
+//  { VOIP_PTCHNG                           ,   0                       ,  -1},
+//  { VOIP_TCMPLT                           ,   0                       ,  -1},
+//  { FAXSTATE                              ,   0                       ,  -1},
+    { FC_VOIP_LOOPBACK                      ,   CMD_CHAN_CONF           ,   2},
+    { FC_VOIP_TONEOFF                       ,   CMD_CHAN_CONF           ,   1},
+//  { VOIP_EVENTDET                         ,   0                       ,  -1},
+    { FC_VOIP_PTMNG                         ,   CMD_CHAN_CONF           ,  26},
+//  { VOIP_SEQREST                          ,   0                       ,  -1},
+//  { VOIP_VINFOTMR                         ,   0                       ,  -1},
+//  { FINFOTMR                              ,   0                       ,  -1},
+//  { VOIP_VINFOIND                         ,   0                       ,  -1},
+//  { FINFOIND                              ,   0                       ,  -1},
+//  { VOIP_SENDNTE                          ,   0                       ,  -1},
+//  { VOIP_NTECMPLT                         ,   0                       ,  -1},
+//  { VOIP_NTERCVD                          ,   0                       ,  -1},
+    { FC_VOIP_DTMFDPAR                      ,   CMD_CHAN_CONF           ,   3},
+//  { FAXLVL                                ,   0                       ,  -1},
+//  { VOIP_SSRCVIOL                         ,   0                       ,  -1},
+//  { VOIP_SS7COT                           ,   0                       ,  -1},
+    { FC_VOIP_PTSET                         ,   CMD_CHAN_CONF           ,   1},
+//  { VOIP_PTMNGRXOVR                       ,   0                       ,  -1},
+//  { VOIP_PTSETRXOVR                       ,   0                       ,  -1},
+    { FC_VOIP_PTSETRXOVR                    ,   CMD_CHAN_CONF           ,   1},
+//  { FAXPAGESTAT                           ,   0                       ,  -1},
+//  { VOIP_DTMFTUNE                         ,   0                       ,  -1},
+    { FC_CND_ONHOOK_GEN                     ,   CMD_CHAN_CONF           ,  19},
+    { FC_CND_SET_PARAMS                     ,   CMD_CHAN_CONF           ,  34},
+    { FC_CND_OFFHOOK_GEN                    ,   CMD_CHAN_CONF           ,  18},
+    { FC_CND_STOP                           ,   CMD_CHAN_CONF           ,   0},
+    { FC_CND_DONE                           ,   CMD_CHAN_CONF           ,   1},
+//  { VCEFEC                                ,   0                       ,  -1},
+//  { CIPHER_AES_OPT                        ,   0                       ,  -1},
+//  { CIPHER_NDES_OPT                       ,   0                       ,  -1},
+//  { CIPHER_RC4_OPT                        ,   0                       ,  -1},
+//  { CIPHER_MMH_OPT                        ,   0                       ,  -1},
+//  { CIPHER_HMAC_OPT                       ,   0                       ,  -1},
+    { FC_VOIP_TONECTRL                      ,   CMD_CHAN_CONF           ,   1},
+    { FC_VOIP_REMDET                        ,   CMD_CHAN_CONF           ,   2},
+//  { VOIP_SIGDET                           ,   0                       ,  -1},
+//  { VOIP_PROGRAM_TONE_ENGINE              ,   0                       ,  -1},
+//  { VOIP_PROGRAM_CADENCE_ENGINE           ,   0                       ,  -1},
+    { FC_VOIP_INDCTRL                       ,   CMD_CHAN_CONF           ,   1},
+    { FC_EC_CONTROL                         ,   CMD_CHAN_CONF           ,   2},
+//  { VOIP_TONE_RELAY_OPTION                ,   0                       ,  -1},
+    { FC_VOIP_DIGITSTRGEN                   ,   CMD_CHAN_CONF           ,  10},
+//  { CNDONDTMFGEN                          ,   0                       ,  -1},
+//  { CNDONDTMFSTOP                         ,   0                       ,  -1},
+//  { CNDONDTMFTUNE                         ,   0                       ,  -1},
+//  { CNDONDTMFDONE                         ,   0                       ,  -1},
+//  { RTCP_ENA                              ,   0                       ,  -1},
+//  { RTCP_SDES_CNAME                       ,   0                       ,  -1},
+//  { RTCP_IND_SR                           ,   0                       ,  -1},
+//  { RTCP_IND_RR                           ,   0                       ,  -1},
+//  { RTCP_IND_SDES_CNAME                   ,   0                       ,  -1},
+//  { RTCP_IND_BYE                          ,   0                       ,  -1},
+//  { RTCP_APP                              ,   0                       ,  -1},
+//  { RTCP_IND_                             ,   0                       ,  -1},
+//  { RTCP_NTP_TIMESTAMP                    ,   0                       ,  -1},
+//  { RTCP_PACKET_GENERATION_GRANULARITY    ,   0                       ,  -1},
+//  { CNDRXMSG                              ,   0                       ,  -1},
+//  { VOCODER_STATUS                        ,   0                       ,  -1},
+//  { VOIP_CDMA_MODES                       ,   0                       ,  -1},
+//  { CNDDETCTL                             ,   0                       ,  -1},
+//  { VOIP_AGCSET                           ,   0                       ,  -1},
+    { FC_AEC_CONTROL                        ,   CMD_CHAN_CONF           ,   4},
+//  { DIAG_TDM                              ,   0                       ,  -1},
+    { BWE_SET                               ,   CMD_CHAN_CONF           ,   2},
+//  { VOIP_SRCHDRCHNG                       ,   0                       ,  -1},
+    { FC_SET_IP_HDR_CHANNEL                 ,   CMD_CHAN_CONF           ,  15},
+//  { GET_IP_HDR_CHANNEL                    ,   0                       ,  -1},
+    { FC_SET_ETH_HDR_CHAN                   ,   CMD_CHAN_CONF           ,   8},
+//  { SET_ALT_HDR_CHANNEL                   ,   0                       ,  -1},
+    { FC_THC_REDIRECT_RX                    ,   CMD_CHAN_CONF           ,   1},
+    { FC_THC_MODE_ENABLE                    ,   CMD_CHAN_CONF           ,   0},
+//  { THC_GEN_PKT                           ,   CMD_CHAN_CONF           ,   1},
+//  { SET_SPI_TDM_BUS                       ,   0                       ,  -1},
+//  { SET_SPI_TDM_INTERRUPT                 ,   0                       ,  -1},
+//  { ENABLE_SPI_TDM                        ,   0                       ,  -1},
+//  { WRITE_TO_SPI                          ,   0                       ,  -1},
+//  { READ_FROM_SPI                         ,   0                       ,  -1},
+//  { EVENT_INDICATION_FROM_SPI             ,   0                       ,  -1},
+//  { EVENT_PROCESS_DONE_TO_SPI             ,   0                       ,  -1},
+    { FC_CONF_CREATE_CONFERENCE             ,   CMD_DEV_CONF            ,   1},
+    { FC_CONF_DESTROY_CONFERENCE            ,   CMD_DEV_CONF            ,   1},
+    { FC_CONF_CREATE_PARTICIPANT            ,   CMD_DEV_CONF            ,   3},
+    { FC_CONF_DESTROY_PARTICIPANT           ,   CMD_DEV_CONF            ,   2},
+    { FC_CONF_MUTE_PARTICIPANT              ,   CMD_DEV_CONF            ,   3},
+    { FC_CONF_PUT_PARTICIPANT_ON_HOLD       ,   CMD_DEV_CONF            ,   4},
+//  { CONF_SPECIFY_DOMINANT_TALKERS         ,   0                       ,  -1},
+//  { MDIO_BUS_WRITE                        ,   0                       ,  -1},
+//  { MDIO_BUS_READ                         ,   0                       ,  -1},
+    { FC_VOIP_SET_CHANNEL_MODE              ,   CMD_CHAN_CONF           ,   3},
+//  { MIRO_SYNCDAT                          ,   CMD_CHAN_CONF           ,   2},
+//  { MIRO_SYNCEOF                          ,   CMD_CHAN_CONF           ,   2},
+//  { SET_FLOWCON                           ,   0                       ,  -1},
+//  { VOIP_DRAIN_PLAYREC_BUFFER             ,   CMD_CHAN_CONF           ,   1},
+    { FC_SUPVSR_NEXT_VOIP_CHAN_ON_ACP       ,   CMD_DEV_CONF            ,   1}
+};
+
+// -----------------------------------------------------------------------------------------------
+// code -> text tables (for error messages & verbose outputs)
+//
+// ATTENTION! KEEP TABLES SORTED ASCENDING BY CODE!
+// (if you use uppercase hex-characters for new entrys a lexical sort does the trick)
+
+// functions & indications
+code2text_t const mspd_functions_table[] = {
+    {0x0000, "SUPVSR_READY"},
+    {0x0001, "REDIRECT_OVER_CSM_ENCAPS"},
+    {0x0002, "IRM_SPUCONVTABLE"},
+    {0x0004, "REDIRECT_OVER_CSM_ENCAPS_OVER_IP_UDP"},
+    {0x000B, "CNDDETSP"},
+    {0x0010, "SUPVSR_CREATE_CHANNEL"},
+    {0x0011, "SUPVSR_DESTROY_CHANNEL"},
+    {0x0013, "SPU_FEATURES_CONTROL"},
+    {0x0021, "SUPVSR_GET_ARM_CODE_VERSION"},
+    {0x0022, "SUPVSR_GET_SPU_CODE_VERSION"},
+    {0x0023, "SUPVSR_RUN_CHECKSUM"},
+    {0x0031, "SUPVSR_GET_DEVICE_TYPE"},
+    {0x0036, "SET_TSA"},
+    {0x00EC, "DIAG_REPORTALLCMD"},
+    {0x00EE, "RESET_INDICATION"},
+    {0x00EF, "DIAG_DISCARDED"},
+    {0x00FB, "DIAG_CMD_TRACE"},
+    {0x0100, "SET_ETH_HDR"},
+    {0x0101, "GET_ETH_HDR"},
+    {0x0103, "SET_RTO"},
+    {0x0104, "ETH_SERVICE_CONFIG"},
+    {0x0105, "ARP_SERVICE_CONFIG"},
+    {0x0107, "SPECIALPKT_HANDLING_SERVICE_CONFIG"},
+    {0x0108, "SPECIALPKT_HANDLING_INDICATION_ETH"},
+    {0x0109, "SPECIALPKT_HANDLING_GEN_ETH"},
+    {0x010A, "CSME_MULTI_CMD"},
+    {0x010B, "SPECIALPKT_HANDLING_INDICATION_IP"},
+    {0x010C, "SPECIALPKT_HANDLING_GEN_IPOAAL5"},
+    {0x010F, "IP_ADDRESS_TABLE"},
+    {0x0200, "PUI_MODE"},
+    {0x0201, "PUI_MASTER_CONTROL"},
+    {0x0203, "ATM_SERVICE_CONFIG"},
+    {0x0204, "AAL2_SERVICE_CONFIG"},
+    {0x0205, "AAL5_SERVICE_CONFIG"},
+    {0x0206, "AAL5_OPTIONS"},
+    {0x0207, "OPTIPHY_CONFIG"},
+    {0x0208, "OPTIPHY_LOOPBACK"},
+    {0x0209, "POS_SERVICE_CONFIG"},
+    {0x020f, "AAL2_SETUP_PROFILE"},
+    {0x0210, "AAL5_PACKET_DETECTION_OPTIONS"},
+    {0x0300, "SET_IP_HDR_DEVICE"},
+    {0x0301, "GET_IP_HDR_DEVICE"},
+    {0x0302, "IP_SERVICE_CONFIG"},
+    {0x0303, "IP_ADDRESS"},
+    {0x0304, "ICMP_SERVICE_CONFIG"},
+    {0x0305, "ICMP_INDICATION"},
+    {0x0306, "IP_OPTIONS"},
+    {0x0307, "IP_REDIRECT_OPTIONS_CFG"},
+    {0x0308, "IP_REDIRECT_INIT_SESSION"},
+    {0x0309, "IP_REDIRECT_SET_LAYER3_HDR"},
+    {0x030A, "IP_REDIRECT_SET_LAYER2_HDR"},
+    {0x030B, "IP_REDIRECT_SRCHDRCHG_IND"},
+    {0x0405, "TDM_ENABLE_BUS"},
+    {0x0406, "LATENCY_LEVEL"},
+    {0x0407, "SUPVSR_SETUP_TDM_PARAMS"},
+    {0x0408, "EXT_CLOCK_STATUS"},
+    {0x040D, "RUN_VBE"},
+    {0x040E, "VBE_RESULT"},
+    {0x0410, "SUPVSR_GET_DEVICE_VERSION"},
+    {0x0411, "SUPVSR_GET_ARM_CLK"},
+    {0x0412, "SUPVSR_GET_SPU_CLK"},
+    {0x0417, "TDM_SELECT_BUS_MODE"},
+    {0x0419, "STANDBY_CONFIG"},
+    {0x041B, "DEVICE_SET_COUNTRY_CODE"},
+    {0x041C, "CP_SET_COUNTRY_CODE_PARAMS"},
+    {0x0424, "SUPVSR_SET_TS_MODE"},
+    {0x0425, "SUPVSR_SET_PCM_LAW"},
+    {0x0500, "SET_ALT_HDR_DEVICE"},
+    {0x0700, "PORT_SELECT"},
+    {0x0701, "NIF_SELECT"},
+    {0x0702, "NIF_DEFAULT_DEST"},
+    {0x0703, "PKT_DEFAULT_DEST"},
+    {0x0706, "PKT_RULE_CONFIG"},
+    {0x0E00, "DIAG_TDM_RX"},
+    {0x0E01, "DIAG_TDM_TX"},
+    {0x0802, "DIAG_PKT_RX"},
+    {0x0803, "DIAG_PKT_TX"},
+    {0x1010, "DIAG_SPU_IOPARAMS"},
+    {0x1011, "DIAG_SPU_INSTREAM"},
+    {0x1012, "DIAG_SPU_OUTSTREAM"},
+    {0x70FF, "IUUP_QUERY_BASICDIAG"},
+    {0x8000, "VOIP_VOPENA"},
+    {0x8001, "VOIP_VCEOPT"},
+    {0x8002, "VOIP_DTMFOPT"},
+    {0x8003, "FAXOPT"},
+    {0x8004, "FAXQUAL"},
+    {0x8005, "VOIP_DGAIN"},
+    {0x8006, "VOIP_ECHOCAN"},
+    {0x8007, "VOIP_RPPH"},
+    {0x8008, "VOIP_ECGAIN"},
+    {0x8009, "VOIP_TONEGEN"},
+    {0x806C, "VOIP_TONEOPT"},
+    {0x800A, "VOIP_SSRCFILT"},
+    {0x800B, "VOIP_RTPSUPP"},
+    {0x800C, "VOIP_RTCPSTAT"},
+    {0x800D, "VOIP_TONEDET"},
+    {0x800E, "VOIP_SSRCCHG"},
+    {0x800F, "VOIP_PTCHNG"},
+    {0x8010, "VOIP_TCMPLT"},
+    {0x8011, "FAXSTATE"},
+    {0x8012, "VOIP_LOOPBACK"},
+    {0x8014, "VOIP_TONEOFF"},
+    {0x8017, "VOIP_EVENTDET"},
+    {0x8018, "VOIP_PTMNG"},
+    {0x8019, "VOIP_SEQREST"},
+    {0x801A, "VOIP_VINFOTMR"},
+    {0x801B, "FINFOTMR"},
+    {0x801C, "VOIP_VINFOIND"},
+    {0x801D, "FINFOIND"},
+    {0x801E, "VOIP_SENDNTE"},
+    {0x801F, "VOIP_NTECMPLT"},
+    {0x8020, "VOIP_NTERCVD"},
+    {0x8021, "VOIP_DTMFDPAR"},
+    {0x8026, "FAXLVL"},
+    {0x8027, "VOIP_SSRCVIOL"},
+    {0x8029, "VOIP_SS7COT"},
+    {0x802B, "VOIP_PTSET"},
+    {0x802C, "VOIP_PTMNGRXOVR"},
+    {0x802D, "VOIP_PTSETRXOVR"},
+    {0x8032, "FAXPAGESTAT"},
+    {0x8034, "VOIP_DTMFTUNE"},
+    {0x8039, "CND_ONHOOK_GEN"},
+    {0x803A, "CND_SET_PARAMS"},
+    {0x803B, "CND_OFFHOOK_GEN"},
+    {0x803C, "CND_STOP"},
+    {0x803D, "CND_DONE"},
+    {0x803F, "VCEFEC"},
+    {0x8046, "CIPHER_AES_OPT"},
+    {0x8047, "CIPHER_NDES_OPT"},
+    {0x8048, "CIPHER_RC4_OPT"},
+    {0x8049, "CIPHER_MMH_OPT"},
+    {0x804A, "CIPHER_HMAC_OPT"},
+    {0x805B, "VOIP_TONECTRL"},
+    {0x805C, "VOIP_REMDET"},
+    {0x805D, "VOIP_SIGDET"},
+    {0x80BF, "PASSTHRU_AUTOSWITCH_IND"},
+    {0x806D, "IP_TONEDET"},
+    {0x806E, "VOIP_PROGRAM_TONE_ENGINE"},
+    {0x806F, "VOIP_PROGRAM_CADENCE_ENGINE"},
+    {0x8084, "VOIP_INDCTRL"},
+    {0x8085, "FOIP_FAXSPLOPT"},
+    {0x8091, "EC_CONTROL"},
+    {0x8092, "VOIP_TONE_RELAY_OPTION"},
+    {0x8093, "CNDONDTMFGEN"},
+    {0x8094, "CNDONDTMFSTOP"},
+    {0x8095, "CNDONDTMFTUNE"},
+    {0x8096, "CNDONDTMFDONE"},
+    {0x80A0, "RTCP_ENA"},
+    {0x80A1, "RTCP_SDES_CNAME"},
+    {0x80A5, "RTCP_IND_SR"},
+    {0x80A6, "RTCP_IND_RR"},
+    {0x80A7, "RTCP_IND_SDES_CNAME"},
+    {0x80A8, "RTCP_IND_BYE"},
+    {0x80A9, "RTCP_APP"},
+    {0x80AA, "RTCP_IND_"},
+    {0x80AB, "RTCP_NTP_TIMESTAMP"},
+    {0x80AC, "RTCP_PACKET_GENERATION_GRANULARITY"},
+    {0x80AD, "CNDRXMSG"},
+    {0x80AF, "VOCODER_STATUS"},
+    {0x80B0, "VOIP_CDMA_MODES"},
+    {0x80B1, "CNDDETCTL"},
+    {0x80D1, "VOIP_AGCSET"},
+    {0x80E5, "AEC_CONTROL"},
+    {0x80F0, "DIAG_TDM"},
+    {0x8700, "VOIP_SRCHDRCHNG"},
+    {0x9000, "SET_IP_HDR_CHANNEL"},
+    {0x9001, "GET_IP_HDR_CHANNEL"},
+    {0x9010, "SET_ETH_HDR_CHAN"},
+    {0x9020, "SET_ALT_HDR_CHANNEL"},
+    {0x9200, "THC_REDIRECT_RX"},
+    {0x9201, "THC_MODE_ENABLE"},
+    {0x9202, "THC_GEN_PKT"},
+    {0x9300, "SET_SPI_TDM_BUS"},
+    {0x9301, "SET_SPI_TDM_INTERRUPT"},
+    {0x9302, "ENABLE_SPI_TDM"},
+    {0x9303, "WRITE_TO_SPI"},
+    {0x9304, "READ_FROM_SPI"},
+    {0x9305, "EVENT_INDICATION_FROM_SPI"},
+    {0x9306, "EVENT_PROCESS_DONE_TO_SPI"},
+    {0x9310, "CONF_CREATE_CONFERENCE"},
+    {0x9311, "CONF_DESTROY_CONFERENCE"},
+    {0x9312, "CONF_CREATE_PARTICIPANT"},
+    {0x9313, "CONF_DESTROY_PARTICIPANT"},
+    {0x9314, "CONF_MUTE_PARTICIPANT"},
+    {0x9315, "CONF_PUT_PARTICIPANT_ON_HOLD"},
+    {0x9316, "CONF_SPECIFY_DOMINANT_TALKERS"},
+    {0x9330, "MDIO_BUS_WRITE"},
+    {0x9331, "MDIO_BUS_READ"},
+    {0x9400, "VOIP_SET_CHANNEL_MODE"},
+    {0x9402, "SYNCDAT"},
+    {0x9403, "SYNCEOF"},
+    {0x9404, "SET_FLOWCON"},
+    {0x9405, "VOIP_DRAIN_PLAYREC_BUFFER"},
+    {0x9406, "VOIP_DRAIN_PLAYREC_BUFFER_IND"},
+    {0x80BE, "SET_PASSTHRU_AUTOSWITCH"}
+};
+
+// -----------------------------------------------------------------------------------------------
+// error array
+code2text_t const mspd_errors_table[] = {
+    {0x0000, "CNF_OK"},
+    {0x0001, "CNF_ERROR_UNSPEC"},
+    {0x0002, "CNF_ERROR_RTPHEADER"},
+    {0x0003, "CNF_ERROR_PT"},
+    {0x0004, "CNF_ERROR_EXTENC"},
+    {0x0005, "CNF_ERROR_HARDRST"},
+    {0x0006, "CNF_ERROR_DOWNLOAD"},
+    {0x0007, "CNF_ERROR_CODECI"},
+    {0x0008, "CNF_ERROR_NEWC"},
+    {0x0009, "CNF_ERROR_ECINIT"},
+    {0x000A, "CNF_ERROR_ENCAPS"},
+    {0x000B, "CNF_ERROR_G727"},
+    {0x000C, "CNF_ERROR_TDTINI"},
+    {0x000D, "CNF_ERROR_TDRINI"},
+    {0x000E, "CNF_ERROR_VOPUNDEF"},
+    {0x0010, "CNF_ERROR_FNOTSUPP"},
+    {0x0011, "CNF_ERROR_FNOSSRC"},
+    {0x0012, "CNF_ERROR_FREDSSRC"},
+    {0x0013, "CNF_ERROR_FNOROOM"},
+    {0x0014, "CNF_ERROR_FDUP"},
+    {0x0015, "CNF_ERROR_FVAD"},
+    {0x0016, "CNF_ERROR_FAUTO"},
+    {0x0017, "CNF_ERROR_REDFORK"},
+    {0x0020, "CNF_ERROR_VOPENA_NOIPCLIENT"},
+    {0x0021, "CNF_ERROR_VOPENA_REG_RTP_NO_IPLAYER"},
+    {0x0022, "CNF_ERROR_VOPENA_REG_RTP_NO_LOWERLAYER"},
+    {0x0023, "CNF_ERROR_VOPENA_REG_RTP_NO_MORECLIENTS"},
+    {0x0024, "CNF_ERROR_VOPENA_REG_RTP_DUPLICATION"},
+    {0x0025, "CNF_ERROR_VOPENA_REG_RTCP_NO_IPLAYER"},
+    {0x0026, "CNF_ERROR_VOPENA_REG_RTCP_NO_LOWERLAYER"},
+    {0x0027, "CNF_ERROR_VOPENA_REG_RTCP_NO_MORECLIENTS"},
+    {0x0028, "CNF_ERROR_VOPENA_REG_RTCP_DUPLICATION"},
+    {0x002B, "CNF_ERROR_VCEOPT_NOIPCLIENT"},
+    {0x002C, "CNF_ERROR_VCEOPT_NOETHCLIENT"},
+    {0x002D, "CNF_ERROR_VOPENA_PACKET_LEN"},
+    {0x002E, "CNF_ERROR_FIFO_LEN"},
+    {0x002F, "CNF_ERROR_PARAM_OUT_OF_RANGE"},
+    {0x0030, "CNF_ERROR_PARAM2_OUT_OF_RANGE"},
+    {0x0031, "CNF_ERROR_FOPENA_REGISSUE_FOIP_INDEX"},
+    {0x0032, "CNF_ERROR_IPV4_DEREG"},
+    {0x0033, "CNF_ERROR_PARAM_INVALID_VALUE"},
+    {0x0040, "CNF_ERR_TDM_MODE_NOT_FOURBUS"},
+    {0x0041, "CNF_ERR_TDM_BUS_OUT_OF_RANGE_FOURBUS_MODE"},
+    {0x0042, "CNF_ERR_TDM_BUS_OUT_OF_RANGE_TWOBUS_MODE"},
+    {0x0043, "CNF_ERR_TDM_BUS_OUT_OF_RANGE_ONEBUS_MODE"},
+    {0x0044, "CNF_ERR_TDM_CONFIG_PARMS_FAILED_FOURBUS_MODE_OLD"},
+    {0x0045, "CNF_ERR_TDM_CONFIG_PARMS_FAILED_FOURBUS_MODE_NEW"},
+    {0x0046, "CNF_ERR_TDM_CONFIG_PARMS_FAILED_TWOBUS_MODE"},
+    {0x0047, "CNF_ERR_TDM_CONFIG_PARMS_FAILED_ONEBUS_MODE"},
+    {0x0048, "CNF_ERR_TDM_PARAMS_INVALID_BUS_MODE"},
+    {0x0049, "CNF_ERR_TDM_SELECT_INVALID_BUS_MODE"},
+    {0x004A, "CNF_ERR_TDM_INVALID_CMD_LEN"},
+    {0x004B, "CNF_ERR_TDM_CONFIG_PARMS_FAILED_SETUP_MULT_INSTANCE"},
+    {0x004C, "CNF_ERR_TDM_CONFIG_PARMS_FAILED_SELECT_MULT_INSTANCE"},
+    {0x004D, "CNF_ERR_TSDRIVE_INVALID_CMD_LEN"},
+    {0x004E, "CNF_ERR_TSDRIVE_INVALID_PARAM"},
+    {0x004F, "CNF_ERR_TSDRIVE_CHAN_ALREADY_CREATED"},
+    {0x0050, "CNF_ERR_SPI_NOT_CHAGALL"},
+    {0x0051, "CNF_ERR_SPI_ENQUEUE_READ_CMD_FAILED"},
+    {0x0052, "CNF_ERR_SPI_ENQUEUE_WRITE_CMD_FAILED"},
+    {0x0053, "CNF_ERR_SPI_BUS_OUT_OF_RANGE"},
+    {0x0054, "CNF_ERR_SPI_INCORRECT_BUS_MODE"},
+    {0x0055, "CNF_ERR_SPI_IRQSIZE_ZERO"},
+    {0x0056, "CNF_ERR_SPI_IRQSIZE_TOO_LARGE"},
+    {0x0057, "CNF_ERR_SPI_IRQSIZE_NOT_SUBMULTIPLE"},
+    {0x0058, "CNF_ERR_SPI_TDM_RELEASE_FAILED"},
+    {0x0059, "CNF_ERR_SPI_TDM_GRAB_FAILED"},
+    {0x005A, "CNF_ERR_SPI_TDM_QUEUE_INIT_FAILED"},
+    {0x005B, "CNF_ERR_SPI_TASK_CREATION_FAILED"},
+    {0x005C, "CNF_ERR_TSDRIVE_INVALID_FOR_MIRO"},
+    {0x0060, "CNF_ERR_THC_MIRO_DEVICE"},
+    {0x0061, "CNF_ERR_THC_CHAN_NOT_ACTIVE"},
+    {0x0062, "CNF_ERR_THC_CHAN_NOT_G711"},
+    {0x0063, "CNF_ERR_THC_NOT_THC"},
+    {0x0064, "CNF_ERR_THC_PEER_CHAN_NULL"},
+    {0x0065, "CNF_ERR_THC_NOT_SAME_CPU"},
+    {0x0066, "CNF_ERR_THC_NOT_SAME_CODING"},
+    {0x0067, "CNF_ERR_THC_HAIRPIN_NULL"},
+    {0x0068, "CNF_ERR_THC_CMD_INVALID_FOR_THC"},
+    {0x0069, "CNF_ERR_PASSTHRU"},
+    {0x006A, "CNF_ERR_CRBT_VCEOPT_INVALID_PARAM"},
+    {0x006B, "CNF_ERR_COMPLEX_CADENCE_ENGINE_FORMAT_ERROR"},
+    {0x006C, "CNF_ERR_TONEGEN_CURRENTLY_RUNNING"},
+    {0x0102, "CNF_ERROR_CID_RANGE"},
+    {0x0103, "CNF_ERROR_NO_VPIVCI"},
+    {0x0104, "CNF_ERROR_PHY_NUMBER"},
+    {0x0105, "CNF_ERROR_VOICE_FT"},
+    {0x0106, "CNF_ERROR_SILENCE_FT"},
+    {0x0107, "CNF_ERROR_CPS_REG"},
+    {0x0108, "CNF_ERROR_CPS_REG_CID_OUT_OF_RANGE"},
+    {0x0109, "CNF_ERROR_CPS_REG_INVALID_VPIVCI"},
+    {0x010A, "CNF_ERROR_CPS_REG_VCC_OUT_OF_RANGE"},
+    {0x010B, "CNF_ERROR_CPS_REG_VCC_USED"},
+    {0x010C, "CNF_ERROR_CPS_REG_VCC_MISMATCH"},
+    {0x010D, "CNF_ERROR_CPS_REG_CID_USED"},
+    {0x010E, "CNF_ERROR_CPS_REG_NO_CPS_LAYER"},
+    {0x010F, "CNF_ERROR_CPS_REG_ATM_RT_REG"},
+    {0x0110, "CNF_ERROR_CPS_REG_INVALID_VCC"},
+    {0x0111, "CNF_ERROR_CPS_DEREG"},
+    {0x0112, "CNF_ERROR_CPS_PACKET_LEN"},
+    {0x0120, "CNF_ERROR_UNSUPPORTED_PROFILE"},
+    {0x0121, "CNF_ERROR_EMPTY_PROFILE"},
+    {0x0122, "CNF_ERROR_AAL2_ACTIVE"},
+    {0x0123, "CNF_ERROR_PROFILE_TYPE"},
+    {0x0124, "CNF_ERROR_PROFILE_SIZE"},
+    {0x0125, "CNF_ERROR_PROFILE_USED"},
+    {0x0126, "CNF_ERROR_INVALID_VOICE_FT"},
+    {0x0127, "CNF_ERROR_INVALID_UUI"},
+    {0x0128, "CNF_ERROR_INVALID_LI"},
+    {0x0129, "CNF_ERROR_PROFILE_CONFLICT"},
+    {0x012A, "CNF_ERROR_CPS_MSGLEN"},
+    {0x012B, "CNF_ERROR_CPS_NOMEM"},
+    {0x012C, "CNF_ERROR_CPS_NOCLIENT"},
+    {0x012D, "CNF_ERROR_CPS_MODE"},
+    {0x012E, "CNF_ERROR_CPS_TOO_MANY_CLIENT"},
+    {0x012F, "CNF_ERROR_CPS_TIMER"},
+    {0x0130, "CNF_ERROR_FEATURE_NOTKEYED"},
+    {0x0202, "CNF_ERROR_ATM_REGISTRATION"},
+    {0x0203, "CNF_ERROR_ATM_LAYER_DOWN"},
+    {0x0204, "CNF_ERROR_N_VALUE"},
+    {0x0205, "CNF_ERROR_AUTO_VPI_VCI"},
+    {0x0206, "CNF_ERROR_LEN_MSG"},
+    {0x0207, "CNF_ERROR_ATM_DEREGISTRATION"},
+    {0x0208, "CNF_ERROR_AAL1_UNKNOWN_FUNC"},
+    {0x0209, "CNF_ERROR_AAL1_VOICE_INACTIVE"},
+    {0x020A, "CNF_ERROR_AAL1_TONEOFF"},
+    {0x020B, "CNF_ERROR_AAL1_CADENCE"},
+    {0x020C, "CNF_ERROR_AAL1_FREQ"},
+    {0x020D, "CNF_ERROR_AAL1_TONEGEN"},
+    {0x020E, "CNF_ERROR_AAL1_GAIN"},
+    {0x020F, "CNF_ERROR_AAL1_TAILLEN"},
+    {0x0210, "CNF_ERROR_AAL1_MODE"},
+    {0x0211, "CNF_ERROR_AAL1_LB_ICHAN_SWITCH"},
+    {0x0212, "CNF_ERROR_AAL1_LB_SELF"},
+    {0x0213, "CNF_ERROR_AAL1_LB_POST_ONTHEFLY"},
+    {0x0214, "CNF_ERROR_AAL1_LB_ICHAN_ONTHEFLY"},
+    {0x0215, "CNF_ERROR_AAL1_LB_ICHAN_SELF"},
+    {0x0216, "CNF_ERROR_AAL1_LB_ONTHEFLY"},
+    {0x0217, "CNF_ERROR_AAL1_LB_NO_DEST"},
+    {0x0218, "CNF_ERROR_AAL1_LB_NOT_IMPLEMENTED"},
+    {0x0219, "CNF_ERROR_AAL1_LB_NO_FPGA"},
+    {0x0302, "CNF_ERROR_CCS_CID_RANGE"},
+    {0x0303, "CNF_ERROR_CCS_AUTO_VPI_VCI"},
+    {0x0304, "CNF_ERROR_ON_INIT_CHANNEL"},
+    {0x0305, "CNF_ERROR_CCS_LEN_MSG"},
+    {0x0306, "CNF_ERROR_CCS_CPS_REG"},
+    {0x0307, "CNF_ERROR_CCS_MSG_NOT_SENT"},
+    {0x0308, "CNF_ERROR_CCS_UNKNOWN_FUNC"},
+    {0x0309, "CNF_ERROR_CCS_CHAN_ENABLED"},
+    {0x0402, "CNF_ERROR_CDMA_MSG_LEN"},
+    {0x0403, "CNF_ERROR_CDMA_PHY_NUMBER"},
+    {0x0404, "CNF_ERROR_CDMA_VOICE_FT"},
+    {0x0405, "CNF_ERROR_CDMA_GPS_OFFSET"},
+    {0x0406, "CNF_ERROR_CDMA_MODE_OF_OPERATION"},
+    {0x0407, "CNF_ERROR_CDMA_DATA_SERVICE_RATE"},
+    {0x0408, "CNF_ERROR_CDMA_GPS_SYNC_SERVICE_DOWN"},
+    {0x0409, "CNF_ERROR_CDMA_DESCRIPTOR"},
+    {0x040A, "CNF_ERROR_CDMA_AAL5_REG_SERVICE_DOWN"},
+    {0x040B, "CNF_ERROR_CDMA_AAL5_REG_MAX_CLIENTS"},
+    {0x040C, "CNF_ERROR_CDMA_AAL5_REG_ALLOC_CLIENT"},
+    {0x040D, "CNF_ERROR_CDMA_AAL5_REG_ATM_REGISTRATION"},
+    {0x040E, "CNF_ERROR_CDMA_AAL5_DEREG_SERVICE_DOWN"},
+    {0x040F, "CNF_ERROR_CDMA_AAL5_DEREG_NO_REGISTERED_CLIENT"},
+    {0x0410, "CNF_ERROR_CDMA_AAL5_DEREG_CLIENT_NOT_FOUND"},
+    {0x0411, "CNF_ERROR_CDMA_MEMORY"},
+    {0x0502, "CNF_ERROR_FOIP_MSG_LEN"},
+    {0x0503, "CNF_ERROR_FOIP_LEVEL"},
+    {0x0504, "CNF_ERROR_FOIP_DEREG"},
+    {0x0505, "CNF_ERROR_FOIP_COD_INVALID"},
+    {0x0506, "CNF_ERROR_FOIP_LIM_INVALID"},
+    {0x0507, "CNF_ERROR_FOIP_PACKINT_SIZE"},
+    {0x0508, "CNF_ERROR_FOIP_PACKINT_GRANULARITY"},
+    {0x0602, "CNF_ERROR_AAL5OPT_MSG_LEN"},
+    {0x0603, "CNF_ERROR_AAL5OPT_CLIENT_DESCRIPTOR"},
+    {0x0604, "CNF_ERROR_AAL5OPT_AAL5_REG_SERVICE_DOWN"},
+    {0x0605, "CNF_ERROR_AAL5OPT_AAL5_REG_MAX_CLIENTS"},
+    {0x0606, "CNF_ERROR_AAL5OPT_AAL5_REG_ALLOC_CLIENT"},
+    {0x0607, "CNF_ERROR_AAL5OPT_AAL5_REG_ATM_REGISTRATION"},
+    {0x0608, "CNF_ERROR_AAL5OPT_AAL5_REG_RFC_ENCAP"},
+    {0x0609, "CNF_ERROR_AAL5OPT_AAL5_DEREG_SERVICE_DOWN"},
+    {0x060A, "CNF_ERROR_AAL5OPT_AAL5_DEREG_NO_REGISTERED_CLIENT"},
+    {0x060B, "CNF_ERROR_AAL5OPT_AAL5_DEREG_CLIENT_NOT_FOUND"},
+    {0x060C, "CNF_ERROR_AAL5OPT_INIT"},
+    {0x060D, "CNF_ERROR_AAL5OPT_ARM0"},
+    {0x060E, "CNF_ERROR_AAL5OPT_DESCRIPTOR"},
+    {0x060F, "CNF_ERROR_AAL5OPT_DEVICEDESC"},
+    {0x0702, "CNF_ERROR_CIPHER_ALGO_NOT_DEFINED"},
+    {0x0703, "CNF_ERROR_CIPHER_BAD_KEY_SIZE"},
+    {0x0704, "CNF_ERROR_CIPHER_ERROR1"},
+    {0x0705, "CNF_ERROR_CIPHER_ERROR2"},
+    {0x0706, "CNF_ERROR_CIPHER_BAD_MODE"},
+    {0x0707, "CNF_ERROR_CIPHER_BAD_PADDING_METHOD"},
+    {0x0708, "CNF_ERROR_CIPHER_BAD_MAC_KEY_SIZE"},
+    {0x0709, "CNF_ERROR_CIPHER_BAD_PACKETCABLE_MODE"},
+    {0x070A, "CNF_ERROR_CIPHER_NOT_IMPLEMENTED"},
+    {0x070B, "CNF_ERROR_CIPHER_BAD_FIFO_LENGTH"},
+    {0x070C, "CNF_ERROR_CIPHER_DSPLIB"},
+    {0x070D, "CNF_ERROR_AUTHENTICATION_BAD_PACKETCABLE_MODE"},
+    {0x070E, "CNF_ERROR_CIPHER_ALLOC"},
+    {0x070F, "CNF_ERROR_AUTHENTICATION_ALLOC"},
+    {0x0710, "CNF_ERROR_CIPHER_BAD_CIPHER_LAYER"},
+    {0x0711, "CNF_ERROR_AUTHENTICATION_BAD_HASHING_FUNCTION"},
+    {0x0712, "CNF_ERROR_AUTHENTICATION_BAD_MAC_SIZE"},
+    {0x0713, "CNF_ERROR_CIPHER_KEY_SCHEDULED"},
+    {0x0714, "CNF_ERROR_CIPHER_REDUNDANCY"},
+    {0x0715, "CNF_ERROR_CIPHER_NOT_ENABLED"},
+    {0x0800, "CNF_ERROR_DESTROY_INVALID_CHAN"},
+    {0x0801, "CNF_ERROR_DESTROY_ACTIVE_CHAN"},
+    {0x0901, "CNF_ERROR_IUUP_UNSPEC"},
+    {0x0902, "CNF_ERROR_IUUP_INIT_RFCI_INCORRECT"},
+    {0x0903, "CNF_ERROR_IUUP_INIT_PDU_INCORRECT"},
+    {0x0904, "CNF_ERROR_IUUP_INIT_MV_NOTSUPPORTED"},
+    {0x0905, "CNF_ERROR_IUUP_INIT_SDU_SIZE_INCORRECT"},
+    {0x0906, "CNF_ERROR_IUUP_RATE_NUM_RFCI_INCORRECT"},
+    {0x0907, "CNF_ERROR_IUUP_RATE_RFCI_NOT_ENABLE"},
+    {0x0908, "CNF_ERROR_IUUP_TA_NOT_POSSIBLE"},
+    {0x0909, "CNF_ERROR_IUUP_TA_NOT_SUPPORTED"},
+    {0x090A, "CNF_ERROR_IUUP_SVC_MV_INCORRECT"},
+    {0x090B, "CNF_ERROR_IUUP_PROCEDURE_ACTIVE"},
+    {0x090C, "CNF_ERROR_IUUP_LENGTH_TOO_BIG"},
+    {0x090D, "CNF_ERROR_IUUP_NOT_UP"},
+    {0x0981, "CNF_ERROR_TFO_UNSPEC"},
+    {0x0982, "CNF_ERROR_TFO_NO_MEM"},
+    {0x0983, "CNF_ERROR_TFO_QUEUE_FULL"},
+    {0x0984, "CNF_ERROR_TFO_QUEUE_EMPTY"},
+    {0x0985, "CNF_ERROR_TFO_EXIST"},
+    {0x0986, "CNF_ERROR_TFO_NOT_CREATED"},
+    {0x0987, "CNF_ERROR_TFO_NO_ACCESS"},
+    {0x0988, "CNF_ERROR_TFO_LENGTH_INCORRECT"},
+    {0x0A00, "CNF_ERROR_SET_ETH_UNK_ID"},
+    {0x0A01, "CNF_ERROR_SET_ETH_TOO_SHORT"},
+    {0x0A02, "CNF_ERROR_SET_RTO_UNK_OPCODE"},
+    {0x0A03, "CNF_ERROR_SET_RTO_UNK_ACTIVE"},
+    {0x0A04, "CNF_ERROR_ARP_NO_ETH_LAYER"},
+    {0x0A05, "CNF_ERROR_CSME_MCP_ACTIVE"},
+    {0x0A06, "CNF_ERROR_CSME_MCP_REG_NO_IPLAYER"},
+    {0x0A07, "CNF_ERROR_CSME_MCP_REG_NO_LOWERLAYER"},
+    {0x0A08, "CNF_ERROR_CSME_MCP_REG_NO_MORECLIENTS"},
+    {0x0A09, "CNF_ERROR_CSME_MCP_REG_DUPLICATION"},
+    {0x0A0B, "CNF_ERROR_CSME_MCP_NO_ETH"},
+    {0x0A0C, "CNF_ERROR_CSME_MRDT_ACTIVE"},
+    {0x0A0D, "CNF_ERROR_CSME_MRDT_REG_NO_IPLAYER"},
+    {0x0A0E, "CNF_ERROR_CSME_MRDT_REG_NO_LOWERLAYER"},
+    {0x0A0F, "CNF_ERROR_CSME_MRDT_REG_NO_MORECLIENTS"},
+    {0x0A10, "CNF_ERROR_CSME_MRDT_REG_DUPLICATION"},
+    {0x0A12, "CNF_ERROR_CSME_MRDT_NO_ETH"},
+    {0x0A13, "CNF_ERROR_CSME_UNK_OPCODE"},
+    {0x0A15, "CNF_ERROR_SPECIALPKT_HANDLING_TOOMANY"},
+    {0x0A16, "CNF_ERROR_ARP_CHAGALL"},
+    {0x0A17, "CNF_ERROR_ARP_MSG_LEN"},
+    {0x0A18, "CNF_ERROR_CSME_NO_CONTEXT"},
+    {0x0A19, "CNF_ERROR_ETH_CLIENT_INUSE"},
+    {0x0A1A, "CNF_ERROR_ETH_CLIENT_CANTREG"},
+    {0x0A1B, "CNF_ERROR_ETH_CLIENT_CANTCHANGE"},
+    {0x0A1C, "CNF_ERROR_ETH_NO_CONTEXT"},
+    {0x0A1D, "CNF_ERROR_IPV4_NO_CONTEXT"},
+    {0x0A1E, "CNF_ERROR_VCID_NO_CONTEXT"},
+    {0x0A1F, "CNF_ERROR_ETH_INIT"},
+    {0x0A20, "CNF_ERROR_ETH_NO_HANDLE"},
+    {0x0A21, "CNF_ERROR_CHAN_MAC_NE_DEVICE"},
+    {0x0A22, "CNF_ERROR_WRONG_PACKET_TYPE"},
+    {0x0A23, "CNF_ERROR_BAD_FRAME_SIZE"},
+    {0x0A24, "CNF_ERROR_SPECIALPKT_NO_MEM"},
+    {0x0A26, "CNF_ERROR_AAL5_IPV4_NOT_REG"},
+    {0x0A30, "CNF_ERROR_CSME_ODIAG_REG_NO_IPLAYER"},
+    {0x0A31, "CNF_ERROR_CSME_ODIAG_REG_NO_LOWERLAYER"},
+    {0x0A32, "CNF_ERROR_CSME_ODIAG_REG_NO_MORECLIENTS"},
+    {0x0A33, "CNF_ERROR_CSME_ODIAG_REG_DUPLICATION"},
+    {0x0B00, "CNF_ERROR_ICMP_NO_IP_LAYER"},
+    {0x0B01, "CNF_ERROR_ICMP_BADTTL"},
+    {0x0B02, "CNF_ERROR_IP_ADDRESS_NO_IP_LAYER"},
+    {0x0B03, "CNF_ERROR_IP_ADDRESS_BAD_IP_ADDRESS"},
+    {0x0B04, "CNF_ERROR_IP_ADDRESS_IPCLIENT_REG"},
+    {0x0B05, "CNF_ERROR_SET_IP_UNKSERVICEID"},
+    {0x0B06, "CNF_ERROR_SET_IP_TOOSHORT"},
+    {0x0B07, "CNF_ERROR_SET_IP_IPADDRESS_NOTSET"},
+    {0x0B08, "CNF_ERROR_SET_IP_BADHEADER"},
+    {0x0B09, "CNF_ERROR_SET_IP_BADTTL"},
+    {0x0B0A, "CNF_ERROR_SET_IP_UNKPROT"},
+    {0x0B0B, "CNF_ERROR_SET_IP_ODDRTP_PORT"},
+    {0x0B0C, "CNF_ERROR_SET_IP_REG_RTP_NO_IPLAYER"},
+    {0x0B0D, "CNF_ERROR_SET_IP_REG_RTP_NO_LOWERLAYER"},
+    {0x0B0E, "CNF_ERROR_SET_IP_REG_RTP_NO_MORECLIENTS"},
+    {0x0B0F, "CNF_ERROR_SET_IP_REG_RTP_DUPLICATION"},
+    {0x0B11, "CNF_ERROR_SET_IP_EVENRTCP_PORT"},
+    {0x0B12, "CNF_ERROR_SET_IP_REG_RTCP_NO_IPLAYER"},
+    {0x0B13, "CNF_ERROR_SET_IP_REG_RTCP_NO_LOWERLAYER"},
+    {0x0B14, "CNF_ERROR_SET_IP_REG_RTCP_NO_MORECLIENTS"},
+    {0x0B15, "CNF_ERROR_SET_IP_REG_RTCP_DUPLICATION"},
+    {0x0B16, "CNF_ERROR_SET_IP_REG_FOIP_NO_IPLAYER"},
+    {0x0B17, "CNF_ERROR_SET_IP_REG_FOIP_NO_LOWERLAYER"},
+    {0x0B18, "CNF_ERROR_SET_IP_REG_FOIP_NO_MORECLIENTS"},
+    {0x0B19, "CNF_ERROR_SET_IP_REG_FOIP_DUPLICATION"},
+    {0x0B1A, "CNF_ERROR_COMMAND_NEEDS_VOPENA_RTP"},
+    {0x0B1B, "CNF_ERROR_COMMAND_NEEDS_VOPENA_SIGNAL"},
+    {0x0B1C, "CNF_ERROR_SS7COT_ERROR"},
+    {0x0B1D, "CNF_ERROR_CND_DATA_INVALID"},
+    {0x0B1E, "CNF_ERROR_NOT_MAX_INFO_COUNT"},
+    {0x0C02, "CNF_ERROR_ATM_SERVICE_ERROR"},
+    {0x0C03, "CNF_ERROR_ATM_SERVICE_BW_EXCEEDED"},
+    {0x0C04, "CNF_ERROR_ATM_SERVICE_VPI_OUT_OF_RANGE"},
+    {0x0C05, "CNF_ERROR_ATM_SERVICE_VCI_OUT_OF_RANGE"},
+    {0x0C06, "CNF_ERROR_ATM_SERVICE_VPCI_NB_NOT_P2"},
+    {0x0C07, "CNF_ERROR_ATM_SERVICE_VPCI_NB_OUT_OF_RANGE"},
+    {0x0C08, "CNF_ERROR_ATM_SERVICE_HANDLE_NOT_REGISTERED"},
+    {0x0C09, "CNF_ERROR_ATM_SERVICE_NO_VCC_TOS"},
+    {0x0C0A, "CNF_ERROR_ATM_SERVICE_CONFIG_NOT_ALLOWED"},
+    {0x0C0B, "CNF_ERROR_ATM_SERVICE_ETH_DOWN"},
+    {0x0C0C, "CNF_ERROR_ATM_SERVICE_SLAVE_MODE_ONLY"},
+    {0x0C0D, "CNF_ERROR_ATM_SERVICE_CANNOT_ALLOC"},
+    {0x0C0E, "CNF_ERROR_ATM_MSG_LEN"},
+    {0x0C0F, "CNF_ERROR_ATM_UNKNOWN_FUNC"},
+    {0x0C10, "CNF_ERROR_ATM_NO_UTP"},
+    {0x0C11, "CNF_ERROR_ATM_NOT_SUPPORTED"},
+    {0x0C12, "CNF_ERROR_ATM_MEMORY"},
+    {0x0C13, "CNF_ERROR_ATM_CELL_NOT_SENT"},
+    {0x0C14, "CNF_ERROR_NOT_LGESSIG"},
+    {0x0C15, "CNF_ERROR_ATM_LAYER_NOT_CONFIGURED"},
+    {0x0D00, "CNF_ERROR_PUI_MSG_LEN"},
+    {0x0D01, "CNF_ERROR_PUI_NOT_INITIALIZED"},
+    {0x0D02, "CNF_ERROR_PUI_MODE_NOT_SET"},
+    {0x0D03, "CNF_ERROR_PUI_CONFIGURED"},
+    {0x0D04, "CNF_ERROR_PUI_DATABUSW"},
+    {0x0D05, "CNF_ERROR_PUI_HANDSHAKE"},
+    {0x0D06, "CNF_ERROR_PUI_NUM_ROUTING_TAGS"},
+    {0x0D07, "CNF_ERROR_PUI_ROUTING_TAGS_ODD"},
+    {0x0D08, "CNF_ERROR_PUI_STRAPCONFIG"},
+    {0x0D09, "CNF_ERROR_PUI_NON_SYMETRIC_ADDRESS"},
+    {0x0D0A, "CNF_ERROR_PUI_INVALID_PHY_ADDRESS"},
+    {0x0D0B, "CNF_ERROR_PUI_UNKNOWN_MODE"},
+    {0x0D0C, "CNF_ERROR_OPTIPHY_LEN"},
+    {0x0D0D, "CNF_ERROR_OPTIPHY_INIT"},
+    {0x0D0E, "CNF_ERROR_OPTIPHY_CFG"},
+    {0x0D0F, "CNF_ERROR_OPTIPHY_LOOPBACK"},
+    {0x0D10, "CNF_ERROR_POS_CLIENT_INIT"},
+    {0x0D11, "CNF_ERROR_POS_CLIENT_CANT_DEREG"},
+    {0x0E00, "CNF_ERR_CONF_MAXNO_CREATED"},
+    {0x0E01, "CNF_ERR_CONF_INVALID_CPU"},
+    {0x0E02, "CNF_ERR_CONF_DESTROY_CONF_FAILED"},
+    {0x0E03, "CNF_ERR_CONF_INVALID_CMD_LEN"},
+    {0x0E04, "CNF_ERR_CONF_INVALID_PART_TYPE"},
+    {0x0E05, "CNF_ERR_CONF_VALIDITY_CHECK_FAILED"},
+    {0x0E06, "CNF_ERR_CONF_DELETE_PART_FAILED"},
+    {0x0E07, "CNF_ERR_CONF_NO_MIXER"},
+    {0x0E08, "CNF_ERR_CONF_MUTE_PART_FAILED"},
+    {0x0E09, "CNF_ERR_CONF_HOLD_PART_FAILED"},
+    {0x0E0A, "CNF_ERR_CONF_NO_MORE_CHANS"},
+    {0x0E0B, "CNF_ERR_CONF_NOT_SAME_CPU"},
+    {0x0E0C, "CNF_ERR_CONF_MAXNO_PARTS_CREATED"},
+    {0x0E0D, "CNF_ERR_CONF_MAX_RSP_SLOTS"},
+    {0x0E0E, "CNF_ERR_CONF_INCORRECT_FRAME_SIZE"},
+    {0x0E0F, "CNF_ERR_CONF_NO_MUTE"},
+    {0x0E10, "CNF_ERR_CONF_NO_HOLD"},
+    {0x0E11, "CNF_ERR_CONF_NO_DESTROY"},
+    {0x0E12, "CNF_ERR_CONF_CMD_INVALID_FOR_LSP"},
+    {0x0E13, "CNF_ERR_CONF_CMD_INVALID_FOR_RSP"},
+    {0x0E14, "CNF_ERR_CONF_CMD_DESTROY_INVALID_FOR_CONF"},
+    {0x0E15, "CNF_ERR_CONF_CMD_NONZERO_PARTICIPANTS"},
+    {0x0E16, "CNF_ERR_CONF_CMD_DOMTALK_INVALID_FOR_MIRO"},
+    {0x0E17, "CNF_ERR_CONF_CMD_SPECIFY_DOMTALK_FAILED"},
+    {0x0E18, "CNF_ERR_CONF_CMD_DOMTALK_NOT_SUPPORTED"},
+    {0x0E19, "CNF_ERR_CONF_CMD_DOMTALK_PARAM_INVALID_VALUE"},
+    {0x0E1A, "CNF_ERR_CONF_CMD_NSC_RSP_NOT_ALLOWED"},
+    {0x0E1B, "CNF_ERR_CONF_CMD_NSC_LSP_NOT_SAME_BUS"},
+    {0x0E1C, "CNF_ERR_CONF_CMD_NSC_NOT_SUPPORTED"},
+    {0x0E1D, "CNF_ERR_CONF_CMD_NSC_PARAM_INVALID_VALUE"},
+    {0x0E1E, "CNF_ERR_CONF_CMD_NSC_NONZERO_CONFS"},
+    {0x0E1F, "CNF_ERR_CONF_CMD_NSC_DGAIN_PART_FAILED"},
+    {0x0E20, "CNF_ERR_CONF_CMD_NSC_NO_DGAIN"},
+    {0x0E21, "CNF_ERR_CONF_CMD_NSC_INVALID_FOR_MIRO"},
+    {0x0E22, "CNF_ERR_CONF_CMD_INVALID_FOR_RSP_WTC"},
+    {0x0E23, "CNF_ERR_CONF_CMD_NSC_MAX_WTC_CREATED"},
+    {0x0F00, "CNF_ERR_AGC_INVALID_FOR_MIRO"},
+    {0x0F01, "CNF_ERR_AGC_NOT_SUPPORTED"},
+    {0x0F02, "CNF_ERR_AGC_PARAM_INVALID_VALUE"},
+    {0x0F03, "CNF_ERR_SNS_INVALID_FOR_MIRO"},
+    {0x0F04, "CNF_ERR_SNS_NOT_SUPPORTED"},
+    {0x0F05, "CNF_ERR_SNS_PARAM_INVALID_VALUE"},
+    {0x1000, "CNF_ERR_SELECTNIF_MAX_VALUE"},
+    {0x1001, "CNF_ERROR_NIF_INIT"},
+    {0x1002, "CNF_ERROR_PL_MAX_RULES"},
+    {0x1003, "CNF_ERROR_PL_MAX_PROTO"},
+    {0x1004, "CNF_ERROR_PL_INVALID_ACTION"},
+    {0x1005, "CNF_ERROR_PL_INVALID_DESTINATION"},
+    {0x1006, "CNF_ERROR_VID_INVALID"},
+    {0x1007, "CNF_ERROR_PORT_INIT"},
+    {0x1008, "CNF_ERROR_PORT_ALLOC"},
+    {0x1009, "CNF_ERROR_PORT_VALUE"},
+    {0x100A, "CNF_ERROR_PORT_INITIALIZED"},
+    {0x100B, "CNF_ERROR_PORT_NOT_INITIALIZED"},
+    {0x100C, "CNF_ERROR_PORT_INVALID"},
+    {0x100D, "CNF_ERROR_PORT_VIRTUAL"},
+    {0x100E, "CNF_ERROR_PORT_NULL"},
+    {0x100F, "CNF_ERROR_PORT_NOT_FREE"},
+    {0x1010, "CNF_ERROR_NIF_ALLOC"},
+    {0x1011, "CNF_ERROR_NIF_NOT_INITIALIZED"},
+    {0x1012, "CNF_ERROR_NIF_NOT_SELECTED"},
+    {0x1013, "CNF_ERROR_CONTEXT_NULL"},
+    {0x1014, "CNF_ERROR_DESTINATION_NULL"},
+    {0x1015, "CNF_ERROR_PKT_NULL"},
+    {0x1500, "CNF_ERROR_HDL_NO_MEMORY"},
+    {0x1501, "CNF_ERROR_HDL_ENCAP_NOT_SUPPORTED"},
+    {0x1502, "CNF_ERROR_HDL_SERVICE_DESC_NOT_SUPPORTED"},
+    {0x1503, "CNF_ERROR_HDL_RX_INIT_FAILURE"},
+    {0x1504, "CNF_ERROR_HDL_CHAN_ALREADY_ENABLED"},
+    {0x1505, "CNF_ERROR_HDL_SERVICE_DESC_IN_USE"},
+    {0x7800, "CNF_ERROR_DIAG_0"},
+    {0x7801, "CNF_ERROR_DIAG_1"},
+    {0x7802, "CNF_ERROR_DIAG_2"},
+    {0x7803, "CNF_ERROR_DIAG_ETHREG1"},
+    {0x7804, "CNF_ERROR_DIAG_ETHREG2"},
+    {0x7805, "CNF_ERROR_DIAG_ETHREG3"},
+    {0x7806, "CNF_ERROR_DIAG_NOFACILITY"},
+    {0x8000, "CNF_ERROR_INVALID_DTMF_DIGIT"},
+    {0x8001, "CNF_ERROR_DISABLE_BAD_PT"},
+    {0x8002, "CNF_ERROR_BAD_FRAME_BUF_LEN"},
+    {0x8003, "CNF_ERROR_NO_FRAME_CTRL"},
+    {0x8004, "CNF_ERROR_TONEOFF"},
+    {0x8005, "CNF_ERROR_TG_TONEGEN"},
+    {0x8006, "CNF_ERROR_TG_FREQ"},
+    {0x8007, "CNF_ERROR_NO_PROT_WITH_RELAY"},
+    {0x8008, "CNF_ERROR_CADENCE"},
+    {0x8009, "CNF_ERROR_VOICE_INACTIVE"},
+    {0x800A, "CNF_ERROR_LB_ICHAN_SWITCH"},
+    {0x800B, "CNF_ERROR_LB_SELF"},
+    {0x800C, "CNF_ERROR_LB_POST_ONTHEFLY"},
+    {0x800D, "CNF_ERROR_LB_ICHAN_ONTHEFLY"},
+    {0x800E, "CNF_ERROR_LB_ICHAN_SELF"},
+    {0x800F, "CNF_ERROR_LB_ONTHEFLY"},
+    {0x8010, "CNF_ERROR_LB_NO_DEST"},
+    {0x8011, "CNF_ERROR_LB_NOT_IMPLEMENTED"},
+    {0x8012, "CNF_ERROR_LB_NO_FPGA"},
+    {0x8013, "CNF_ERR_NO_HIGHWAY"},
+    {0x8014, "CNF_ERR_WRONG_HIGHWAY"},
+    {0x8015, "CNF_ERR_NO_CHANGE_CHAN_IN_SVSR"},
+    {0x8016, "CNF_ERR_NO_SPEECH_PROC"},
+    {0x8017, "CNF_ERR_CHAGALL"},
+    {0x8018, "CNF_ERR_NO_DIAGQRYCB"},
+    {0x8019, "CNF_ERR_NO_DIAGENACB"},
+    {0x801A, "CNF_ERR_NO_CFGCHANGECB"},
+    {0x801B, "CNF_ERR_NO_CFGQUERYCB"},
+    {0x801C, "CNF_ERR_NO_STATCB"},
+    {0x801D, "DELAYED_ACK"},
+    {0xFFA5, "ERR_SPU_FEATURE_NOT_ENABLED"},
+    {0xFFA6, "ERR_DSPDIAG_INVCODECID"},
+    {0xFFA7, "ERR_CHANNELS_NOT_RUNNING"},
+    {0xFFA8, "ERR_VBE_CONFIG"},
+    {0xFFA9, "ERR_HEARTBEAT_SIZE"},
+    {0xFFAA, "ERR_STAGGER_SIZE"},
+    {0xFFAB, "ERR_MAX_SIZE"},
+    {0xFFAC, "ERR_CHANNELS_RUNNING"},
+    {0xFFAD, "ERR_UNKNOWN_FUNCTION"},
+    {0xFFAE, "ERR_COMMAND_LEN"},
+    {0xFFAF, "ERR_RTXC_TASK_CREATE_FAILURE"},
+    {0xFFBD, "ERR_TDMDRV_INVTS"},
+    {0xFFBE, "ERR_TDMDRV_INVBUSID"},
+    {0xFFBF, "ERR_TDMDRV_INVBUFSZ"},
+    {0xFFCF, "ERR_SPEECH_NO_SUCH_CODEC"},
+    {0xFFDE, "ERR_CHANCTRL_NO_SUCH_CHAN"},
+    {0xFFDF, "ERR_CHANCTRL_NEED_ARM1_RES"},
+    {0xFFEB, "ERR_RM_NO_SPU_MIPS_AVAILABLE"},
+    {0xFFEC, "ERR_RM_NO_ARM1_MIPS_AVAILABLE"},
+    {0xFFED, "ERR_RM_NO_ARM0_MIPS_AVAILABLE"},
+    {0xFFEE, "ERR_RM_NO_ARM_MIPS_AVAILABLE"},
+    {0xFFEF, "ERR_RM_NEED_ARM1_RES"},
+    {0xFFF1, "ERR_MALLOC_GENERIC"},
+    {0xFFF2, "DELAYED_VOIPCONFIG_ACK"},
+    {0xFFF3, "ERR_OUT_OF_RANGE"},
+    {0xFFF4, "ERR_MALLOC_IRAM_LOCAL_NCNB_HEAP"},
+    {0xFFF5, "ERR_MALLOC_IRAM_LOCAL_HEAP"},
+    {0xFFF6, "ERR_MALLOC_IRAM_GLOBAL_NCNB_HEAP"},
+    {0xFFF7, "ERR_MALLOC_IRAM_GLOBAL_HEAP"},
+    {0xFFF8, "ERR_MALLOC_ERAM_LOCAL_NCNB_HEAP"},
+    {0xFFF9, "ERR_MALLOC_ERAM_LOCAL_HEAP"},
+    {0xFFFA, "ERR_MALLOC_ERAM_GLOBAL_NCNB_HEAP"},
+    {0xFFFB, "ERR_MALLOC_ERAM_GLOBAL_HEAP"},
+    {0xFFFC, "ERR_MALLOC_SDRAM_LOCAL_NCNB_HEAP"},
+    {0xFFFD, "ERR_MALLOC_SDRAM_LOCAL_HEAP"},
+    {0xFFFE, "ERR_MALLOC_SDRAM_GLOBAL_NCNB_HEAP"},
+    {0xFFFF, "ERR_MALLOC_SDRAM_GLOBAL_HEAP"},
+};
+
+// ================================================================================================
+// Local functions
+
+// -----------------------------------------------------------------------------------------------
+// finds the size of command csm message and its class and type
+command_map_t const *
+get_command_map_entry (uint16_t func_code)
+{
+    uint i;
+    command_map_t const *p;
+
+#ifdef FIRMIX_USE_BSEARCH_FOR_COMMAND_MAP
+    static int was_checked = 0;
+
+    if (!was_checked) {
+        for (i = 1, p = &command_map[1];
+             i < sizeof(command_map) / sizeof(*command_map);
+             ++i, ++p)
+        {
+            if (p[-1].func_code >= p->func_code) {
+                MSPD_ERR("*** internal error, command_map[] not sorted by func-code ***\n");
+                exit(1);
+            }
+        }
+        was_checked = 1;
+    }
+#error "bsearch for command-map lookup not implemented yet"
+#else
+    for (i = 0, p = command_map;
+         i < sizeof(command_map) / sizeof(*command_map);
+         ++i, ++p)
+    {
+        if (p->func_code == func_code)
+            return p;
+    }
+#endif
+
+    return NULL;
+}
+
+// -----------------------------------------------------------------------------------------------
+// code -> text (no need to be super fast here, just do a linear search)
+char const *
+code2text (uint code, code2text_t const *table, size_t nelements)
+{
+    uint i;
+    code2text_t const *p;
+    for (i = 0, p = table; i < nelements; ++i, ++p) {
+        if (p->code == code)
+            return p->text;
+    }
+    return NULL;
+}
+
+// -----------------------------------------------------------------------------------------------
+char *
+cmdclass2text (uint16_t cmd)
+{
+    uint8_t cmd_class = cmd >> 8;
+    switch (cmd_class) {
+        case CMD_CLASS_STAT_CHANNEL:            return "STAT_CHAN";
+        case CMD_CLASS_CONF_CHANNEL:            return "CONF_CHAN";
+        case CMD_CLASS_LEGACY_MSG:              return "LEGACY";
+        case CMD_CLASS_ETH_BOOT_MSG:            return "ETH_BOOTL";
+        case CMD_CLASS_STAT_DEVICE:             return "STAT_DEV";
+        case CMD_CLASS_CONF_DEVICE:             return "CONF_DEV";
+        case CMD_CLASS_REF_DIAG:                return "REF_DIAG";
+        case CMD_CLASS_OPEN_DIAG:               return "OPEN_DIAG";
+        case CMD_CLASS_DIAG_TOOL:               return "DIAG_TOOL";
+        default:                                return "**UNKOWN_CLASS**";
+    }
+}
+
+// -----------------------------------------------------------------------------------------------
+char *
+cmdtype2text (uint16_t cmd)
+{
+    uint8_t cmd_type = cmd & 0x00ff;
+    switch(cmd_type) {
+        case CMD_TYPE_CONF_CHANGE:              return "CONF_CHG";
+        case CMD_TYPE_QUERY:                    return "CONF_QRY";
+        case CMD_TYPE_CONF_RESP:                return "ACK";
+        case CMD_TYPE_INDICATION:               return "IND";
+        case CMD_TYPE_QUERY_RESP:               return "QRY_RSP";
+        case CMD_TYPE_INDICATION_RESP:          return "IND_RSP";
+        case CMD_TYPE_DIAG_QUERY:               return "DIAG_QRY";
+        case CMD_TYPE_DIAG_QUERY_RESP:          return "DIAG_QRY_RSP";
+        case CMD_TYPE_DIAG_REL_QUERY:           return "RQRY";
+        case CMD_TYPE_DIAG_REL_QUERY_RESP:      return "RQRY_RSP";
+        case CMD_TYPE_DIAG_MON_LIVE_CTRL:       return "MON_LCTL";
+        case CMD_TYPE_DIAG_MON_LIVE_IND:        return "MON_LIND";
+        //case CMD_TYPE_MONITOR_DUMP_STORE:     return "MON_DSTR";
+        //case CMD_TYPE_MONITOR_DUMP_INDICATION:return "MON_DIND";
+        case CMD_TYPE_DIAG_CONFIG:              return "DIAG_CONF";
+        case CMD_TYPE_SUPV_READY:               return "SUPVSR_READY";
+        default:                                return "**UNKOWN_TYPE**";
+    }
+}
+
+// -----------------------------------------------------------------------------------------------
+// fills in FIFO with given cmd class, type, function type and parameters
+static int
+mspd_new_msg (SMsg *msg,
+        uint            channel_id,
+        uint            fifo_size,
+        uint16_t        cmd_class_type,
+        uint16_t        func_code,
+        int             *argv)
+{
+    uint padded_fifo_size = ((fifo_size + 3) / 4) * 4;
+    int  value, argc, idx;
+    int  override_n_params = 0;
+
+    if (padded_fifo_size > MAX_FIFO_SIZE)
+        goto bad_fifo_size;
+
+    for (argc = 0, idx = 0; ; ++argc) {
+        value = argv[argc];
+        if (!(argc % 2)) {
+            if (argc == 0 && value == DC_OVERRIDE_N_PARAMS) {
+                override_n_params = 1;
+                continue;
+            }
+            if (value == DC_EOM)
+                break;
+            if (value < 4 || value * sizeof(uint16_t) >= fifo_size) {
+                MSPD_ERR("out-of-bounds fifo[]-index %d for command %s(%04x), fifo-size =  %u\n",
+                        value, mspd_lookup_msg_id(func_code), func_code, fifo_size);
+                return 1;
+            }
+            idx = value;
+        }
+        else {
+            if (argc == 1 && override_n_params) {
+                fifo_size = value * 2 + 8;
+                padded_fifo_size = ((fifo_size + 3) / 4) * 4;
+                if (padded_fifo_size > MAX_FIFO_SIZE)
+                    goto bad_fifo_size;
+                continue;
+            }
+            ((uint16_t*)msg->pusFifo)[idx] = value;
+        }
+    }
+    msg->sMailbox.usMsgId          = 0x000b;
+    msg->sMailbox.usParam1         = padded_fifo_size;
+    msg->sMailbox.usParam2         = channel_id;
+    msg->sMailbox.usParam3         = 0;
+    msg->uiFifoSize                = padded_fifo_size;
+    ((uint8_t*)msg->pusFifo) [0]   = fifo_size;
+    ((uint8_t*)msg->pusFifo) [1]   = 0; /* command index, we don't use it */
+    ((uint16_t*)msg->pusFifo)[1]   = cmd_class_type;
+    ((uint16_t*)msg->pusFifo)[2]   = func_code;
+    ((uint16_t*)msg->pusFifo)[3]   = 0;
+
+    return 0;
+
+bad_fifo_size:
+    MSPD_ERR("padded-fifo-size=%u > maximum for command %s(%04x)\n",
+            padded_fifo_size, mspd_lookup_msg_id(func_code), func_code);
+    return 1;
+}
+
+// ================================================================================================
+// Global functions
+
+// -----------------------------------------------------------------------------------------------
+// helper, returns mnemo names for functions codes
+char const *
+mspd_lookup_msg_id (uint code)
+{
+    char const * const text
+        = code2text(code, mspd_functions_table,
+                                        sizeof(mspd_functions_table) / sizeof(*mspd_functions_table));
+    return text ? text : "**UNKNOWN_ID**";
+}
+
+// -----------------------------------------------------------------------------------------------
+// helper, returns mnemo names for error codes
+char const *
+mspd_lookup_error_code (uint code)
+{
+    char const * const text
+        = code2text(code, mspd_errors_table,
+                                        sizeof(mspd_errors_table) / sizeof(*mspd_errors_table));
+    return text ? text : "**UNKNOWN_ERR**";
+}
+
+// -----------------------------------------------------------------------------------------------
+// helper, converts binary CSM message to a readable string
+void
+mspd_fifo2str(char *buf, int n, uint fifo_size, uint16_t *fifo)
+{
+    uint i;
+    char tmp1 [80], tmp2 [80], tmp3 [80];
+    char tmp4 [256];
+    char tmp  [256];
+
+    sprintf(tmp, "%s (0x%04x)", mspd_lookup_msg_id(fifo[2]), fifo[2]);
+    //snprintf(buf, n, " [%s|%s] %s",
+    snprintf(buf, n, "  %s %s  %s",
+            term_color(tmp1, cmdclass2text(fifo[1]), COLOR_BLUE,    0, sizeof(tmp1)),
+            term_color(tmp2, cmdtype2text (fifo[1]), COLOR_BLUE,    0, sizeof(tmp2)),
+            term_color(tmp3, tmp,                    COLOR_BRGREEN, 0, sizeof(tmp3)));
+
+    for (i = 4; i < fifo_size/2; i++) {
+        sprintf(tmp, " [%d]=%04x", i, fifo[i]);
+        snprintf(buf+strlen(buf), n-strlen(buf), " %s",
+                term_color(tmp4, tmp, COLOR_BLUE, 0, sizeof(tmp4)));
+    }
+}
+
+// -----------------------------------------------------------------------------------------------
+// fifo of msg must be suitable for all messages (i.e. allocate maximal possible size!)
+int
+mspd_make_msg (SMsg *msg, uint channel_id, uint func_code, int *argv)
+{
+    command_map_t const *cm = get_command_map_entry(func_code);
+    int fifo_size = cm ? (int)cm->n_params * 2 + 8 : -1;
+
+    if (fifo_size < 8) {
+        MSPD_ERR("Channel message '%s/%04x' has invalid size %d "
+                "(add default size of message to command_map[])\n",
+                mspd_lookup_msg_id(func_code), func_code, fifo_size);
+        return 1;
+    }
+    return mspd_new_msg(msg, channel_id, fifo_size, cm->cmd_class_type, func_code, argv);
+}
+
+// -----------------------------------------------------------------------------------------------
+// Calculates time since MSPD channel module was loaded
+mspd_time
+mspd_get_time_ms ()
+{
+    mspd_timer now;
+    gettimeofday(&now, NULL);
+
+    mspd_time ret = {0, 0};
+    ret.sec  = now.tv_sec;
+    ret.msec = now.tv_usec / 1000;
+
+    if (ret.msec < 0) {
+        ret.sec  -= 1;
+        ret.msec += 1000;
+    }
+
+    return ret;
+}
+
+// -----------------------------------------------------------------------------------------------
+// This function can be useful in cases of analysis time dependent issues
+// To enable debug mode perform from CLI "set debug 1" and additionally
+// set verbosity level at least 8 by command "set verbose 8".
+void
+mspd_print_time()
+{
+    if ((option_debug) && (option_verbose >= 8)) {
+        mspd_time ofs =  mspd_get_time_ms();
+        ast_verbose("[%d.%03d] ", ofs.sec, ofs.msec);
+    }
+}
+
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/main/rtp_engine.c asterisk-1.8.2.3.new/main/rtp_engine.c
--- asterisk-1.8.2.3/main/rtp_engine.c	2010-11-03 23:35:14.000000000 +0530
+++ asterisk-1.8.2.3.new/main/rtp_engine.c	2012-02-17 21:59:26.000000000 +0530
@@ -39,6 +39,7 @@
 #include "asterisk/pbx.h"
 #include "asterisk/translate.h"
 #include "asterisk/netsock2.h"
+#include "asterisk/mspd/cmmlib.h"
 
 struct ast_srtp_res *res_srtp = NULL;
 struct ast_srtp_policy_res *res_srtp_policy = NULL;
@@ -95,7 +96,10 @@
 	{{1, AST_FORMAT_ULAW}, "audio", "G711U", 8000},
 	{{1, AST_FORMAT_ALAW}, "audio", "PCMA", 8000},
 	{{1, AST_FORMAT_ALAW}, "audio", "G711A", 8000},
-	{{1, AST_FORMAT_G726}, "audio", "G726-32", 8000},
+	{{1, AST_FORMAT_G726_32}, "audio", "G726-32", 8000},
+	{{1, AST_FORMAT_G726_40}, "audio", "G726-40", 8000},
+	{{1, AST_FORMAT_G726_16}, "audio", "G726-16", 8000},
+	{{1, AST_FORMAT_G726_24}, "audio", "G726-24", 8000},
 	{{1, AST_FORMAT_ADPCM}, "audio", "DVI4", 8000},
 	{{1, AST_FORMAT_SLINEAR}, "audio", "L16", 8000},
 	{{1, AST_FORMAT_SLINEAR16}, "audio", "L16", 16000},
@@ -106,6 +110,9 @@
 	{{1, AST_FORMAT_SPEEX}, "audio", "speex", 8000},
 	{{1, AST_FORMAT_SPEEX16}, "audio", "speex", 16000},
 	{{1, AST_FORMAT_ILBC}, "audio", "iLBC", 8000},
+	{{1, AST_FORMAT_ILBC_1}, "audio", "iLBC", 8000},
+	{{1, AST_FORMAT_AMR},     "audio", "AMR", 8000},
+	{{1, AST_FORMAT_AMR_WB},  "audio", "AMR-WB", 8000},
 	/* this is the sample rate listed in the RTP profile for the G.722
 	              codec, *NOT* the actual sample rate of the media stream
 	*/
@@ -158,8 +165,15 @@
 	[18] = {1, AST_FORMAT_G729A},
 	[19] = {0, AST_RTP_CN},         /* Also used for CN */
 	[26] = {1, AST_FORMAT_JPEG},
+	[29] = {1, AST_FORMAT_ILBC_1},
+	[30] = {1, AST_FORMAT_ILBC},
 	[31] = {1, AST_FORMAT_H261},
 	[34] = {1, AST_FORMAT_H263},
+	[39] = {1, AST_FORMAT_AMR},
+	[64] = {1, AST_FORMAT_AMR_WB},
+	[90] = {1, AST_FORMAT_G726_40},
+	[91] = {1, AST_FORMAT_G726_16},
+	[92] = {1, AST_FORMAT_G726_24},
 	[97] = {1, AST_FORMAT_ILBC},
 	[98] = {1, AST_FORMAT_H263_PLUS},
 	[99] = {1, AST_FORMAT_H264},
@@ -170,7 +184,7 @@
 	[105] = {1, AST_FORMAT_T140RED},   /* Real time text chat (with redundancy encoding) */
 	[106] = {1, AST_FORMAT_T140},      /* Real time text chat */
 	[110] = {1, AST_FORMAT_SPEEX},
-	[111] = {1, AST_FORMAT_G726},
+	[111] = {1, AST_FORMAT_G726_32},
 	[112] = {1, AST_FORMAT_G726_AAL2},
 	[115] = {1, AST_FORMAT_SIREN14},
 	[116] = {1, AST_FORMAT_G719},
@@ -301,7 +315,7 @@
 
 struct ast_rtp_instance *ast_rtp_instance_new(const char *engine_name,
 		struct sched_context *sched, const struct ast_sockaddr *sa,
-		void *data)
+		void *data, int is_msp_socket)
 {
 	struct ast_sockaddr address = {{0,}};
 	struct ast_rtp_instance *instance = NULL;
@@ -344,7 +358,7 @@
 	ast_debug(1, "Using engine '%s' for RTP instance '%p'\n", engine->name, instance);
 
 	/* And pass it off to the engine to setup */
-	if (instance->engine->new(instance, sched, &address, data)) {
+	if (instance->engine->new(instance, sched, &address, data, is_msp_socket)) {
 		ast_debug(1, "Engine '%s' failed to setup RTP instance '%p'\n", engine->name, instance);
 		ao2_ref(instance, -1);
 		return NULL;
@@ -810,6 +824,10 @@
 	enum ast_bridge_result res = AST_BRIDGE_FAILED;
 	struct ast_channel *who = NULL, *other = NULL, *cs[3] = { NULL, };
 	struct ast_frame *fr = NULL;
+	int sock0_id = -1;
+	int sock1_id = -1;
+	int rtp_session_id = -1;
+	int fpp_fail = 0;
 
 	/* Start locally bridging both instances */
 	if (instance0->engine->local_bridge && instance0->engine->local_bridge(instance0, instance1)) {
@@ -840,6 +858,7 @@
 	cs[0] = c0;
 	cs[1] = c1;
 	cs[2] = NULL;
+
 	for (;;) {
 		/* If the underlying formats have changed force this bridge to break */
 		if ((c0->rawreadformat != c1->rawwriteformat) || (c1->rawreadformat != c0->rawwriteformat)) {
@@ -878,6 +897,31 @@
 		/* Read in frame from channel */
 		fr = ast_read(who);
 		other = (who == c0) ? c1 : c0;
+
+		if (rtp_session_id < 0 && !fpp_fail) {
+			if (who == c0) {
+				if (instance0->engine->get_fpp_socket)
+					sock0_id = instance0->engine->get_fpp_socket(instance0);
+				if (sock0_id < 0)
+					fpp_fail = 1;
+			}
+			else {
+				if (instance1->engine->get_fpp_socket)
+					sock1_id = instance1->engine->get_fpp_socket(instance1);
+				if (sock1_id < 0)
+					fpp_fail = 1;
+			}
+			if (sock0_id > 0 && sock1_id > 0) {
+				rtp_session_id = ast_cmm_fpp_create_rtp_session(sock0_id, sock1_id);
+				if (rtp_session_id > 0)
+					ast_verb(5, "RTP cut-through enabled (%d)<-->(%d)\n", sock0_id, sock1_id);
+				else {
+					ast_log(LOG_ERROR, "Setting RTP cut-through failed (err=%d)\n", rtp_session_id);
+					fpp_fail = 1;
+				}
+			}
+		}
+
 		/* Depending on the frame we may need to break out of our bridge */
 		if (!fr || ((fr->frametype == AST_FRAME_DTMF_BEGIN || fr->frametype == AST_FRAME_DTMF_END) &&
 			    ((who == c0) && (flags & AST_BRIDGE_DTMF_CHANNEL_0)) |
@@ -953,6 +997,11 @@
 		cs[1] = cs[2];
 	}
 
+	if (rtp_session_id > 0) {
+		ast_verb(5, "RTP cut-through disabled (%d)<-->(%d)\n", sock0_id, sock1_id);
+		ast_cmm_fpp_close_rtp_session(rtp_session_id);
+	}
+
 	/* Stop locally bridging both instances */
 	if (instance0->engine->local_bridge) {
 		instance0->engine->local_bridge(instance0, NULL);
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/main/translate.c asterisk-1.8.2.3.new/main/translate.c
--- asterisk-1.8.2.3/main/translate.c	2010-08-13 01:45:41.000000000 +0530
+++ asterisk-1.8.2.3.new/main/translate.c	2011-11-10 18:16:29.000000000 +0530
@@ -1017,6 +1017,14 @@
 	format_t src_audio = src & AST_FORMAT_AUDIO_MASK;
 	format_t src_video = src & AST_FORMAT_VIDEO_MASK;
 
+	/* XXX: report that we can handle any kind of translation.
+	 * We can't actually at the moment (for example SIP->SIP call with G711->G729).
+	 * But we need to report as if we can to enable sending SIP SDP with several codecs in it.
+	 * The latter is needed for FPT mode.
+	 * TODO: fix/remove this when generic codec transcoding using MSP is implemented.
+	 */
+	return res;
+
 	/* if we don't have a source format, we just have to try all
 	   possible destination formats */
 	if (!src)
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/Makefile.rules asterisk-1.8.2.3.new/Makefile.rules
--- asterisk-1.8.2.3/Makefile.rules	2010-07-28 02:46:05.000000000 +0530
+++ asterisk-1.8.2.3.new/Makefile.rules	2011-03-16 17:00:25.000000000 +0530
@@ -43,12 +43,6 @@
   endif
 endif
 
-ifeq ($(findstring DONT_OPTIMIZE,$(MENUSELECT_CFLAGS))$(AST_CODE_COVERAGE),no)
-    _ASTCFLAGS+=$(OPTIMIZE)
-else
-    _ASTCFLAGS+=-O0
-endif
-
 ifeq ($(AST_CODE_COVERAGE),yes)
     _ASTCFLAGS+=-ftest-coverage -fprofile-arcs
     _ASTLDFLAGS+=-ftest-coverage -fprofile-arcs
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/menuselect/Makefile asterisk-1.8.2.3.new/menuselect/Makefile
--- asterisk-1.8.2.3/menuselect/Makefile	2008-12-11 03:30:19.000000000 +0530
+++ asterisk-1.8.2.3.new/menuselect/Makefile	2011-02-01 21:25:12.000000000 +0530
@@ -63,6 +63,9 @@
 
 $(OBJS) $(C_OBJS) $(N_OBJS) $(G_OBJS) $(M_OBJS): autoconfig.h menuselect.h
 
+%.o: %.c
+	$(BUILD_CC) -o $@ -c $<
+
 makeopts autoconfig.h: autoconfig.h.in makeopts.in
 	@./configure $(CONFIGURE_SILENT) CC= LD= AR= CFLAGS=
 
@@ -71,7 +74,7 @@
 ifdef C_OBJS
 menuselect_curses.o: CFLAGS+=$(C_INCLUDE)
 cmenuselect: $(OBJS) $(C_OBJS)
-	$(CC) -o $@ $^ $(C_LIBS)
+	$(BUILD_CC) -o $@ $^ $(C_LIBS)
 else
 cmenuselect:
 endif
@@ -79,7 +82,7 @@
 ifdef G_OBJS
 menuselect_gtk.o: CFLAGS+=$(G_INCLUDE)
 gmenuselect: $(OBJS) $(G_OBJS)
-	$(CC) -o $@ $^ $(G_LIBS)
+	$(BUILD_CC) -o $@ $^ $(G_LIBS)
 else
 gmenuselect:
 endif
@@ -87,13 +90,13 @@
 ifdef N_OBJS
 menuselect_newt.o: CFLAGS+=$(N_INCLUDE)
 nmenuselect: $(OBJS) $(N_OBJS)
-	$(CC) -o $@ $^ $(N_LIBS)
+	$(BUILD_CC) -o $@ $^ $(N_LIBS)
 else
 nmenuselect:
 endif
 
 menuselect: $(OBJS) $(M_OBJS)
-	$(CC) -o $@ $^ $(M_LIBS)
+	$(BUILD_CC) -o $@ $^ $(M_LIBS)
 
 mxml/libmxml.a:
 	@if test ! -f mxml/Makefile ; then cd mxml && ./configure ; fi
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/menuselect/mxml/Makefile.in asterisk-1.8.2.3.new/menuselect/mxml/Makefile.in
--- asterisk-1.8.2.3/menuselect/mxml/Makefile.in	2010-07-20 02:39:02.000000000 +0530
+++ asterisk-1.8.2.3.new/menuselect/mxml/Makefile.in	2011-02-15 15:56:38.000000000 +0530
@@ -71,7 +71,7 @@
 
 .SUFFIXES:	.0 .1 .3 .c .man .o
 .c.o:
-	$(CC) $(CFLAGS) -c $<
+	$(BUILD_CC) $(CFLAGS) -c $<
 .man.0 .man.1 .man.3:
 	$(RM) $@
 	$(NROFF) -man $< >$@
@@ -230,8 +230,8 @@
 
 libmxml.a:	$(LIBOBJS)
 	$(RM) $@
-	$(AR) $(ARFLAGS) $@ $(LIBOBJS)
-	$(RANLIB) $@
+	/usr/bin/ar $(ARFLAGS) $@ $(LIBOBJS)
+	/usr/bin/ranlib $@
 
 $(LIBOBJS):	mxml.h
 
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/menuselect-tree asterisk-1.8.2.3.new/menuselect-tree
--- asterisk-1.8.2.3/menuselect-tree	2011-01-27 02:48:39.000000000 +0530
+++ asterisk-1.8.2.3.new/menuselect-tree	2012-01-11 21:40:01.000000000 +0530
@@ -21,7 +21,7 @@
 	<defaultenabled>no</defaultenabled>
 </member>
 <member name="format_mp3" displayname="MP3 format [Any rate but 8000hz mono is optimal]" remove_on_change="addons/format_mp3.o addons/format_mp3.so">
-	<defaultenabled>no</defaultenabled>
+	<defaultenabled>yes</defaultenabled>
 </member>
 <member name="res_config_mysql" displayname="MySQL RealTime Configuration Driver" remove_on_change="addons/res_config_mysql.o addons/res_config_mysql.so">
 	<depend>mysqlclient</depend>
@@ -214,6 +214,8 @@
 <category name="MENUSELECT_BRIDGES" displayname="Bridging Modules" remove_on_change="bridges/modules.link">
 <member name="bridge_builtin_features" displayname="Built in bridging features" remove_on_change="bridges/bridge_builtin_features.o bridges/bridge_builtin_features.so">
 </member>
+<member name="bridge_mspd" displayname="MSPD multi-party voice mixer by using MSP processor" remove_on_change="bridges/bridge_mspd.o bridges/bridge_mspd.so">
+</member>
 <member name="bridge_multiplexed" displayname="Multiplexed two channel bridging module" remove_on_change="bridges/bridge_multiplexed.o bridges/bridge_multiplexed.so">
 </member>
 <member name="bridge_simple" displayname="Simple two channel bridging module" remove_on_change="bridges/bridge_simple.o bridges/bridge_simple.so">
@@ -240,12 +242,12 @@
 <member name="cdr_radius" displayname="RADIUS CDR Backend" remove_on_change="cdr/cdr_radius.o cdr/cdr_radius.so">
 	<depend>radius</depend>
 </member>
-<member name="cdr_sqlite3_custom" displayname="SQLite3 Custom CDR Module" remove_on_change="cdr/cdr_sqlite3_custom.o cdr/cdr_sqlite3_custom.so">
-	<depend>sqlite3</depend>
-</member>
 <member name="cdr_sqlite" displayname="SQLite CDR Backend" remove_on_change="cdr/cdr_sqlite.o cdr/cdr_sqlite.so">
 	<depend>sqlite</depend>
 </member>
+<member name="cdr_sqlite3_custom" displayname="SQLite3 Custom CDR Module" remove_on_change="cdr/cdr_sqlite3_custom.o cdr/cdr_sqlite3_custom.so">
+	<depend>sqlite3</depend>
+</member>
 <member name="cdr_syslog" displayname="Customizable syslog CDR Backend" remove_on_change="cdr/cdr_syslog.o cdr/cdr_syslog.so">
 	 <depend>syslog</depend>
 </member>
@@ -322,6 +324,8 @@
 	<depend>misdn</depend>
 	<depend>suppserv</depend>
 </member>
+<member name="chan_mspd" displayname="Mindspeed channel module" remove_on_change="channels/chan_mspd.o channels/chan_mspd.so">
+</member>
 <member name="chan_multicast_rtp" displayname="Multicast RTP Paging Channel" remove_on_change="channels/chan_multicast_rtp.o channels/chan_multicast_rtp.so">
 </member>
 <member name="chan_nbs" displayname="Network Broadcast Sound Support" remove_on_change="channels/chan_nbs.o channels/chan_nbs.so">
@@ -352,12 +356,12 @@
 </member>
 </category>
 <category name="MENUSELECT_CODECS" displayname="Codec Translators" remove_on_change="codecs/modules.link">
+<member name="codec_a_mu" displayname="A-law and Mulaw direct Coder/Decoder" remove_on_change="codecs/codec_a_mu.o codecs/codec_a_mu.so">
+</member>
 <member name="codec_adpcm" displayname="Adaptive Differential PCM Coder/Decoder" remove_on_change="codecs/codec_adpcm.o codecs/codec_adpcm.so">
 </member>
 <member name="codec_alaw" displayname="A-law Coder/Decoder" remove_on_change="codecs/codec_alaw.o codecs/codec_alaw.so">
 </member>
-<member name="codec_a_mu" displayname="A-law and Mulaw direct Coder/Decoder" remove_on_change="codecs/codec_a_mu.o codecs/codec_a_mu.so">
-</member>
 <member name="codec_dahdi" displayname="Generic DAHDI Transcoder Codec Translator" remove_on_change="codecs/codec_dahdi.o codecs/codec_dahdi.so">
 	<depend>dahdi</depend>
 </member>
@@ -413,10 +417,10 @@
 </member>
 <member name="format_siren7" displayname="ITU G.722.1 (Siren7, licensed from Polycom)" remove_on_change="formats/format_siren7.o formats/format_siren7.so">
 </member>
-<member name="format_sln16" displayname="Raw Signed Linear 16KHz Audio support (SLN16)" remove_on_change="formats/format_sln16.o formats/format_sln16.so">
-</member>
 <member name="format_sln" displayname="Raw Signed Linear Audio support (SLN)" remove_on_change="formats/format_sln.o formats/format_sln.so">
 </member>
+<member name="format_sln16" displayname="Raw Signed Linear 16KHz Audio support (SLN16)" remove_on_change="formats/format_sln16.o formats/format_sln16.so">
+</member>
 <member name="format_vox" displayname="Dialogic VOX (ADPCM) File Format" remove_on_change="formats/format_vox.o formats/format_vox.so">
 </member>
 <member name="format_wav" displayname="Microsoft WAV/WAV16 format (8kHz/16kHz Signed Linear)" remove_on_change="formats/format_wav.o formats/format_wav.so">
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/README asterisk-1.8.2.3.new/README
--- asterisk-1.8.2.3/README	2009-10-23 03:54:03.000000000 +0530
+++ asterisk-1.8.2.3.new/README	2014-04-21 18:49:17.000000000 +0530
@@ -1,5 +1,5 @@
-===============================================================================
-===                     The Asterisk(R) Open Source PBX
+===============================================================================   
+===                     The Asterisk(R) Open Source PBX  
 ===
 ===                   by Mark Spencer <markster@digium.com>
 ===                  and the Asterisk.org developer community
diff -udNr --exclude=CVS --ignore-matching-lines='\$Id' --ignore-matching-lines='\$Author' --ignore-matching-lines='\$Revision' --ignore-matching-lines='\$Header' --ignore-matching-lines='\$Source' --ignore-matching-lines='\$Date' --ignore-matching-lines='\$Log' asterisk-1.8.2.3/res/res_rtp_asterisk.c asterisk-1.8.2.3.new/res/res_rtp_asterisk.c
--- asterisk-1.8.2.3/res/res_rtp_asterisk.c	2010-10-06 10:05:51.000000000 +0530
+++ asterisk-1.8.2.3.new/res/res_rtp_asterisk.c	2012-02-17 21:59:27.000000000 +0530
@@ -50,6 +50,9 @@
 #include "asterisk/module.h"
 #include "asterisk/rtp_engine.h"
 
+#include "asterisk/mspd/cmmlib.h"
+#include <cmmd.h>
+
 #define MAX_TIMESTAMP_SKEW	640
 
 #define RTP_SEQ_MOD     (1<<16)	/*!< A sequence number can't be more than 16 bits */
@@ -60,6 +63,8 @@
 #define DEFAULT_RTP_START 5000 /*!< Default port number to start allocating RTP ports from */
 #define DEFAULT_RTP_END 31000  /*!< Default maximum port number to end allocating RTP ports at */
 
+#define DEFAULT_RTP_RBUFSIZE 0
+
 #define MINIMUM_RTP_PORT 1024 /*!< Minimum port number to accept */
 #define MAXIMUM_RTP_PORT 65535 /*!< Maximum port number to accept */
 
@@ -91,6 +96,8 @@
 static int nochecksums;
 #endif
 static int strictrtp;
+static int rtprbufsize = DEFAULT_RTP_RBUFSIZE;
+static int rtpcutthru = 0;
 
 enum strict_rtp_state {
 	STRICT_RTP_OPEN = 0, /*! No RTP packets should be dropped, all sources accepted */
@@ -170,6 +177,8 @@
 	struct ast_sockaddr alt_rtp_address; /*!<Alternate remote address information */
 
 	struct rtp_red *red;
+	int fpp_socket;
+	int is_msp_socket;
 };
 
 /*!
@@ -251,7 +260,7 @@
 AST_LIST_HEAD_NOLOCK(frame_list, ast_frame);
 
 /* Forward Declarations */
-static int ast_rtp_new(struct ast_rtp_instance *instance, struct sched_context *sched, struct ast_sockaddr *addr, void *data);
+static int ast_rtp_new(struct ast_rtp_instance *instance, struct sched_context *sched, struct ast_sockaddr *addr, void *data, int is_msp_socket);
 static int ast_rtp_destroy(struct ast_rtp_instance *instance);
 static int ast_rtp_dtmf_begin(struct ast_rtp_instance *instance, char digit);
 static int ast_rtp_dtmf_end(struct ast_rtp_instance *instance, char digit);
@@ -272,6 +281,7 @@
 static void ast_rtp_stun_request(struct ast_rtp_instance *instance, struct ast_sockaddr *suggestion, const char *username);
 static void ast_rtp_stop(struct ast_rtp_instance *instance);
 static int ast_rtp_qos_set(struct ast_rtp_instance *instance, int tos, int cos, const char* desc);
+static int ast_rtp_get_fpp_socket(struct ast_rtp_instance *instance);
 
 /* RTP Engine Declaration */
 static struct ast_rtp_engine asterisk_rtp_engine = {
@@ -297,6 +307,7 @@
 	.stun_request = ast_rtp_stun_request,
 	.stop = ast_rtp_stop,
 	.qos = ast_rtp_qos_set,
+	.get_fpp_socket = ast_rtp_get_fpp_socket,
 };
 
 static inline int rtp_debug_test_addr(struct ast_sockaddr *addr)
@@ -428,6 +439,8 @@
 			setsockopt(sock, SOL_SOCKET, SO_NO_CHECK, &nochecksums, sizeof(nochecksums));
 		}
 #endif
+		if (rtprbufsize)
+			setsockopt(sock, SOL_SOCKET, SO_RCVBUF, &rtprbufsize, sizeof(rtprbufsize));
 	}
 
 	return sock;
@@ -435,7 +448,7 @@
 
 static int ast_rtp_new(struct ast_rtp_instance *instance,
 		       struct sched_context *sched, struct ast_sockaddr *addr,
-		       void *data)
+		       void *data, int is_msp_socket)
 {
 	struct ast_rtp *rtp = NULL;
 	int x, startplace;
@@ -489,6 +502,11 @@
 	/* Record any information we may need */
 	rtp->sched = sched;
 
+	// FPP socket will be created in the bridge, when we know our IP
+	// Just store the type for now
+	if (rtpcutthru)
+		rtp->is_msp_socket = is_msp_socket;
+
 	/* Associate the RTP structure with the RTP instance and be done */
 	ast_rtp_instance_set_data(instance, rtp);
 
@@ -522,6 +540,9 @@
 		ast_free(rtp->red);
 	}
 
+        if (rtpcutthru && rtp->fpp_socket > 0) 
+		ast_cmm_fpp_close_socket(rtp->fpp_socket);
+
 	/* Finally destroy ourselves */
 	ast_free(rtp);
 
@@ -1255,6 +1276,8 @@
 		case AST_FORMAT_SIREN7:
 		case AST_FORMAT_SIREN14:
 		case AST_FORMAT_G719:
+		case AST_FORMAT_AMR:
+		case AST_FORMAT_AMR_WB:
 			/* these are all frame-based codecs and cannot be safely run through
 			   a smoother */
 			break;
@@ -2376,6 +2399,39 @@
 	return;
 }
 
+static int ast_rtp_get_fpp_socket(struct ast_rtp_instance *instance)
+{
+	if (!rtpcutthru)
+		return -1;
+
+	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
+	if(rtp->fpp_socket > 0) // Return existing FPP socket
+		return rtp->fpp_socket;
+
+	struct ast_sockaddr our;
+	struct ast_sockaddr their;
+	int socket_type;
+
+	if (rtp->is_msp_socket) socket_type = CMMD_SOCKET_TYPE_MSP;
+	else                    socket_type = CMMD_SOCKET_TYPE_LANWAN;
+
+	ast_rtp_instance_get_local_address (instance, &our);
+	ast_rtp_instance_get_remote_address(instance, &their);
+
+	struct sockaddr_in *socket = (struct sockaddr_in *) &our.ss;
+	if (!socket->sin_addr.s_addr)        // IP address is 0.0.0.0
+		ast_ouraddrfor (&their, &our);   // Finding our real IP address
+
+	ast_verb(5, "Local address  = %s\n", ast_sockaddr_stringify (&our));
+	ast_verb(5, "Remote address = %s\n", ast_sockaddr_stringify (&their));
+
+	// Create and update new FPP socket
+	rtp->fpp_socket = ast_cmm_fpp_create_socket(socket_type, (struct sockaddr_in *) &our.ss);
+	ast_cmm_fpp_update_socket(rtp->fpp_socket, (struct sockaddr_in *) &their.ss);
+
+	return rtp->fpp_socket;
+}
+
 static int ast_rtp_fd(struct ast_rtp_instance *instance, int rtcp)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
@@ -2402,6 +2458,9 @@
 		rtp->strict_rtp_state = STRICT_RTP_LEARN;
 	}
 
+	if (rtpcutthru && rtp->fpp_socket > 0) 
+		ast_cmm_fpp_update_socket(rtp->fpp_socket, (struct sockaddr_in *) &addr->ss); 
+
 	return;
 }
 
@@ -2733,6 +2792,7 @@
 	rtpend = DEFAULT_RTP_END;
 	dtmftimeout = DEFAULT_DTMF_TIMEOUT;
 	strictrtp = STRICT_RTP_OPEN;
+	rtprbufsize = DEFAULT_RTP_RBUFSIZE;
 	if (cfg) {
 		if ((s = ast_variable_retrieve(cfg, "general", "rtpstart"))) {
 			rtpstart = atoi(s);
@@ -2776,6 +2836,12 @@
 		if ((s = ast_variable_retrieve(cfg, "general", "strictrtp"))) {
 			strictrtp = ast_true(s);
 		}
+                if ((s = ast_variable_retrieve(cfg, "general", "rtprbufsize"))) {
+			rtprbufsize = atoi(s);
+		}
+                if ((s = ast_variable_retrieve(cfg, "general", "rtpcutthru"))) {
+                        rtpcutthru = ast_true(s);
+                }
 		ast_config_destroy(cfg);
 	}
 	if (rtpstart >= rtpend) {
